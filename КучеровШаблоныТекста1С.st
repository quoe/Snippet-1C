{1,
{129,
{"КучеровРМ (сниппеты)",1,0,"",""},
{3,
{"Стандартные",1,0,"",""},
{27,
{"Управляющие",1,0,"",""},
{0,
{"Если",0,0,"Если","Если <?""Условие""> Тогда
	<?>
КонецЕсли;"}
},
{0,
{"Если с комментарием",0,0,"ЕслиКом","Если <?""Условие""> Тогда //<?""Комментарий"">
	<?>
КонецЕсли; //<?""Комментарий"">"}
},
{0,
{"ИначеЕсли",0,0,"ИначеЕ","ИначеЕсли <?""Условие""> Тогда
	<?>"}
},
{0,
{"ЕслиИначе",0,0,"ЕслиИ[наче]","Если <?""Условие""> Тогда
	<?>
Иначе
	
КонецЕсли;"}
},
{0,
{"Если ИначеЕсли Иначе ",0,0,"ЕслиИЕ","Если <?""Условие""> Тогда
	<?>
ИначеЕсли  Тогда
	
Иначе
	
КонецЕсли;"}
},
{0,
{"Пока",0,0,"Пока","Пока <?""Условие""> Цикл
	
	<?>
	
КонецЦикла;"}
},
{0,
{"Для",0,0,"Для","Для <?""Счетчик""> По <?""Ограничение""> Цикл
	
	<?>
	
КонецЦикла;"}
},
{0,
{"Для каждого",0,0,"Для[ Каждого]","Для каждого <?""Переменная""> Из <?""Коллекция""> Цикл
	
	<?>
	
КонецЦикла;"}
},
{0,
{"Для каждого Строка",0,0,"Для[ Каждого]","Для каждого <?""Коллекция"">Строка Из <?""Коллекция""> Цикл
	
	<?""Коллекция"">Строка<?>
	
КонецЦикла;"}
},
{0,
{"Для каждого Элем",0,0,"Для[ Каждого]","Для каждого <?""Коллекция"">Элем Из <?""Коллекция""> Цикл
	
	<?""Коллекция"">Элем<?>
	
КонецЦикла;"}
},
{0,
{"Для каждого счетчик",0,0,"Для[ Каждого]","лСчетчик 				= 0;
<?""Коллекция"">Количество 	= <?""Коллекция"">.Количество();
Для Каждого <?""Переменная""> Из <?""Коллекция""> Цикл
	
	лСчетчик 	= лСчетчик + 1; 
	Состояние("""" + <?""Переменная""> + "" "" + лСчетчик + "" из "" + <?""Коллекция"">Количество);
	<?>
	
	ОбработкаПрерыванияПользователя();
	
КонецЦикла;"}
},
{0,
{"Процедура",0,0,"Проц[едура]","Процедура <?""Имя процедуры"">()
	
	<?>
	
КонецПроцедуры // <?""Имя процедуры"">()
"}
},
{0,
{"Процедура доработана",0,0,"ПроцДор[абот]","Процедура <?""Имя процедуры"">_Доработан()
	
	//ОРИГИНАЛ
	#Область ОРИГИНАЛ
	
	#КонецОбласти // ОРИГИНАЛ 
	<?>
	
	//ДОРАБОТАН
	#Область ДОРАБОТАН
	
	#КонецОбласти // ДОРАБОТАН 
	
КонецПроцедуры // <?""Имя процедуры"">_Доработан()
"}
},
{0,
{"Процедура (с заголовком)",0,0,"Проц[едура]","//Процедура <?>
//-------------------------------------------------------------------------
//Параметры:
//		Параметр 	- Тип 	- описание
//-------------------------------------------------------------------------
//автор: КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy"">
Процедура <?""Имя процедуры"">()
	
	<?>
	
КонецПроцедуры // <?""Имя процедуры"">()
"}
},
{0,
{"Процедура модуля формы",0,0,"Проц[едура]","//Процедура <?>
//-------------------------------------------------------------------------
//Параметры:
//		Параметр 	- Тип 	- описание
//-------------------------------------------------------------------------
//автор: КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy"">
&<?""Выберите директиву компиляции"", ВыборВарианта, ""НаКлиенте"", ""НаКлиенте"", ""НаСервере"", ""НаСервере"", ""НаСервереБезКонтекста"", ""НаСервереБезКонтекста"", ""НаКлиентеНаСервереБезКонтекста"", ""НаКлиентеНаСервереБезКонтекста"">
Процедура <?""Имя процедуры"">()
	
	<?>
	
КонецПроцедуры // <?""Имя процедуры"">()
"}
},
{0,
{"Процедура модуля команды",0,0,"Проц[едура]","//Процедура <?>
//-------------------------------------------------------------------------
//Параметры:
//		Параметр 	- Тип 	- описание
//-------------------------------------------------------------------------
//автор: КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy"">
&<?""Выберите директиву компиляции"", ВыборВарианта, ""НаКлиенте"", ""НаКлиенте"", ""НаСервере"", ""НаСервере"", ""НаКлиентеНаСервере"", ""НаКлиентеНаСервере"">
Процедура <?""Имя процедуры"">()
	
	<?>
	
КонецПроцедуры // <?""Имя процедуры"">()
"}
},
{0,
{"Функция",0,0,"Функ[ция]","Функция <?""Имя функции"">()
	
	лРезультат 	= Неопределено;
	
	<?>
	
	Возврат лРезультат;
	
КонецФункции // <?""Имя функции"">()
"}
},
{0,
{"Функция доработана",0,0,"ФункДор[абот]","Функция <?""Имя функции"">_Доработан()
	
	лРезультат 	= Неопределено;
	
	//ОРИГИНАЛ
	#Область ОРИГИНАЛ
	
	#КонецОбласти // ОРИГИНАЛ 
	<?>
	
	//ДОРАБОТАН
	#Область ДОРАБОТАН
	
	#КонецОбласти // ДОРАБОТАН
	
	Возврат лРезультат;
	
КонецФункции // <?""Имя функции"">_Доработан()
"}
},
{0,
{"Функция Результат",0,0,"ВозвРез[ульт]","лРезультат<?""Подписать результату (слитно, напр Успех)""> 	= Неопределено;
<?>
Возврат лРезультат<?""Подписать результату (слитно, напр Успех)"">;"}
},
{0,
{"Функция (с заголовком)",0,0,"Функ[ция]","//Функция <?>
//-------------------------------------------------------------------------
//Параметры:
//		Параметр 	- Тип 	- описание
//Возвращаемое значение:
//		Тип 	- описание
//-------------------------------------------------------------------------
//автор: КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy"">
Функция <?""Имя функции"">()
	
	лРезультат 	= Неопределено;
	<?>
	Возврат лРезультат;
	
КонецФункции // <?""Имя функции"">()
"}
},
{0,
{"Функция модуля формы",0,0,"Функ[ция]","//Функция <?>
//-------------------------------------------------------------------------
//Параметры:
//		Параметр 	- Тип 	- описание
//Возвращаемое значение:
//		Тип 	- описание
//-------------------------------------------------------------------------
//автор: КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy"">
&<?""Выберите директиву компиляции"", ВыборВарианта, ""НаКлиенте"", ""НаКлиенте"", ""НаСервере"", ""НаСервере"", ""НаСервереБезКонтекста"", ""НаСервереБезКонтекста"", ""НаКлиентеНаСервереБезКонтекста"", ""НаКлиентеНаСервереБезКонтекста"">
Функция <?""Имя функции"">()
	
	лРезультат 	= Неопределено;
	<?>
	Возврат лРезультат;
	
КонецФункции // <?""Имя функции"">()
"}
},
{0,
{"Функция модуля команды",0,0,"Функ[ция]","//Функция <?>
//-------------------------------------------------------------------------
//Параметры:
//		Параметр 	- Тип 	- описание
//Возвращаемое значение:
//		Тип 	- описание
//-------------------------------------------------------------------------
//автор: КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy"">
&<?""Выберите директиву компиляции"", ВыборВарианта, ""НаКлиенте"", ""НаКлиенте"", ""НаСервере"", ""НаСервере"", ""НаКлиентеНаСервере"", ""НаКлиентеНаСервере"">
Функция <?""Имя функции"">()
	
	лРезультат 	= Неопределено;
	<?>
	Возврат лРезультат;
	
КонецФункции // <?""Имя функции"">()
"}
},
{0,
{"Возврат",0,0,"","Возврат;<?>"}
},
{0,
{"Попытка",0,0,"Попы[тка]","Попытка
	
	<?>
	
Исключение
	лСообщениеОшибки 	= ""Ошибка: "" + ОписаниеОшибки();
	Сообщить(лСообщениеОшибки, СтатусСообщения.Важное);
КонецПопытки;"}
},
{0,
{"Директива компиляции",0,0,"Дирек[тива]","&<?""Выберите директиву компиляции"", ВыборВарианта, ""НаКлиенте"", ""НаКлиенте"", ""НаСервере"", ""НаСервере"", ""НаСервереБезКонтекста"", ""НаСервереБезКонтекста"", ""НаКлиентеНаСервере"", ""НаКлиентеНаСервере"", ""НаКлиентеНаСервереБезКонтекста"", ""НаКлиентеНаСервереБезКонтекста"">"}
},
{0,
{"Инструкция Если",0,0,"Инстр[укция]","#Если <?""Выберите инструкцию препроцессора"", ВыборВарианта, ""Сервер"", ""Сервер"", ""Клиент"", ""Клиент"", ""ТонкийКлиент"", ""ТонкийКлиент"", ""ВебКлиент"", ""ВебКлиент"", ""ВнешнееСоединение"", ""ВнешнееСоединение"", ""ТолстыйКлиентУправляемоеПриложение"", ""ТолстыйКлиентУправляемоеПриложение"", ""ТолстыйКлиентОбычноеПриложение"", ""ТолстыйКлиентОбычноеПриложение""> Тогда
	<?>
#КонецЕсли"}
},
{0,
{"Инструкция Область",0,0,"#Обл[асть]","#Область <?>

#КонецОбласти"}
}
},
{18,
{"Прикладные",1,0,"",""},
{0,
{"Перечисление",0,1,"Переч[исление]","ПредопределенноеЗначение(""Перечисление.<?""Выберите значение перечисления"", ЗначениеПеречисления>"")"}
},
{2,
{"Функциональные опции",1,0,"",""},
{0,
{"Получить функциональную опцию",0,1,"Функ[циональная опция]","ПолучитьФункциональнуюОпцию(""<?""Выберите функциональную опцию"", ОбъектМетаданных, ""ФункциональнаяОпция"">"")"}
},
{0,
{"Получить функциональную опцию интерфейса",0,1,"Функ[циональная опция]","ПолучитьФункциональнуюОпциюИнтерфейса(""<?""Выберите функциональную опцию"", ОбъектМетаданных, ""ФункциональнаяОпция"">"")"}
}
},
{4,
{"Общие формы",1,0,"",""},
{0,
{"Открыть общую форму",0,0,"Открыть[Форму]","ОткрытьФорму(""ОбщаяФорма.<?""Выберите общую форму"", ОбъектМетаданных, ""ОбщаяФорма"">"");"}
},
{0,
{"Открыть общую форму (с параметрами)",0,0,"","ПараметрыФормы = Новый Структура;
ПараметрыФормы.Вставить(""<?>"", );
ОткрытьФорму(""ОбщаяФорма.<?""Выберите общую форму"", ОбъектМетаданных, ""ОбщаяФорма"">"", ПараметрыФормы);"}
},
{0,
{"Получить общую форму",0,0,"Получить[Форму]","ПолучитьФорму(""ОбщаяФорма.<?""Выберите общую форму"", ОбъектМетаданных, ""ОбщаяФорма"">"");"}
},
{0,
{"Получить общую форму (с параметрами)",0,0,"","ПараметрыФормы = Новый Структура;
ПараметрыФормы.Вставить(""<?>"", );
Форма = ПолучитьФорму(""ОбщаяФорма.<?""Выберите общую форму"", ОбъектМетаданных, ""ОбщаяФорма"">"");
"}
}
},
{5,
{"Планы обмена",1,0,"",""},
{0,
{"Открыть форму плана обмена",0,0,"Открыть[Форму]","ОткрытьФорму(""ПланОбмена.<?""Выберите план обмена"", ПланОбмена>.<?""Выберите форму"", ВыборВарианта, ""Объекта"", ""ФормаОбъекта"", ""Списка"", ""ФормаСписка"", ""Выбора"", ""ФормаВыбора"", ""Произвольная"", ""Форма."">"");"}
},
{0,
{"Открыть форму плана обмена (с параметрами)",0,0,"","ПараметрыФормы = Новый Структура;
ПараметрыФормы.Вставить(""<?>"", );
ОткрытьФорму(""ПланОбмена.<?""Выберите план обмена"", ПланОбмена>.<?""Выберите форму"", ВыборВарианта, ""Объекта"", ""ФормаОбъекта"", ""Списка"", ""ФормаСписка"", ""Выбора"", ""ФормаВыбора"", ""Произвольная"", ""Форма."">"", ПараметрыФормы);"}
},
{0,
{"Получить форму плана обмена",0,0,"Получить[Форму]","ПолучитьФорму(""ПланОбмена.<?""Выберите план обмена"", ПланОбмена>.<?""Выберите форму"", ВыборВарианта, ""Объекта"", ""ФормаОбъекта"", ""Списка"", ""ФормаСписка"", ""Выбора"", ""ФормаВыбора"", ""Произвольная"", ""Форма."">"");"}
},
{0,
{"Получить форму плана обмена (с параметрами)",0,0,"","ПараметрыФормы = Новый Структура;
ПараметрыФормы.Вставить(""<?>"", );
Форма = ПолучитьФорму(""ПланОбмена.<?""Выберите план обмена"", ПланОбмена>.<?""Выберите форму"", ВыборВарианта, ""Объекта"", ""ФормаОбъекта"", ""Списка"", ""ФормаСписка"", ""Выбора"", ""ФормаВыбора"", ""Произвольная"", ""Форма."">"", ПараметрыФормы);
"}
},
{0,
{"Обход элементов",0,0,"","Выборка = ПланыОбмена.<?"""", ПланОбмена>.Выбрать();

Пока Выборка.Следующий() Цикл

	<?>

КонецЦикла;"}
}
},
{3,
{"Константы",1,0,"",""},
{0,
{"Получить/установить",0,0,"Конст[анты]","Константы.<?"""", Константа>.<?""Выбор метода"", ВыборВарианта, ""Получить"", ""Получить"", ""Установить"", ""Установить"">()"}
},
{0,
{"Установить",0,0,"","Константы.<?"""", Константа>.Установить(<?>);"}
},
{0,
{"Получить",0,0,"","Константы.<?"""", Константа>.Получить()"}
}
},
{6,
{"Справочники",1,0,"",""},
{0,
{"Открыть форму справочника",0,0,"Открыть[Форму]","ОткрытьФорму(""Справочник.<?""Выберите справочник"", Справочник>.<?""Выберите форму"", ВыборВарианта, ""Объекта"", ""ФормаОбъекта"", ""Списка"", ""ФормаСписка"", ""Выбора"", ""ФормаВыбора"", ""Группы"", ""ФормаГруппы"", ""Выбора группы"", ""ФормаВыбораГруппы"", ""Произвольная"", ""Форма.""><?>"");"}
},
{0,
{"Открыть форму справочника (с параметрами)",0,0,"","ПараметрыФормы = Новый Структура;
ПараметрыФормы.Вставить(""<?>"", );
ОткрытьФорму(""Справочник.<?""Выберите справочник"", Справочник>.<?""Выберите форму"", ВыборВарианта, ""Объекта"", ""ФормаОбъекта"", ""Списка"", ""ФормаСписка"", ""Выбора"", ""ФормаВыбора"", ""Группы"", ""ФормаГруппы"", ""Выбора группы"", ""ФормаВыбораГруппы"", ""Произвольная"", ""Форма."">"", ПараметрыФормы);"}
},
{0,
{"Получить форму справочника",0,0,"Получить[Форму]","ПолучитьФорму(""Справочник.<?""Выберите справочник"", Справочник>.<?""Выберите форму"", ВыборВарианта, ""Объекта"", ""ФормаОбъекта"", ""Списка"", ""ФормаСписка"", ""Выбора"", ""ФормаВыбора"", ""Группы"", ""ФормаГруппы"", ""Выбора группы"", ""ФормаВыбораГруппы"", ""Произвольная"", ""Форма.""><?>"");"}
},
{0,
{"Получить форму справочника (с параметрами)",0,0,"","ПараметрыФормы = Новый Структура;
ПараметрыФормы.Вставить(""<?>"", );
Форма = ПолучитьФорму(""Справочник.<?""Выберите справочник"", Справочник>.<?""Выберите форму"", ВыборВарианта, ""Объекта"", ""ФормаОбъекта"", ""Списка"", ""ФормаСписка"", ""Выбора"", ""ФормаВыбора"", ""Группы"", ""ФормаГруппы"", ""Выбора группы"", ""ФормаВыбораГруппы"", ""Произвольная"", ""Форма."">"", ПараметрыФормы);
"}
},
{0,
{"Обход элементов",0,0,"","Выборка = Справочники.<?"""", Справочник>.Выбрать();

Пока Выборка.Следующий() Цикл

	<?>

КонецЦикла;"}
},
{0,
{"Обход элементов иерархически",0,0,"","Выборка = Справочники.<?"""", Справочник>.ВыбратьИерархически();

Пока Выборка.Следующий() Цикл

	<?>

КонецЦикла;"}
}
},
{6,
{"Документы",1,0,"",""},
{0,
{"Открыть форму документа",0,0,"Открыть[Форму]","ОткрытьФорму(""Документ.<?""Выберите документ"", Документ>.<?""Выберите форму"", ВыборВарианта, ""Объекта"", ""ФормаОбъекта"", ""Списка"", ""ФормаСписка"", ""Выбора"", ""ФормаВыбора"", ""Произвольная"", ""Форма.""><?>"");"}
},
{0,
{"Открыть форму документа (с параметрами)",0,0,"","ПараметрыФормы = Новый Структура;
ПараметрыФормы.Вставить(""<?>"", );
ОткрытьФорму(""Документ.<?""Выберите документ"", Документ>.<?""Выберите форму"", ВыборВарианта, ""Объекта"", ""ФормаОбъекта"", ""Списка"", ""ФормаСписка"", ""Выбора"", ""ФормаВыбора"", ""Произвольная"", ""Форма."">"", ПараметрыФормы);"}
},
{0,
{"Получить форму документа",0,0,"Получить[Форму]","ПолучитьФорму(""Документ.<?""Выберите документ"", Документ>.<?""Выберите форму"", ВыборВарианта, ""Объекта"", ""ФормаОбъекта"", ""Списка"", ""ФормаСписка"", ""Выбора"", ""ФормаВыбора"", ""Произвольная"", ""Форма.""><?>"");"}
},
{0,
{"Получить форму документа (с параметрами)",0,0,"","ПараметрыФормы = Новый Структура;
ПараметрыФормы.Вставить(""<?>"", );
Форма = ПолучитьФорму(""Документ.<?""Выберите документ"", Документ>.<?""Выберите форму"", ВыборВарианта, ""Объекта"", ""ФормаОбъекта"", ""Списка"", ""ФормаСписка"", ""Выбора"", ""ФормаВыбора"", ""Произвольная"", ""Форма."">"", ПараметрыФормы);
"}
},
{0,
{"Обход документов",0,0,"","Выборка = Документы.<?"""", Документ>.Выбрать();

Пока Выборка.Следующий() Цикл

	<?>

КонецЦикла;"}
},
{0,
{"Движения",0,0,"","Движения.<?""Выбор регистра"", ОбъектМетаданных, ""РегистрСведений"", ""РегистрНакопления"", ""РегистрБухгалтерии"", ""РегистрРасчета"">"}
}
},
{4,
{"Отчеты",1,0,"",""},
{0,
{"Открыть форму отчета",0,0,"Открыть[Форму]","ОткрытьФорму(""Отчет.<?""Выберите отчет"", Отчет>.<?""Выберите форму"", ВыборВарианта, ""Форма"", ""Форма"", ""ФормаНастроек"", ""ФормаНастроек"", ""ФормаРедактированияВарианта"", ""ФормаРедактированияВарианта"", ""Произвольная"", ""Форма.""><?>"");"}
},
{0,
{"Открыть форму отчета (с параметрами)",0,0,"Открыть[Форму]","ПараметрыФормы = Новый Структура;
ПараметрыФормы.Вставить(""<?>"", );
ОткрытьФорму(""Отчет.<?""Выберите отчет"", Отчет>.<?""Выберите форму"", ВыборВарианта, ""Форма"", ""Форма"", ""ФормаНастроек"", ""ФормаНастроек"", ""ФормаРедактированияВарианта"", ""ФормаРедактированияВарианта"", ""Произвольная"", ""Форма."">"", ПараметрыФормы);"}
},
{0,
{"Получить форму отчета",0,0,"Получить[Форму]","ПолучитьФорму(""Отчет.<?""Выберите отчет"", Отчет>.<?""Выберите форму"", ВыборВарианта, ""Форма"", ""Форма"", ""ФормаНастроек"", ""ФормаНастроек"", ""ФормаРедактированияВарианта"", ""ФормаРедактированияВарианта"", ""Произвольная"", ""Форма.""><?>"");"}
},
{0,
{"Получить форму отчета (с параметрами)",0,0,"Получить[Форму]","ПараметрыФормы = Новый Структура;
ПараметрыФормы.Вставить(""<?>"", );
Форма = ПолучитьФорму(""Отчет.<?""Выберите отчет"", Отчет>.<?""Выберите форму"", ВыборВарианта, ""Форма"", ""Форма"", ""ФормаНастроек"", ""ФормаНастроек"", ""ФормаРедактированияВарианта"", ""ФормаРедактированияВарианта"", ""Произвольная"", ""Форма."">"", ПараметрыФормы);
"}
}
},
{4,
{"Обработки",1,0,"",""},
{0,
{"Открыть форму обработки",0,0,"Открыть[Форму]","ОткрытьФорму(""Обработка.<?""Выберите обработку"", Обработка>.<?""Выберите форму"", ВыборВарианта, ""Форма"", ""Форма"", ""Произвольная"", ""Форма.""><?>"");"}
},
{0,
{"Открыть форму обработки (с параметрами)",0,0,"Открыть[Форму]","ПараметрыФормы = Новый Структура;
ПараметрыФормы.Вставить(""<?>"", );
ОткрытьФорму(""Обработка.<?""Выберите обработку"", Обработка>.<?""Выберите форму"", ВыборВарианта, ""Форма"", ""Форма"", ""Произвольная"", ""Форма."">"", ПараметрыФормы);"}
},
{0,
{"Получить форму обработки",0,0,"Получить[Форму]","ПолучитьФорму(""Обработка.<?""Выберите обработку"", Обработка>.<?""Выберите форму"", ВыборВарианта, ""Форма"", ""Форма"", ""Произвольная"", ""Форма.""><?>"");"}
},
{0,
{"Получить форму обработки (с параметрами)",0,0,"Получить[Форму]","ПараметрыФормы = Новый Структура;
ПараметрыФормы.Вставить(""<?>"", );
Форма = ПолучитьФорму(""Обработка.<?""Выберите обработку"", Обработка>.<?""Выберите форму"", ВыборВарианта, ""Форма"", ""Форма"", ""Произвольная"", ""Форма."">"", ПараметрыФормы);
"}
}
},
{5,
{"Планы видов характеристик",1,0,"",""},
{0,
{"Открыть форму плана видов характеристик",0,0,"Открыть[Форму]","ОткрытьФорму(""ПланВидовХарактеристик.<?""Выберите ПВХ"", ПланВидовХарактеристик>.<?""Выберите форму"", ВыборВарианта, ""Объекта"", ""ФормаОбъекта"", ""Списка"", ""ФормаСписка"", ""Выбора"", ""ФормаВыбора"", ""Группы"", ""ФормаГруппы"", ""Выбора группы"", ""ФормаВыбораГруппы"", ""Произвольная"", ""Форма.""><?>"");"}
},
{0,
{"Открыть форму плана видов характеристик (с параметрами)",0,0,"","ПараметрыФормы = Новый Структура;
ПараметрыФормы.Вставить(""<?>"", );
ОткрытьФорму(""ПланВидовХарактеристик.<?""Выберите ПВХ"", ПланВидовХарактеристик>.<?""Выберите форму"", ВыборВарианта, ""Объекта"", ""ФормаОбъекта"", ""Списка"", ""ФормаСписка"", ""Выбора"", ""ФормаВыбора"", ""Группы"", ""ФормаГруппы"", ""Выбора группы"", ""ФормаВыбораГруппы"", ""Произвольная"", ""Форма."">"", ПараметрыФормы);"}
},
{0,
{"Получить форму плана видов характеристик",0,0,"Получить[Форму]","ПолучитьФорму(""ПланВидовХарактеристик.<?""Выберите ПВХ"", ПланВидовХарактеристик>.<?""Выберите форму"", ВыборВарианта, ""Объекта"", ""ФормаОбъекта"", ""Списка"", ""ФормаСписка"", ""Выбора"", ""ФормаВыбора"", ""Группы"", ""ФормаГруппы"", ""Выбора группы"", ""ФормаВыбораГруппы"", ""Произвольная"", ""Форма.""><?>"");"}
},
{0,
{"Получить форму плана видов характеристик (с параметрами)",0,0,"","ПараметрыФормы = Новый Структура;
ПараметрыФормы.Вставить(""<?>"", );
Форма = ПолучитьФорму(""ПланВидовХарактеристик.<?""Выберите ПВХ"", ПланВидовХарактеристик>.<?""Выберите форму"", ВыборВарианта, ""Объекта"", ""ФормаОбъекта"", ""Списка"", ""ФормаСписка"", ""Выбора"", ""ФормаВыбора"", ""Группы"", ""ФормаГруппы"", ""Выбора группы"", ""ФормаВыбораГруппы"", ""Произвольная"", ""Форма."">"", ПараметрыФормы);
"}
},
{0,
{"Обход видов характеристик",0,0,"","Выборка = ПланыВидовХарактеристик.<?"""", ПланВидовХарактеристик>.Выбрать();

Пока Выборка.Следующий() Цикл

	<?>

КонецЦикла;"}
}
},
{5,
{"Планы счетов",1,0,"",""},
{0,
{"Открыть форму плана счетов",0,0,"Открыть[Форму]","ОткрытьФорму(""ПланСчетов.<?""Выберите план счетов"", ПланСчетов>.<?""Выберите форму"", ВыборВарианта, ""Объекта"", ""ФормаОбъекта"", ""Списка"", ""ФормаСписка"", ""Выбора"", ""ФормаВыбора"", ""Произвольная"", ""Форма.""><?>"");"}
},
{0,
{"Открыть форму плана счетов (с параметрами)",0,0,"","ПараметрыФормы = Новый Структура;
ПараметрыФормы.Вставить(""<?>"", );
ОткрытьФорму(""ПланСчетов.<?""Выберите план счетов"", ПланСчетов>.<?""Выберите форму"", ВыборВарианта, ""Объекта"", ""ФормаОбъекта"", ""Списка"", ""ФормаСписка"", ""Выбора"", ""ФормаВыбора"", ""Произвольная"", ""Форма."">"", ПараметрыФормы);"}
},
{0,
{"Получить форму плана счетов",0,0,"Получить[Форму]","ПолучитьФорму(""ПланСчетов.<?""Выберите план счетов"", ПланСчетов>.<?""Выберите форму"", ВыборВарианта, ""Объекта"", ""ФормаОбъекта"", ""Списка"", ""ФормаСписка"", ""Выбора"", ""ФормаВыбора"", ""Произвольная"", ""Форма.""><?>"");"}
},
{0,
{"Получить форму плана счетов (с параметрами)",0,0,"","ПараметрыФормы = Новый Структура;
ПараметрыФормы.Вставить(""<?>"", );
Форма = ПолучитьФорму(""ПланСчетов.<?""Выберите план счетов"", ПланСчетов>.<?""Выберите форму"", ВыборВарианта, ""Объекта"", ""ФормаОбъекта"", ""Списка"", ""ФормаСписка"", ""Выбора"", ""ФормаВыбора"", ""Произвольная"", ""Форма."">"", ПараметрыФормы);
"}
},
{0,
{"Найти по коду",0,0,"","ПланыСчетов.<?"""", ПланСчетов>.НайтиПоКоду(<?>)"}
}
},
{5,
{"Планы видов расчета",1,0,"",""},
{0,
{"Открыть форму плана видов расчета",0,0,"Открыть[Форму]","ОткрытьФорму(""ПланВидовРасчета.<?""Выберите план видов расчета"", ПланВидовРасчета>.<?""Выберите форму"", ВыборВарианта, ""Объекта"", ""ФормаОбъекта"", ""Списка"", ""ФормаСписка"", ""Выбора"", ""ФормаВыбора"", ""Произвольная"", ""Форма.""><?>"");"}
},
{0,
{"Открыть форму плана видов расчета (с параметрами)",0,0,"","ПараметрыФормы = Новый Структура;
ПараметрыФормы.Вставить(""<?>"", );
ОткрытьФорму(""ПланВидовРасчета.<?""Выберите план видов расчета"", ПланВидовРасчета>.<?""Выберите форму"", ВыборВарианта, ""Объекта"", ""ФормаОбъекта"", ""Списка"", ""ФормаСписка"", ""Выбора"", ""ФормаВыбора"", ""Произвольная"", ""Форма."">"", ПараметрыФормы);"}
},
{0,
{"Получить форму плана видов расчета",0,0,"Получить[Форму]","ПолучитьФорму(""ПланВидовРасчета.<?""Выберите план видов расчета"", ПланВидовРасчета>.<?""Выберите форму"", ВыборВарианта, ""Объекта"", ""ФормаОбъекта"", ""Списка"", ""ФормаСписка"", ""Выбора"", ""ФормаВыбора"", ""Произвольная"", ""Форма.""><?>"");"}
},
{0,
{"Получить форму плана видов расчета (с параметрами)",0,0,"","ПараметрыФормы = Новый Структура;
ПараметрыФормы.Вставить(""<?>"", );
Форма = ПолучитьФорму(""ПланВидовРасчета.<?""Выберите план видов расчета"", ПланВидовРасчета>.<?""Выберите форму"", ВыборВарианта, ""Объекта"", ""ФормаОбъекта"", ""Списка"", ""ФормаСписка"", ""Выбора"", ""ФормаВыбора"", ""Произвольная"", ""Форма."">"", ПараметрыФормы);
"}
},
{0,
{"Обход видов расчета",0,0,"","Выборка = ПланыВидовРасчета.<?"""", ПланВидовРасчета>.Выбрать();

Пока Выборка.Следующий() Цикл

	<?>

КонецЦикла;"}
}
},
{5,
{"Бизнес-процессы",1,0,"",""},
{0,
{"Открыть форму бизнес-процесса",0,0,"Открыть[Форму]","ОткрытьФорму(""БизнесПроцесс.<?""Выберите бизнес-процесс"", БизнесПроцесс>.<?""Выберите форму"", ВыборВарианта, ""Объекта"", ""ФормаОбъекта"", ""Списка"", ""ФормаСписка"", ""Выбора"", ""ФормаВыбора"", ""Произвольная"", ""Форма.""><?>"");"}
},
{0,
{"Открыть форму бизнес-процесса (с параметрами)",0,0,"","ПараметрыФормы = Новый Структура;
ПараметрыФормы.Вставить(""<?>"", );
ОткрытьФорму(""БизнесПроцесс.<?""Выберите бизнес-процесс"", БизнесПроцесс>.<?""Выберите форму"", ВыборВарианта, ""Объекта"", ""ФормаОбъекта"", ""Списка"", ""ФормаСписка"", ""Выбора"", ""ФормаВыбора"", ""Произвольная"", ""Форма."">"", ПараметрыФормы);"}
},
{0,
{"Получить форму бизнес-процесса",0,0,"Получить[Форму]","ПолучитьФорму(""БизнесПроцесс.<?""Выберите бизнес-процесс"", БизнесПроцесс>.<?""Выберите форму"", ВыборВарианта, ""Объекта"", ""ФормаОбъекта"", ""Списка"", ""ФормаСписка"", ""Выбора"", ""ФормаВыбора"", ""Произвольная"", ""Форма.""><?>"");"}
},
{0,
{"Получить форму бизнес-процесса (с параметрами)",0,0,"","ПараметрыФормы = Новый Структура;
ПараметрыФормы.Вставить(""<?>"", );
Форма = ПолучитьФорму(""БизнесПроцесс.<?""Выберите бизнес-процесс"", БизнесПроцесс>.<?""Выберите форму"", ВыборВарианта, ""Объекта"", ""ФормаОбъекта"", ""Списка"", ""ФормаСписка"", ""Выбора"", ""ФормаВыбора"", ""Произвольная"", ""Форма."">"", ПараметрыФормы);
"}
},
{0,
{"Обход бизнес-процессов",0,0,"","Выборка = БизнесПроцессы.<?"""", БизнесПроцесс>.Выбрать();

Пока Выборка.Следующий() Цикл

	<?>

КонецЦикла;"}
}
},
{4,
{"Задачи",1,0,"",""},
{0,
{"Открыть форму задачи",0,0,"Открыть[Форму]","ОткрытьФорму(""Задача.<?""Выберите задачу"", Задача>.<?""Выберите форму"", ВыборВарианта, ""Объекта"", ""ФормаОбъекта"", ""Списка"", ""ФормаСписка"", ""Выбора"", ""ФормаВыбора"", ""Произвольная"", ""Форма.""><?>"");"}
},
{0,
{"Открыть форму задачи (с параметрами)",0,0,"","ПараметрыФормы = Новый Структура;
ПараметрыФормы.Вставить(""<?>"", );
ОткрытьФорму(""Задача.<?""Выберите задачу"", Задача>.<?""Выберите форму"", ВыборВарианта, ""Объекта"", ""ФормаОбъекта"", ""Списка"", ""ФормаСписка"", ""Выбора"", ""ФормаВыбора"", ""Произвольная"", ""Форма."">"", ПараметрыФормы);"}
},
{0,
{"Получить форму задачи",0,0,"Получить[Форму]","ПолучитьФорму(""Задача.<?""Выберите задачу"", Задача>.<?""Выберите форму"", ВыборВарианта, ""Объекта"", ""ФормаОбъекта"", ""Списка"", ""ФормаСписка"", ""Выбора"", ""ФормаВыбора"", ""Произвольная"", ""Форма.""><?>"");"}
},
{0,
{"Получить форму задачи (с параметрами)",0,0,"","ПараметрыФормы = Новый Структура;
ПараметрыФормы.Вставить(""<?>"", );
Форма = ПолучитьФорму(""Задача.<?""Выберите задачу"", Задача>.<?""Выберите форму"", ВыборВарианта, ""Объекта"", ""ФормаОбъекта"", ""Списка"", ""ФормаСписка"", ""Выбора"", ""ФормаВыбора"", ""Произвольная"", ""Форма."">"", ПараметрыФормы);
"}
}
},
{6,
{"Регистры сведений",1,0,"",""},
{0,
{"Открыть форму регистра сведений",0,0,"Открыть[Форму]","ОткрытьФорму(""РегистрСведений.<?""Выберите регистр сведений"", РегистрСведений>.<?""Выберите форму"", ВыборВарианта, ""Записи"", ""ФормаЗаписи"", ""Списка"", ""ФормаСписка"", ""Произвольная"", ""Форма.""><?>"");"}
},
{0,
{"Открыть форму регистра сведений (с параметрами)",0,0,"","ПараметрыФормы = Новый Структура;
ПараметрыФормы.Вставить(""<?>"", );
ОткрытьФорму(""РегистрСведений.<?""Выберите регистр сведений"", РегистрСведений>.<?""Выберите форму"", ВыборВарианта, ""Записи"", ""ФормаЗаписи"", ""Списка"", ""ФормаСписка"", ""Произвольная"", ""Форма."">"", ПараметрыФормы);"}
},
{0,
{"Получить форму регистра сведений",0,0,"Получить[Форму]","ПолучитьФорму(""РегистрСведений.<?""Выберите регистр сведений"", РегистрСведений>.<?""Выберите форму"", ВыборВарианта, ""Записи"", ""ФормаЗаписи"", ""Списка"", ""ФормаСписка"", ""Произвольная"", ""Форма.""><?>"");"}
},
{0,
{"Получить форму регистра сведений (с параметрами)",0,0,"","ПараметрыФормы = Новый Структура;
ПараметрыФормы.Вставить(""<?>"", );
Форма = ПолучитьФорму(""РегистрСведений.<?""Выберите регистр сведений"", РегистрСведений>.<?""Выберите форму"", ВыборВарианта, ""Записи"", ""ФормаЗаписи"", ""Списка"", ""ФормаСписка"", ""Произвольная"", ""Форма."">"", ПараметрыФормы);
"}
},
{0,
{"Выборка записей регистра сведений",0,0,"","Выборка = РегистрСведений.<?""Выберите регистр сведений"", РегистрСведений>.Выбрать();

Пока Выборка.Следующий() Цикл

	<?>

КонецЦикла;"}
},
{0,
{"Выборка записей регистра сведений (по регистратору)",0,0,"","Выборка = РегистрСведений.<?""Выберите регистр сведений"", РегистрСведений>.ВыбратьПоРегистратору(<?>);

Пока Выборка.Следующий() Цикл


КонецЦикла;"}
}
},
{6,
{"Регистры накопления",1,0,"",""},
{0,
{"Открыть форму регистра накопления",0,0,"Открыть[Форму]","ОткрытьФорму(""РегистрНакопления.<?""Выберите регистр накопления"", РегистрНакопления>.<?""Выберите форму"", ВыборВарианта, ""Списка"", ""ФормаСписка"", ""Произвольная"", ""Форма.""><?>"");"}
},
{0,
{"Открыть форму регистра накопления (с параметрами)",0,0,"","ПараметрыФормы = Новый Структура;
ПараметрыФормы.Вставить(""<?>"", );
ОткрытьФорму(""РегистрНакопления.<?""Выберите регистр накопления"", РегистрНакопления>.<?""Выберите форму"", ВыборВарианта, ""Списка"", ""ФормаСписка"", ""Произвольная"", ""Форма."">"", ПараметрыФормы);"}
},
{0,
{"Получить форму регистра накопления",0,0,"Получить[Форму]","ПолучитьФорму(""РегистрНакопления.<?""Выберите регистр накопления"", РегистрНакопления>.<?""Выберите форму"", ВыборВарианта, ""Списка"", ""ФормаСписка"", ""Произвольная"", ""Форма.""><?>"");"}
},
{0,
{"Получить форму регистра накопления (с параметрами)",0,0,"","ПараметрыФормы = Новый Структура;
ПараметрыФормы.Вставить(""<?>"", );
Форма = ПолучитьФорму(""РегистрНакопления.<?""Выберите регистр накопления"", РегистрНакопления>.<?""Выберите форму"", ВыборВарианта, ""Списка"", ""ФормаСписка"", ""Произвольная"", ""Форма."">"", ПараметрыФормы);
"}
},
{0,
{"Выборка записей регистра накопления",0,0,"","Выборка = РегистрСведений.<?""Выберите регистр накопления"", РегистрНакопления>.Выбрать();

Пока Выборка.Следующий() Цикл

	<?>

КонецЦикла;"}
},
{0,
{"Выборка записей регистра накопления (по регистратору)",0,0,"","Выборка = РегистрСведений.<?""Выберите регистр накопления"", РегистрНакопления>.ВыбратьПоРегистратору(<?>);

Пока Выборка.Следующий() Цикл


КонецЦикла;"}
}
},
{6,
{"Регистры бухгалтерии",1,0,"",""},
{0,
{"Открыть форму регистра бухгалтерии",0,0,"Открыть[Форму]","ОткрытьФорму(""РегистрБухгалтерии.<?""Выберите регистр бухгалтерии"", РегистрБухгалтерии>.<?""Выберите форму"", ВыборВарианта, ""Списка"", ""ФормаСписка"", ""Произвольная"", ""Форма.""><?>"");"}
},
{0,
{"Открыть форму регистра бухгалтерии (с параметрами)",0,0,"","ПараметрыФормы = Новый Структура;
ПараметрыФормы.Вставить(""<?>"", );
ОткрытьФорму(""РегистрБухгалтерии.<?""Выберите регистр бухгалтерии"", РегистрБухгалтерии>.<?""Выберите форму"", ВыборВарианта, ""Списка"", ""ФормаСписка"", ""Произвольная"", ""Форма."">"", ПараметрыФормы);"}
},
{0,
{"Получить форму регистра бухгалтерии",0,0,"Получить[Форму]","ПолучитьФорму(""РегистрБухгалтерии.<?""Выберите регистр бухгалтерии"", РегистрБухгалтерии>.<?""Выберите форму"", ВыборВарианта, ""Списка"", ""ФормаСписка"", ""Произвольная"", ""Форма.""><?>"");"}
},
{0,
{"Получить форму регистра бухгалтерии (с параметрами)",0,0,"","ПараметрыФормы = Новый Структура;
ПараметрыФормы.Вставить(""<?>"", );
Форма = ПолучитьФорму(""РегистрБухгалтерии.<?""Выберите регистр бухгалтерии"", РегистрБухгалтерии>.<?""Выберите форму"", ВыборВарианта, ""Списка"", ""ФормаСписка"", ""Произвольная"", ""Форма."">"", ПараметрыФормы);
"}
},
{0,
{"Выборка записей регистра бухгалтерии",0,0,"","Выборка = РегистрСведений.<?""Выберите регистр бухгалтерии"", РегистрБухгалтерии>.Выбрать();

Пока Выборка.Следующий() Цикл

	<?>

КонецЦикла;"}
},
{0,
{"Выборка записей регистра бухгалтерии (по регистратору)",0,0,"","Выборка = РегистрСведений.<?""Выберите регистр бухгалтерии"", РегистрБухгалтерии>.ВыбратьПоРегистратору(<?>);

Пока Выборка.Следующий() Цикл


КонецЦикла;"}
}
},
{6,
{"Регистры расчета",1,0,"",""},
{0,
{"Открыть форму регистра расчета",0,0,"Открыть[Форму]","ОткрытьФорму(""РегистрРасчета.<?""Выберите регистр расчета"", РегистрРасчета>.<?""Выберите форму"", ВыборВарианта, ""Списка"", ""ФормаСписка"", ""Произвольная"", ""Форма.""><?>"");"}
},
{0,
{"Открыть форму регистра расчета (с параметрами)",0,0,"","ПараметрыФормы = Новый Структура;
ПараметрыФормы.Вставить(""<?>"", );
ОткрытьФорму(""РегистрРасчета.<?""Выберите регистр расчета"", РегистрРасчета>.<?""Выберите форму"", ВыборВарианта, ""Списка"", ""ФормаСписка"", ""Произвольная"", ""Форма."">"", ПараметрыФормы);"}
},
{0,
{"Получить форму регистра расчета",0,0,"Получить[Форму]","ПолучитьФорму(""РегистрРасчета.<?""Выберите регистр расчета"", РегистрРасчета>.<?""Выберите форму"", ВыборВарианта, ""Списка"", ""ФормаСписка"", ""Произвольная"", ""Форма.""><?>"");"}
},
{0,
{"Получить форму регистра расчета (с параметрами)",0,0,"","ПараметрыФормы = Новый Структура;
ПараметрыФормы.Вставить(""<?>"", );
Форма = ПолучитьФорму(""РегистрРасчета.<?""Выберите регистр расчета"", РегистрРасчета>.<?""Выберите форму"", ВыборВарианта, ""Списка"", ""ФормаСписка"", ""Произвольная"", ""Форма."">"", ПараметрыФормы);
"}
},
{0,
{"Выборка записей регистра расчета",0,0,"","Выборка = РегистрСведений.<?""Выберите регистр расчета"", РегистрРасчета>.Выбрать();

Пока Выборка.Следующий() Цикл

	<?>

КонецЦикла;"}
},
{0,
{"Выборка записей регистра расчета (по регистратору)",0,0,"","Выборка = РегистрСведений.<?""Выберите регистр расчета"", РегистрРасчета>.ВыбратьПоРегистратору(<?>);

Пока Выборка.Следующий() Цикл


КонецЦикла;"}
}
}
},
{18,
{"Прочие",1,0,"",""},
{0,
{"Сообщение",0,1,"Сообщ[ение]","лСообщение = Новый СообщениеПользователю;
лСообщение.Текст = ""<?>"";
лСообщение.Поле = """";
лСообщение.УстановитьДанные();
лСообщение.Сообщить();"}
},
{0,
{"Предупреждение",0,0,"Предупр[еждение]","Предупреждение(<?>);"}
},
{0,
{"Формат",0,0,"Формат","Формат(<?>, ""<?, ФорматнаяСтрока>"")"}
},
{0,
{"Форматная строка",0,1,"","""<?, ФорматнаяСтрока>"""}
},
{0,
{"Создать структуру",0,0,"Струк[тура]","Новый Структура(""<?>"", )"}
},
{0,
{"Создать структуру вертикально",0,0,"СтрукВерт[икал]","Новый Структура(
		""""
	,			
)"}
},
{0,
{"Создать структуру со вставкой 1",0,0,"СтрукВст[ав]","<?""Имя структуры (слитно)""> 	= Новый Структура;
<?""Имя структуры (слитно)"">.Вставить(""<?>""	, );"}
},
{0,
{"Создать структуру со вставкой 3",0,0,"СтрукВст3","<?""Имя структуры (слитно)""> 	= Новый Структура;
<?""Имя структуры (слитно)"">.Вставить(""<?>""	, );
<?""Имя структуры (слитно)"">.Вставить(""""	, );
<?""Имя структуры (слитно)"">.Вставить(""""	, );"}
},
{0,
{"Создать структуру со вставкой 5",0,0,"СтрукВст5","<?""Имя структуры (слитно)""> 	= Новый Структура;
<?""Имя структуры (слитно)"">.Вставить(""<?>""	, );
<?""Имя структуры (слитно)"">.Вставить(""""	, );
<?""Имя структуры (слитно)"">.Вставить(""""	, );
<?""Имя структуры (слитно)"">.Вставить(""""	, );
<?""Имя структуры (слитно)"">.Вставить(""""	, );"}
},
{0,
{"Запрос",0,0,"Зап[рос]","Запрос 			= Новый Запрос;
Запрос.Текст 	= ""<?"""", ТекстЗапроса>"";

лРезультатЗапроса 	= Запрос.Выполнить();

Если НЕ лРезультатЗапроса.Пустой() Тогда
	Пока лВыборка.Следующий() Цикл
		лВыборка 	= лРезультат.Выбрать();
		<?>
		Прервать;	
	КонецЦикла;
КонецЕсли;
"}
},
{0,
{"Запрос с параметром",0,0,"ЗСП[арам]","Запрос 			= Новый Запрос;
Запрос.Текст 	= """";

Запрос.УстановитьПараметр("""", );

РезультатЗапроса 	= Запрос.Выполнить();

Если НЕ РезультатЗапроса.Пустой() Тогда
	Выборка 	= РезультатЗапроса.Выбрать();
	Пока Выборка.Следующий() Цикл
		<?>
		Прервать;	
	КонецЦикла;
КонецЕсли;"}
},
{0,
{"Запрос.УстановитьПараметр",0,0,"ЗУП[арам]","Запрос.УстановитьПараметр(""<?>""	, );"}
},
{0,
{"Запрос Выполнить",0,0,"ЗапВып[олн]","РезультатЗапроса 	= Запрос.Выполнить();

Если НЕ РезультатЗапроса.Пустой() Тогда
	Выборка 	= РезультатЗапроса.Выбрать();
	Пока Выборка.Следующий() Цикл
		<?>
		Прервать;	
	КонецЦикла;
КонецЕсли;"}
},
{0,
{"Вопрос",0,0,"Вопр[ос]","Вопрос(""<?""Текст вопроса"">"", <?""Режим диалога вопрос"", ВыборВарианта, ""ДаНет"", ""РежимДиалогаВопрос.ДаНет"", ""ДаНетОтмена"", ""РежимДиалогаВопрос.ДаНетОтмена"", ""ОК"", ""РежимДиалогаВопрос.ОК"", ""ОКОтмена"", ""РежимДиалогаВопрос.ОКОтмена"", ""ПовторитьОтмена"", ""РежимДиалогаВопрос.ПовторитьОтмена"", ""ПрерватьПовторитьПропустить"", ""РежимДиалогаВопрос.ПрерватьПовторитьПропустить"">)"}
},
{0,
{"Вопрос с анализом результата",0,0,"Вопр[ос]","Вопрос(""<?""Текст вопроса"">"", <?""Режим диалога вопрос"", ВыборВарианта, ""ДаНет"", ""РежимДиалогаВопрос.ДаНет"", ""ДаНетОтмена"", ""РежимДиалогаВопрос.ДаНетОтмена"", ""ОК"", ""РежимДиалогаВопрос.ОК"", ""ОКОтмена"", ""РежимДиалогаВопрос.ОКОтмена"", ""ПовторитьОтмена"", ""РежимДиалогаВопрос.ПовторитьОтмена"", ""ПрерватьПовторитьПропустить"", ""РежимДиалогаВопрос.ПрерватьПовторитьПропустить"">) = <?""Код возврата диалога"", ВыборВарианта, ""Да"", ""КодВозвратаДиалога.Да"", ""Нет"", ""КодВозвратаДиалога.Нет"", ""ОК"", ""КодВозвратаДиалога.ОК"", ""Отмена"", ""КодВозвратаДиалога.Отмена"", ""Повторить"", ""КодВозвратаДиалога.Повторить"", ""Прервать"", ""КодВозвратаДиалога.Прервать"", ""Пропустить"", ""КодВозвратаДиалога.Пропустить"", ""Таймаут"", ""КодВозвратаДиалога.Таймаут"">"}
},
{0,
{"Проверка типа",0,0,"","Если ТипЗнч(<?""Выражение для проверки типа"">) = Тип(""<?""Выберите тип"", ВыборТипа>"") Тогда

	<?>

КонецЕсли;"}
},
{0,
{"КонструкторОписанияТипов",0,0,"","<?""Конструктор описания типов"", КонструкторОписанияТипов>"}
},
{0,
{"УникальныйИдентификатор",0,0,"УИ","УникальныйИдентификатор()"}
}
}
},
{22,
{"Комментарий",1,0,"",""},
{4,
{"Автор",1,0,"",""},
{0,
{"Автор",0,0,"/авт","// АйТи КучеровРМ"}
},
{0,
{"Автор, дата",0,0,"/автД[ат]","// АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy"">"}
},
{0,
{"Автор, дата, ТЗ (пояснение, комментарий)",0,0,"/автК[оомент]","// АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> # <?""Номент ТЗ или поясление (напиши хоть что-то по теме, чтобы потом лечге найти!)"">"}
},
{0,
{"Автор процедур и функций (методов)",0,0,"/автМ","// автор: КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy"">"}
}
},
{27,
{"Шапки и заголовки кода, разделители",1,0,"",""},
{0,
{"Шапка без тире",0,0,"/шапка","////////////////////////////////////////////////////////////////////////////////
// <?""Название"">
//
////////////////////////////////////////////////////////////////////////////////
<?>"}
},
{0,
{"Шапка без тире с автором",0,0,"/шапкаА[втор]","////////////////////////////////////////////////////////////////////////////////
// [ АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> ТЗ # <?""Номент ТЗ или поясление (напиши хоть что-то по теме, чтобы потом лечге найти!)""> ]
// <?""Название""> 
////////////////////////////////////////////////////////////////////////////////
<?>
"}
},
{0,
{"Шапка фирменная",0,0,"/шапкаФ[ирма]","////////////////////////////////////////////////////////////////////////////////
// Влюбленная в свое дело команда ООО «АйТи-Консалтинг»,
// г. Ярославль, ул. Советская, д.69, к.2, этаж 1,
// тел. (4852) 59-33-33, info@allzon.ru,
// https://itcons99.ru/, http://itcons76.ru/
////////////////////////////////////////////////////////////////////////////////
<?>"}
},
{0,
{"Шапка с тире",0,0,"шапка [с тире]","////////////////////////////////////////////////////////////////////////////////
// --------------------------------------- <?""Название""> -------------------------------------
////////////////////////////////////////////////////////////////////////////////
<?>"}
},
{0,
{"Шапка из =",0,0,"","// ============================================================================//.
// <?""Название"">
// ============================================================================//.
<?>"}
},
{0,
{"Шапка мини",0,0,"","///
// <?""Название""> 
///
<?>"}
},
{0,
{"Шапки в паре",0,0,"","////////////////////////////////////////////////////////////////////////////////
// +++----------- <?""Название""> --------------

<?>

// --------------- <?""Название""> ----------+++
////////////////////////////////////////////////////////////////////////////////"}
},
{0,
{"Заголовок в паре с автором",0,0,"/загПа[ра]","////////////////////////////////////////////////////////////////////////////////
// +++ <?""Название""> [ АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> ТЗ # <?""Номент ТЗ или поясление (напиши хоть что-то по теме, чтобы потом лечге найти!)""> ]

<?>

// --- <?""Название""> [ АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> ТЗ # <?""Номент ТЗ или поясление (напиши хоть что-то по теме, чтобы потом лечге найти!)""> ]
////////////////////////////////////////////////////////////////////////////////"}
},
{0,
{"Заголовок с //",0,0,"/заг","////////////////////////////////////////////////////////////////////////////////
// <?""Название"">"}
},
{0,
{"Заголовок с ::::::",0,0,"/заг","// ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
// <?""Название"">"}
},
{0,
{"Заголовок блока текста (:::)",0,0,"/:","//:::<?>"}
},
{0,
{"Заголовок процедуры",0,0,"/загП[роцедура]","//Процедура <?>
//-------------------------------------------------------------------------
//Параметры:
//		Параметр 	- Тип 	- описание
//-------------------------------------------------------------------------
//автор: КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy"">"}
},
{0,
{"Заголовок функции",0,0,"/загФ[ункция]","//Функция <?>
//-------------------------------------------------------------------------
//Параметры:
//		Параметр 	- Тип 	- описание
//Возвращаемое значение:
//		Тип 	- описание
//-------------------------------------------------------------------------
//автор: КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy"">"}
},
{0,
{"Комментарий для функции",0,0,"/загК[омментарий]","//-------------------------------------------------------------------------
//<?""Текст комментария""><?>
//-------------------------------------------------------------------------"}
},
{0,
{"Разделитель",0,0,"/раз","//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////"}
},
{0,
{"Разделитель с названием",0,0,"/разН[азв]","//  <?""Название"">  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////"}
},
{0,
{"Параметр процедур и функций",0,0,"/п","//		Параметр 	- Тип 	- описание"}
},
{0,
{"Параметр процедур и функций - Строка ",0,0,"/пС","//		Параметр 	- Строка 	- описание"}
},
{0,
{"Параметр процедур и функций - Число",0,0,"/пЧ","//		Параметр 	- Число 	- описание"}
},
{0,
{"Параметр процедур и функций - Булево",0,0,"/пБ","//		Параметр 	- Булево 	- описание"}
},
{0,
{"Параметр процедур и функций - Дата",0,0,"/пД","//		Параметр 	- Дата 	- описание"}
},
{0,
{"Параметр процедур и функций - Структура",0,0,"/пСт","//		Параметр 	- Структура 	- описание"}
},
{0,
{"Параметр процедур и функций - ТаблицаЗначений",0,0,"/пТЗ","//		Параметр 	- ТаблицаЗначений 	- описание"}
},
{0,
{"Параметр процедур и функций - ДокументСсылка",0,0,"/пДС","//		Параметр 	- ДокументСсылка 	- описание"}
},
{0,
{"Параметр процедур и функций - ДокументОбъект",0,0,"/пДО","//		Параметр 	- ДокументОбъект 	- описание"}
},
{0,
{"ПодПараметр процедур и функций",0,0,"/пп","//					* Параметр 	- Тип 	- описание"}
},
{0,
{"Подпараметр параметра",0,0,"/	","//			<?>"}
}
},
{2,
{"Чужие комментарии (по проектам)",1,0,"",""},
{0,
{"Норд",0,0,"/комНорд[Стар]","//Нордстар+, <?"""", ДатаВремя, ""ДФ=yyyy-MM-dd"">, ЕфимоваД, Омега, <?""ID заявки "">, <?""№"">
<?>
//Нордстар-
"}
},
{0,
{"Компсистемс",0,0,"/комКомпС[истемс]","//+++ Компсистемс КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> ТЗ № <?""№"">
<?>
//--- Компсистемс КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> ТЗ № <?""№"">"}
}
},
{2,
{"Пояснительные комментарии (добавлен, изменён, удалён)",1,0,"",""},
{4,
{"//+++{ (эти при поиске будут выдаться с типовыми комментариями других)",1,0,"",""},
{0,
{"Комментарий Добавлен (в блоки +++)",0,0,"/ком+Х","//+++{ АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> # <?""Номент ТЗ или поясление (напиши хоть что-то по теме, чтобы потом лечге найти!)"">
<?>
//+++} АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> # <?""Номент ТЗ или поясление (напиши хоть что-то по теме, чтобы потом лечге найти!)"">"}
},
{0,
{"Комментарий Изменен (в блоки ***)",0,0,"/ком*Х","//***{ АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> # <?""Номент ТЗ или поясление (напиши хоть что-то по теме, чтобы потом лечге найти!)"">
<?>
//***} АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> # <?""Номент ТЗ или поясление (напиши хоть что-то по теме, чтобы потом лечге найти!)"">"}
},
{0,
{"Комментарий Удалён (в блоки ---)",0,0,"/ком-Х","//---{ АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> # <?""Номент ТЗ или поясление (напиши хоть что-то по теме, чтобы потом лечге найти!)"">
<?>
//---} АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> # <?""Номент ТЗ или поясление (напиши хоть что-то по теме, чтобы потом лечге найти!)"">"}
},
{0,
{"Замена кода",0,0,"/зам*","//***{ АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> # <?""Номент ТЗ или поясление (напиши хоть что-то по теме, чтобы потом лечге найти!)"">
//---{ АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> # <?""Номент ТЗ или поясление (напиши хоть что-то по теме, чтобы потом лечге найти!)"">

//---} АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> # <?""Номент ТЗ или поясление (напиши хоть что-то по теме, чтобы потом лечге найти!)"">

//***} АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> # <?""Номент ТЗ или поясление (напиши хоть что-то по теме, чтобы потом лечге найти!)"">"}
}
},
{4,
{"//{ (эти комментарии не будут выдаваться поиском типовых комментариев, они ""эксклюзивные"") (они удобнее, нагляднее)",1,0,"",""},
{0,
{"Комментарий Добавлен (в блоки +++)",0,0,"/ком+","//{+++ АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> # <?""Номент ТЗ или поясление (напиши хоть что-то по теме, чтобы потом лечге найти!)"">
<?>
//}+++ АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> # <?""Номент ТЗ или поясление (напиши хоть что-то по теме, чтобы потом лечге найти!)"">"}
},
{0,
{"Комментарий Изменен (в блоки ***) (изменнённый код комментируется двумя //, т.е. ////)",0,0,"/ком*","//{*** АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> # <?""Номент ТЗ или поясление (напиши хоть что-то по теме, чтобы потом лечге найти!)"">
<?>
//}*** АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> # <?""Номент ТЗ или поясление (напиши хоть что-то по теме, чтобы потом лечге найти!)"">"}
},
{0,
{"Комментарий Удалён (в блоки ---)",0,0,"/ком-","//{--- АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> # <?""Номент ТЗ или поясление (напиши хоть что-то по теме, чтобы потом лечге найти!)"">
<?>
//}--- АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> # <?""Номент ТЗ или поясление (напиши хоть что-то по теме, чтобы потом лечге найти!)"">"}
},
{0,
{"Замена кода",0,0,"/зам*Х","//{*** АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> # <?""Номент ТЗ или поясление (напиши хоть что-то по теме, чтобы потом лечге найти!)"">
//{--- АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> # <?""Номент ТЗ или поясление (напиши хоть что-то по теме, чтобы потом лечге найти!)"">

//}--- АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> # <?""Номент ТЗ или поясление (напиши хоть что-то по теме, чтобы потом лечге найти!)"">

//}*** АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> # <?""Номент ТЗ или поясление (напиши хоть что-то по теме, чтобы потом лечге найти!)"">"}
}
}
},
{0,
{"Область кода",0,0,"обл[асть]","#Область <?""Название области"">
<?>
#КонецОбласти // <?""Название области"">"}
},
{0,
{"Подменю",0,0,"подм[еню]","//====== <?""Название""> ===================================================================

<?>

//====== <?""Название""> ==================================================================="}
},
{0,
{"Подменю, начало и конец",0,0,"подм[еню]","//+++ ====== <?""Название""> ================================================

<?>

//--- ====== <?""Название""> ================================================"}
},
{0,
{"Подменю, начало и конец, автор",0,0,"подм[еню]","//+++ ====== <?""Название""> [ АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> ТЗ № <?""№""> ] ================================================

<?>

//--- ====== <?""Название""> [ АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> ТЗ № <?""№""> ] ================================================"}
},
{0,
{"Комментарий",0,0,"/ком","//+++ АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy"">
<?>
//--- АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy"">"}
},
{0,
{"Комментарий с пояснением (пояснение условно называется в этих шаблонах как ""Комментарий"")",0,0,"/комК","//+++ АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> # <?""Номент ТЗ или поясление (напиши хоть что-то по теме, чтобы потом лечге найти!)"">
<?>
//--- АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> # <?""Номент ТЗ или поясление (напиши хоть что-то по теме, чтобы потом лечге найти!)"">"}
},
{0,
{"Комментарий с пояснением и с ссылкой (лучше создавать такой коммент программно)",0,0,"","//+++ АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> # <?""Номент ТЗ или поясление (напиши хоть что-то по теме, чтобы потом лечге найти!)""> >> <?""Ссылка на документ с заданием"">
<?>
//--- АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> # <?""Номент ТЗ или поясление (напиши хоть что-то по теме, чтобы потом лечге найти!)""> >> <?""Ссылка на документ с заданием"">"}
},
{0,
{"Комментарий с заменой предыдущего кода",0,0,"/комЗ[амены]","//+++ АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> # <?""Номент ТЗ или поясление (напиши хоть что-то по теме, чтобы потом лечге найти!)"">
//Причина заменты кода: <?>
//+++Было до <?"""", ДатаВремя, """">
// Далее тут старый код, который теперь заменён
//---Было до <?"""", ДатаВремя, """">
<?>
//--- АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> # <?""Номент ТЗ или поясление (напиши хоть что-то по теме, чтобы потом лечге найти!)"">"}
},
{0,
{"Комментарий с пояснением",0,0,"/комП[ояснение]","//+++ АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> <?""Символы пояснения"", ВыборВарианта, ""//"", ""//"", "">>"", "">>"", ""[["", ""[["", ""**"", ""**"", ""#"", ""#""> <?""Текст пояснения"">
<?>
//--- АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> <?""Символы пояснения"", ВыборВарианта, ""//"", ""//"", "">>"", "">>"", ""[["", ""[["", ""**"", ""**"", ""#"", ""#""> <?""Текст пояснения"">"}
},
{0,
{"Было до_право",0,0,"былоП","// [ АйТи КучеровРМ ] Справа было до <?"""", ДатаВремя, """">: <?""Какое было предыдущее состояние"">"}
},
{0,
{"Было до_право (командой /БП (т.е. было справо))",0,0,"/БП","// [ АйТи КучеровРМ ] Справа было до <?"""", ДатаВремя, """">: <?""Какое было предыдущее состояние"">"}
},
{0,
{"Было до_лево",0,0,"былоЛ","// [ АйТи КучеровРМ ] Слево было до <?"""", ДатаВремя, """">: <?""Какое было предыдущее состояние"">"}
},
{0,
{"Было до_лево  (командой /БП (т.е. было слево))",0,0,"/БЛ","// [ АйТи КучеровРМ ] Слево было до <?"""", ДатаВремя, """">: <?""Какое было предыдущее состояние"">"}
},
{0,
{"Новое условие в Если",0,1,"","Если Истина Тогда // [ АйТи КучеровРМ ] было до <?"""", ДатаВремя, """">: <?""Какое было предыдущее состояние""> "}
},
{0,
{"Техническое задание",0,0,"/ТЗ","// ТЗ № <?""№"">"}
},
{0,
{"Замена кода",0,0,"/зам[ена]","// Причина заменты кода: 
//+++ Было до <?"""", ДатаВремя, """"> // Далее тут старый код, который теперь заменён
<?>
//--- Было до <?"""", ДатаВремя, """">"}
},
{0,
{"Бекап",0,0,"бек[ап]","1Cv8_КучеровРМ_<?"""", ДатаВремя, ""ДФ='yyyy-MM-dd_HH-mm'""><?"""", ВыборВарианта, ""Без расширения"", """", "".cf"", "".cf"", "".dt"", "".dt"">"}
},
{3,
{"Комментарии других языков (XML, HTML)",1,0,"",""},
{0,
{"Комментарий в XML, HTML",0,0,"","<!-- + АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> # <?""Номент ТЗ или поясление (напиши хоть что-то по теме, чтобы потом лечге найти!)""> -->
<?>
<!-- - АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> # <?""Номент ТЗ или поясление (напиши хоть что-то по теме, чтобы потом лечге найти!)""> -->"}
},
{0,
{"Комментарий в XML, HTML (через {})",0,0,"","<!--{ АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> # <?""Номент ТЗ или поясление (напиши хоть что-то по теме, чтобы потом лечге найти!)""> -->
<?>
<!--} АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> # <?""Номент ТЗ или поясление (напиши хоть что-то по теме, чтобы потом лечге найти!)""> -->"}
},
{0,
{"Комментарий в JSON (хотя они тут не предусмотрены)",0,0,"","{
   ""_comment"": ""АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> # <?""Номент ТЗ или поясление (напиши хоть что-то по теме, чтобы потом лечге найти!)"">"",
}"}
}
}
},
{1,
{"Внешние обработки",1,0,"",""},
{0,
{"Настройка внешней обработки",0,0,"","Функция СведенияОВнешнейОбработке() Экспорт

	СведенияОбОбработке = Новый Структура;
	//	1. Вид - вид обработки.
	//	Тип данных - строка, допустимо одно из 6 значений.
	//	Значения.
	//	1) Глобальные - ""ДополнительнаяОбработка"", ""ДополнительныйОтчет""
	//	2) Назначаемые - ""ЗаполнениеОбъекта"", ""Отчет"", ""ПечатнаяФорма"" или ""СозданиеСвязанныхОбъектов"".
	СведенияОбОбработке.Вставить(""Вид"", ""<?""Вид обработки"", ВыборВарианта, ""Дополнительная обработка"", ""ДополнительнаяОбработка"", ""Дополнительный отчет"", ""ДополнительныйОтчет"", ""Заполнение объекта"", ""ЗаполнениеОбъекта"", ""Отчет"", ""Отчет"", ""Печатная форма"", ""ПечатнаяФорма"", ""Создание связанных объектов"", ""СозданиеСвязанныхОбъектов"">"");

	//	2. Назначение - объект, для которого назначается данная обработка, 
	//	Массив строк имен объектов метаданных.
	//	Примеры значений массива - ""Документ.АвансовыйОтчет"" или ""Справочник.*"", где * - означает все объекта данного вида.
	//	Для глобальных (не назначаемых) обработок параметр не имеет смысла.
	ОбъектыМетаданных = Новый Массив;                  
	ОбъектыМетаданных.Добавить(""Документ.<?""Назначение обработки"", Документ>"");
	СведенияОбОбработке.Вставить(""Назначение"", ОбъектыМетаданных);
	
	//	3. Наименование - название обработки, произвольное наименование
	//	Тип данных - произвольная строка.
	//	Данное наименование будет отображаться в списке дополнительных обработок.
	СведенияОбОбработке.Вставить(""Наименование "", ""<?""Наименование обработки"">"");
	
	//	4. Версия - номер версии обработки
	//	Тип данных - строка в формате ""ХХ.ХХ"".
	//	Обозначает версию данной обработки, данная версия будет отображаться в списке дополнительных отчетов и обработок.
	СведенияОбОбработке.Вставить(""Версия "", ""1.0"");
	
	//	5. БезопасныйРежим - режим контроля прав пользователя.
	//	Тип данных - булево.
	СведенияОбОбработке.Вставить(""БезопасныйРежим"", <?""Безопасный режим"", ВыборВарианта, ""Да"", ""Истина"", ""Нет"", ""Ложь"">);
	
	//	6. Информация - краткое описание обработки.
	//	Тип данных - строка.
	//	Данное описание будет отображаться в списке дополнительных обработок.
	СведенияОбОбработке.Вставить(""Информация"", ""<?""Информация о обработке"">"");
	
	//	7. Команды - действия предоставляемые обработкой.
	//	Тип данных - таблица значений.
	//	Таблица содержит 5 колонок:
	//	1) Представление. Наименование команды в пользовательском интерфейсе;
	//	2) Идентификатор. Для печатных форм список макетов, для остальных обработок любая строка, уникальная для данной обработки.
	//	3) Использование. Строка, одно из значений - 
	//		- ОткрытиеФормы. Открывает форму обработки.
	//		- ВызовКлиентскогоМетода. Вызов клиентского экспортного метода модуля формы
	//		- ВызовСерверногоМетода. Вызов экспортного серверного метода модуля объекта.
	//		Для внешних печатных форм нужно указывать последнее значение.
	//	4) ПоказыватьОповещение. Булево, нужно ли показывать оповещение при начале и окончании действия.
	//	5) Модификатор. Для внешних печатных форм должно содержаться значение ""ПечатьMXL"".
	ТаблицаКоманд = ПолучитьТаблицуКоманд();
	ДобавитьКоманду(ТаблицаКоманд, ""<?""Представление. Наименование команды в пользовательском интерфейсе"">"", ""<?""Идентификатор. Для печатных форм список макетов, для остальных обработок любая строка, уникальная для данной обработки."">"", ""<?""Использование"", ВыборВарианта, ""Открытие формы"", ""ОткрытиеФормы"", ""Вызов клиентского метода"", ""ВызовКлиентскогоМетода"", ""Вызов серверного метода"", ""ВызовСерверногоМетода"">"");
	СведенияОбОбработке.Вставить(""Команды"", ТаблицаКоманд);
	
	Возврат СведенияОбОбработке;
	
КонецФункции // СведенияОВнешнейОбработке()

Функция ПолучитьТаблицуКоманд()

	ТаблицаКоманд = Новый ТаблицаЗначений;
	ТаблицаКоманд.Колонки.Добавить(""Представление"", Новый ОписаниеТипов(""Строка""));
	ТаблицаКоманд.Колонки.Добавить(""Идентификатор"", Новый ОписаниеТипов(""Строка""));
	ТаблицаКоманд.Колонки.Добавить(""Использование"", Новый ОписаниеТипов(""Строка""));
	ТаблицаКоманд.Колонки.Добавить(""ПоказыватьОповещение"", Новый ОписаниеТипов(""Булево""));
	ТаблицаКоманд.Колонки.Добавить(""Модификатор"", Новый ОписаниеТипов(""Строка""));

	Возврат ТаблицаКоманд;

КонецФункции

Процедура ДобавитьКоманду(ТаблицаКоманд, Представление, Идентификатор, Использование, ПоказыватьОповещение = Ложь, Модификатор = """")

	НоваяКоманда = ТаблицаКоманд.Добавить();
	НоваяКоманда.Представление = Представление;
	НоваяКоманда.Идентификатор = Идентификатор;
	НоваяКоманда.Использование = Использование;
	НоваяКоманда.ПоказыватьОповещение = ПоказыватьОповещение;
	НоваяКоманда.Модификатор = Модификатор;
  
КонецПроцедуры

Процедура ВыполнитьКоманду(ИдентификаторКоманды, ОбъектыНазначения, СозданныеОбъекты) Экспорт
	
	

КонецПроцедуры
"}
}
},
{7,
{"Транслит",1,0,"",""},
{0,
{"БЮ в <>",0,0,"БЮ","<>"}
},
{0,
{"ХЪ в []",0,0,"ХЪ","[<?>]"}
},
{0,
{"ТГДД в NULL",0,0,"ТГДД","NULL"}
},
{0,
{"ЭЭ в ''",0,0,"ЭЭ","'<?>'"}
},
{0,
{"ЮЮ",0,0,"ЮЮ","// >> <?>"}
},
{0,
{"Ю= в >=",0,0,"ю=",">="}
},
{0,
{"Б= в <=",0,0,"б=","<="}
}
},
{8,
{"Регулярные выражения",1,0,"",""},
{0,
{"ЗаменитьСимволыПоШаблону",0,0,"","&НаСервереБезКонтекста
Функция ЗаменитьСимволыПоШаблону(Строка, ШаблонЗамены, ЗаменитьНа = """")
	
	Если ПустаяСтрока(Строка) ИЛИ ПустаяСтрока(ШаблонЗамены) Тогда
		Возврат Строка; 
	КонецЕсли;
	
	RegExp 				= Новый COMОбъект(""VBScript.RegExp""); //Для 1C v 7.x: CreateObject(""VBScript.RegExp"") 
	RegExp.IgnoreCase 	= Истина; //Игнорировать регистр 
	RegExp.Global 		= Истина; //Поиск всех вхождений шаблона 
	RegExp.MultiLine 	= Истина; //Многострочный режим 
	RegExp.Pattern 		= ШаблонЗамены; 
	
	Возврат RegExp.Replace(Строка, ЗаменитьНа);
	
КонецФункции // ЗаменитьСимволыПоШаблону()"}
},
{0,
{"ОтобратьТолькоЧисла",0,0,"","&НаСервереБезКонтекста
Функция ОтобратьТолькоЧисла(Строка)
	
	Возврат ЗаменитьСимволыПоШаблону(Строка, ""[^0-9]"");
	
КонецФункции // ОтобратьТолькоЧисла()
 
"}
},
{0,
{"ОтборТолькоЧисел_РВ",0,0,"","RegExp 				= Новый COMОбъект(""VBScript.RegExp""); //Для 1C v 7.x: CreateObject(""VBScript.RegExp"") 
RegExp.IgnoreCase 	= Истина; //Игнорировать регистр 
RegExp.Global 		= Истина; //Поиск всех вхождений шаблона 
RegExp.MultiLine 	= Истина; //Многострочный режим 
RegExp.Pattern 		= ""[^0-9]""; //Отбор только чисел
СтрокаОбработана 	= RegExp.Replace(Строка, """");"}
},
{0,
{"РазложитьСтрокуВМассив",0,0,"","  // Пример с использованием предустановленной библиотеки RegExp, т.е. она есть в любом windows.
  Функция РазложитьСтрокуВМассив(Строка, Разделитель = "","") Экспорт
	  
	  RegExp = Новый COMОбъект(""VBScript.RegExp"");    // создаем объект для работы с регулярными выражениями
	  
	  //Параметры:
	  RegExp.MultiLine = Ложь;  // истина — текст многострочный, ложь — одна строка
	  RegExp.Global = Истина;   // истина — поиск по всей строке, ложь — до первого совпадения
	  RegExp.IgnoreCase = Ложь; // истина — игнорировать регистр строки при поиске
	  
	  //Разбор строки вида 1,СЛОВО,(1+2); Маска для разделителя ',' [^\,]*""
	  RegExp.Pattern = ""[^\"" + Разделитель + ""]+"";
	  Matches = RegExp.Execute (Строка);
	  
	  Массив = Новый Массив;
	  
	  Для Сч = 0 По Matches.Count - 1 Цикл
		  Массив.Добавить(Matches.Item(Сч).Value);
	  КонецЦикла;
	  
	  RegExp = Неопределено;
	  
	  Возврат Массив;
	  
  КонецФункции "}
},
{0,
{"Тест",0,0,"","RegExp 				= Новый COMОбъект(""VBScript.RegExp""); //Для 1C v 7.x: CreateObject(""VBScript.RegExp"") 
RegExp.IgnoreCase 	= Истина; //Игнорировать регистр 
RegExp.Global 		= Истина; //Поиск всех вхождений шаблона 
RegExp.MultiLine 	= Истина; //Многострочный режим 
RegExp.Pattern 		= Шаблон;

Если RegExp.Test(ПроверяемыйШаблон) Тогда
    Сообщить(""Совпал"");
КонецЕсли;"}
},
{0,
{"Примеры",0,0,"","///////////////////////////////////////////////////////////////////////
//Поиск вхождений подстроки
Процедура RegExp_Exec()
    
    //Для 1С 7.7:
    Истина=-1;
    Ложь=0;
    RegExp = CreateObject(""VBScript.RegExp"");
    
    RegExp.IgnoreCase = Ложь; //Игнорировать регистр
    RegExp.Global = Истина; //Поиск всех вхождений шаблона
    RegExp.MultiLine = Ложь; //Многострочный режим
    
    RegExp.Pattern = ""<[^>]*>""; //Ищем теги HTML
    Matches=RegExp.Execute(""Это <hr> строка <br> с тегами HTML"");
    ЧислоВхождений=Matches.Count();
    Если ЧислоВхождений>0 Тогда 
        Для к = 0 По ЧислоВхождений-1 Цикл
            Match = Matches.Item(к);
            Сообщить(""Найден тег:""+ Match.Value);
        КонецЦикла;
    Иначе
        Сообщить(""Вхождений шаблона не найдено"");
    КонецЕсли;
    //Выдаст в окно сообщений:    
    //Найден тег:<hr>
    //Найден тег:<br>    
КонецПроцедуры


Более продвинутый пример разбора HTML использует подвыражения (SubMatches) и позволяет находить как сами теги, так и текст между ними. 

///////////////////////////////////////////////////////////////////////
//Поиск вхождений подстроки с использованием подвыражений
Процедура RegExp_Exec1()
    
    //Для 1С 7.7:
    Истина=-1;
    Ложь=0;
    RegExp = CreateObject(""VBScript.RegExp"");
    
    RegExp.IgnoreCase = Ложь; //Игнорировать регистр
    RegExp.Global = Истина; //Поиск всех вхождений шаблона
    RegExp.MultiLine = Ложь; //Многострочный режим
    
    RegExp.Pattern = ""([^<]*)(<[^>]*>)([^<]*)""; //Ищем теги HTML, а также текст до и после тега
    Matches=RegExp.Execute(""  <tr><td id=aaa>Дятел <td> долбит <td> сосну </tr>"");
    ЧислоВхождений=Matches.Count();
    Если ЧислоВхождений>0 Тогда 
        Для к = 0 По ЧислоВхождений-1 Цикл
            Match = Matches.Item(к);
            
            SubMatches = Match.SubMatches;
            ЧислоПодвыражений=SubMatches.Count();
            Для н = 0 По ЧислоПодвыражений-1 Цикл
                SubMatch=SubMatches.Item(н);
                Если SubMatch="""" Тогда
                    Продолжить;
                КонецЕсли;    
                
                Сообщить(""Подстрока: ""+SubMatch);
            КонецЦикла;    
        КонецЦикла;
    Иначе
        Сообщить(""Вхождений шаблона не найдено"");
    КонецЕсли;
КонецПроцедуры

//Выводит в окно сообщений:
//Подстрока:   
//Подстрока: <tr>
//Подстрока: <td id=aaa>
//Подстрока: Дятел 
//Подстрока: <td>
//Подстрока:  долбит 
//Подстрока: <td>
//Подстрока:  сосну 
//Подстрока: </tr>


Часто регулярные выражения используются для тестирования строк, например пользовательского ввода. 
Этот пример позволяет узнать, является ли строка целым числом. 

///////////////////////////////////////////////////////////////////////
//Проверка подстроки
Процедура RegExp_Test()
    RegExp = CreateObject(""VBScript.RegExp"");
    RegExp.Pattern =  ""^\d+$""; //Шаблон, который соответствует целому числу
    стр=""12345"";//Строка, которую тестируем
    Если RegExp.Test(стр)=0 Тогда
        Сообщить(""Это не целое число"");
    Иначе
        Сообщить(""Это целое число"");
    КонецЕсли;
    //Выдаст в окно сообщений:    
    //""Это целое число""
КонецПроцедуры


Регулярные выражения поддерживают не только поиск, но и замену текста. При этом найденные подвыражения (в круглых скобках) могут быть представлены в строке замены как $1, $2 и т. д. 
(знак доллара используется в VBScript.RegExp; в других средах программирования, например в JavaScript, используемый для этой цели символ может отличаться). 

///////////////////////////////////////////////////////////////////////
//Замена текста в подстроке
Процедура RegExp_Replace()
    
    //Строка, где мы будем производить замены
    стр=""Дятел долбил сосну"";
    
    Истина=-1;
    Ложь=0;
    RegExp = CreateObject(""VBScript.RegExp"");
    
    RegExp.IgnoreCase = Истина; //Игнорировать регистр
    RegExp.Global = Истина; //Поиск всех вхождений шаблона
    RegExp.MultiLine = Истина; //Многострочный режим
    
    
    RegExp.Pattern = ""(долбил)""; 
    
    стр=RegExp.Replace(стр, ""про$1""); 
    Сообщить(стр);
    //Выдаст в окно сообщений:    
    //""Дятел продолбил сосну""
КонецПроцедуры"}
},
{0,
{"СтеретьВремя",0,0,"","&НаСервереБезКонтекста
Функция СтеретьВремя(Строка)
	// СтеретьВремя в наименовании документа
	Результат = ЗаменитьСимволыПоШаблону(Строка, ""(2[0-3]|[0-1]\d|0{1,2}):[0-5]\d:[0-5]\d"");
	Возврат Результат;

КонецФункции // ЕстьВремя()"}
},
{2,
{"Строки",1,0,"",""},
{0,
{"ОчиститьСтрокуПоШаблону",0,0,"","&НаСервереБезКонтекста
Функция ОчиститьСтрокуПоШаблону(Строка, Шаблон)
	
	Возврат ЗаменитьСимволыПоШаблону(Строка, Шаблон) 
	
КонецФункции // ОчиститьСтркуОтСимвола()"}
},
{0,
{"ОчиститьСтрокуОтСимволов",0,0,"","&НаСервереБезКонтекста
Функция ОчиститьСтрокуОтСимволов(Строка, СимволыДляОчищения)
	
	Возврат ЗаменитьСимволыПоШаблону(Строка, ""["" + СимволыДляОчищения + ""]"") ;
	
КонецФункции // ОчиститьСтркуОтСимвола()"}
}
}
},
{1,
{"Исключения",1,0,"",""},
{0,
{"Заметка",0,0,"искл[заметка]","//+++ <?"""", ДатаВремя, """"> Заметка выводимая через исключение
Попытка
	// В попытке может содержаться случай, при котором появляется баг в системе
	ПринудительныйВызовОшибкиДляПривлеченияВнимания 		= 1 / 0;
Исключение
	ПринудительныйВызовОшибкиДляПривлеченияВниманияИнфо 	= ИнформацияОбОшибке();
	ПринудительныйВызовОшибкиДляПривлеченияВниманияДопИнфо 	= ""
	|
	|Описание: """""" + ПринудительныйВызовОшибкиДляПривлеченияВниманияИнфо.Описание + """"""
	|ИсходнаяСтрока: """""" + ПринудительныйВызовОшибкиДляПривлеченияВниманияИнфо.ИсходнаяСтрока + """""""";
	ПринудительныйВызовОшибкиДляПривлеченияВниманияАвтор 	= ""
	|
	|Заметку добавил пользователь: """"АйТи КучеровРМ"""", <?"""", ДатаВремя, """">.""; 
	
	ПринудительныйВызовОшибкиДляПривлеченияВниманияЗаметка 	= ""<?""Текст заметки или комментария"">'""; // Причина, по которой надо вызвать исключение
	ПринудительныйВызовОшибкиДляПривлеченияВнимания 		= 
	""ПРИНУДИТЕЛЬНЫЙ ВЫЗОВ ОШИБКИ ДЛЯ ПРИВЛЕЧЕНИЯ ВНИМАНИЯ!
	|В модуле: """""" + ПринудительныйВызовОшибкиДляПривлеченияВниманияИнфо.ИмяМодуля + """""", 
	|в строке № "" + ПринудительныйВызовОшибкиДляПривлеченияВниманияИнфо.НомерСтроки + "".
	|Заметка: """""" + ПринудительныйВызовОшибкиДляПривлеченияВниманияЗаметка + """""""" +  
	//ПринудительныйВызовОшибкиДляПривлеченияВниманияДопИнфо + // Для вывода информации описания ошибки и вида исходной ошибочной строки 
	ПринудительныйВызовОшибкиДляПривлеченияВниманияАвтор;
	
	ВызватьИсключение(ПринудительныйВызовОшибкиДляПривлеченияВнимания);
	
КонецПопытки;
//--- <?"""", ДатаВремя, """"> Заметка выводимая через исключение
"}
}
},
{14,
{"Запрос",1,0,"",""},
{0,
{"ВыбратьПервые",0,0,"","КоличествоВыбираемых 	= ВыбратьПервые;
Если ВибиратьПервыеЗначения Тогда
	КоличествоВыбираемых 			= ВыбратьПервые;
	ЗапросВибиратьПервыеЗначения 	= "" ПЕРВЫЕ "" + КоличествоВыбираемых;
Иначе 
	ЗапросВибиратьПервыеЗначения 	= """";
КонецЕсли; 

Если ЗапросВибиратьПервыеЗначения = Неопределено Тогда
	ЗапросВибиратьПервыеЗначения 	= """"; 
КонецЕсли; 

Запрос 			= Новый Запрос;
Запрос.Текст 	= 
""ВЫБРАТЬ "" + ЗапросВибиратьПервыеЗначения + """}
},
{0,
{"ПодВыборка (ОбходРезультатаЗапроса.ПоГруппировкам)",0,0,"ЗапросПодвыб[орк]","Если НЕ РезультатЗапроса.Пустой() Тогда
	лВыборка 	= РезультатЗапроса.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	Пока лВыборка.Следующий() Цикл
		
		лПодВыборка 	= лВыборка.Выбрать();
		
		Пока лПодВыборка.Следующий() Цикл
			
			<?>
			
		КонецЦикла;
		
	Прервать;
		
	КонецЦикла;
Иначе
КонецЕсли;"}
},
{0,
{"РезультатЗапроса.Пустой Пока",0,0,"еслиРезП[ока]","Если НЕ РезультатЗапроса.Пустой() Тогда
	лВыборка 	= РезультатЗапроса.Выбрать();
	Пока лВыборка.Следующий() Цикл
		лВыборкаЭлем<?""Выбираемый элемент выборки, если есть (слитно)""> 	= лВыборка.<?""Выбираемый элемент выборки, если есть (слитно)"">;
		Прервать;
	КонецЦикла;
Иначе
КонецЕсли; "}
},
{0,
{"РезультатЗапроса.Пустой Если",0,0,"еслиРезЕ[сли]","Если НЕ РезультатЗапроса.Пустой() Тогда
	лВыборка 	= РезультатЗапроса.Выбрать();
	Если лВыборка.Следующий() Тогда
		лВыборкаЭлем<?""Выбираемый элемент выборки, если есть (слитно)""> 	= лВыборка.<?""Выбираемый элемент выборки, если есть (слитно)"">;
	КонецЕсли;
Иначе
КонецЕсли; 
"}
},
{0,
{"ДопЗапрос",0,0,"","Запрос.Текст 	= Запрос.Текст + ДопЗапрос;"}
},
{0,
{"Дописать параметр в запрос",0,0,"ЗапросЗам","Если НЕ ПустаяСтрока(<?""Имя параметра в запрос (Слитно)"">) Тогда			   
	Запрос<?""Замена точки в \""Запрос.Текст\"" (слитно)"">Текст 	= Запрос<?""Замена точки в \""Запрос.Текст\"" (слитно)"">Текст + ""
	|	И ДоговорыКонтрагентов.Наименование = &Наименование"";
	Запрос.УстановитьПараметр(""Наименование""	, <?""Имя параметра в запрос (Слитно)"">);
КонецЕсли;"}
},
{0,
{"ВыборкаДетальныеЗаписи",0,0,"ВДЗ[_]","ВДЗ_<?""Имя ревизита/поля (силитно)""> 	= ВыборкаДетальныеЗаписи.<?""Имя ревизита/поля (силитно)"">;"}
},
{0,
{"лВыборка",0,0,"Выборка[.]","лВыборка<?""Имя ревизита/поля (силитно)""> 	= лВыборка.<?""Имя ревизита/поля (силитно)"">;"}
},
{0,
{"Остаток от деления в запросе",0,0,"","<?""Делимое число""> - (<?""Делитель числа""> * ВЫРАЗИТЬ((<?""Делимое число""> / <?""Делитель числа"">) - 0.5 КАК ЧИСЛО(15, 0)))"}
},
{0,
{"Целая часть деления в запросе",0,0,"","ВЫБОР
	КОГДА <?""Название переменной числа (слитно)""> > 0
		ТОГДА ВЫРАЗИТЬ(<?""Название переменной числа (слитно)""> - 0.5 КАК ЧИСЛО(15, 0))
	ИНАЧЕ ВЫРАЗИТЬ(<?""Название переменной числа (слитно)""> + 0.5 КАК ЧИСЛО(15, 0))
КОНЕЦ"}
},
{0,
{"МенеджерВременныхТаблиц",0,0,"МВТ","лМвт<?""Имя менеджера временных таблиц (слитно)""> 	= Новый МенеджерВременныхТаблиц;"}
},
{0,
{"Удалить заданные временные таблицы",0,0,"","//Удаляю насозданные типовым методом временные таблицы, чтобы вызвать доработанный метод
лЗапросТекст 	= """";
Для каждого МенеджерТаблицыЭлем Из Менеджер.Таблицы Цикл
	
	лМенеджерТаблицыЭлемПолноеИмя 	= МенеджерТаблицыЭлем.ПолноеИмя; 
	Если лМенеджерТаблицыЭлемПолноеИмя = ""ТаблицаНераспределенных"" ИЛИ лМенеджерТаблицыЭлемПолноеИмя = ""ТаблицаОшибокТоварныеМеста"" Тогда
		лЗапросТекст = лЗапросТекст + ""УНИЧТОЖИТЬ "" + лМенеджерТаблицыЭлемПолноеИмя + ""
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|"";
	КонецЕсли; 
	
КонецЦикла;

Если НЕ ПустаяСтрока(лЗапросТекст) Тогда
	Запрос 	= Новый Запрос;
	Запрос.МенеджерВременныхТаблиц 	= Менеджер;
	Запрос.Текст 	= лЗапросТекст;
	Запрос.Выполнить();
КонецЕсли;"}
},
{0,
{"МенеджерВременныхТаблиц из вычисления выражения (Запрос.МенеджерВременныхТаблиц.Таблицы[0].ПолучитьДанные().Выгрузить())",0,0,"","Запрос.МенеджерВременныхТаблиц.Таблицы[0].ПолучитьДанные().Выгрузить()"}
},
{0,
{"Добавить данные в запрос (программно, через СтрЗаменить)",0,0,"","// Функция - Добавить данные в запрос
//
// Параметры:
//  пТекстЗапроса				 - Строка	 - Весь текст запроса для добавления в него своего кода
//  пТекстИсходнойСтрокиДляЗаменты		 - Строка	 - Часть запроса, которая будет искаться и заменяться так, чтобы после неё вставились наши новые данные
//  пСтруктураВставкиДанных		 - Структура	 - Данные полей и таблиц для подстановки. Ключ = ИмяТаблицы, чтобы поля были разными (нужно для уникальности структуры). Если имеется таблицы и её реквизиты.
//  							 - Строка	 - Строка для замены, проямо один текс заменится на этом, при необходимости с учетом параметра пТекстСтрокиДляПодстановки
//  пСимволВКонецСтроки			 - Строка	 - В конец каждой строки структуры будет добавлен этот символ, напр., "",""
//  пТекстВКонецЗапроса		 - Строка	 - Символ в самый конец запроса, напр., ""}""
//Возврат:
//	Булево - Есть в запросе пТекстЗапроса подстрока пТекстИсходнойСтрокиДляЗаменты
// АйТи КучеровРМ 26.07.2019 
Функция ДобавитьДанныеВЗапрос(пТекстЗапроса, Знач пТекстИсходнойСтрокиДляЗаменты, пСтруктураВставкиДанных, Знач пТекстИсходнойСтрокиДляПодстановки = """", пДобавляяПослеИсходнойСтроки = Истина, пСимволВКонецСтроки = "","", пТекстВКонецЗапроса = """") Экспорт
	
	лЕстьПодстрока 	= СтрНайти(пТекстЗапроса, пТекстИсходнойСтрокиДляЗаменты) > 0; 
	
	Если лЕстьПодстрока Тогда
		Если ПустаяСтрока(пТекстИсходнойСтрокиДляПодстановки) Тогда			   
			пТекстИсходнойСтрокиДляПодстановки 	= пТекстИсходнойСтрокиДляЗаменты;
		КонецЕсли; 
		
		Если ТипЗнч(пСтруктураВставкиДанных) = Тип(""Строка"") Тогда
			Если пДобавляяПослеИсходнойСтроки Тогда
				пТекстЗапроса 	= СтрЗаменить(пТекстЗапроса, пТекстИсходнойСтрокиДляЗаменты, 
				пТекстИсходнойСтрокиДляЗаменты + ""
				|"" + пСтруктураВставкиДанных);
			Иначе
				пТекстЗапроса 	= СтрЗаменить(пТекстЗапроса, пТекстИсходнойСтрокиДляЗаменты, пСтруктураВставкиДанных);
			КонецЕсли; 
		ИначеЕсли ТипЗнч(пСтруктураВставкиДанных) = Тип(""Структура"") Тогда
			Для каждого Элем Из пСтруктураВставкиДанных Цикл
				
				пТекстЗапроса 	= СтрЗаменить(пТекстЗапроса, пТекстИсходнойСтрокиДляПодстановки,
				пТекстИсходнойСтрокиДляЗаменты + ""
				|	"" + Элем.Значение + ""."" + Элем.Ключ + "" КАК "" + Элем.Ключ + пСимволВКонецСтроки);
				
			КонецЦикла;	
		КонецЕсли;
		
		пТекстЗапроса 	= пТекстЗапроса + пТекстВКонецЗапроса;
	КонецЕсли; 
	  
	Возврат лЕстьПодстрока
	
КонецФункции // ДобавитьДанныеВЗапрос()

//СписокЗапасыПоиска - Пример с убиранием и добавлением }
АйТи_ОбщиеФункцииСервер.ДобавитьДанныеВЗапрос(СписокЗапасыПоиска.ТекстЗапроса, ""СправочникНоменклатура.Ссылка КАК НоменклатураСсылка,"", ""isnull(НоменклатураДополнительныеРеквизиты.Значение, Неопределено) КАК Производитель,"");
АйТи_ОбщиеФункцииСервер.ДобавитьДанныеВЗапрос(СписокЗапасыПоиска.ТекстЗапроса, ""ПО СправочникНоменклатура.Ссылка = РезервыЗапасов.Номенклатура}"", ""
|ПО СправочникНоменклатура.Ссылка = РезервыЗапасов.Номенклатура
|ЛЕВОЕ СОЕДИНЕНИЕ Справочник.Номенклатура.ДополнительныеРеквизиты КАК НоменклатураДополнительныеРеквизиты
|	ПО НоменклатураДополнительныеРеквизиты.Ссылка = СправочникНоменклатура.Ссылка
|		И (НоменклатураДополнительныеРеквизиты.Свойство.Имя = """"Производитель"""")}"",, Ложь);

//СписокХарактеристик - Производитель
АйТи_ОбщиеФункцииСервер.ДобавитьДанныеВЗапрос(СписокХарактеристик.ТекстЗапроса, ""ВсеХарактеристикиСНоменклатурой.НоменклатураСсылка КАК НоменклатураСсылка,"", ""isnull(НоменклатураДополнительныеРеквизиты.Значение, Неопределено) КАК Производитель,"");
АйТи_ОбщиеФункцииСервер.ДобавитьДанныеВЗапрос(СписокХарактеристик.ТекстЗапроса, ""И СправочникХарактеристики.Ссылка = РезервыЗапасов.Характеристика"", ""
|ЛЕВОЕ СОЕДИНЕНИЕ Справочник.Номенклатура.ДополнительныеРеквизиты КАК НоменклатураДополнительныеРеквизиты
|	ПО ВсеХарактеристикиСНоменклатурой.НоменклатураСсылка = НоменклатураДополнительныеРеквизиты.Ссылка
|		И (НоменклатураДополнительныеРеквизиты.Свойство.Имя = """"Производитель"""")"");

//СписокХарактеристик - Поставщик
АйТи_ОбщиеФункцииСервер.ДобавитьДанныеВЗапрос(СписокХарактеристик.ТекстЗапроса, ""ВсеХарактеристикиСНоменклатурой.НоменклатураСсылка КАК НоменклатураСсылка,"", Новый Структура(""Поставщик"", ""ВсеХарактеристикиСНоменклатурой.НоменклатураСсылка""));
"}
}
},
{7,
{"СКД",1,0,"",""},
{0,
{"Группа в отборе",0,0,"","//Отбор в динамическом списке дс c группой условий

ЭлементыОтбора = ТекущиеЗаявкиТикеты.Отбор.Элементы;
ЭлементыОтбора.Очистить();
Группа = ЭлементыОтбора.Добавить(Тип(""ГруппаЭлементовОтбораКомпоновкиДанных""));
Группа.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИли;
//ДатаПостановки

ЭлементОтбора = Группа.Элементы.Добавить(Тип(""ЭлементОтбораКомпоновкиДанных"")); 
НовыйПолеКомпоновкиДанных = Новый ПолеКомпоновкиДанных(""ДатаПостановки"");
ЭлементОтбора.Использование  = Истина;
ЭлементОтбора.ЛевоеЗначение  = НовыйПолеКомпоновкиДанных; 
ЭлементОтбора.ВидСравнения   = ВидСравненияКомпоновкиДанных.Больше;
ЭлементОтбора.ПравоеЗначение = (НачалоДня(ТекущаяДата())-((3600*24)*7));;
//Выполнить

ЭлементОтбора = Группа.Элементы.Добавить(Тип(""ЭлементОтбораКомпоновкиДанных"")); 
НовыйПолеКомпоновкиДанных = Новый ПолеКомпоновкиДанных(""Выполнена"");
ЭлементОтбора.Использование  = Истина;
ЭлементОтбора.ЛевоеЗначение  = НовыйПолеКомпоновкиДанных; 
ЭлементОтбора.ВидСравнения   = ВидСравненияКомпоновкиДанных.Равно;
ЭлементОтбора.ПравоеЗначение = Ложь;
//ОтказОтЗадачи

ЭлементОтбора = Группа.Элементы.Добавить(Тип(""ЭлементОтбораКомпоновкиДанных"")); 
НовыйПолеКомпоновкиДанных = Новый ПолеКомпоновкиДанных(""ОтказОтЗадачи"");
ЭлементОтбора.Использование  = Ложь;
ЭлементОтбора.ЛевоеЗначение  = НовыйПолеКомпоновкиДанных; 
ЭлементОтбора.ВидСравнения   = ВидСравненияКомпоновкиДанных.Равно;
ЭлементОтбора.ПравоеЗначение = Ложь;"}
},
{0,
{"Программный вывод результат отчета СКД в таблицу значений",0,0,"","// Программный вывод результат отчета СКД в таблицу значений
// https://erpdev.ru/blog/471
//Для программного вывода результата отчета СКД в таблицу значений, необходимо в модуле объекта объявить обработчик событий «ПриКомпоновкеРезультата» и прописать код, который указан в примере:     

Процедура ПриКомпоновкеРезультата(ДокументРезультат, ДанныеРасшифровки, СтандартнаяОбработка)
        
    КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных();    
    МакетКомпоновкиДанных = КомпоновщикМакета.Выполнить(СхемаКомпоновкиДанных, КомпоновщикНастроек.ПолучитьНастройки(),,,Тип(""ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений""));
    
    // Инициализация процессора компоновки
    ПроцессорКомпоновкиДанных = Новый ПроцессорКомпоновкиДанных;
    ПроцессорКомпоновкиДанных.Инициализировать(МакетКомпоновкиДанных,,,);
    
    Таблица = Новый ТаблицаЗначений;
    
    // Получение результата
    ПроцессорВыводаРезультатаКомпоновкиДанных = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
    ПроцессорВыводаРезультатаКомпоновкиДанных.УстановитьОбъект(Таблица);
    ПроцессорВыводаРезультатаКомпоновкиДанных.Вывести(ПроцессорКомпоновкиДанных);
    
КонецПроцедуры"}
},
{0,
{"СКД программно",0,0,"","Функция АйТи_ФормированиеДанныхКонтрагентов(пОбщиеНастройки, ТипДанных) Экспорт
	
	ОбщиеНастройки = Новый Структура;
	Для Каждого ЭлементСтруктуры Из пОбщиеНастройки Цикл
	  ОбщиеНастройки.Вставить(ЭлементСтруктуры.Ключ, ЭлементСтруктуры.Значение);
	КонецЦикла;	
	
	Б24_ОбменСПорталомВызовСервера.ДобавитьСложныеНастройкиОбменаВСтруктуру(ОбщиеНастройки);
	
	Если ТипДанных = ОбщиеНастройки.ТипыОбъектовОбмена.Компания тогда
		
		СКД 	= Новый СхемаКомпоновкиДанных;
		ИД 		= СКД.ИсточникиДанных.Добавить();
		ИД.Имя 	= ""ИсточникДанных"";
		ИД.ТипИсточникаДанных 	= ""local"";
		НаборДанных 			= СКД.НаборыДанных.Добавить(Тип(""НаборДанныхЗапросСхемыКомпоновкиДанных""));
		НаборДанных.Имя 		= ""НаборДанный1"";
		НаборДанных.Запрос 		= ""ВЫБРАТЬ
		|	Контрагенты.Ссылка КАК Объект
		|ИЗ
		|	Справочник.Контрагенты КАК Контрагенты"";
		
		НаборДанных.ИсточникДанных 	= ""ИсточникДанных"";
		СхемаКомпоновкиДанных 		= СКД;
		
		//Настройки 	= Новый НастройкиКомпоновкиДанных; //КомпоновщикНастроек.Настройки; //КомпоновщикНастроек.Настройки - если с формы
		Настройки 	= ОбщиеНастройки.НастройиСинхронизацииКонтрагентов.НастройкиКомпоновкиДанныхКонтрагентов;
		
		//Настройки.Отбор = НастройкиМодуля.Отбор; //Так не присвоится, заругается
		
		//Помещаем в переменную данные о расшифровке данных 
		ДанныеРасшифровки = Новый ДанныеРасшифровкиКомпоновкиДанных;
		
		//Формируем макет, с помощью компоновщика макета 
		КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
		
		//Передаем в макет компоновки схему, настройки и данные расшифровки 
		МакетКомпоновки = КомпоновщикМакета.Выполнить(СхемаКомпоновкиДанных, Настройки, ДанныеРасшифровки);
		
		//Выполним компоновку с помощью процессора компоновки 
		ПроцессорКомпоновкиДанных = Новый ПроцессорКомпоновкиДанных;
		ПроцессорКомпоновкиДанных.Инициализировать(МакетКомпоновки,, ДанныеРасшифровки);
		
		//Очищаем поле табличного документа 
		//Результат = ЭлементыФормы.Результат;
		//Результат.Очистить();
		
		Запрос = Новый Запрос;
		
		КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных();
		
		//МакетКомпоновкиДанных = КомпоновщикМакета.Выполнить(СхемаВыгрузки, КомпоновщикНастроек.ПолучитьНастройки(),,,);
		
		Запрос.Текст = МакетКомпоновки.НаборыДанных[НаборДанных.Имя].Запрос;
		
		Для каждого Параметр Из МакетКомпоновки.ЗначенияПараметров Цикл
			Запрос.Параметры.Вставить(Параметр.Имя, Параметр.Значение);
		КонецЦикла;
		
		//Выводим результат в табличный документ 
		//ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВТабличныйДокумент;
		//ПроцессорВывода.УстановитьДокумент(Результат);
		//
		//ПроцессорВывода.Вывести(ПроцессорКомпоновкиДанных);
		//
		//ЭлементыФормы.Результат.ПоказатьУровеньГруппировокСтрок(0);
		////*
		//Запрос = ПолучитьЗапросДляВыгрузкиДанных(ОбщиеНастройки, ТипДанных, ОбщиеНастройки.СтруктураСхемКомпоновки.Компании, ОбщиеНастройки.НастройиСинхронизацииКонтрагентов.НастройкиКомпоновкиДанныхКонтрагентов);
		
		ТаблицаОбъектовОбменаВыгрузки = запрос.Выполнить().Выгрузить();
		
		Возврат ТаблицаОбъектовОбменаВыгрузки;
		
	КонецЕсли;
	
КонецФункции
"}
},
{0,
{"СКД программано (с сайта)",0,0,"","СхемаКомпоновки = Новый СхемаКомпоновкиДанных;
//   
//    ИсточникДанных = СхемаКомпоновки.ИсточникиДанных.Добавить();
//    ИсточникДанных.Имя = ""МойИсточникДанных"";
//    ИсточникДанных.ТипИсточникаДанных = ""Local"";
//   
//    НаборДанных = СхемаКомпоновки.НаборыДанных.Добавить(Тип(""НаборДанныхЗапросСхемыКомпоновкиДанных""));
//    НаборДанных.Имя = ""МойНаборДанных"";
//    НаборДанных.ИсточникДанных = ИсточникДанных.Имя;
//    НаборДанных.Запрос = ""ВЫБРАТЬ
//                         |    ПродажиОбороты.Номенклатура,
//                         |    ПродажиОбороты.Контрагент,
//                         |    ПродажиОбороты.СуммаОборот
//                         |ИЗ
//                         |    РегистрНакопления.Продажи.Обороты КАК ПродажиОбороты"";
//   
//    ДоступноеПоле = НаборДанных.Поля.Добавить(Тип(""ПолеНабораДанныхСхемыКомпоновкиДанных""));
//    ДоступноеПоле.Поле = ""Номенклатура"";
//    ДоступноеПоле.ПутьКДанным = ""Номенклатура"";
//    ДоступноеПоле.Роль.Измерение = Истина;"}
},
{0,
{"СКД программно 3",0,0,"","//Получаем схему из макета
СхемаКомпоновкиДанных = ПолучитьМакет(""ОтчетПоСборнымЗаказам"");

//создадим компоновщик настроек и загрузим настройки по умолчанию, вместо настроек по умолчанию можно использовать восстановленные настройки
КомпоновщикНастроек = Новый КомпоновщикНастроекКомпоновкиДанных();
КомпоновщикНастроек.Инициализировать(Новый ИсточникДоступныхНастроекКомпоновкиДанных(СхемаКомпоновкиДанных));
КомпоновщикНастроек.ЗагрузитьНастройки(СхемаКомпоновкиДанных.НастройкиПоУмолчанию);
Настройки = КомпоновщикНастроек.Настройки;

//установка параметров отчета, без КомпоновщикНастроекКомпоновкиДанных делать это гораздо сложнее
Настройки.ПараметрыДанных.УстановитьЗначениеПараметра(""СвойствоВодитель"",         мСвойствоВодитель);
Настройки.ПараметрыВывода.УстановитьЗначениеПараметра(""Заголовок"",            Заголовок);

//Помещаем в переменную данные о расшифровке данных - здесь ненужный пункт, но пусть будет.
ДанныеРасшифровки = Новый ДанныеРасшифровкиКомпоновкиДанных;

//Формируем макет, с помощью компоновщика макета
КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;

//Передаем в макет компоновки схему, настройки и данные расшифровки
МакетКомпоновки = КомпоновщикМакета.Выполнить(СхемаКомпоновкиДанных, Настройки, ДанныеРасшифровки);

//Выполним компоновку с помощью процессора компоновки
ПроцессорКомпоновкиДанных = Новый ПроцессорКомпоновкиДанных;
ПроцессорКомпоновкиДанных.Инициализировать(МакетКомпоновки, , ДанныеРасшифровки);

//Очищаем поле табличного документа
Результат = Новый ТабличныйДокумент();
//Выводим результат в табличный документ
ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВТабличныйДокумент;
ПроцессорВывода.УстановитьДокумент(Результат);

ПроцессорВывода.Вывести(ПроцессорКомпоновкиДанных);

Результат.ОтображатьЗаголовки = Ложь;
Результат.ОтображатьСетку = Ложь;
Результат.Показать();


//А вот бонусом программное восстановление значений полей из настроек для управляемой формы
	
&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	Отбор = Новый Структура();
	Отбор.Вставить(""КлючОбъекта"", ИмяФормы);
	Отбор.Вставить(""КлючНастройки"", ""Основная""); //тут имя настройки
	Отбор.Вставить(""Пользователь"", глЗначениеПеременной(""глТекущийПользователь"").Код);
	Настройки = ХранилищеНастроекДанныхФорм.Выбрать(Отбор);
	Если Настройки.Следующий() Тогда
		Для Каждого стр из Настройки.Настройки Цикл
			Выполнить(стр.Ключ + "" = стр.Значение"");
		КонецЦикла;
	КонецЕсли;
КонецПроцедуры"}
},
{0,
{"СКД отчет_Уровень группировки при открытии отчета",0,0,"","Процедура ПриКомпоновкеРезультата(ДокументРезультат, ДанныеРасшифровки, СтандартнаяОбработка) Экспорт
	// СКД Уровень группировки при открытии отчета
	СтандартнаяОбработка = Ложь;
	КомпоновщикМакет = Новый КомпоновщикМакетаКомпоновкиДанных;
	Макет = КомпоновщикМакет.Выполнить(СхемаКомпоновкиДанных, КомпоновщикНастроек.ПолучитьНастройки(), ДанныеРасшифровки);
	ПроцессорКомпоновки = Новый ПроцессорКомпоновкиДанных;
	ПроцессорКомпоновки.Инициализировать(Макет, , ДанныеРасшифровки);
	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВТабличныйДокумент;
	ПроцессорВывода.УстановитьДокумент(ДокументРезультат);
	ПроцессорВывода.Вывести(ПроцессорКомпоновки);
	
	//ДокументРезультат.ПоказатьУровеньГруппировокСтрок(2); //Уровень 3
	//ДокументРезультат.ПоказатьУровеньГруппировокСтрок(1); //Уровень 2
	//ДокументРезультат.ПоказатьУровеньГруппировокСтрок(0); //Уровень 1
КонецПроцедуры"}
},
{6,
{"СКД отбор для таблицы",1,0,"",""},
{1,
{"Рабочее",1,0,"",""},
{0,
{"СКД",0,0,"","Функция ПолучитьТЗКонрагенты(НастройкиКомпоновщика) Экспорт 
	ТЗКонрагенты = Новый ТаблицаЗначений;
	СхемаКомпоновкиДанныхКонсоли = ПолучитьМакет(""МакетСКД"");
	
	ИсполняемыеНастройки = НастройкиКомпоновщика;
	
	ПараметрСоздатьНаДату = ИсполняемыеНастройки.ПараметрыДанных.Элементы.Найти(""ТекущаяДата"");
	ПараметрСоздатьНаДату.Значение = СоздатьНаДату;
	ПараметрСоздатьНаДату.Использование = Истина;
	
	//ЭлементыОтбора = ИсполняемыеНастройки.Отбор.Элементы;
	//ЭлементОтбора = ЭлементыОтбора.Добавить(Тип(""ЭлементОтбораКомпоновкиДанных""));
	//ЭлементОтбора.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(""Контрагент"");   
	//ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.ВСписке;
	//ЭлементОтбора.Использование = Истина;
	//ЭлементОтбора.ПравоеЗначение = Справочники.Контрагенты.НайтиПоКоду(""00-013011"");
	
	КомпоновщикМакета 		= Новый КомпоновщикМакетаКомпоновкиДанных;
	МакетКомпоновкиДанных 	= КомпоновщикМакета.Выполнить(СхемаКомпоновкиДанныхКонсоли, ИсполняемыеНастройки,,,Тип(""ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений""));
	
	ПроцессорКомпоновкиДанных = Новый ПроцессорКомпоновкиДанных;
	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
	ПроцессорКомпоновкиДанных.Инициализировать(МакетКомпоновкиДанных);
	ПроцессорВывода.УстановитьОбъект(ТЗКонрагенты);
	ПроцессорВывода.Вывести(ПроцессорКомпоновкиДанных);	
	
	Возврат ТЗКонрагенты;
КонецФункции //ПолучитьМакетКомпоновкиДанных()"}
}
},
{0,
{"При создании",0,0,"","//ПриСозданииНаСервере
ФормаОбъект		= РеквизитФормыВЗначение(""Объект"");
СхемаКД			= ФормаОбъект.ПолучитьМакет(""МакетСКД"");

ВременноеХранилищеСКД = ПоместитьВоВременноеХранилище(СхемаКД, УникальныйИдентификатор);

//КомпоновщикНастроекКД элемент на форме из реквизита типа КомпоновщикНастроекКомпоновкиДанных
// На форму перетащен ""Отбор"" из ""Настройки""
КомпоновщикНастроекКД.Инициализировать(Новый ИсточникДоступныхНастроекКомпоновкиДанных(ВременноеХранилищеСКД));
КомпоновщикНастроекКД.ЗагрузитьНастройки(СхемаКД.НастройкиПоУмолчанию);
"}
},
{0,
{"Для вывода",0,0,"","//&НаСервере
//Для вывода
ФормаОбъект		= РеквизитФормыВЗначение(""Объект"");
СхемаКД			= ФормаОбъект.ПолучитьМакет(""МакетСКД"");

НастройкиКД = КомпоновщикНастроекКД.Настройки;

КомпоновщикМакетаКД	= Новый КомпоновщикМакетаКомпоновкиДанных;
МакетКД		= КомпоновщикМакетаКД.Выполнить(СхемаКД, НастройкиКД,,,Тип(""ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений""));

ПроцессорКД = Новый ПроцессорКомпоновкиДанных;
ПроцессорКД.Инициализировать(МакетКД);

ДеревоСкладТовар	= Новый ДеревоЗначений;
ПроцессорВывода	= Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
ПроцессорВывода.УстановитьОбъект(ДеревоСкладТовар);
ПроцессорВывода.Вывести(ПроцессорКД);

ЗначениеВРеквизитФормы(ДеревоСкладТовар, ""ДеревоСкладыТовары"");
"}
},
{0,
{"Отбор СКД (много кода)",0,0,"","//+++====== Отбор СКД ================================================

// Формирует синоним переменной.
// Пример: на входе ""ИмяПеременнойАБВГ"", на выходе ""Имя переменной АБВГ""
//
// Параметры
// ИмяРеквизита - Строка. Имя переменной, имя колонки таблицы
//
// Возвращаемое значение:
// Строка - Представление переменной
//
Функция СформироватьСиноним(ИмяРеквизита)
	
	Перем Синоним, ъ, Символ, ПредСимвол, СледСимвол, Прописная, ПредПрописная, СледПрописная, ДлинаСтроки;
	
	Синоним = ВРег(Сред(ИмяРеквизита, 1, 1));
	ДлинаСтроки = СтрДлина(ИмяРеквизита);
	Для ъ=2 По ДлинаСтроки Цикл
		Символ = Сред(ИмяРеквизита, ъ, 1);
		ПредСимвол = Сред(ИмяРеквизита, ъ-1, 1);
		СледСимвол = Сред(ИмяРеквизита, ъ+1, 1);
		Прописная = Символ = ВРег(Символ);
		ПредПрописная = ПредСимвол = ВРег(ПредСимвол);
		СледПрописная = СледСимвол = ВРег(СледСимвол);
		
		// Варианты:
		Если НЕ ПредПрописная И Прописная Тогда
			Синоним = Синоним + "" "" + Символ;
		ИначеЕсли Прописная И НЕ СледПрописная Тогда
			Синоним = Синоним + "" "" + Символ;
		Иначе
			Синоним = Синоним + Символ;
		Конецесли;
	КонецЦикла;
	
	Возврат Синоним;
	
КонецФункции // СформироватьСиноним()

&НаСервере
Функция ПолучитьКлючНастроек()
	
	ЭтотОбъектМетаданные 	= ПолучитьМетаданныеОбработки();
	ИмяОбработки 			= ЭтотОбъектМетаданные.Имя;	
	
	КлючДляПользователя 	= Ложь;
	Если КлючДляПользователя Тогда
		ТекущийПользователь = ""."" + СтрЗаменить(ИмяПользователя(), "" "", """");
	Иначе
		ТекущийПользователь = """";
	КонецЕсли; 
	
	КлючНастроек 			= ""Обработка."" + ИмяОбработки + ТекущийПользователь;
	
	Возврат КлючНастроек;
	
КонецФункции

&НаСервере
Функция ОпределитьОтборНаСервере(пНастройкиКомпоновщика = Неопределено)
	
	пОбъект = РеквизитФормыВЗначение(""Объект""); 
	МакетСКД = пОбъект.ПолучитьМакет(""СхемаКомпоновкиДанных"");
	
	АдресВременногоХранилищаМакетаСКД = ПоместитьВоВременноеХранилище(МакетСКД, Новый УникальныйИдентификатор());
	
	ИсточникНастроек = Новый ИсточникДоступныхНастроекКомпоновкиДанных(АдресВременногоХранилищаМакетаСКД);
	КомпоновщикНастроекКомпоновкиДанных.Инициализировать(ИсточникНастроек);
	
	Если пНастройкиКомпоновщика = Неопределено Тогда
		КомпоновщикНастроекКомпоновкиДанных.ЗагрузитьНастройки(МакетСКД.НастройкиПоУмолчанию);
	Иначе
		КомпоновщикНастроекКомпоновкиДанных.ЗагрузитьНастройки(пНастройкиКомпоновщика);
	Конецесли;
	//ЗначениеВРеквизитФормы(КомпоновщикНастроекКомпоновкиДанных,""КомпоновщикНастроекКомпоновкиДанных"");
	//ЗначениеВРеквизитФормы(СправочникОбъект,""Объект"");
	
КонецФункции

&НаКлиенте
Процедура ЗаполнитьТаблицу(Команда)
	
	РегенерацияТаблицы();
	
	// Приминение условных оформлений
	ПерезаполнитьУФФормы();
	
	// Дополнительные программные условные оформления
	ПрименитьУсловноеОфомление(""Таблица.Флаг"", ВидСравненияКомпоновкиДанных.Равно, Истина, ""Таблица"", , , , Истина); // Выделение жирным строк с флагом
	
КонецПроцедуры

&НаКлиенте
Процедура РегенерацияТаблицы()
	
	СформироватьТаблицуИзСКД();
	
	ТаблицаПриИзменении(Неопределено);
	
КонецПроцедуры

&НаКлиенте
Процедура СформироватьТаблицуИзСКД()
	
	Если Таблица.Количество() > 0 Тогда
		Ответ = Вопрос(""Перед заполнением таблица будет очищена. Заполнить?"", РежимДиалогаВопрос.ДаНет, , КодВозвратаДиалога.Нет, ""Проверка заполнения табличной части"");
		Если Ответ = КодВозвратаДиалога.Нет Тогда
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	ЗаполнитьТаблицуНаСервере();
	//Элементы.ОбъектРезультатВыборкиДоговора.Свернуть(""Контрагент, СсылкаНаДоговор, ДатаДействияДоговора"");
	
КонецПроцедуры

&НаСервере
Процедура УстановитьЗаголовокКолонки(ИмяКолонки, ЗначениеЗаголовка)
	
	ЭлементНайти = Элементы.Найти(ИмяКолонки);
	Если ЭлементНайти = Неопределено Тогда
		Возврат;	
	КонецЕсли; 
	
	ЭлементНайти.Заголовок 				= ЗначениеЗаголовка;
	
	ПредставлениеКолонокТекущая 		= ПредставлениеКолонок.НайтиПоЗначению(ИмяКолонки);
	ПредставлениеКолонокТекущая.Представление = ЗначениеЗаголовка;
	
КонецПроцедуры // УстановитьВидимостьКолонки()

&НаСервере
Процедура УстановитьВидимостьКолонки(ИмяКолонки, ЗначениеВидимости)
	
	ЭлементНайти = Элементы.Найти(ИмяКолонки);
	Если ЭлементНайти = Неопределено Тогда
		Возврат;	
	КонецЕсли; 
	
	ЭлементНайти.Видимость 				= ЗначениеВидимости;
	
	ПредставлениеКолонокТекущая 		= ПредставлениеКолонок.НайтиПоЗначению(ИмяКолонки);
	ПредставлениеКолонокТекущая.Пометка = ЗначениеВидимости;
	
КонецПроцедуры // УстановитьВидимостьКолонки()
 
&НаСервере
Процедура ЗаполнитьТаблицуНаСервере()
	
	// Поля необходимые для вывода в таблицу результата на форме.
	СтруктураНастроек = ПолучитьПустуюСтруктуруНастроек();
	
	СтруктураНастроек.КомпоновщикНастроек            = КомпоновщикНастроекКомпоновкиДанных;
	СтруктураНастроек.ИмяМакетаСхемыКомпоновкиДанных = ПолучитьСхемуКомпоновкиДанных(Истина);
	
	Таблица.Очистить();
	ПредставлениеКолонок.Очистить();
	
	// ВыполнениеЗапроса
	ОбработкаОбъект = РеквизитФормыВЗначение(""Объект"");
	
	Запросы = ПодготовитьСтруктуруДанных(СтруктураНастроек, ОбработкаОбъект);
	
	Запрос = Запросы.ЗапросНабора1;
	// Установка параметров для запроса (параметры в СКД на соответствующей вкладке)
	//Запрос.УстановитьПараметр(""ДатаНачала"", ПериодФормы.ДатаНачала);
	//Запрос.УстановитьПараметр(""ДатаОкончания"", ПериодФормы.ДатаОкончания);
	РезультатЗапроса = Запрос.Выполнить();
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		РезультатЗапросаТЗ = РезультатЗапроса.Выгрузить();
		РезультатЗапросаТЗКолонки = РезультатЗапросаТЗ.Колонки;
		
		Для каждого ИмяКолонки Из РезультатЗапросаТЗКолонки Цикл
			
			//Таблица.Колонки.Добавить(ИмяКолонки);
			ИмяКолонкиИмя 		= ИмяКолонки.Имя;
			ИмяКолонкиЗаголовок = ИмяКолонки.Заголовок; 
			ИмяКолонкиТипЗначения = ИмяКолонки.ТипЗначения;
			
			ПредставлениеКолонок.Добавить(ИмяКолонкиИмя, ИмяКолонкиЗаголовок, Истина); // Пометкой отмечаются видимые
			
			ДобавитьКолонкуНаСервере(ИмяКолонкиИмя, ИмяКолонкиТипЗначения, СформироватьСиноним(ИмяКолонкиЗаголовок), ""Таблица"", Элементы.Таблица);
			
		КонецЦикла;
		
		Таблица.Загрузить(РезультатЗапросаТЗ);
	КонецЕсли; 
	
	// Если нужно снять видимость, то делать это через: УстановитьВидимостьКолонки(ИмяКолонки, ЗначениеВидимости)
	ТаблицаСсылкаИмя = ""Ссылка"";
	УстановитьВидимостьКолонки(ТаблицаСсылкаИмя, Истина);
	
	// Установка видимости для служебных колонок (для отбора или условного оформления)
	//НазваниеКолонки = ""НазваниеКолонки"";
	//Если Элементы.Найти(НазваниеКолонки) <> Неопределено Тогда // Т.к. могло вернуться 0 элементов
	//	Элементы[НазваниеКолонки].Видимость = Ложь;  	
	//КонецЕсли;
	
	// Выполнение запроса для другого набора данных
	//Запрос = Запросы.ЗапросНабора2;
	//РезультатЗапроса = Запрос.Выполнить();
	//
	//Если НЕ РезультатЗапроса.Пустой() Тогда
	//	РезультатЗапросаТЗ = РезультатЗапроса.Выгрузить();
	//	Таблица.Загрузить(РезультатЗапросаТЗ);
	//КонецЕсли;
	
	Элементы.ПредставлениеКолонок.Видимость = УстановитьВидимостьНастройкиПредставления();
	
	Если Таблица.Количество() = 0 Тогда
		Сообщить(""Не найдено элементов!"");
	КонецЕсли; 
	
КонецПроцедуры // ЗаполнитьТаблицуТоваровНаСервере()

//Процедура программно добавит колонку в таблицу
//-------------------------------------------------------------------------
//Параметры:
//		ИмяКолонки - Строка - вида ""Тест3""
//		ОписаниеТипов - ОписаниеТипов - напр., ""Строка""
//		Заголовок - Строка - напр., ""Пример""
//		Реквизит - Строка - Путь к реквизиту, напр ""Таблица"" или ""Объект.Таблица""
//		ЭлементыРеквизит - ТаблицаФормы - Путь к элементу на форме
//-------------------------------------------------------------------------
//автор: Кучеров Р 28.05.2018 
&НаСервере
Процедура ДобавитьКолонкуНаСервере(ИмяКолонки, ОписаниеТипов, Заголовок, Реквизит, ЭлементыРеквизит)
	
	Если Элементы.Найти(ИмяКолонки) = Неопределено Тогда
		нРеквизиты = Новый Массив;
		нРеквизиты.Добавить(Новый РеквизитФормы(ИмяКолонки, Новый ОписаниеТипов(ОписаниеТипов), Реквизит, Заголовок, Истина));
		ИзменитьРеквизиты(нРеквизиты);
		
		нЭлемент = Элементы.Добавить(ИмяКолонки, Тип(""ПолеФормы""), ЭлементыРеквизит);
		нЭлемент.Вид = ВидПоляФормы.ПолеВвода;
		нЭлемент.ПутьКДанным = Реквизит + ""."" + ИмяКолонки;
	КонецЕсли; 
	
КонецПроцедуры

//Процедура ПрименитьУсловноеОфомление 
//-------------------------------------------------------------------------
//Параметры:
//		ИмяПроверяемогоЭлемента - Строка - Напр., ""Объект.Имя_Проверяемого_Элемента""
//		ВидСравненияКД - Строка - ВидСравненияКомпоновкиДанных., напр ВидСравненияКомпоновкиДанных.Равно
//		ПравоеЗначениеОтбора - ЛюбойТип - Ннапр., Истина
//		ИмяОформляемогоЭлемента - Строка - Напр., ""Имя_Оформляемого_Элемента""
//		ИдентификаторПользовательскойНастройки - Строка - Напр., ""ИдентификаторПользовательскойНастройки"" (ИПН)
//														если заданный ИПН не найден, будет добавлен слемент с этим ИПН
//		ЦветТекста - WebЦвета - Напр., WebЦвета.Черный
//		ЦветФона - WebЦвета - Напр., WebЦвета.Лосоль
//		ЖирныйШрифт - Булево - Напр., Истина
//-------------------------------------------------------------------------
//автор: КучеровРМ 30.07.2018
&НаСервере
Процедура ПрименитьУсловноеОфомление(ИмяПроверяемогоЭлемента, ВидСравненияКД, ПравоеЗначениеОтбора, ИмяОформляемогоЭлемента, ИдентификаторПользовательскойНастройки = """", ЦветТекста = Неопределено, ЦветФона = Неопределено, ЖирныйШрифт = Ложь)
	
	УсловноеОформлениеЭлементы = УсловноеОформление.Элементы;
	
	Если ПустаяСтрока(ИдентификаторПользовательскойНастройки) Тогда
		ПрисвоитьИдентификаторПользовательскойНастройки = ИмяПроверяемогоЭлемента + ""_"" + ИмяОформляемогоЭлемента;
	КонецЕсли;
	
	ЕстьЭлементСИПН = Ложь;
	
	Для каждого ЭлементУО Из УсловноеОформлениеЭлементы Цикл
		
		Если ЭлементУО.ИдентификаторПользовательскойНастройки = ПрисвоитьИдентификаторПользовательскойНастройки Тогда
			ЕстьЭлементСИПН = Истина;
		КонецЕсли; 
		
	КонецЦикла;
	
	Если НЕ ЕстьЭлементСИПН Тогда // Добавляем новое условное офомление
		//УсловноеОформлениеЭлементы = УсловноеОформление.Элементы;
		ЭлементОформления = УсловноеОформлениеЭлементы.Добавить();
		
		ЭлементОформления.ИдентификаторПользовательскойНастройки = ПрисвоитьИдентификаторПользовательскойНастройки;
		// Создаем условие отбора
		ЭлементОтбора = ЭлементОформления.Отбор.Элементы.Добавить(Тип(""ЭлементОтбораКомпоновкиДанных""));
		ЭлементОтбора.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяПроверяемогоЭлемента); // ИмяПроверяемогоЭлемента = ""Объект.Имя_Проверяемого_Элемента""
		ЭлементОтбора.ВидСравнения = ВидСравненияКД; 
		//Значение для отбора
		ЭлементОтбора.ПравоеЗначение = ПравоеЗначениеОтбора;
		ЭлементОтбора.Использование = Истина;
		// Установка значения элемента УО
		Если ЦветТекста <> Неопределено Тогда
			ЭлементОформления.Оформление.УстановитьЗначениеПараметра(""ЦветТекста"", ЦветТекста); // WebЦвета.Черный
		КонецЕсли; 
		Если ЦветФона <> Неопределено Тогда
			ЭлементОформления.Оформление.УстановитьЗначениеПараметра(""ЦветФона"", ЦветФона); // Томатный, Лосоль
		КонецЕсли;
		Если ЖирныйШрифт Тогда
			ЭлементОформления.Оформление.УстановитьЗначениеПараметра(""Шрифт"", Новый Шрифт(, 10, Истина,,,,,)); //Выделение жирным шрифтом
		КонецЕсли;
		
		// Создаем поля оформления
		ПолеОформления = ЭлементОформления.Поля.Элементы.Добавить();
		ПолеОформления.Поле = Новый ПолеКомпоновкиДанных(ИмяОформляемогоЭлемента); // ИмяОформляемогоЭлемента = ""Имя_Оформляемого_Элемента""
		ПолеОформления.Использование = Истина;
	КонецЕсли;
	
КонецПроцедуры

 
&НаСервере
Процедура ДобавитьУсловноеОфомление(УсловноеОформлениеЭлементы, ИмяПроверяемогоЭлемента, ИмяОформляемогоЭлемента, ИдентификаторПользовательскойНастройки = """")
	
	//УсловноеОформлениеЭлементы = УсловноеОформление.Элементы;
	ЭлементОформления = УсловноеОформлениеЭлементы.Добавить();
	
	ЭлементОформления.ИдентификаторПользовательскойНастройки = ИдентификаторПользовательскойНастройки;
	// Создаем условие отбора
	ЭлементОтбора = ЭлементОформления.Отбор.Элементы.Добавить(Тип(""ЭлементОтбораКомпоновкиДанных""));
	ЭлементОтбора.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяПроверяемогоЭлемента); // ИмяПроверяемогоЭлемента = ""Объект.Имя_Проверяемого_Элемента""
	ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно; 
	//Значение для отбора
	ЭлементОтбора.ПравоеЗначение = Истина;
	ЭлементОтбора.Использование = Истина;
	// Установка значения элемента УО
	//ЭлементОформления.Оформление.УстановитьЗначениеПараметра(""ЦветТекста"", WebЦвета.Черный);
	//ЭлементОформления.Оформление.УстановитьЗначениеПараметра(""ЦветФона"", WebЦвета.Коралловый); // Томатный, Лосоль
	ЭлементОформления.Оформление.УстановитьЗначениеПараметра(""Шрифт"", Новый Шрифт(, 10, Истина,,,,,)); //Выделение жирным шрифтом
	// Создаем поля оформления
	ПолеОформления = ЭлементОформления.Поля.Элементы.Добавить();
	ПолеОформления.Поле = Новый ПолеКомпоновкиДанных(ИмяОформляемогоЭлемента); // ИмяОформляемогоЭлемента = ""Имя_Оформляемого_Элемента""
	ПолеОформления.Использование = Истина; 
	
КонецПроцедуры

//Возвращает схему компановки данных, полученную из макета или только имя макета (в зависсимости от параметра)
&НаСервере
Функция ПолучитьСхемуКомпоновкиДанных(ТолькоИмяВернуть = Ложь)
	
	СхемаКомпоновкиДанных 	= Неопределено;
	ОбработкаОбъект 		= РеквизитФормыВЗначение(""Объект"");
    
	СхемаКомпоновкиДанныхИмя = ""СхемаКомпоновкиДанных"";
	
	Возврат  ?(ТолькоИмяВернуть, СхемаКомпоновкиДанныхИмя, ОбработкаОбъект.ПолучитьМакет(СхемаКомпоновкиДанныхИмя));
 	
КонецФункции

&НаСервере
Функция ПолучитьПустуюСтруктуруРезультата() Экспорт
	
	Структура = Новый Структура;
	Структура.Вставить(""ЗапросНабора1"" , Неопределено);
	//Структура.Вставить(""ЗапросНабора2"", Новый Соответствие);
	
	Возврат Структура;
	
КонецФункции // ПолучитьПустуюСтруктуруРезультата()

&НаСервере
 Функция ПолучитьПустуюСтруктуруНастроек() Экспорт
	
	СтруктураНастроек = Новый Структура;
	СтруктураНастроек.Вставить(""ОбязательныеПоля""   , Новый Массив); //
	СтруктураНастроек.Вставить(""ПараметрыДанных""    , Новый Структура);
	СтруктураНастроек.Вставить(""КомпоновщикНастроек"", Неопределено); // Отбор
	СтруктураНастроек.Вставить(""ИмяМакетаСхемыКомпоновкиДанных"" , Неопределено);
	
	Возврат СтруктураНастроек;
	
КонецФункции

&НаСервере
//Функция Функция подготавливает структуру данных, необходимую для вывода
//-------------------------------------------------------------------------
//Параметры:
//		СтруктураНастроек - Тип - описание
//		ОбработкаОбъект - Тип - описание
//Возвращаемое значение:
//		Стрруктура - описание
//-------------------------------------------------------------------------
//автор: Кучеров Р 28.05.2018 
Функция ПодготовитьСтруктуруДанных(СтруктураНастроек, ОбработкаОбъект) Экспорт
    
	СтруктураРезультата = ПолучитьПустуюСтруктуруРезультата();
	
	////////////////////////////////////////////////////////////////////////////////
	// ПОДГОТОВКА СХЕМЫ КОМПОНОВКИ ДАННЫХ И КОМПОНОВЩИКА НАСТРОЕК СКД
	
	// Схема компоновки.
	СхемаКомпоновкиДанных = ОбработкаОбъект.ПолучитьМакет(СтруктураНастроек.ИмяМакетаСхемыКомпоновкиДанных);

	// Подготовка компоновщика макета компоновки данных.
	Компоновщик 	= Новый КомпоновщикНастроекКомпоновкиДанных;
	НовыйИсточник 	= Новый ИсточникДоступныхНастроекКомпоновкиДанных(СхемаКомпоновкиДанных);
	Компоновщик.Инициализировать(НовыйИсточник);
	Компоновщик.ЗагрузитьНастройки(СхемаКомпоновкиДанных.НастройкиПоУмолчанию);
	
	//Копирование настроек с формы в компоновщик	
	Если СтруктураНастроек.КомпоновщикНастроек <> Неопределено Тогда
		СкопироватьЭлементы(Компоновщик.Настройки.Отбор, СтруктураНастроек.КомпоновщикНастроек.Настройки.Отбор);
		СкопироватьЭлементы(Компоновщик.Настройки.Выбор, СтруктураНастроек.КомпоновщикНастроек.Настройки.Выбор);
		СкопироватьЭлементы(Компоновщик.Настройки.Порядок, СтруктураНастроек.КомпоновщикНастроек.Настройки.Порядок);
		СкопироватьЭлементы(Компоновщик.Настройки.УсловноеОформление, СтруктураНастроек.КомпоновщикНастроек.Настройки.УсловноеОформление);
	КонецЕсли;
	
	// Параметры компоновщика настроек.
	//Если СтруктураНастроек.КомпоновщикНастроек <> Неопределено Тогда
	//	Для каждого Элемент  из Компоновщик.Настройки.ПараметрыДанных.Элементы Цикл
	//		ЗначениеПараметраИзСтруктурыНастроек = СтруктураНастроек.КомпоновщикНастроек.Настройки.ПараметрыДанных.НайтиЗначениеПараметра(Элемент.Параметр) ;
	//		Если Строка(ЗначениеПараметраИзСтруктурыНастроек.Параметр) = ""ВыводитьСерии"" Тогда
	//			ЗначениеПараметра = ЗначениеПараметраИзСтруктурыНастроек.Значение и ЗначениеПараметраИзСтруктурыНастроек.Использование;
	//			Компоновщик.Настройки.ПараметрыДанных.УстановитьЗначениеПараметра(Элемент.Параметр,ЗначениеПараметра);
	//		Иначе	
	//			Если ЗначениеПараметраИзСтруктурыНастроек.Использование Тогда
	//				Компоновщик.Настройки.ПараметрыДанных.УстановитьЗначениеПараметра(Элемент.Параметр,ЗначениеПараметраИзСтруктурыНастроек.Значение);
	//			КонецЕсли;
	//		КонецЕсли;			
	//	КонецЦикла;
	//КонецЕсли; 	
	// Компоновка макета компоновки данных.
	КомпоновщикМакета 		= Новый КомпоновщикМакетаКомпоновкиДанных;
	МакетКомпоновкиДанных 	= КомпоновщикМакета.Выполнить(СхемаКомпоновкиДанных, Компоновщик.Настройки,,,Тип(""ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений""));
	
	////////////////////////////////////////////////////////////////////////////////
	// ПОДГОТОВКА ВСПОМОГАТЕЛЬНЫХ ДАННЫХ ДЛЯ СОПОСТАВЛЕНИЯ ПОЛЕЙ ШАБЛОНА И СКД
	
	//Для каждого Поле Из МакетКомпоновкиДанных.НаборыДанных.НаборДанных1.Поля Цикл
	//	СтруктураРезультата.СоответствиеПолейСКДКолонкамТаблицыТоваров.Вставить(ПолучитьИмяПоляВШаблоне(Поле.ПутьКДанным), Поле.Имя);
	//КонецЦикла;
	
	////////////////////////////////////////////////////////////////////////////////
	// ВЫПОЛНЕНИЕ ЗАПРОСА
	
	СтруктураРезультата.ЗапросНабора1 = Новый Запрос(МакетКомпоновкиДанных.НаборыДанных.НаборДанных1.Запрос);
	//СтруктураРезультата.ЗапросНабора2 = Новый Запрос(МакетКомпоновкиДанных.НаборыДанных.НаборДанных2.Запрос);
	
	// Заполнение параметров с полей отбора компоновщика настроек формы обработки.
	Для каждого Параметр Из МакетКомпоновкиДанных.ЗначенияПараметров Цикл
		СтруктураРезультата.ЗапросНабора1.Параметры.Вставить(Параметр.Имя, Параметр.Значение);
		//СтруктураРезультата.ЗапросНабора2.Параметры.Вставить(Параметр.Имя, Параметр.Значение);
	КонецЦикла;
	
	Возврат СтруктураРезультата;
	
КонецФункции // ПодготовитьСтруктуруДанных()

&НаСервере
Процедура ЗаполнитьЭлементы(ПриемникЗначения, ИсточникЗначения, ПервыйУровень = Неопределено)
	
	Если ТипЗнч(ПриемникЗначения) = Тип(""КоллекцияЗначенийПараметровКомпоновкиДанных"") Тогда
		КоллекцияЗначений = ИсточникЗначения;
	Иначе
		КоллекцияЗначений = ИсточникЗначения.Элементы;
	КонецЕсли;
	
	Для каждого ЭлементИсточник Из КоллекцияЗначений Цикл
		Если ПервыйУровень = Неопределено Тогда
			ЭлементПриемник = ПриемникЗначения.НайтиЗначениеПараметра(ЭлементИсточник.Параметр);
		Иначе
			ЭлементПриемник = ПервыйУровень.НайтиЗначениеПараметра(ЭлементИсточник.Параметр);
		КонецЕсли;
		Если ЭлементПриемник = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		ЗаполнитьЗначенияСвойств(ЭлементПриемник, ЭлементИсточник);
		Если ТипЗнч(ЭлементИсточник) = Тип(""ЗначениеПараметраКомпоновкиДанных"") Тогда
			Если ЭлементИсточник.ЗначенияВложенныхПараметров.Количество() <> 0 Тогда
				ЗаполнитьЭлементы(ЭлементПриемник.ЗначенияВложенныхПараметров, ЭлементИсточник.ЗначенияВложенныхПараметров, ПриемникЗначения);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

&НаСервере
// Копирует элементы из одной коллекции в другую
Процедура СкопироватьЭлементы(ПриемникЗначения, ИсточникЗначения, ПроверятьДоступность = Ложь, ОчищатьПриемник = Истина) 
	
	Если ТипЗнч(ИсточникЗначения) = Тип(""УсловноеОформлениеКомпоновкиДанных"")
		ИЛИ ТипЗнч(ИсточникЗначения) = Тип(""ВариантыПользовательскогоПоляВыборКомпоновкиДанных"")
		ИЛИ ТипЗнч(ИсточникЗначения) = Тип(""ОформляемыеПоляКомпоновкиДанных"")
		ИЛИ ТипЗнч(ИсточникЗначения) = Тип(""ЗначенияПараметровДанныхКомпоновкиДанных"") Тогда
		СоздаватьПоТипу = Ложь;
	Иначе
		СоздаватьПоТипу = Истина;
	КонецЕсли;
	ПриемникЭлементов = ПриемникЗначения.Элементы;
	ИсточникЭлементов = ИсточникЗначения.Элементы;
	Если ОчищатьПриемник Тогда
		ПриемникЭлементов.Очистить();
	КонецЕсли;
	
	Для каждого ЭлементИсточник Из ИсточникЭлементов Цикл
		
		Если ТипЗнч(ЭлементИсточник) = Тип(""ЭлементПорядкаКомпоновкиДанных"") Тогда
			// Элементы порядка добавляем в начало
			Индекс = ИсточникЭлементов.Индекс(ЭлементИсточник);
			ЭлементПриемник = ПриемникЭлементов.Вставить(Индекс, ТипЗнч(ЭлементИсточник));
		Иначе
			Если СоздаватьПоТипу Тогда
				ЭлементПриемник = ПриемникЭлементов.Добавить(ТипЗнч(ЭлементИсточник));
			Иначе
				ЭлементПриемник = ПриемникЭлементов.Добавить();
			КонецЕсли;
		КонецЕсли;
		
		ЗаполнитьЗначенияСвойств(ЭлементПриемник, ЭлементИсточник);
		// В некоторых коллекциях необходимо заполнить другие коллекции
		Если ТипЗнч(ИсточникЭлементов) = Тип(""КоллекцияЭлементовУсловногоОформленияКомпоновкиДанных"") Тогда
			СкопироватьЭлементы(ЭлементПриемник.Поля, ЭлементИсточник.Поля);
			СкопироватьЭлементы(ЭлементПриемник.Отбор, ЭлементИсточник.Отбор);
			ЗаполнитьЭлементы(ЭлементПриемник.Оформление, ЭлементИсточник.Оформление); 
		ИначеЕсли ТипЗнч(ИсточникЭлементов)	= Тип(""КоллекцияВариантовПользовательскогоПоляВыборКомпоновкиДанных"") Тогда
			СкопироватьЭлементы(ЭлементПриемник.Отбор, ЭлементИсточник.Отбор);
		КонецЕсли;
		
		// В некоторых элементах коллекции необходимо заполнить другие коллекции
		Если ТипЗнч(ЭлементИсточник) = Тип(""ГруппаЭлементовОтбораКомпоновкиДанных"") Тогда
			СкопироватьЭлементы(ЭлементПриемник, ЭлементИсточник);
		ИначеЕсли ТипЗнч(ЭлементИсточник) = Тип(""ГруппаВыбранныхПолейКомпоновкиДанных"") Тогда
			СкопироватьЭлементы(ЭлементПриемник, ЭлементИсточник);
		ИначеЕсли ТипЗнч(ЭлементИсточник) = Тип(""ПользовательскоеПолеВыборКомпоновкиДанных"") Тогда
			СкопироватьЭлементы(ЭлементПриемник.Варианты, ЭлементИсточник.Варианты);
		ИначеЕсли ТипЗнч(ЭлементИсточник) = Тип(""ПользовательскоеПолеВыражениеКомпоновкиДанных"") Тогда
			ЭлементПриемник.УстановитьВыражениеДетальныхЗаписей (ЭлементИсточник.ПолучитьВыражениеДетальныхЗаписей());
			ЭлементПриемник.УстановитьВыражениеИтоговыхЗаписей(ЭлементИсточник.ПолучитьВыражениеИтоговыхЗаписей());
			ЭлементПриемник.УстановитьПредставлениеВыраженияДетальныхЗаписей(ЭлементИсточник.ПолучитьПредставлениеВыраженияДетальныхЗаписей ());
			ЭлементПриемник.УстановитьПредставлениеВыраженияИтоговыхЗаписей(ЭлементИсточник.ПолучитьПредставлениеВыраженияИтоговыхЗаписей ());
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

&НаСервере
// Найти поле СКД по полному имени.
//
Функция НайтиПолеСКДПоПолномуИмени(Элементы, ПолноеИмя) Экспорт

	масЧастейИмен = ИзПолногоИмениПоляПолучитьЧасти(ПолноеИмя);
	колЧастей = масЧастейИмен.Количество();
	
	текИмя = масЧастейИмен[0];
	Поле = НайтиПолеСКДПоИмени(Элементы, текИмя);
	Если Поле = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Для Сч = 2 По колЧастей Цикл
		текИмя = текИмя +""."" + масЧастейИмен[Сч-1];
		Поле = НайтиПолеСКДПоИмени(Поле.Элементы, текИмя);
		Если Поле = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Поле;

КонецФункции // НайтиПолеСКДПоПолномуИмени()

&НаСервере
// Функция выполняет получение имени поля из доступных полей компоновки данных.
//
Функция ПолучитьИмяПоляВШаблоне(Знач ИмяПоля) Экспорт
	
	ИмяПоля = СтрЗаменить(ИмяПоля, "".DeletionMark"", "".ПометкаУдаления"");
	ИмяПоля = СтрЗаменить(ИмяПоля, "".Owner"", "".Владелец"");
	ИмяПоля = СтрЗаменить(ИмяПоля, "".Code"", "".Код"");
	ИмяПоля = СтрЗаменить(ИмяПоля, "".Parent"", "".Родитель"");
	ИмяПоля = СтрЗаменить(ИмяПоля, "".Predefined"", "".Предопределенный"");
	ИмяПоля = СтрЗаменить(ИмяПоля, "".IsFolder"", "".ЭтоГруппа"");
	ИмяПоля = СтрЗаменить(ИмяПоля, "".Description"", "".Наименование"");
	Возврат ИмяПоля;
	
КонецФункции // ПолучитьИмяПоляВШаблоне()

&НаСервере
// Полное имя поля разделить по частям
//
Функция ИзПолногоИмениПоляПолучитьЧасти(ПолноеИмя)

	масЧастей = Новый Массив;
	СтрИмя = ПолноеИмя;
	
	Пока Не ПустаяСтрока(СтрИмя) Цикл
		Если Лев(СтрИмя, 1) = ""["" Тогда
			
			Поз = Найти(СтрИмя, ""]"");
			Если Поз = 0 Тогда
				масЧастей.Добавить(Сред(СтрИмя, 2));
				СтрИмя = """";
			Иначе
				масЧастей.Добавить(Сред(СтрИмя, 1, Поз));
				СтрИмя = Сред(СтрИмя, Поз + 2);
			КонецЕсли;
			
		Иначе
			
			Поз = Найти(СтрИмя, ""."");
			Если Поз = 0 Тогда
				масЧастей.Добавить(СтрИмя);
				СтрИмя = """";
			Иначе
				масЧастей.Добавить(Лев(СтрИмя, Поз - 1));
				СтрИмя = Сред(СтрИмя, Поз + 1);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат масЧастей;

КонецФункции // ИзПолногоИмениПоляПолучитьЧасти()

&НаСервере
// Среди элементов полей СКД найти поле по имени.
//
Функция НайтиПолеСКДПоИмени(Элементы, Имя)
	
	Для Каждого Элемент Из Элементы Цикл
		Если ВРЕГ(Строка(Элемент.Поле)) = ВРЕГ(Имя) Тогда
			Возврат Элемент;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции // НайтиПолеСКДПоИмени()

//---====== Отбор СКД ================================================ 
"}
},
{0,
{"Сохранение и Загрузка настроек СКД",0,0,"","//+++ ====== Сохранение и Загрузка настроек СКД ================================================

&НаКлиенте
Процедура СохранитьНастройкиКомпановкиДанных()
	
	СохранитьНастройкиКомпановкиДанныхНаСервере();
	
КонецПроцедуры 

&НаСервере
Процедура СохранитьНастройкиКомпановкиДанныхНаСервере()
	
	НастройкиКомпоновщикаХранилище = Новый ХранилищеЗначения(КомпоновщикНастроекКомпоновкиДанных.Настройки);
	
	КлючНастроек 	= ПолучитьКлючНастроек();
	ДопПараметры 	= Новый Структура();
	ДопПараметры.Вставить(""НастройкиКомпоновщикаХранилище""	, НастройкиКомпоновщикаХранилище);
	ДопПараметры.Вставить(""ЗагружатьСохраненныеНастройки""	, ЗагружатьСохраненныеНастройки);
	ДопПараметры.Вставить(""СохранитьНастройкиПриЗакрытии""	, СохранитьНастройкиПриЗакрытии);
	
	ХранилищеОбщихНастроек.Сохранить(КлючНастроек, КлючНастроек, ДопПараметры);
	
КонецПроцедуры

&НаКлиенте
Процедура ЗагрузитьСохраненныеНастройки(Команда)
	
	ПрименениеСКД();
	
КонецПроцедуры

&НаСервере
Процедура ЗагрузитьСохраненныеНастройкиНаСервере(пНастройкиКомпоновщика)
	
	КлючНастроек 			= ПолучитьКлючНастроек();
	СохраненныеНастройки 	= ХранилищеОбщихНастроек.Загрузить(КлючНастроек, КлючНастроек);
	
	Если СохраненныеНастройки <> Неопределено Тогда
		Если СохраненныеНастройки.Свойство(""НастройкиКомпоновщикаХранилище"") Тогда
			пНастройкиКомпоновщика = СохраненныеНастройки.НастройкиКомпоновщикаХранилище.Получить();
		Конецесли;
		Если СохраненныеНастройки.Свойство(""ЗагружатьСохраненныеНастройки"") Тогда
			ЗагружатьСохраненныеНастройки = СохраненныеНастройки.ЗагружатьСохраненныеНастройки;
		Конецесли;
		Если СохраненныеНастройки.Свойство(""СохранитьНастройкиПриЗакрытии"") Тогда
			СохранитьНастройкиПриЗакрытии = СохраненныеНастройки.СохранитьНастройкиПриЗакрытии;
		Конецесли;
	Конецесли;
	
КонецПроцедуры

//--- ====== Сохранение и Загрузка настроек СКД ================================================ 
"}
},
{0,
{"Условное оформление таблицы значений из СКД",0,0,"","//+++ ====== Условное оформление ================================================
// https://infostart.ru/public/186640/

// Процедуры для работы с условным оформлением

&НаСервере
Процедура ПерезаполнитьУФФормы()
	
	УсловноеОформление.Элементы.Очистить();
	
	УсловноеОформлениеКомпоновщика = КомпоновщикНастроекКомпоновкиДанных.Настройки.УсловноеОформление;
	
	Для каждого ЭлементУФ Из УсловноеОформлениеКомпоновщика.Элементы Цикл
		
		ЭлементУсловногоОформления = УсловноеОформление.Элементы.Добавить();
		ЭлементУсловногоОформления.Использование = ЭлементУФ.Использование;
		
		// Заполняем поля к которым будет применятся условное оформление
		СкопироватьПоляУсловногоОформления(ЭлементУсловногоОформления, ЭлементУФ);
		
		// Заполняем отбор для условного офрмления
		СкопироватьОтборУсловногоОформления(ЭлементУсловногоОформления, ЭлементУФ.Отбор);
		
		// Заполняем элементы условного офрмления
		СкопироватьЭлементОформления(ЭлементУсловногоОформления, ЭлементУФ);
		
	КонецЦикла;
	
КонецПроцедуры // ПерезаполнитьУФФормы()

&НаСервере
Процедура СкопироватьПоляУсловногоОформления(ЭлементУсловногоОформления, ЭлементКомпоновщика)
	
	ЭлементыПоля = ЭлементКомпоновщика.Поля.Элементы;
	Если ЭлементыПоля.Количество() = 0 Тогда
		ОформляемоеПоле = ЭлементУсловногоОформления.Поля.Элементы.Добавить();
		ОформляемоеПоле.Поле = Новый ПолеКомпоновкиДанных(""ТаблицаНоменклатуры"");
		ОформляемоеПоле.Использование = Истина;
	Иначе
		Для каждого ЭлементПоля Из ЭлементыПоля Цикл
			ОформляемоеПоле = ЭлементУсловногоОформления.Поля.Элементы.Добавить();
			ЗаполнитьЗначенияСвойств(ОформляемоеПоле, ЭлементПоля);
			ОформляемоеПоле.Поле = Новый ПолеКомпоновкиДанных(Строка(ЭлементПоля.Поле));
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры // СкопироватьПоляУсловногоОформления()

&НаСервере
Процедура СкопироватьОтборУсловногоОформления(ЭлементУсловногоОформления, ЭлементКомпоновщика)
	
	Для каждого ЭлементОтбора Из ЭлементКомпоновщика.Элементы Цикл
		Если ТипЗнч(ЭлементОтбора) = Тип(""ГруппаЭлементовОтбораКомпоновкиДанных"") Тогда
			ГруппаОтбора = ЭлементУсловногоОформления.Отбор.Элементы.Добавить(Тип(""ГруппаЭлементовОтбораКомпоновкиДанных""));
			ЗаполнитьЗначенияСвойств(ГруппаОтбора, ЭлементОтбора);
			СкопироватьОтборУсловногоОформления(ЭлементУсловногоОформления, ЭлементОтбора);
		Иначе
			НовыйЭлементОтбора = ЭлементУсловногоОформления.Отбор.Элементы.Добавить(Тип(""ЭлементОтбораКомпоновкиДанных""));
			ЗаполнитьЗначенияСвойств(НовыйЭлементОтбора, ЭлементОтбора);
			НовыйЭлементОтбора.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(""ТаблицаНоменклатуры."" + Строка(ЭлементОтбора.ЛевоеЗначение));
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры // СкопироватьОтборУсловногоОформления()

&НаСервере
Процедура СкопироватьЭлементОформления(ЭлементУсловногоОформления, ЭлементКомпоновщика)
	
	ЭлементыОформления = ЭлементКомпоновщика.Оформление.Элементы;
	
	Для каждого ЭлементОформления Из ЭлементыОформления Цикл
		Если ЭлементОформления.Использование Тогда
			ЭлементУсловногоОформления.Оформление.УстановитьЗначениеПараметра(ЭлементОформления.Параметр, ЭлементОформления.Значение);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры // СкопироватьЭлементОформления()

//--- ====== Условное оформление ================================================ "}
}
}
},
{6,
{"ЭтоЧисло",1,0,"",""},
{0,
{"ЭтоЧисло_1",0,0,"","Функция ЭтоЧисло(Символ)
	Возврат ?(Найти(""1234567890"", Символ) = 0, Ложь, Истина);
КонецФункции
"}
},
{0,
{"ЭтоЧисло_2",0,0,"","Функция ЭтоЧисло(Строка)
	ЗначениеВозврата = Истина;
	Попытка
		Число = Число(Строка);
	Исключение
		ЗначениеВозврата = Ложь;
	КонецПопытки;
	
	Возврат ЗначениеВозврата;
КонецФункции
"}
},
{0,
{"ЭтоЧисло_3",0,0,"","Функция ЭтоЧисло(Текст)
	
	Если ПустаяСтрока(Текст) Тогда
		Возврат Ложь;
	КонецЕсли; 
	Если СтрЧислоВхождений(Текст, ""."")+СтрЧислоВхождений(Текст, "","")>1 Тогда
		Возврат Ложь;
	КонецЕсли; 
	Для ии = 1 По СтрДлина(Текст) Цикл
		Символ = Сред(Текст, ии, 1);
		Если Найти("" 0123456789.,""+Символы.НПП, Символ)>0 Тогда
			Продолжить;
		КонецЕсли;
		Возврат Ложь;
	КонецЦикла;
	Возврат Истина;
	
КонецФункции
"}
},
{0,
{"ЭтоЧисло_4",0,0,"","//Функция проверяет является ли строка числом. Строка может содержать ""."" и "","" - это не числа
//-------------------------------------------------------------------------
//Параметры:
//		Текст - Строка - Исходная строка для проверки
//Возвращаемое значение:
//		Булево - Истина, если ЭтоЧисло
//-------------------------------------------------------------------------
//автор: Кучеров Р <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> 
Функция ЭтоЧисло(Текст)
	
	Если ПустаяСтрока(Текст) Тогда
		Возврат Ложь;
	КонецЕсли; 
	Если СтрЧислоВхождений(Текст, ""."") + СтрЧислоВхождений(Текст, "","") > 1 Тогда
		Возврат Ложь;
	КонецЕсли; 
	ТекстДлина = СтрДлина(Текст);
	Для ии = 1 По ТекстДлина Цикл
		Символ = Сред(Текст, ии, 1);
		Если НЕ Найти(""1234567890"", Символ) > 0 Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	Возврат Истина;
	
КонецФункции
"}
},
{0,
{"ЭтоЧисло_5",0,0,"","Функция ЭтоЧисло(зн) //Возвращает число ли передано или строка
	стрЗн = СокрЛП(Зн);
	Если стрЗн="""" Тогда Возврат 0; КонецЕсли;
	
	флгЧисло = Истина; знЧисло = """";
	Для й=1 По СтрДлина(стрЗн) Цикл
		КодСимв = КодСимвола(стрЗн, й);
		Если (КодСимв=32) или (КодСимв=160) или (КодСимв=39) Тогда Продолжить; //space newspace '
		ИначеЕсли (КодСимв=44) или (КодСимв=46) Тогда
			знЧисло = знЧисло + ""."";
		ИначеЕсли ((КодСимв >= 48) и (КодСимв <= 58)) или (КодСимв=43) или (КодСимв=45) Тогда //цифры, Минус
			ЗнЧисло = знЧисло + Символ(КодСимв);
		Иначе
			флгЧисло = Ложь;
			Прервать;
		КонецЕсли;
	КонецЦикла;

	Возврат флгЧисло;
КонецФункции"}
},
{0,
{"Получить только числа",0,0,"","Функция ВернутьЦифрыИзСтроки(СтрокаПроверки) 
     
    Если ТипЗнч(СтрокаПроверки) <> Тип(""Строка"") Тогда 
        Возврат """"; 
    КонецЕсли; 
     
    ЦифрыИзСтроки = """"; 
     
    Для Счетчик = 1 По СтрДлина(СтрокаПроверки) Цикл 
        Символ = Сред(СтрокаПроверки, Счетчик, 1); 
        Если ЭтоЦифра(Символ) Тогда 
            ЦифрыИзСтроки = ЦифрыИзСтроки + Символ; 
        КонецЕсли; 
    КонецЦикла; 
     
    Возврат ЦифрыИзСтроки; 
     
КонецФункции 

Функция ЭтоЦифра(Символ) 
    КодСимвола = КодСимвола(Символ); 
    Возврат (КодСимвола >= 48 И КодСимвола <= 57) 
КонецФункции"}
}
},
{2,
{"Office",1,0,"",""},
{12,
{"Word",1,0,"",""},
{0,
{"ЗаменаВWord",0,0,"","//Процедура производит замену старого значения на новое, если находит старое 
//-------------------------------------------------------------------------
//Word - COMОбъект типа (""Word.Application""),
//СтароеЗначение - строка,
//НовоеЗначение - строка;
//-------------------------------------------------------------------------
//автор: неизвестен.
Процедура ЗаменаВWord(Word, СтароеЗначение="""", НовоеЗначение="""") Экспорт
	//Сообщить(""меняю """"""+СтароеЗначение+"""""" на """"""+НовоеЗначение);
	Попытка
		Если ЗначениеЗаполнено(НовоеЗначение)  Тогда   
			Если ТипЗнч(НовоеЗначение)=Тип(""Строка"") Тогда
				Если СтрДлина(НовоеЗначение)>=250 Тогда
					Н=Цел(СтрДлина(НовоеЗначение)/250);               
					ДлинаСтроки=НовоеЗначение;
					Если Word.SELECTION.Find.Execute(СтароеЗначение,0,-1,,,,-1,,,"""",)=-1 Тогда					
						Word.SELECTION.Select();
						Word.SELECTION.Cut();
						Для К=0 По Н Цикл
							Word.SELECTION.Paste();                           
							НовоеЗначение=СокрЛП(Сред(ДлинаСтроки,К*250+1,250));
							Word.ActiveDocument.Content.Find.Execute(СтароеЗначение,1,,,,,,,,НовоеЗначение,2);	
						КонецЦикла; 
					КонецЕсли;
				Иначе
					Word.ActiveDocument.Content.Find.Execute(СтароеЗначение,1,,,,,,,,НовоеЗначение,2); 				
				Конецесли;
			Иначе
				Word.ActiveDocument.Content.Find.Execute(СтароеЗначение,1,,,,,,,,НовоеЗначение,2);	
			КонецЕсли;
		Иначе
			Word.ActiveDocument.Content.Find.Execute(СтароеЗначение,1,,,,,,,,"""",2);	
		Конецесли;
	Исключение
		Сообщить(""Ошибка при замене значения в Word: ""+ОписаниеОшибки(),СтатусСообщения.Важное);
	КонецПопытки;
КонецПроцедуры //ЗаменаВWord 
"}
},
{0,
{"Новый COMОбъект(""Word.Application"")",0,0,"","Попытка
	MSWord = Новый COMОбъект(""Word.Application"");
	ИмяВременногоФайла = ПолучитьИмяВременногоФайла(""DOC"");
	Макет.Записать(ИмяВременногоФайла);
	MSWord.Documents.Open(ИмяВременногоФайла);
Исключение
	Сообщить(""Возможно у вас не установлена программа Microsoft Office: Word (""+ОписаниеОшибки()+"")"");
	Возврат;
КонецПопытки;
"}
},
{0,
{"Заполнение",0,0,"","
Попытка
	MSWord = Новый COMОбъект(""Word.Application"");
	ИмяВременногоФайла = ПолучитьИмяВременногоФайла(""DOC"");
	Макет.Записать(ИмяВременногоФайла);
	MSWord.Documents.Open(ИмяВременногоФайла);
Исключение
	Сообщить(""Возможно у вас не установлена программа Microsoft Office: Word (""+ОписаниеОшибки()+"")"");
	Возврат;
КонецПопытки;

ПараметрыМакета = Новый Массив;
ЗначенияПараметровМакета = Новый Массив;

//ЗаполнитьМассивПараметров

Для параметрМакета = 0 По ПараметрыМакета.Количество() - 1 Цикл
	Попытка
		ЗаменаВWord(MSWord, ПараметрыМакета[параметрМакета], ЗначенияПараметровМакета[параметрМакета]);        
	Исключение
		Сообщить(""Ошибка при выводе шаблона документа в Word: ""+ОписаниеОшибки(),СтатусСообщения.Важное);
		MSWord.Quit();
		MSWord="""";
	КонецПопытки
	
КонецЦикла;

MSWord.Visible=1;
MSWord.Activate();
MSWord.ActiveWindow.WindowState=1;

//Процедура ЗаполнитьМассивПараметров
//-------------------------------------------------------------------------
//Параметры:
//		МассивПараметров - Массив - Параметры которые нужно заменить в макете
//		МассивЗначенийПараметров - Массив - Значения для параметров
//		ПараметрИмя - Строка - Имя параметра (в документе они должны быть в спец символах)
//		ПараметрЗначение - Строка - значение параметра (которое будет подставлена для указанного ПараметрИмя)
//		СпецСимволПараметра - Строка - символ которым обрамляется заменяемое значение в документе. Например ""#"" (для вида #парам#) или ""[]"" (для вида [парам])
//		ОкончаниеПараметра - Строка - Например ""Орг"" для организации. Для вида ПараметрОрг
//-------------------------------------------------------------------------
//Порядок параметров в  МассивЗначенийПараметров должен соответствовать порядку параметро в МассивПараметров.
//Тоесть, первый элемент МассивПараметров будет заполнен значением первого элемента из МассивЗначенийПараметров и тд.
//-------------------------------------------------------------------------
//автор: Кучеров Р 06.06.2018 
&НаСервереБезКонтекста
Процедура ЗаполнитьМассивПараметров(МассивПараметров, МассивЗначенийПараметров, ПараметрИмя, ПараметрЗначение, СпецСимволПараметра = ""#"", ОкончаниеПараметра = """")
	
	Если СпецСимволПараметра = ""[]"" Тогда
		МассивПараметров.Добавить(""["" + ПараметрИмя + ОкончаниеПараметра + ""]"");
	Иначе
		МассивПараметров.Добавить(СпецСимволПараметра + ПараметрИмя + ОкончаниеПараметра + СпецСимволПараметра);
	КонецЕсли; 
	
	МассивЗначенийПараметров.Добавить(ПараметрЗначение);
	
КонецПроцедуры // ЗаполнитьМассивПараметров()
"}
},
{0,
{"УчетПустойСтроки",0,0,"","//Функция УчетПустойСтроки
//-------------------------------------------------------------------------
//Параметры:
//		ЭлементУчета - Любой - Будет обработан переводом в строку
//		КоличествоСимволовЗамены - Число - Сколько символов отведено под эту запись
//		СимволЗамены - Строка - Какие символы отведены под эту запись
//Возвращаемое значение:
//		Строка - Вида: ""   "", ""_____"", ""#####"" и т.д.
//-------------------------------------------------------------------------
//автор: Кучеров Р 06.06.2018
&НаКлиентеНаСервереБезКонтекста
Функция УчетПустойСтроки(ЭлементУчета, КоличествоСимволовЗамены = 1, СимволЗамены = """")
	
	ЭлементУчетаСтрока = ?(ТипЗнч(ЭлементУчета) = Тип(""Строка""), ЭлементУчета, Строка(ЭлементУчета));
	
	Если ПустаяСтрока(ЭлементУчетаСтрока) Тогда
		Если НЕ ПустаяСтрока(СимволЗамены) ИЛИ СимволЗамены = "" "" Тогда
			РезультатЭлементУчетаСтрока = """";
			
			Для ии = 1 По КоличествоСимволовЗамены Цикл
				
				РезультатЭлементУчетаСтрока = РезультатЭлементУчетаСтрока + СимволЗамены;
				
			КонецЦикла;
		Иначе
			РезультатЭлементУчетаСтрока = """";
		КонецЕсли;
	Иначе 
		Возврат ЭлементУчетаСтрока;
	КонецЕсли; 
	
	Возврат РезультатЭлементУчетаСтрока;
	
КонецФункции // УчетПустойСтроки()"}
},
{0,
{"Замена подробно",0,0,"","wrdApp = Новый COMОбъект(""Word.Application"");

wrdDoc = wrdApp.Documents.Open(""C:\!Work\Word.docx"");
wrdDoc.Activate();
wrdApp.Visible = True;

wrdApp.Selection.Find.ClearFormatting();
wrdApp.Selection.Find.Replacement.ClearFormatting();
wrdApp.Selection.Find.Text = """"; //строка поиска
wrdApp.Selection.Find.Replacement.Text = """";  //строка замены
wrdApp.Selection.Find.Forward = True;
wrdApp.Selection.Find.Wrap = 1;
wrdApp.Selection.Find.Format = False;
wrdApp.Selection.Find.MatchCase = False;
wrdApp.Selection.Find.MatchWholeWord = False;
wrdApp.Selection.Find.MatchWildcards = False;
wrdApp.Selection.Find.MatchSoundsLike = False;
wrdApp.Selection.Find.MatchAllWordForms = False;
wrdApp.Selection.Find.Execute( , , , , , , , , , , 2);
wrdDoc.Save();"}
},
{0,
{"Замена в колонтитулах (Headers, Footers)",0,0,"","// для верхнего колонтитула ""Headers""
Документ.Sections(1).Headers(1).Range.Find.Execute(""[значениеДляЗамены]"", Ложь, Истина, Ложь, , , Истина, , Ложь, переменнаяСНужнымТекстом, 2);

// для нижнего колонтитула ""Footers""
Документ.Sections(1).Footers(1).Range.Find.Execute(""[значениеДляЗамены]"", Ложь, Истина, Ложь, , , Истина, , Ложь, переменнаяСНужнымТекстом, 2);
"}
},
{0,
{"Печать сертификатов",0,0,"","//Печать сертификатов
Для Каждого Строка Из СертификатыНаПечать Цикл
	
	ФайлСертификата = Новый Файл(Строка.ИмяФайла);
	Если ФайлСертификата.Существует() Тогда
		Ворд = Новый COMОбъект(""Word.Application"");;
		Документ = Ворд.Documents.Open(Строка.ИмяФайла, -1);
		Колонтитул = Документ.Sections.First.Headers(1).Range;
		Колонтитул.Font.Name = ""Arial"";
		Колонтитул.Font.Size = 10;
		Колонтитул.Text = Строка(ДокументОбъект.Ссылка) + ""    "" + Строка(ДокументОбъект.Контрагент);
		Документ.PrintOut();
		Документ.Close(0);
		Документ="""";
	КонецЕсли;
	
КонецЦикла;"}
},
{0,
{"Пример работы с Word через OLE. Часть 1",0,0,"","Процедура ВыполнитьОбработку() Экспорт

    Попытка
        Объект = ПолучитьCOMОбъект(ПутьКФайлу);
        // Покажем документ. Для красоты.
        Объект.Application.Visible = 1;
        Word = Объект.Application;

        Doc = Объект.Application.Documents(1);
        Doc.Activate();

        // Готовим переменную в которой будет содержимое нашего документа
        // (текст, таблицы и проч).
        Text = Word.Selection;

        // Очистим документ
        // Ctrl-A
        Text.WholeStory();
        // Del
        Text.Delete(1, 1);
        // Двигаемся на 3 строки ниже. Документ пустой, поэтому добавляем
        // строки ""Переводами коретки""

        Text.TypeText(Символы.ВК);
        Text.TypeText(Символы.ВК);
        Text.TypeParagraph(); // другой вариант того же действия
        // Выводим текст.
        Text.TypeText(""Обычный текст, набранный первую очередь"");

        // Курсор в конце строки
        // Эмулируем нажатие Shift+Home - выделяем строку
        Text.HomeKey(, 1);
        // Форматирование выделенной строки
        Text.Font.Bold = 9999998;
        Text.Font.Size = 14;
        Text.Font.Name = ""Verdana"";

        // Сдвигаем курсор. Сдвинуть курсор по строкам возможно, только,
        // если эти строки уже содержат текст, иначе ничего не произойдет.
        Text.MoveUp(,2);   // вверх на 2 строки
        //Word.Selection.MoveDown(,числострок); // вниз
        //Word.Selection.MoveLeft(,числострок); // влево
        //Word.Selection.MoveRight(,числострок);// вправо

        // Добавление текста. Текст выводится начиная с текщей позиции
        // курсора.
        Text.HomeKey(, 1);
        Text.TypeText(""Обычный текст, набранный во вторую очередь"");

        Text.MoveDown(,1); // вниз на 2 строки
        Text.EndKey(); // в конец строки
        Text.TypeParagraph(); // и в начало следующей строки

        // Очищаем форматирование
        Text.ClearFormatting();
        // Добавляем таблицу.
        // Получаем текущую позицию курсора
        Position = Text.Range();

        // Параметры: Позиция, число строк, число колонок,
        // последние 2 параметра отвечают за автоподбор высоты и отображение
        // границ таблицы
        Table = Doc.Tables.Add(Position, 1, 6, 1, 2);

        // Устанавливаем ширину колонок
        Table.Columns(1).PreferredWidth=10;
        Table.Columns(2).PreferredWidth=50;
        Table.Columns(3).PreferredWidth=10;
        Table.Columns(4).PreferredWidth=10;
        Table.Columns(5).PreferredWidth=10;
        Table.Columns(6).PreferredWidth=10;

        // Задаем заголовки колонок
        Row1=Table.Rows(1);
        Row1.Cells(1).Range.Text=""№ п/п"";
        Row1.Cells(2).Range.Text=""Наименование"";
        Row1.Cells(4).Range.Text=""Кол-во"";
        Row1.Cells(3).Range.Text=""Ед. изм."";
        Row1.Cells(5).Range.Text=""Цена,руб."";
        Row1.Cells(6).Range.Text=""Сумма,руб."";

        // Построчно выводим содержимое таблицы Товары
        НомерСтроки = 1;
        Для каждого СтрокаТовары Из Ссылка.Товары Цикл
            Row=Table.Rows.Add();
            Row.Cells(1).Range.Text=НомерСтроки;
            // Выравнивание по левому краю
            Row.Cells(1).Range.ParagraphFormat.Alignment = 1;
            // В качестве текста можно передать только значение ""простого"" формата
            // все агрегатные объекты, переданные как текст, что нормально для платформы 1с
            // вызовут исключение.
            Row.Cells(2).Range.Text=СтрокаТовары.Номенклатура.Наименование
                   +?(ЗначениеЗаполнено(СтрокаТовары.ХарактеристикаНоменклатуры),
                   "" (""+СтрокаТовары.ХарактеристикаНоменклатуры+"")"","""");
            Row.Cells(4).Range.Text=Строка(СтрокаТовары.Количество);
            Row.Cells(4).Range.ParagraphFormat.Alignment = 1;
            Row.Cells(3).Range.Text=?(ЗначениеЗаполнено(СтрокаТовары.Номенклатура.БазоваяЕдиницаИзмерения)
                                  ,СтрокаТовары.Номенклатура.БазоваяЕдиницаИзмерения.Наименование,""-"");
            Row.Cells(3).Range.ParagraphFormat.Alignment = 1;
            Row.Cells(5).Range.Text=Формат(СтрокаТовары.Цена,""ЧДЦ=2"");
            Row.Cells(5).Range.ParagraphFormat.Alignment = 1;
            Row.Cells(6).Range.Text=Формат(СтрокаТовары.Сумма,""ЧДЦ=2"");
            Row.Cells(6).Range.ParagraphFormat.Alignment = 1;
            НомерСтроки=НомерСтроки+1;
        КонецЦикла;

        // Задаем форматирование первой строки
        // Если сделать это сразу, то все новые строки таблицы будут
        // формироваться с тем же форматом
        Row1.Range.Font.Bold = 9999998;
        Row1.Range.Font.Size = 14;
        Row1.Range.Font.Name = ""Verdana"";
        Row1.Range.ParagraphFormat.Alignment = 1;

        // Последняя строка...
        Row = Table.Rows.Add();
        Row.Range.Font.Bold = 9999998;
        Row.Cells(1).Range.Text=""Итого:"";
    Исключение
        Doc.Save();
        Сообщить(ОписаниеОшибки());
        Объект.Application.Quit();
        Объект = Неопределено;
    КонецПопытки;

    Попытка // эта конструкция выдает исключительную ситуацию, но при этом
        // результат все-равно работает))
        // объединяем ячейки в конце таблицы
        Table.cell(НомерСтроки+1, 1).Merge(Table.cell(НомерСтроки+1, 5));
    Исключение
    КонецПопытки;

    Попытка
        Row.Cells(1).Range.ParagraphFormat.Alignment = 3;
        Row.Cells(2).Range.Text=Формат(Ссылка.Товары.Итог(""Сумма""), ""ЧДЦ=2"");
        Row.Cells(2).Range.ParagraphFormat.Alignment = 1;

        Doc.Save();
        Объект.Application.Quit();
        Объект = Неопределено;
    Исключение
        Doc.Save();
        Сообщить(ОписаниеОшибки());
        Объект.Application.Quit();
        Объект = Неопределено;
    КонецПопытки;

КонецПроцедуры"}
},
{0,
{"Пример работы с Word через OLE. Часть 2",0,0,"","Процедура ВыполнитьОбработку() Экспорт

    Попытка

        //Объект = ПолучитьCOMОбъект(ПутьКФайлу);
        Объект = ПолучитьCOMОбъект(""C:\Users\NKrylov\Desktop\Тест.docx"");
        // Покажем документ.
        Объект.Application.Visible = 1;
        Word = Объект.Application;

        ThisDocument = Word.Documents(1);
        ThisDocument.Activate();

        // Отключим проверку грамматики и вывод информации о грамматических ошибках.
        ThisDocument.GrammarChecked=0;
        ThisDocument.ShowGrammaticalErrors=0;

        // Готовим переменную в которой будет содержимое документа (текст).
        Selection = Word.Selection;

        // Очистим документ
        // Ctrl-A
        Selection.WholeStory();
        // Del
        Selection.Delete(1, 1);

        // Уменьшим междустрочный интервал.
        Selection.ParagraphFormat.LineSpacingRule = 0; // 1 по умолчанию
        Selection.ParagraphFormat.SpaceAfter = 0;      // 10 по умолчанию

        // Разметим документ. Это можно сделать и предварительно в макете
        ThisDocument.Bookmarks.Add(""Закладка1"", Selection.Range());
        Selection.TypeParagraph();
        Selection.TypeText(""34r3 "");
        Selection.HomeKey(, 1);
        ThisDocument.Bookmarks.Add(""Закладка2"", Selection.Range());
        Selection.EndKey();
        Selection.TypeParagraph();
        ThisDocument.Bookmarks.Add(""Закладка3"", Selection.Range());
        Selection.TypeParagraph();
        ThisDocument.Bookmarks.Add(""Закладка4"", Selection.Range());
        Selection.EndKey();

        // Так можно работать с текстом только в конкреной области документа - это и будет замена метода Find-Execute. 
        ThisDocument.Bookmarks(""Закладка3"").Range.Select();
        Selection = Word.Selection;

        Bookmark = ThisDocument.Bookmarks(""Закладка3"");
        Table = ThisDocument.Tables.Add(Bookmark.Range(),1,5,1,2);
        Table.Rows(1).Cells(1).Range.Text = 1;
        Table.Rows(1).Cells(2).Range.Text = 2;
        Table.Rows(1).Cells(3).Range.Text = 3;
        Table.Rows(1).Cells(4).Range.Text = 4;
        Table.Rows(1).Cells(5).Range.Text = 5;

        // После вывода таблицы, появится ""лишняя строка"", удалим ее
        // в результате курсор встанет в область закладки 4
        Selection.MoveDown(, 1);
        Selection.Delete(1, 1);

        // Этот текст будет выведен не с последней позиции курсора, а в активной области.
        // в данном случае - в области закладки 2
        ThisDocument.Bookmarks(""Закладка2"").Range.Select();
        Selection = Word.Selection;
        Text = Selection.Range.Text;
        Selection.TypeText(Text + "" sdcsdcs"");
        // При выводе текста закладка ""сбросилась"". Восстановим.
        // ""Победить"" эту проблему я так и не смог((
        // Хотя на практике, закладка больше и не понадобится.
        // Дважды выводить текст в одну и ту же область - не имеет смысла.
        Selection.HomeKey(, 1);
        ThisDocument.Bookmarks.Add(""Закладка2"", Selection.Range());
        Selection.EndKey();

        // В области закладки 4 сформируем нумерованный список
        ThisDocument.Bookmarks(""Закладка4"").Range.Select();
        Selection = Word.Selection; // активная (выделенная) область будет начинаться
        // от закладки 4)

        // Добавим текст ""для опытов""
        // 1
        Selection.TypeText(""sdcsdcsdcsdc"");
        Selection.TypeParagraph();
        // 2
        Selection.TypeText(""sdcsdcsdcsdc"");
        Selection.TypeParagraph();
        // 3
        Selection.TypeText(""sdcsdcsdcsdc"");
        Selection.TypeParagraph();
        // 4
        Selection.TypeText(""sdcsdcsdcsdc"");
        Selection.TypeParagraph();
        // Выделяем введенный текст
        Selection.MoveUp(,4,1);

        // Настроим шаблон объекта галереи списков
        // Галереи списков бывают несккольких типов, 2 - нумерованные списки
        ListTemplate = Word.ListGalleries(2).ListTemplates(1).ListLevels(1);
        // Формат нумератора списка - точка после символа нумерации
        ListTemplate.NumberFormat = ""%1."";
        // стиль нумератора - арабские цифры
        ListTemplate.NumberStyle = 0; // wdListNumberStyleArabic
        // 4 - маленькие латинские буквы.
        // 2 - маленькие римские цифры.
        // 58- меленькие русские буквы.
        // Font = Template.Font; // можно указать форматирование текста списка

        // Применим шаблон к выделенному тексту
 Selection.Range.ListFormat.ApplyListTemplateWithLevel( Word.ListGalleries(2).ListTemplates(1));

        // Перейдем в конец текста
        Selection.EndKey(6);

        // Добавим картинку
        // Параметры: путь к файлу, создавать ссылку на картинку, сохранять с файлом
        Picture = Selection.InlineShapes.AddPicture(""C:\Users\NKrylov\Desktop\Новый.bmp"", Ложь, Истина);
        // Зададим размер
        Picture.Height = 100;
        Picture.Width  = 150;

        // Чтобы установить обтекание текста, конвертируем рисунок в фигуру
        Shape = Picture.ConvertToShape();
        Shape.WrapFormat.Type = 0; // по контуру...

        ThisDocument.Save();
        //Объект.Application.Quit();
        Объект = Неопределено;
    Исключение
        ThisDocument.Save();
        Сообщить(ОписаниеОшибки());
        //Объект.Application.Quit();
        Объект = Неопределено;
    КонецПопытки;

КонецПроцедуры"}
},
{0,
{"Удалиить межстрочный интервал",0,0,"","ПечатнаяФорма.COMСоединение.Application.Selection.WholeStory(); // Выделяем весь текст

ParagraphFormat = ПечатнаяФорма.COMСоединение.Selection.ParagraphFormat; // Обращаемся к формату параграфов 

// Удаляем интервал
ParagraphFormat.SpaceBeforeAuto = False;
ParagraphFormat.SpaceAfterAuto 	= False;
ParagraphFormat.SpaceBefore = 0;
ParagraphFormat.SpaceAfter 	= 0;

// Снять выделение 
ПечатнаяФорма.COMСоединение.ActiveDocument.Range(0, 0).Select();
"}
},
{0,
{"Задание полей",0,0,"","// Можно выполнять после формирования документа
ЛевыйОтступ = 2;
ПечатнаяФорма.COMСоединение.Application.Selection.PageSetup.LeftMargin = Макет.COMСоединение.Documents.Application.CentimetersToPoints(ЛевыйОтступ);
//RightMargin"}
},
{1,
{"Типовое",1,0,"",""},
{0,
{"КА",0,0,"","//+++ АйТи КучеровРМ 18.09.2018 ТЗ № ИС00-004955

&НаСервереБезКонтекста
Функция СформироватьСуммуПрописьюНаСервере(Сумма, Валюта)

	Возврат РаботаСКурсамиВалют.СформироватьСуммуПрописью(Сумма, Валюта)

КонецФункции // СформироватьСуммуПрописьюНаСервере()
 
&НаСервереБезКонтекста
Функция ЗаполнитьДанныеОбъектаНаСервере(ДанныеОбъекта, ДокументСсылка)

	СуммаДокумента 	= ДокументСсылка.СуммаРегл;
	Организация 	= ДокументСсылка.Организация;
	КонтрагентКредитор 	= ДокументСсылка.КонтрагентКредитор;
	
	ДатаДокумента 	= ДокументСсылка.Дата;
	
	СуммаНДС 		= 0.18;
	Валюта 			= ДокументСсылка.ДебиторскаяЗадолженность[0].ВалютаВзаиморасчетов;
	СуммаПрописью 	= СформироватьСуммуПрописьюНаСервере(СуммаДокумента, Валюта);
	НомерДоговора 	= ДокументСсылка.Номер;
	
	СуммаДокументаНДС 	= СуммаДокумента * СуммаНДС;
	СуммаПринятаяВЗачет = СуммаДокумента;
	СуммаПринятаяНДС 	= СуммаДокументаНДС;
	СуммаПринятаяВЗачетИтого 	= СуммаПринятаяВЗачет;
	СуммаПринятаяНДСИтого 		= СуммаПринятаяНДС;
	СуммаДокументаНДС 			= СуммаПринятаяНДСИтого;
	СуммаДокументаНДСПрописью 	= СформироватьСуммуПрописьюНаСервере(СуммаДокументаНДС, Валюта);

	ДанныеОбъекта.Вставить(""СуммаПрописью""	, НРег(СуммаПрописью));
	ДанныеОбъекта.Вставить(""НомерДоговора""	, НомерДоговора);
	ДанныеОбъекта.Вставить(""Валюта""			, Валюта);	
	
	// ДанныеОбъектаДебиторскаяЗадолженность
	ДанныеОбъектаДебиторскаяЗадолженность 	= ДанныеОбъекта.ДебиторскаяЗадолженность;
	ДокументДебиторскаяЗадолженность 		= ДокументСсылка.ДебиторскаяЗадолженность;
	
	Для Сч = 0 По ДанныеОбъектаДебиторскаяЗадолженность.ВГраница() Цикл
	
		СуммаПринята 	= ДокументДебиторскаяЗадолженность[Сч].СуммаРегл;
		ДатаДокумента 	= ДокументДебиторскаяЗадолженность[Сч].Заказ.Дата;
		НомерДокумента 	= ДокументДебиторскаяЗадолженность[Сч].Заказ.Номер;
		
		ДанныеОбъектаДебиторскаяЗадолженность[Сч].Вставить(""СуммаДокументаНДС""	, Формат(СуммаПринята * СуммаНДС, ""ЧДЦ=2""));
		ДанныеОбъектаДебиторскаяЗадолженность[Сч].Вставить(""СуммаПринятаяВЗачет""	, Формат(СуммаПринята, ""ЧДЦ=2""));
		ДанныеОбъектаДебиторскаяЗадолженность[Сч].Вставить(""СуммаПринятаяНДС""		, Формат(СуммаПринята * СуммаНДС, ""ЧДЦ=2""));
		ДанныеОбъектаДебиторскаяЗадолженность[Сч].Вставить(""ДатаДокумента""		, Формат(ДатаДокумента, ""ДФ=dd.MM.yyyy""));
		ДанныеОбъектаДебиторскаяЗадолженность[Сч].Вставить(""НомерДокумента""		, НомерДокумента);
		
	КонецЦикла; 
	
	// ДанныеОбъектаКредиторскаяЗадолженность
	ДанныеОбъектаКредиторскаяЗадолженность 	= ДанныеОбъекта.КредиторскаяЗадолженность;
	ДокументКредиторскаяЗадолженность 		= ДокументСсылка.КредиторскаяЗадолженность;
	
	Для Сч = 0 По ДанныеОбъектаКредиторскаяЗадолженность.ВГраница() Цикл
	
		СуммаПринята 	= ДокументКредиторскаяЗадолженность[Сч].СуммаРегл;
		ДатаДокумента 	= ДокументКредиторскаяЗадолженность[Сч].Заказ.Дата;
		НомерДокумента 	= ДокументКредиторскаяЗадолженность[Сч].Заказ.Номер;
		
		ДанныеОбъектаКредиторскаяЗадолженность[Сч].Вставить(""СуммаДокументаНДС""	, Формат(СуммаПринята * СуммаНДС, ""ЧДЦ=2""));
		ДанныеОбъектаКредиторскаяЗадолженность[Сч].Вставить(""СуммаПринятаяВЗачет""	, Формат(СуммаПринята, ""ЧДЦ=2""));
		ДанныеОбъектаКредиторскаяЗадолженность[Сч].Вставить(""СуммаПринятаяНДС""		, Формат(СуммаПринята * СуммаНДС, ""ЧДЦ=2""));
		ДанныеОбъектаКредиторскаяЗадолженность[Сч].Вставить(""ДатаДокумента""		, Формат(ДатаДокумента, ""ДФ=dd.MM.yyyy""));
		ДанныеОбъектаКредиторскаяЗадолженность[Сч].Вставить(""НомерДокумента""	, НомерДокумента);
		
	КонецЦикла;
	
	//ДанныеОбъекта.ДебиторскаяЗадолженность.Добавить();
	//
	//ДанныеОбъекта.КредиторскаяЗадолженность.Добавить();
	
	ДанныеОбъекта.Вставить(""СуммаДокументаНДС""	, Формат(СуммаДокументаНДС, ""ЧДЦ=2""));
	ДанныеОбъекта.Вставить(""СуммаПринятаяВЗачет"", Формат(СуммаПринятаяВЗачет, ""ЧДЦ=2""));
	ДанныеОбъекта.Вставить(""СуммаПринятаяНДС""	, Формат(СуммаПринятаяНДС, ""ЧДЦ=2""));
	ДанныеОбъекта.Вставить(""СуммаПринятаяВЗачетИтого"", Формат(СуммаДокумента, ""ЧДЦ=2""));
	ДанныеОбъекта.Вставить(""СуммаПринятаяНДСИтого""	, Формат(СуммаДокумента * СуммаНДС, ""ЧДЦ=2""));
	ДанныеОбъекта.Вставить(""СуммаДокументаНДС""		, Формат(СуммаДокументаНДС, ""ЧДЦ=2""));
	ДанныеОбъекта.Вставить(""СуммаДокументаНДСПрописью"", НРег(СуммаДокументаНДСПрописью));
	
	СтруктураПараметров = ДенежныеСредстваСервер.ПараметрыЗаполненияБанковскогоСчетаОрганизацииПоУмолчанию();
	СтруктураПараметров.Организация    			= Организация;
	СтруктураПараметров.Валюта    				= Валюта;
	//СтруктураПараметров.НаправлениеДеятельности	= НаправлениеДеятельности;
	БанковскийСчетОрганизации = ЗначениеНастроекПовтИсп.ПолучитьБанковскийСчетОрганизацииПоУмолчанию(СтруктураПараметров);  
	
	СведенияОЮрФизЛицеОрганизации = ФормированиеПечатныхФорм.СведенияОЮрФизЛице(Организация, ДатаДокумента);
	ИНН_КПП_Организации = ФормированиеПечатныхФорм.ОписаниеОрганизации(СведенияОЮрФизЛицеОрганизации, ""ИНН, КПП"");
	РасчСчетОрганизации = ФормированиеПечатныхФорм.ОписаниеОрганизации(СведенияОЮрФизЛицеОрганизации, ""НомерСчета,Банк"");
	БикОрганизации 		= ФормированиеПечатныхФорм.ОписаниеОрганизации(СведенияОЮрФизЛицеОрганизации, ""БИК,КоррСчет"");

	ДанныеОбъекта.Вставить(""ИНН_КПП_Организации"", ИНН_КПП_Организации);
	ДанныеОбъекта.Вставить(""РасчСчетОрганизации"", РасчСчетОрганизации);
	ДанныеОбъекта.Вставить(""БикОрганизации""		, БикОрганизации);
	
	СведенияОЮрФизЛицеКонтрагентаДебитора = ФормированиеПечатныхФорм.СведенияОЮрФизЛице(КонтрагентКредитор, ДатаДокумента);
	ИНН_КПП_КонтрагентаДебитора = ФормированиеПечатныхФорм.ОписаниеОрганизации(СведенияОЮрФизЛицеКонтрагентаДебитора, ""ИНН, КПП"");
	РасчСчетКонтрагентаДебитора = ФормированиеПечатныхФорм.ОписаниеОрганизации(СведенияОЮрФизЛицеКонтрагентаДебитора, ""НомерСчета,Банк"");
	БикКонтрагентаДебитора 		= ФормированиеПечатныхФорм.ОписаниеОрганизации(СведенияОЮрФизЛицеКонтрагентаДебитора, ""БИК,КоррСчет"");
	
	ДанныеОбъекта.Вставить(""ИНН_КПП_КонтрагентаДебитора"", ИНН_КПП_КонтрагентаДебитора);
	ДанныеОбъекта.Вставить(""РасчСчетКонтрагентаДебитора"", РасчСчетКонтрагентаДебитора);
	ДанныеОбъекта.Вставить(""БикКонтрагентаДебитора""		, БикКонтрагентаДебитора);
	
	Возврат ДанныеОбъекта;
	
КонецФункции // ЗаполнитьДанныеОбъектаНаСервере()
 
//--- АйТи КучеровРМ 18.09.2018 ТЗ № ИС00-004955 

// Печатает акт взаимозачета задолженности
//
// Параметры:
//	ОписаниеКоманды - Структура
//
// Возвращаемое значение:
//	Неопределено
//
&НаКлиенте
Функция ПечатьАктаВзаимозачетаЗадолженностиMicrosoftWord(Макет, ОписаниеКоманды) Экспорт
	
	ОчиститьСообщения();
	
	Состояние(НСтр(""ru = 'Выполняется формирование печатных форм'""));
	
	ИмяМакета = ""ПФ_DOC_АктВзаимозачета_ru"";
	ТипМакета = ""doc"";
	
	МакетИДанныеОбъекта = УправлениеПечатьюВызовСервера.МакетыИДанныеОбъектовДляПечати(""Документ.ВзаимозачетЗадолженности"",
		ИмяМакета,
		ОписаниеКоманды.ОбъектыПечати);
		
	//+++ АйТи КучеровРМ 18.09.2018 ТЗ № ИС00-004955
	МакетИДанныеОбъекта.Макеты.ДвоичныеДанныеМакетов.ПФ_DOC_АктВзаимозачета_ru = Макет; // Подменяем макет на наш из обработки
	//--- АйТи КучеровРМ 18.09.2018 ТЗ № ИС00-004955 
	
	ДвоичныеДанныеМакетов = МакетИДанныеОбъекта.Макеты.ДвоичныеДанныеМакетов;
	
	Секции = МакетИДанныеОбъекта.Макеты.ОписаниеСекций;
	
	Для Каждого ДокументСсылка Из ОписаниеКоманды.ОбъектыПечати Цикл
		
		ДанныеОбъекта = МакетИДанныеОбъекта.Данные[ДокументСсылка][ИмяМакета];
		
		//+++ АйТи КучеровРМ 18.09.2018 ТЗ № ИС00-004955
		ДанныеОбъекта = ЗаполнитьДанныеОбъектаНаСервере(ДанныеОбъекта, ДокументСсылка);
		//--- АйТи КучеровРМ 18.09.2018 ТЗ № ИС00-004955 
		
		Если Не ДанныеОбъекта.Взаимозачет Тогда
			
			Текст = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр(""ru = 'Не требуется печатать акт взаимозачета для документа %1'""),
				ДокументСсылка);
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
				Текст,
				ДокументСсылка);
			
		Иначе
		
			Попытка
					
				ПечатнаяФорма = УправлениеПечатьюКлиент.ИнициализироватьПечатнуюФорму(ТипМакета);

				Макет = УправлениеПечатьюКлиент.ИнициализироватьМакетОфисногоДокумента(
					ДвоичныеДанныеМакетов[ИмяМакета], ТипМакета);
					
				// Вывод колонтитулов документа.
				Область = УправлениеПечатьюКлиент.ОбластьМакета(Макет, Секции[ИмяМакета][""ВерхнийКолонтитул""]);
				УправлениеПечатьюКлиент.ПрисоединитьОбластьИЗаполнитьПараметры(ПечатнаяФорма, Область, ДанныеОбъекта, Ложь);
			
				Область = УправлениеПечатьюКлиент.ОбластьМакета(Макет, Секции[ИмяМакета][""НижнийКолонтитул""]);
				УправлениеПечатьюКлиент.ПрисоединитьОбластьИЗаполнитьПараметры(ПечатнаяФорма, Область, ДанныеОбъекта, Ложь);
				
				// Выводим заголовок документа.	
				Область = УправлениеПечатьюКлиент.ОбластьМакета(Макет, Секции[ИмяМакета].Заголовок);
				УправлениеПечатьюКлиент.ПрисоединитьОбластьИЗаполнитьПараметры(ПечатнаяФорма, Область, ДанныеОбъекта, Истина);
				
				// Выводим данные дебиторской задолженности;
				Область = УправлениеПечатьюКлиент.ОбластьМакета(Макет, Секции[ИмяМакета].ДебиторскаяЗадолженность);
				УправлениеПечатьюКлиент.ПрисоединитьОбластьИЗаполнитьПараметры(ПечатнаяФорма, Область, ДанныеОбъекта, Истина);
				
				Область = УправлениеПечатьюКлиент.ОбластьМакета(Макет, Секции[ИмяМакета].ШапкаТаблицы);
				УправлениеПечатьюКлиент.ПрисоединитьОбласть(ПечатнаяФорма, Область, Ложь);
				
				Область = УправлениеПечатьюКлиент.ОбластьМакета(Макет, Секции[ИмяМакета].СтрокаТаблицы);
				УправлениеПечатьюКлиент.ПрисоединитьИЗаполнитьКоллекцию(ПечатнаяФорма,Область, ДанныеОбъекта.ДебиторскаяЗадолженность, Ложь);
				
				// Выводим данные кредиторской задолженности.
				Область = УправлениеПечатьюКлиент.ОбластьМакета(Макет, Секции[ИмяМакета].КредиторскаяЗадолженность);
				УправлениеПечатьюКлиент.ПрисоединитьОбластьИЗаполнитьПараметры(ПечатнаяФорма, Область, ДанныеОбъекта, Истина);
				
				Область = УправлениеПечатьюКлиент.ОбластьМакета(Макет, Секции[ИмяМакета].ШапкаТаблицы);
				УправлениеПечатьюКлиент.ПрисоединитьОбласть(ПечатнаяФорма, Область, Ложь);
				
				Область = УправлениеПечатьюКлиент.ОбластьМакета(Макет, Секции[ИмяМакета].СтрокаТаблицы);
				УправлениеПечатьюКлиент.ПрисоединитьИЗаполнитьКоллекцию(ПечатнаяФорма,Область, ДанныеОбъекта.КредиторскаяЗадолженность, Ложь);
				
				// Выводим подвал документа.
				Область = УправлениеПечатьюКлиент.ОбластьМакета(Макет, Секции[ИмяМакета].Подвал);
				УправлениеПечатьюКлиент.ПрисоединитьОбластьИЗаполнитьПараметры(ПечатнаяФорма, Область, ДанныеОбъекта, Истина);

				//+++ АйТи КучеровРМ 18.09.2018 ТЗ № ИС00-004955
				ЛевыйОтступ = 2;
				ПечатнаяФорма.COMСоединение.Application.Selection.PageSetup.LeftMargin = Макет.COMСоединение.Documents.Application.CentimetersToPoints(ЛевыйОтступ);
				
				ПечатнаяФорма.COMСоединение.Application.Selection.WholeStory();
				
				ParagraphFormat = ПечатнаяФорма.COMСоединение.Selection.ParagraphFormat; 
				
				ParagraphFormat.SpaceBeforeAuto = False;
				ParagraphFormat.SpaceAfterAuto 	= False;
				ParagraphFormat.SpaceBefore 	= 0;
				ParagraphFormat.SpaceAfter 	= 0;
				//--- АйТи КучеровРМ 18.09.2018 ТЗ № ИС00-004955 
				
				УправлениеПечатьюКлиент.ПоказатьДокумент(ПечатнаяФорма);
				
			Исключение
			
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
				
				УправлениеПечатьюКлиент.ОчиститьСсылки(ПечатнаяФорма);
				УправлениеПечатьюКлиент.ОчиститьСсылки(Макет);
						
				Возврат Ложь;
				
			КонецПопытки;

			УправлениеПечатьюКлиент.ОчиститьСсылки(ПечатнаяФорма, Ложь);
			УправлениеПечатьюКлиент.ОчиститьСсылки(Макет);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Состояние(НСтр(""ru = 'Формирование печатных форм завершено'""));
	
КонецФункции 
"}
}
}
},
{8,
{"Excel",1,0,"",""},
{0,
{"Скелет формирования Excel выгрузки",0,0,"","// Загрузка объекта Microsoft Excel
Попытка
	Состояние(""Выгрузка данных из 1С в Microsoft Excel..."");            
	ExcelПриложение = Новый COMОбъект(""Excel.Application"");
Исключение
	Сообщить(""Ошибка при запуске Microsoft Excel."" + Символы.ПС + ОписаниеОшибки(), СтатусСообщения.Внимание);
	Возврат;
КонецПопытки;

// Создадим книгу, по умолчанию в ней уже есть листы
Книга = ExcelПриложение.WorkBooks.Add();

// Используем первый лист книги Excel
Лист 	= Книга.WorkSheets(1);

// Сформировать шапку документа в первой строке листа
Лист.Cells(1,1).Value = ""1"";

// Сохраним созданную книгу в файл xls
//Книга.SaveAs(ПутьФайла);

// Обязательно закроем соединение с COM объектом для освобождения памяти
ExcelПриложение.Quit();
"}
},
{0,
{"КоличествоСтрок",0,0,"","КоличествоСтрок = ТекЛист.UsedRange.Rows.Count;"}
},
{0,
{"КоличествоКолонок",0,0,"","КоличествоКолонок = ТекЛист.UsedRange.Columns.Count;"}
},
{0,
{"Количество строк и колонок",0,0,"","//Получим количество строк и колонок.
//В разных версиях Excel получаются по-разному, поэтому сначала определим версию Excel
Версия = Лев(Excel.Version,Найти(Excel.Version,""."")-1);
Если Версия = ""8"" Тогда
	ФайлСтрок   = Excel.Cells.CurrentRegion.Rows.Count;
	ФайлКолонок = Excel.Cells.CurrentRegion.Columns.Count;
Иначе
	ФайлСтрок   = Excel.Cells(1,1).SpecialCells(11).Row;
	ФайлКолонок = Excel.Cells(1,1).SpecialCells(11).Column;
КонецЕсли;"}
},
{0,
{"СкелетОбработки и выбор файла",0,0,"","// Открытие файла
ДиалогВыбораФайла = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Открытие);

ДиалогВыбораФайла.Заголовок = ""Прочитать табличный документ из файла"";
ДиалогВыбораФайла.Фильтр    = ""Лист Excel 2007 (*.xlsx)|*.xlsx|Лист Excel (*.xls)|*.xls"";
Если ДиалогВыбораФайла.Выбрать() Тогда
	
	//ТабличныйДокумент = ЭлементыФормы.ТабличныйДокумент;
	ВыбФайл = Новый Файл(ДиалогВыбораФайла.ПолноеИмяФайла);
	ВыбрФайл = ВыбФайл.ПолноеИмя;
	
	Если нРег(ВыбФайл.Расширение) = "".xlsx"" Тогда
		//мПрочитатьТабличныйДокументИзExcel(ТабличныйДокумент,ДиалогВыбораФайла.ПолноеИмяФайла);
		//очисткафайла(Число(Номермесяца),ДиалогВыбораФайла.ПолноеИмяФайла)  ;
	ИначеЕсли нРег(ВыбФайл.Расширение) = "".xls"" Тогда
		//мПрочитатьТабличныйДокументИзExcel(ТабличныйДокумент,ДиалогВыбораФайла.ПолноеИмяФайла);
		//очисткафайла(Число(Номермесяца),ДиалогВыбораФайла.ПолноеИмяФайла)  ;
		
		//ИначеЕсли нРег(ВыбрФайл.Расширение) = "".txt"" Тогда
		//	мПрочитатьТабличныйДокументИзТекста(ТабличныйДокумент,ДиалогВыбораФайла.ПолноеИмяФайла);
		//ИначеЕсли нРег(ВыбрФайл.Расширение) = "".dbf"" Тогда
		//	мПрочитатьТабличныйДокументИзDBF(ТабличныйДокумент,ДиалогВыбораФайла.ПолноеИмяФайла);
	КонецЕсли;
	
КонецЕсли;

// Обработка
ВыбФайл = Новый Файл(ВыбрФайл);
Если НЕ ВыбФайл.Существует() Тогда
	Сообщить(""Файл не существует!"");
	Возврат ;
КонецЕсли;

// Формирование таблицы данных
ТЗ = Новый ТаблицаЗначений;
ТЗ.Колонки.Добавить(""Номенклатура"");
ТЗ.Колонки.Добавить(""Код"");

// Чтение Excel
НомерПервойСтроки = 13;

//подключаемся к эксель
Попытка
	Excel = Новый COMОбъект(""Excel.Application"");
	Excel.WorkBooks.Open(ВыбрФайл);
	Состояние(""Обработка файла Microsoft Excel..."");
Исключение
	Сообщить(""Ошибка при открытии файла с помощью Excel! Загрузка не будет произведена!"");
	Сообщить(ОписаниеОшибки());
	Возврат;
КонецПопытки;

Попытка
	//Открываем необходимый лист
	//+++ АйТи КучеровРМ 14.08.2018 ТЗ № ИС00-004597
	НомерЛистаДляОбработки = Неопределено;
	
	КоличествоЛистров = Excel.Workbooks(1).Sheets.Count;
	Если НомерЛиста = 0 Тогда
		Для Лист = 1  По КоличествоЛистров Цикл
			Если ВРег(СокрЛП(Excel.Sheets(Лист).Name)) = ""БЛАНК"" Тогда
				НомерЛистаДляОбработки = Лист;
				Прервать;
			КонецЕсли; 	
		КонецЦикла;
	КонецЕсли; 
	
	Если НомерЛиста > КоличествоЛистров Тогда
		НомерЛиста = КоличествоЛистров;
	КонецЕсли;
	
	Если НомерЛиста = 0 И НомерЛистаДляОбработки <> Неопределено Тогда
		Excel.Sheets(НомерЛистаДляОбработки).Select(); // лист 1, по умолчанию	
	Иначе
		Excel.Sheets(НомерЛиста).Select(); // лист 1, по умолчанию
	КонецЕсли;
	//--- АйТи КучеровРМ 14.08.2018 ТЗ № ИС00-004597
Исключение
	//Закрываем Excel
	Excel.ActiveWorkbook.Close();
	Excel = 0;
	Сообщить(""Файл ""+Строка(ВыбрФайл)+"" не соответствует необходимому формату! Первый лист не найден!"");
	Возврат;
КонецПопытки;

ФайлСтрок   = 0;
ФайлКолонок = 0;

//Получим количество строк и колонок.
//В разных версиях Excel получаются по-разному, поэтому сначала определим версию Excel
Версия = Лев(Excel.Version,Найти(Excel.Version,""."")-1);
Если Версия = ""8"" Тогда
	ФайлСтрок   = Excel.Cells.CurrentRegion.Rows.Count;
	ФайлКолонок = Макс(Excel.Cells.CurrentRegion.Columns.Count, 13);
Иначе
	ФайлСтрок   = Excel.Cells(1,1).SpecialCells(11).Row;
	ФайлКолонок = Excel.Cells(1,1).SpecialCells(11).Column;
КонецЕсли;

Попытка //Если случится ошибка, то закроем файл, чтобы не висел в процессах
	
	ПредыдущееОписание = """";
	
	Для Сч = НомерПервойСтроки По ФайлСтрок Цикл
		Состояние(""Обрабатывается строка "" + Строка(Сч) + "" из "" + Строка(ФайлСтрок));
		
		Если СокрЛП(Excel.Cells(Сч, 16).Value) = """" ИЛИ СокрЛП(Excel.Cells(Сч, 1).Value) = """" Тогда
			Продолжить;
		КонецЕсли;
		
		НоваяСтрока                        = ТЗ.Добавить();
		НоваяСтрока.Код                    = СтрЗаменить(СокрЛП(Excel.Cells(Сч, 1).Value), Символ(160), """");
		НоваяСтрока.КоличествоВКоробке     = Число(СокрЛП(Excel.Cells(Сч, 3).Value));
		НоваяСтрока.ЦенаЗаШтукуБезНДС      = Число(СокрЛП(Excel.Cells(Сч, 7).Value));
		НоваяСтрока.ЦенаЗаШтукуСНДС        = Число(СокрЛП(Excel.Cells(Сч, 8).Value));
		НоваяСтрока.ЦенаЗаКоробкуБезНДС    = Число(СокрЛП(Excel.Cells(Сч, 10).Value));
		НоваяСтрока.ЦенаЗаКоробкуСНДС      = Число(СокрЛП(Excel.Cells(Сч, 11).Value));
		НоваяСтрока.КоличествоЗаказано     = Число(СокрЛП(Excel.Cells(Сч, 16).Value));
		НоваяСтрока.КоличествоЗаказаноШтук = 0;
		НоваяСтрока.ЦенаДляДокумента       = 0;
		НоваяСтрока.СуммаБезНДС            = Число(СокрЛП(Excel.Cells(Сч, 17).Value));
		НоваяСтрока.СуммаСНДС              = Число(СокрЛП(Excel.Cells(Сч, 19).Value));
		
		НоваяСтрока.КолАкции               = ?(СокрЛП(Excel.Cells(Сч, 21).Value) = """", 0, Число(СокрЛП(Excel.Cells(Сч, 21).Value)));
		НоваяСтрока.КолБрак                = ?(СокрЛП(Excel.Cells(Сч, 22).Value) = """", 0, Число(СокрЛП(Excel.Cells(Сч, 22).Value)));
		НоваяСтрока.КолСеминары            = ?(СокрЛП(Excel.Cells(Сч, 23).Value) = """", 0, Число(СокрЛП(Excel.Cells(Сч, 23).Value)));
		НоваяСтрока.КолПрочие              = ?(СокрЛП(Excel.Cells(Сч, 24).Value) = """", 0, Число(СокрЛП(Excel.Cells(Сч, 24).Value)));
		
		// КодСимвола(Сред(СокрЛП(Excel.Cells(Сч, 1).Value), 3, 1))
		
	КонецЦикла;
Исключение
	//Закрываем Excel
	Excel.ActiveWorkbook.Close();
	Excel.Quit();
	Сообщить(ОписаниеОшибки());
	Возврат;
КонецПопытки;

Попытка
	Сообщить(""Файл Excel прочитан!"");
	Excel.DisplayAlerts = 0; 
	Excel.Quit();
	Excel.DisplayAlerts = 1;
Исключение
	Сообщить(ОписаниеОшибки());
	Возврат;
КонецПопытки;"}
},
{0,
{"Поиск первой значимой строки",0,0,"","НомерПервойСтроки = 0;
Для Сч = 1 По ФайлСтрок Цикл // Поиск первой значимой строки
	<?""Имя элемента для поиска (для переменной, т.е. слитно)""> = СокрЛП(Excel.Cells(Сч, 1).Value);
	Если ЭтоЧисло(<?""Имя элемента для поиска (для переменной, т.е. слитно)"">) Тогда
		НомерПервойСтроки = Сч;
		Прервать;
	КонецЕсли; 
КонецЦикла;"}
},
{0,
{"Ошибка открытия файла Эксель на сервере",0,0,"","Excel, Ошибка открытия файла Эксель на сервере.
Следующий код работает на клиенте, но не работает на сервере. 
    ExcelПриложение = Новый COMОбъект(""Excel.Application"");
    ExcelПриложение.WorkBooks.Open(ИмяФайла);
	
С ошибкой: Ошибка при вызове метода контекста (Open) 
ExcelПриложение.WorkBooks.Open(ИмяФайла); 
по причине: 
Произошла исключительная ситуация (Microsoft Office Excel): Нет доступа к файлу '\\Sd\test\KPI.xls'. Это может быть вызвано одной из следующих причин. 
• Имени файла или пути не существует. 
• Файл используется другой программой. 
• Имя книги, которую вы пытаетесь сохранить, совпадает с именем открытой в данный момент книги.

Причина:
Эксель не предназначен для работы на сервере, ищет папку ""Desktop"" при её отсутствии падает
	
Решение:
Создать папку C:\Windows\SysWOW64\config\systemprofile\Desktop или C:\Windows\System32\config\systemprofile\Desktop (в зависимости от разрядности вашей системы)
"}
},
{0,
{"ЗЯ (Значение Ячейки)",0,0,"","Функция ЗЯ(Страница, Стр, Кол) //Значение Ячейки
	ВВ = СокрЛП(Инвойс.Sheets(Страница).Cells(Стр, Кол).Value); //Инвойс = ПолучитьCOMОбъект(АдресФайла);
	Возврат ВВ;
КонецФункции"}
}
}
},
{18,
{"Обработка ""Внешних обработок""",1,0,"",""},
{0,
{"Настройка внешней обработки",0,0,"","Функция СведенияОВнешнейОбработке() Экспорт
	
	СведенияОбОбработке = Новый Структура;
	//	1. Вид - вид обработки.
	//	Тип данных - строка, допустимо одно из 6 значений.
	//	Значения.
	//	1) Глобальные - ""ДополнительнаяОбработка"", ""ДополнительныйОтчет""
	//	2) Назначаемые - ""ЗаполнениеОбъекта"", ""Отчет"", ""ПечатнаяФорма"" или ""СозданиеСвязанныхОбъектов"".
	СведенияОбОбработке.Вставить(""Вид"", ""<?""Вид обработки"", ВыборВарианта, ""Дополнительная обработка"", ""ДополнительнаяОбработка"", ""Дополнительный отчет"", ""ДополнительныйОтчет"", ""Заполнение объекта"", ""ЗаполнениеОбъекта"", ""Отчет"", ""Отчет"", ""Печатная форма"", ""ПечатнаяФорма"", ""Создание связанных объектов"", ""СозданиеСвязанныхОбъектов"">"");
	
	//	2. Назначение - объект, для которого назначается данная обработка, 
	//	Массив строк имен объектов метаданных.
	//	Примеры значений массива - ""Документ.АвансовыйОтчет"" или ""Справочник.*"", где * - означает все объекта данного вида.
	//	Для глобальных (не назначаемых) обработок параметр не имеет смысла.
	ОбъектыМетаданных = Новый Массив;                  
	ОбъектыМетаданных.Добавить(""Документ.<?""Назначение обработки"", Документ>"");
	СведенияОбОбработке.Вставить(""Назначение"", ОбъектыМетаданных);
	
	//	3. Наименование - название обработки, произвольное наименование
	//	Тип данных - произвольная строка.
	//	Данное наименование будет отображаться в списке дополнительных обработок.
	СведенияОбОбработке.Вставить(""Наименование "", ""<?""Наименование обработки"">"");
	
	//	4. Версия - номер версии обработки
	//	Тип данных - строка в формате ""ХХ.ХХ"".
	//	Обозначает версию данной обработки, данная версия будет отображаться в списке дополнительных отчетов и обработок.
	СведенияОбОбработке.Вставить(""Версия "", ""1.0"");
	
	//	5. БезопасныйРежим - режим контроля прав пользователя.
	//	Тип данных - булево.
	СведенияОбОбработке.Вставить(""БезопасныйРежим"", <?""Безопасный режим"", ВыборВарианта, ""Да"", ""Истина"", ""Нет"", ""Ложь"">);
	
	//	6. Информация - краткое описание обработки.
	//	Тип данных - строка.
	//	Данное описание будет отображаться в списке дополнительных обработок.
	СведенияОбОбработке.Вставить(""Информация"", ""<?""Информация о обработке"">"");
	
	//	7. Команды - действия предоставляемые обработкой.
	//	Тип данных - таблица значений.
	//	Таблица содержит 5 колонок:
	//	1) Представление. Наименование команды в пользовательском интерфейсе;
	//	2) Идентификатор. Для печатных форм список макетов, для остальных обработок любая строка, уникальная для данной обработки.
	//	3) Использование. Строка, одно из значений - 
	//		- ОткрытиеФормы. Открывает форму обработки.
	//		- ВызовКлиентскогоМетода. Вызов клиентского экспортного метода модуля формы
	//		- ВызовСерверногоМетода. Вызов экспортного серверного метода модуля объекта.
	//		Для внешних печатных форм нужно указывать последнее значение.
	//	4) ПоказыватьОповещение. Булево, нужно ли показывать оповещение при начале и окончании действия.
	//	5) Модификатор. Для внешних печатных форм должно содержаться значение ""ПечатьMXL"".
	ТаблицаКоманд = ПолучитьТаблицуКоманд();
	ДобавитьКоманду(ТаблицаКоманд, ""<?""Представление. Наименование команды в пользовательском интерфейсе"">"", ""<?""Идентификатор. Для печатных форм список макетов, для остальных обработок любая строка, уникальная для данной обработки."">"", ""<?""Использование"", ВыборВарианта, ""Открытие формы"", ""ОткрытиеФормы"", ""Вызов клиентского метода"", ""ВызовКлиентскогоМетода"", ""Вызов серверного метода"", ""ВызовСерверногоМетода"">"");
	СведенияОбОбработке.Вставить(""Команды"", ТаблицаКоманд);
	
	Возврат СведенияОбОбработке;
	
КонецФункции // СведенияОВнешнейОбработке()

Функция ПолучитьТаблицуКоманд()
	
	ТаблицаКоманд = Новый ТаблицаЗначений;
	ТаблицаКоманд.Колонки.Добавить(""Представление"", Новый ОписаниеТипов(""Строка""));
	ТаблицаКоманд.Колонки.Добавить(""Идентификатор"", Новый ОписаниеТипов(""Строка""));
	ТаблицаКоманд.Колонки.Добавить(""Использование"", Новый ОписаниеТипов(""Строка""));
	ТаблицаКоманд.Колонки.Добавить(""ПоказыватьОповещение"", Новый ОписаниеТипов(""Булево""));
	ТаблицаКоманд.Колонки.Добавить(""Модификатор"", Новый ОписаниеТипов(""Строка""));
	
	Возврат ТаблицаКоманд;
	
КонецФункции

Процедура ДобавитьКоманду(ТаблицаКоманд, Представление, Идентификатор, Использование, ПоказыватьОповещение = Ложь, Модификатор = """")
	
	НоваяКоманда = ТаблицаКоманд.Добавить();
	НоваяКоманда.Представление = Представление;
	НоваяКоманда.Идентификатор = Идентификатор;
	НоваяКоманда.Использование = Использование;
	НоваяКоманда.ПоказыватьОповещение = ПоказыватьОповещение;
	НоваяКоманда.Модификатор = Модификатор;
	
КонецПроцедуры

Процедура ВыполнитьКоманду(ИдентификаторКоманды, ОбъектыНазначения, СозданныеОбъекты) Экспорт
	
	
	
КонецПроцедуры
"}
},
{0,
{"Подключение обработки через БСП",0,0,"","//************************************************************
// Создает в таблице команд новую строку
Функция ДобавитьКоманду(ТаблицаКоманд, Представление, Идентификатор, Использование, ПоказыватьОповещение = Ложь, Модификатор = """", ЗаменяемыеКоманды = """")
	
	НоваяКоманда 						= ТаблицаКоманд.Добавить();
	НоваяКоманда.Представление 			= Представление;
	НоваяКоманда.Идентификатор 			= Идентификатор;
	НоваяКоманда.Использование 			= Использование;
	НоваяКоманда.ПоказыватьОповещение 	= ПоказыватьОповещение;
	НоваяКоманда.Модификатор 			= Модификатор;
	НоваяКоманда.ЗаменяемыеКоманды 		= ЗаменяемыеКоманды;
	
КонецФункции

//************************************************************
// Вызываться программой, при добавлении файла внешней обработки в справочник.
Функция СведенияОВнешнейОбработке() Экспорт
	
	//Данные для заполнения сведений об обработке:
	ЭтотОбъектМетаданные 	= ЭтотОбъект.Метаданные();
	НаименованиеОбработки 	= ЭтотОбъектМетаданные.Синоним;	// Возьмем из синонима
	
	ЭтотОбъектМетаданныеКомментарий = ЭтотОбъектМетаданные.Комментарий;
	КомментарийМассив 				= СтрРазделить(ЭтотОбъектМетаданныеКомментарий, "","");
	ВерсияОбработки 				= СтрЗаменить(КомментарийМассив[0], ""v"", """"); 	// Возьмем из комментария
	ИнформацияПоОбрабтке 			= НаименованиеОбработки + "" (внешняя)"";	// описание
	
	//Массив назначений
	МассивНазначений 	= Новый Массив;
	УказанныеТипы 		= ЭтотОбъектМетаданные.Реквизиты.СсылкаНаДокумент.Тип.Типы();      // Возьмем типы из реквизита ""СсылкаНаДокумент""
	Для Каждого УказанныйТип ИЗ УказанныеТипы Цикл
		ОбъектМетаданных = Метаданные.НайтиПоТипу(УказанныйТип);
		Если ОбъектМетаданных <> Неопределено Тогда
			МассивНазначений.Добавить(""Документ."" + ОбъектМетаданных.Имя);
		КонецЕсли;	
	КонецЦикла;	
	
	ПараметрыРегистрации 					= ДополнительныеОтчетыИОбработки.СведенияОВнешнейОбработке(""2.4.6.167"");
	
	//Добавляемые команды на формы документов
	Использование = ДополнительныеОтчетыИОбработкиКлиентСервер.ТипКомандыВызовСерверногоМетода();
	
	ДобавитьКоманду(ПараметрыРегистрации.Команды, НаименованиеОбработки, ""ПФ_MXL_ИНВ3"", Использование, Истина, ""ПечатьMXL"", ""ИНВ3"");
	
	ПараметрыРегистрации.Вид 				= ДополнительныеОтчетыИОбработкиКлиентСервер.ВидОбработкиПечатнаяФорма(); // Варинаты: ЗаполнениеОбъекта, ДополнительныйОтчет, СозданиеСвязанныхОбъектов... 
	ПараметрыРегистрации.Назначение 		= МассивНазначений; 		// Массив документов, обрабатываемых обработкой
	ПараметрыРегистрации.Наименование 		= НаименованиеОбработки; 	// Имя под которым обработка будет зарегестрирована в справочнике внешних обработок
	ПараметрыРегистрации.Версия 			= ВерсияОбработки; 			// Версия обработки, которая будет отображаться в справочнике внешних обработок
	ПараметрыРегистрации.БезопасныйРежим 	= Ложь;						// Состояние безопасного режима
	ПараметрыРегистрации.Информация 		= ИнформацияПоОбрабтке; 	// Описание обработки для пользователя
	
	Возврат ПараметрыРегистрации;
	
КонецФункции // СведенияОВнешнейОбработке()
"}
},
{0,
{"ПутьКОбработке",0,0,"ПутьКОбр[аботке]","//ПутьКОбработке = ПолучитьПутьКОбработке();
&НаСервере
Функция ПолучитьПутьКОбработке()
	
	ОбработкаОбъект 	= РеквизитФормыВЗначение(""Объект"");
	ПутьКОбработке 		= ОбработкаОбъект.Метаданные().ПолноеИмя();
	
	Возврат ПутьКОбработке;
	
КонецФункции // ПолучитьПутьКОбработке()"}
},
{0,
{"СведенияОВнешнейОбработке",0,0,"","// Возвращает сведения о внешней обработке.
Функция СведенияОВнешнейОбработке() Экспорт
	
	ПараметрыРегистрации = ДополнительныеОтчетыИОбработки.СведенияОВнешнейОбработке();
	
	ПараметрыРегистрации.Вид 		= ДополнительныеОтчетыИОбработкиКлиентСервер.ВидОбработкиДополнительнаяОбработка();
	ПараметрыРегистрации.Версия 	= ""1.0"";
	
	НоваяКоманда = ПараметрыРегистрации.Команды.Добавить();
	НоваяКоманда.Представление 				= НСтр(""ru = 'Регламентная задача'"");
	НоваяКоманда.Идентификатор 				= ""РегЗадача"";
	НоваяКоманда.Использование 				= ДополнительныеОтчетыИОбработкиКлиентСервер.ТипКомандыВызовСерверногоМетода();
	НоваяКоманда.ПоказыватьОповещение 		= Истина;
	
	Возврат ПараметрыРегистрации;
	
КонецФункции // СведенияОВнешнейОбработке()

// Интерфейс для запуска логики обработки.
Процедура ВыполнитьКоманду(ИмяКоманды, ПараметрыВыполнения) Экспорт
	
	// Диспетчеризация обработчиков команд.
	Если ИмяКоманды = ""РегЗадача"" Тогда
		ВыполнитьРегЗадание(ПараметрыВыполнения);
	КонецЕсли;
	
КонецПроцедуры"}
},
{0,
{"СведенияОВнешнейОбработке по метаданным",0,0,"","Функция СведенияОВнешнейОбработке() Экспорт

	//Данные для заполнения сведений об обработке:
	ЭтотОбъектМетаданные 	= ЭтотОбъект.Метаданные();
	НаименованиеОбработки 	= ЭтотОбъектМетаданные.Синоним; 					// Возьмем из синонима
	
	ЭтотОбъектМетаданныеКомментарий = ЭтотОбъектМетаданные.Комментарий;
	КомментарийМассив 				= СтрРазделить(ЭтотОбъектМетаданныеКомментарий, "","");
	ВерсияОбработки 				= СтрЗаменить(КомментарийМассив[0], ""v"", """");	// Возьмем из комментария
	ИнформацияПоОбрабтке 			= ""Внешняя печатная форма"";						// Произвольное описание
	
	//Массив назначений
	МассивНазначений 	= Новый Массив;
	УказанныеТипы 		= ЭтотОбъектМетаданные.Реквизиты.СсылкаНаДокумент.Тип.Типы();	// Возьмем типы из реквизита ""Документ""
	Для Каждого УказанныйТип ИЗ УказанныеТипы Цикл
		ОбъектМетаданных = Метаданные.НайтиПоТипу(УказанныйТип);
		Если ОбъектМетаданных <> Неопределено Тогда
			МассивНазначений.Добавить(""Документ."" + ОбъектМетаданных.Имя);
		КонецЕсли;	
	КонецЦикла;	
	
	//Заполняем структуру сведений
	//	1. Вид - вид обработки.
	//	Тип данных - строка, допустимо одно из 6 значений.
	//	Значения.
	//	1) Глобальные - ""ДополнительнаяОбработка"", ""ДополнительныйОтчет""
	//	2) Назначаемые - ""ЗаполнениеОбъекта"", ""Отчет"", ""ПечатнаяФорма"" или ""СозданиеСвязанныхОбъектов"".
	
	//	2. Назначение - объект, для которого назначается данная обработка, 
	//	Массив строк имен объектов метаданных.
	//	Примеры значений массива - ""Документ.АвансовыйОтчет"" или ""Справочник.*"", где * - означает все объекта данного вида.
	//	Для глобальных (не назначаемых) обработок параметр не имеет смысла.
	
	//	3. Наименование - название обработки, произвольное наименование
	//	Тип данных - произвольная строка.
	//	Данное наименование будет отображаться в списке дополнительных обработок.
	
	//	4. Версия - номер версии обработки
	//	Тип данных - строка в формате ""ХХ.ХХ"".
	//	Обозначает версию данной обработки, данная версия будет отображаться в списке дополнительных отчетов и обработок.
	
	//	5. БезопасныйРежим - режим контроля прав пользователя.
	//	Тип данных - булево.
	
	//	6. Информация - краткое описание обработки.
	//	Тип данных - строка.
	//	Данное описание будет отображаться в списке дополнительных обработок.
	
	//	7. Команды - действия предоставляемые обработкой.
	//	Тип данных - таблица значений.
	//	Таблица содержит 5 колонок:
	//	1) Представление. Наименование команды в пользовательском интерфейсе;
	//	2) Идентификатор. Для печатных форм список макетов, для остальных обработок любая строка, уникальная для данной обработки.
	//	3) Использование. Строка, одно из значений - 
	//		- ОткрытиеФормы. Открывает форму обработки.
	//		- ВызовКлиентскогоМетода. Вызов клиентского экспортного метода модуля формы
	//		- ВызовСерверногоМетода. Вызов экспортного серверного метода модуля объекта.
	//		Для внешних печатных форм нужно указывать последнее значение.
	//	4) ПоказыватьОповещение. Булево, нужно ли показывать оповещение при начале и окончании действия.
	//	5) Модификатор. Для внешних печатных форм должно содержаться значение ""ПечатьMXL"".
	
	//Добавляемые команды на формы документов
	ТаблицаКоманд = ПолучитьТаблицуКоманд();
	ДобавитьКоманду(ТаблицаКоманд, НаименованиеОбработки, ""Идентификатор"", ""ВызовСерверногоМетода"", Истина, ""ПечатьMXL"");
	
	ПараметрыРегистрации = Новый Структура;
	ПараметрыРегистрации.Вставить(""Вид""				, ""ПечатнаяФорма""); 		// Варинаты: ЗаполнениеОбъекта, ДополнительныйОтчет, СозданиеСвязанныхОбъектов... 
	ПараметрыРегистрации.Вставить(""Назначение""		, МассивНазначений);  		// Массив документов, обрабатываемых обработкой
	ПараметрыРегистрации.Вставить(""Наименование""	, НаименованиеОбработки); 	// Имя под которым обработка будет зарегестрирована в справочнике внешних обработок
	ПараметрыРегистрации.Вставить(""Версия""			, ВерсияОбработки);         // Версия обработки, которая будет отображаться в справочнике внешних обработок
	ПараметрыРегистрации.Вставить(""БезопасныйРежим""	, Ложь);       				// Включение безопасного режима
	ПараметрыРегистрации.Вставить(""Информация""		, ИнформацияПоОбрабтке);	// Описание обработки для пользователя
	ПараметрыРегистрации.Вставить(""Команды""			, ТаблицаКоманд);        	// Таблица команд, добавляемых в систему
	Возврат ПараметрыРегистрации;
	
КонецФункции // СведенияОВнешнейОбработке()"}
},
{0,
{"ОткрытьВнешнОбработку",0,0,"","Процедура ОткрытьВнешнОбработку(йКод, Наименование = """")
	
	Если ПустаяСтрока(Наименование) Тогда
		спр = Справочники.ВнешниеОбработки.НайтиПоКоду(йКод);
	Иначе
		спр = Справочники.ВнешниеОбработки.НайтиПоНаименованию(Наименование);
	КонецЕсли;
	
	Если спр.Пустая() Тогда 
		Предупреждение(""Не найдена обработка с кодом "" + йКод); 
		Возврат; 
	КонецЕсли;
	
	ЭтоОбработка = Истина;
	ЭтоОтчет     = Ложь;
	
	Попытка
		ИмяФайла 		= ПолучитьИмяВременногоФайла();
		ДвоичныеДанные 	= спр.ХранилищеВнешнейОбработки.Получить();
		ДвоичныеДанные.Записать(ИмяФайла);
		Форма = ВнешниеОбработки.ПолучитьФорму(ИмяФайла);
		Если Не Форма = Неопределено Тогда
			Форма.Открыть();
		Конецесли;
	Исключение
		Предупреждение(""Выбранный файл не является внешней обработкой.
		|Либо, данная обработка не предназначена для
		|запуска в этой конфигурации."");
	КонецПопытки;
	
КонецПроцедуры"}
},
{0,
{"Печать ВПФ",0,0,"","ДеревоМакетовПечати = УниверсальныеМеханизмы.ПолучитьДеревоМакетовПечати(СсылкаНаДокумент, Неопределено); 

СтрокаКнопки = ДеревоМакетовПечати.Строки.Найти(""ИМЯ-ВАШЕГО-МАКЕТА"", ""Текст""); 

Расшифровка = СтрокаКнопки.Расшифровка; 
Если ТипЗнч(Расшифровка) = Тип(""Структура"") Тогда 
	ТабДокументСФ = УниверсальныеМеханизмы.НапечататьВнешнююФорму(СсылкаНаДокумент, Расшифровка); 
КонецЕсли;"}
},
{0,
{"Печать универсально",0,0,"","//+++====== Печать универсально [АйТи Кучеров Р 18.05.2018 ТЗ № ИС00-001738] ================================================

//Функция постарается напечатать средствами ВПФ и вернёт Истину, если всё удачно
//-------------------------------------------------------------------------
//Параметры:
//		НаименованиеОбработки - Строка - Представление обработки (имя)
//		ОбъектыНазначения - Массив - Объекты на печать
//		ПараметрыИсточникаИдентификаторКоманды - Строка - Идентификатор обработки
//Возвращаемое значение:
//		Булево - Истина, если была найдена ВПФ, иначе Ложь
//-------------------------------------------------------------------------
//автор: Кучеров Р 18.05.2018 
&НаКлиенте
Функция ПечатьВПФ(НаименованиеОбработки, ОбъектыНазначения, ПараметрыИсточникаИдентификаторКоманды)
	
	ВПФ = ДополнительныеОтчетыИОбработкиНайтиПоНаименованию(НаименованиеОбработки);
	Если ВПФ.Пустая() Тогда // Значит печать надо обычными средствами
		Возврат Ложь;
	КонецЕсли;
	
	// Печать через ВПФ 
	ПараметрыОткрытия 					= Новый Структура(""ИсточникДанных, ПараметрыИсточника"");
	ПараметрыОткрытия.ИсточникДанных 	= ВПФ;
	ПараметрыОткрытия.ПараметрыИсточника = Новый Структура(""ИдентификаторКоманды, ОбъектыНазначения"");
	ПараметрыОткрытия.ПараметрыИсточника.ИдентификаторКоманды 	= ПараметрыИсточникаИдентификаторКоманды;
	ПараметрыОткрытия.ПараметрыИсточника.ОбъектыНазначения 		= ОбъектыНазначения;
	ОткрытьФорму(""ОбщаяФорма.ПечатьДокументов"", ПараметрыОткрытия);
	
	Возврат Истина;
	
КонецФункции

&НаСервереБезКонтекста
Функция ДополнительныеОтчетыИОбработкиНайтиПоНаименованию(пНаименованиеОбработки)
	лДополнительныеОтчетыИОбработки = Справочники.ДополнительныеОтчетыИОбработки.НайтиПоНаименованию(пНаименованиеОбработки);
	Возврат лДополнительныеОтчетыИОбработки;
КонецФункции

//Функция 
//-------------------------------------------------------------------------
//Параметры:
//		НаименованиеОбработки - Тип - описание
//		ИмяМенеджераПечати - Тип - ""Документ."" + ""АктВыполненныхРабот""
//		ОбъектыНазначения - Массив - описание
//		ПараметрыИсточникаИдентификаторКоманды - Строка - описание
//-------------------------------------------------------------------------
//автор: Кучеров Р 18.05.2018 
&НаКлиенте
Процедура ПечатьДокумента(НаименованиеОбработки, ИмяМенеджераПечати, ОбъектыНазначения, ПараметрыИсточникаИдентификаторКоманды)
	
	НапечатаноЧерезВПФ = ПечатьВПФ(НаименованиеОбработки, ОбъектыНазначения, ПараметрыИсточникаИдентификаторКоманды);
	Если НЕ НапечатаноЧерезВПФ Тогда
		ИменаМакетов			= ПараметрыИсточникаИдентификаторКоманды; 
		МассивОбъектов			= ОбъектыНазначения;
		ВладелецФормы			= ЭтаФорма;
		ПараметрыПечати			= Неопределено; 
		УправлениеПечатьюКлиент.ВыполнитьКомандуПечати(ИмяМенеджераПечати, ИменаМакетов, МассивОбъектов, ВладелецФормы, ПараметрыПечати);
	КонецЕсли; 
	
КонецПроцедуры

//Функция 
//-------------------------------------------------------------------------
//Параметры:
//		Идентификатор - Тип - описание
//		ИмяМенеджераПечати - Тип - ""Документ."" + ""АктВыполненныхРабот""
//		ИмяФормы - Строка - ""Документ.АктВыполненныхРабот.Форма.ФормаДокумента""
//		МассивОбъектов - Массив - описание
//Возвращаемое значение:
//		Тип - описание
//-------------------------------------------------------------------------
//автор: Кучеров Р 18.05.2018 
&НаКлиенте
Процедура ПечатьУниверсально(Идентификатор, ИмяМенеджераПечати, ИмяФормы, МассивОбъектов)
	
	Представление = ПолучитьПредставлениеКоманды(ИмяФормы, Идентификатор); 
	
	Если Представление <> Неопределено Тогда
		ПечатьДокумента(Представление, ИмяМенеджераПечати, МассивОбъектов, Идентификатор);
	КонецЕсли; 
	
КонецПроцедуры

//Функция ПолучитьПредставлениеКоманды
//-------------------------------------------------------------------------
//Параметры:
//		ИмяФормы - Строка - Вида: ""Документ.АктВыполненныхРабот.Форма.ФормаДокумента"" 
//		Идентификатор - Строка - Вида: ""АктОбОказанииУслуг"", ""ПФ_MXL_Акт"" 
//Возвращаемое значение:
//		Строка - Представление КомандыПечати
//-------------------------------------------------------------------------
//автор: Кучеров Р 18.05.2018 
&НаСервереБезКонтекста
Функция ПолучитьПредставлениеКоманды(ИмяФормы, Идентификатор)
	
	КомандыПечати 	= ПолучитьКомандыПечати(ИмяФормы);
	
	ПараметрыОтбора = Новый Структура;
	ПараметрыОтбора.Вставить(""Идентификатор"", Идентификатор);
	ПараметрыОтбора.Вставить(""Отключена"", Ложь);
	НайденныеСтроки = КомандыПечати.НайтиСтроки(ПараметрыОтбора);
	Если ЗначениеЗаполнено(НайденныеСтроки) Тогда
		СтрокаТЗ = НайденныеСтроки[0];
	КонецЕсли;
	
	Если СтрокаТЗ <> Неопределено Тогда
		Представление = СтрокаТЗ.Представление;
	Иначе
		Представление = Неопределено;
	КонецЕсли; 
	
	Возврат Представление
	
КонецФункции // ПолучитьПредставлениеКоманды()

&НаСервереБезКонтекста
Функция ПолучитьКомандыПечати(ИмяФормы)
	Возврат УправлениеПечатьюПовтИсп.КомандыПечатиФормы(ИмяФормы).Скопировать();
КонецФункции // ПолучитьКомандыПечати()

//---====== Печать универсально [АйТи Кучеров Р 18.05.2018 ТЗ № ИС00-001738] ================================================ 

//Функция ЗаполнитьСписокВыбораКомандамиПечати
//-------------------------------------------------------------------------
//Параметры:
//		ИмяФормы - Строка - Вида ""Документ.АктВыполненныхРабот.Форма.ФормаДокумента""
//		СписокЗначенийПечати - Элементы.СписокЗначенийПечатиАкта.СписокВыбора - СписокВыбора на форме
//		ВернутьИндексЗаданногоИмени - Булево - Вернуть индекс элемента с именем в параметре ""ЗаданноеИмяДляВозвратаИндекса""
//		ЗаданноеИмяДляВозвратаИндекса - Строка - Элемент для поиска индекса
//Возвращаемое значение:
//		Число - Индекс
//-------------------------------------------------------------------------
//автор: Кучеров Р 18.05.2018
&НаСервере
Функция ЗаполнитьСписокВыбораКомандамиПечати(ИмяФормы, СписокЗначенийПечати, ВернутьИндексЗаданногоИмени = Ложь, ЗаданноеИмяДляВозвратаИндекса = """")
	
	Если ПустаяСтрока(ИмяФормы) Тогда
		Возврат 0;
	КонецЕсли;
	
	КомандыПечати 	= ПолучитьКомандыПечати(ИмяФормы);
	
	ПараметрыОтбора = Новый Структура;
	ПараметрыОтбора.Вставить(""Отключена"", Ложь);
	АктуальныеКомандыПечати = КомандыПечати.НайтиСтроки(ПараметрыОтбора);
	
	ИндексЗаданногоИмени = 0; 
	
	Индекс = 0;
	Для каждого ЭлМасс Из АктуальныеКомандыПечати Цикл
		
		Представление = ЭлМасс.Представление;
		Идентификатор = ЭлМасс.Идентификатор;
		
		Если ВернутьИндексЗаданногоИмени Тогда
			Если Представление = ЗаданноеИмяДляВозвратаИндекса  Тогда
				ИндексЗаданногоИмени = Индекс;
			КонецЕсли; 
		КонецЕсли; 
		
		СписокЗначенийПечати.Добавить(Идентификатор, Представление);
		
		Индекс = Индекс + 1;
		
	КонецЦикла;
	
	Возврат ИндексЗаданногоИмени;
	
КонецФункции // ЗаполнитьСписокВыбораКомандамиПечати()

Акт_ИмяФормы 	= ""Документ.АктВыполненныхРабот.Форма.ФормаДокумента"";
ИндексИскомого 	= ЗаполнитьСписокВыбораКомандамиПечати(Акт_ИмяФормы, Элементы.СписокЗначенийПечатиАкта.СписокВыбора, Истина, ""Акт об оказании услуг"");
СписокЗначенийПечатиАкта 	= Элементы.СписокЗначенийПечатиАкта.СписокВыбора[ИндексИскомого].Значение;"}
},
{0,
{"Создать на основании",0,0,"","//Не все знают, что конфигурации на основе БСП (УТ 11, БП 3.0, ЗУП 3.0 и т.д.) имеют механизм, который позволяет создавать связанные объекты, что в какой-то мере является аналогом создания на основании.
//Понятно, что многие гуру знают об этой возможности, но статья все же не для них. Предупреждаю сразу. :)

//Есть разные виды внешних отчетов и обработок:

//// Вид - строка - возможные значения: ""ДополнительнаяОбработка""
//// ""ДополнительныйОтчет""
//// ""ЗаполнениеОбъекта""
//// ""Отчет""
//// ""ПечатнаяФорма""
//// ""СозданиеСвязанныхОбъектов""

//Поговорим о последнем виде... Как оказалось - это достаточно мощная возможность добавить новый функционал без необходимости непосредственного изменения конфигурации. Лучше всего рассмотрим на примере:

//Мне была поставлена следующая задача.

//Задача: Есть УТ 11, с одним складом и несколькими складскими помещениями и ордерной схемой работы. При закупке имеем следующее:

//Заказ поставщику → Поступление товаров → Приходный ордер (центральное помещение) → [?] Перемещение (в другие помещения)

//И все бы хорошо, но на последнем шаге, после того, как товар будет оприходован в центральное помещение, его начинают перемещать в другие помещения в рамках одного склада. Т.е. документ ""Перемещение товаров"" не сделать, все необходимо делать с помощью ""Ордера на перемещение товаров"", который выпадает из схемы закупки. И так получается, что этот документ нельзя создать на основании ""Приходного ордера"", или документа ""Поступление товаров"". Подходим к вопросу о том, как это сделать.

//Необходимо: Добавить возможность создания документа ""Ордер на перемещение товаров"" на основании ""Приходного ордера"".

Функция СведенияОВнешнейОбработке() Экспорт
	
	ПараметрыРегистрации = Новый Структура;
	
	// Добавим куда нужно вставить возможность создания на основании
	МассивНазначений = Новый Массив;
	МассивНазначений.Добавить(""Документ.ПриходныйОрдерНаТовары"");
	
	ПараметрыРегистрации.Вставить(""Вид""             , ""СозданиеСвязанныхОбъектов"");
	ПараметрыРегистрации.Вставить(""Назначение""      , МассивНазначений);
	ПараметрыРегистрации.Вставить(""Наименование""    , ""Создать ордер на перемещение товаров на основании приходного ордера"");
	ПараметрыРегистрации.Вставить(""Версия""          , ""1.0"");
	ПараметрыРегистрации.Вставить(""БезопасныйРежим"" , Истина);
	ПараметрыРегистрации.Вставить(""Информация""      , ""Дополнительная обработка"");
	
	ТаблицаКоманд = ПолучитьТаблицуКоманд();
	
	// Добавим команду
	ДобавитьКоманду(
	ТаблицаКоманд,
	""Ордер на перемещение товаров"",
	""Ордер на перемещение товаров"",
	""ВызовКлиентскогоМетода"",
	Истина
	);
	
	ПараметрыРегистрации.Вставить(""Команды"", ТаблицаКоманд);
	
	Возврат ПараметрыРегистрации;
	
КонецФункции

Функция ПолучитьТаблицуКоманд()
	
	Команды = Новый ТаблицаЗначений;
	Команды.Колонки.Добавить(""Представление""        , Новый ОписаниеТипов(""Строка""));
	Команды.Колонки.Добавить(""Идентификатор""        , Новый ОписаниеТипов(""Строка""));
	Команды.Колонки.Добавить(""Использование""        , Новый ОписаниеТипов(""Строка""));
	Команды.Колонки.Добавить(""ПоказыватьОповещение"" , Новый ОписаниеТипов(""Булево""));
	Команды.Колонки.Добавить(""Модификатор""          , Новый ОписаниеТипов(""Строка""));
	
	Возврат Команды;
	
КонецФункции

Процедура ДобавитьКоманду(ТаблицаКоманд, Представление, Идентификатор, Использование, ПоказыватьОповещение = Истина, Модификатор = """")
	
	НоваяКоманда                      = ТаблицаКоманд.Добавить();
	НоваяКоманда.Представление        = Представление;
	НоваяКоманда.Идентификатор        = Идентификатор;
	НоваяКоманда.Использование        = Использование;
	НоваяКоманда.ПоказыватьОповещение = ПоказыватьОповещение;
	НоваяКоманда.Модификатор          = Модификатор;
	
КонецПроцедуры
Добавляем форму, в которой описываем перезаполнение:

&НаКлиенте
Процедура ВыполнитьКоманду(ИдентификаторКоманды, ОбъектыНазначенияМассив, СозданныеОбъекты) Экспорт
	
	//Переберем все выбранные документы на основании, которых будет созданы другие новые документы
	Для каждого Элемент из ОбъектыНазначенияМассив Цикл    
		
		//Получая форму объекта создаваемого документа
		ФормаДок = ПолучитьФорму(""Документ.ОрдерНаПеремещениеТоваров.ФормаОбъекта""); 
		
		//Далее мы получаем объект только, что созданной формы и помещаем её в переменную
		//В объекте содержатся все реквизиты (элементы) формы
		ДанныеФормы = ФормаДок.Объект; 
		
		//Мы помещаем объект формы в переменную, 
		//так как должны передать её в процедуру на сервере,
		//где нельзя изменять объект формы, зато можно править переменную содержащую его
		СоздатьНовыйДокумент(Элемент, ДанныеФормы);
		
		//После выполнения процедуры на сервере мы получаем изменную переменную ДанныеФормы,
		//которую необходимо передать в уже созданную нами форму
		КопироватьДанныеФормы(ДанныеФормы, ФормаДок.Объект);
		
		//Открываем результат выполнения обработки
		ФормаДок.Открыть();
		
	КонецЦикла;    
	
КонецПроцедуры

&НаСервере
Процедура СоздатьНовыйДокумент(Элемент, НовыйОбъект)
	
	// Заполняем
	Основание             = Элемент.Ссылка;
	
	НовыйОбъект.Дата         = ТекущаяДата();
	НовыйОбъект.Склад         = Основание.Склад; 
	НовыйОбъект.ПомещениеОтправитель= Основание.Помещение; 
	
	// Переносим строки
	Для каждого СтрокаТЧ из Основание.Товары Цикл
		ЗаполнитьЗначенияСвойств(НовыйОбъект.Товары.Добавить(), СтрокаТЧ);
	КонецЦикла;
	
КонецПроцедуры"}
},
{0,
{"При помощи БСП программно открыть внешний отчет/обработку",0,0,"","1С 8.3 Как при помощи БСП программно открыть внешний отчет из ""Дополнительные отчеты и обработки"" и передать параметры
https://www.e-du.ru/2018/03/1c-open-ext-report.html

// имя внешней обработки - ВнешняяОбработкаПример  (в допобработках)
// имя внешнего отчета - ВнешнийОтчетСКДПример  (в допобработках)
// во внешнем отчете/обработке, даже если это СКД, должна быть создана форма
// (для СКД - это стандартная форма отчета по умолчанию)

// Открытие внешней обработки без параметров 
&НаКлиенте
Процедура ОткрытьВнешнююОбработку(Команда)
    ОткрытьВнешнийОтчетОбработкуПоИмениСДопПараметрами (""ВнешняяОбработкаПример"", Неопределено, Ложь); 
КонецПроцедуры

// Открытие внешней обработки с передачей параметров
&НаКлиенте
Процедура ОткрытьВнешнююОбработкуСПараметром(Команда)
    ПараметрыОбработки = Новый Структура;
    ПараметрыОбработки.Вставить(НазваниеПараметра, ЗначениеПараметра);
    ОткрытьВнешнийОтчетОбработкуПоИмениСДопПараметрами (""ВнешняяОбработкаПример"", ПараметрыОбработки, Ложь);
КонецПроцедуры

// Открытие внешнего отчета СКД без параметров 
&НаКлиенте
Процедура ОткрытьВнешнийОтчетСКД(Команда)
    ОткрытьВнешнийОтчетОбработкуПоИмениСДопПараметрами (""ВнешнийОтчетСКДПример"", Неопределено, Истина);
КонецПроцедуры

// Открытие внешнего отчета СКД с передачей параметров
&НаКлиенте
Процедура ОткрытьВнешнийОтчетСКДсПараметром(Команда)  
    ПользовательскиеНастройки = Новый ПользовательскиеНастройкиКомпоновкиДанных;
    ПользовательскиеНастройки.ДополнительныеСвойства.Вставить(НазваниеПараметра, ЗначениеПараметра);
    // добавляем другие нужные параметры по желанию
    //ПользовательскиеНастройки.ДополнительныеСвойства.Вставить(НазваниеПараметра2, ЗначениеПараметра2);
    //ПользовательскиеНастройки.ДополнительныеСвойства.Вставить(""Период"", Новый СтандартныйПериод(ДатаНачала,ДатаОкончания));   
    ПараметрыОтчета = Новый Структура;
    ПараметрыОтчета.Вставить(""СформироватьПриОткрытии"", Истина);
    ПараметрыОтчета.Вставить(""КлючВарианта"", ""ФормированиеПоПараметрам"");
    ПараметрыОтчета.Вставить(""ПользовательскиеНастройки"", ПользовательскиеНастройки);   
    ОткрытьВнешнийОтчетОбработкуПоИмениСДопПараметрами (""ВнешнийОтчетСКДПример"", ПараметрыОтчета, Истина);
КонецПроцедуры

// процедура, открывающая отчет/обработку по имени, заданному в допобработках
&НаКлиенте
Процедура ОткрытьВнешнийОтчетОбработкуПоИмениСДопПараметрами(ИмяОтчетаОбработки, ПараметрыОткрытия, ЭтоОтчет, РодительскаяФорма = Неопределено)
    ВнешнийОтчетОбработкаДляОткрытияСсылка = ПолучитьСсылкуНаВнешнийОтчетОбработкуПоИмениНаСервере (ИмяОтчетаОбработки);  
     // ВЫЗОВ ИЗ БСП ФУНКЦИИ ПОДКЛЮЧЕНИЯ ВНЕШНЕЙ ОБРАБОТКИ
    ИмяОбработкиСлужебное = ДополнительныеОтчетыИОбработкиВызовСервера.ПодключитьВнешнююОбработку(ВнешнийОтчетОбработкаДляОткрытияСсылка);
    Если ЭтоОтчет Тогда
        ОткрытьФорму(""ВнешнийОтчет."" + ИмяОбработкиСлужебное + "".Форма"", ПараметрыОткрытия, РодительскаяФорма);
    Иначе
        ОткрытьФорму(""ВнешняяОбработка."" + ИмяОбработкиСлужебное + "".Форма"", ПараметрыОткрытия, РодительскаяФорма);
    КонецЕсли;
КонецПроцедуры

&НаСервере
Функция ПолучитьСсылкуНаВнешнийОтчетОбработкуПоИмениНаСервере(ИмяОтчетаОбработки)
    Возврат Справочники.ДополнительныеОтчетыИОбработки.НайтиПоНаименованию(ИмяОтчетаОбработки).Ссылка;
КонецФункции

Процедуры:
ОткрытьВнешнююОбработку - пример обработки команды запуска внешней обработки без передачи параметров.
ОткрытьВнешнююОбработкуСПараметром  - пример обработки команды запуска внешней обработки с передачей одного параметра.
ОткрытьВнешнийОтчетСКД - пример обработки команды запуска СКД отчета без передачи параметров.
ОткрытьВнешнийОтчетСКДсПараметром - пример обработки команды запуска СКД отчета с передачей параметров отбора.
ПолучитьСсылкуНаВнешнийОтчетОбработкуПоИмениНаСервере - служебная функция, выполняемая на сервере, получающая ссылку на экземпляр отчета (обработки) по имени, заданном в ""Дополнительные отчеты и обработки"".
ОткрытьВнешнийОтчетОбработкуПоИмениСДопПараметрами - общая процедура,  непосредственно осуществляющая открытие. Внутри нее как раз строка кода вызывающая стандартную функцию из БСП (выгружает вызываемый отчет/обработку и передает ее наименование, чтобы к нему можно было обратиться по имени при открытии формы):
ИмяОбработкиСлужебное = ДополнительныеОтчетыИОбработкиВызовСервера.ПодключитьВнешнююОбработку(ВнешнийОтчетОбработкаДляОткрытияСсылка);

////////////////////////////////////////////////////////////////////////////////
// ОТЧЕТ СКД
 
Если вызывается отчет на СКД, то обязательно нужно создать для него типовую форму. Подробнее см. Как добавить типовую форму для СКД
Чтобы сработал код передачи параметров в СКД (ОткрытьВнешнийОтчетСКДсПараметром), нужно в модуле объекта СКД добавить код, принимающий эти параметры:

Процедура ПриКомпоновкеРезультата(ДокументРезультат, ДанныеРасшифровки, СтандартнаяОбработка)
    ЗаполнитьПользовательскиеНастройки();
КонецПроцедуры

Процедура ЗаполнитьПользовательскиеНастройки()      
    ДополнительныеСвойства = КомпоновщикНастроек.ПользовательскиеНастройки.ДополнительныеСвойства;
    Если Не ДополнительныеСвойства.Количество() Тогда
        Возврат;
    КонецЕсли;                                        
    Параметры = КомпоновщикНастроек.Настройки.ПараметрыДанных.Элементы;
    Отборы    = КомпоновщикНастроек.Настройки.Отбор.Элементы;   
    Для каждого Элемент Из Параметры Цикл                          
        ИмяПараметра = Строка(Элемент.Параметр);
        ЗначениеПараметра = Неопределено;                 
        Если ДополнительныеСвойства.Свойство(ИмяПараметра, ЗначениеПараметра) Тогда
            Настройка = КомпоновщикНастроек.ПользовательскиеНастройки.Элементы.Найти(Элемент.ИдентификаторПользовательскойНастройки);
            Настройка.Значение      = ЗначениеПараметра;
            Настройка.Использование = Истина;
        КонецЕсли;    
    КонецЦикла;  
    Для каждого Элемент Из Отборы Цикл    
        ИмяПараметра = Строка(Элемент.ЛевоеЗначение);
        ЗначениеПараметра = Неопределено;     
        Если ДополнительныеСвойства.Свойство(ИмяПараметра, ЗначениеПараметра) Тогда
            Настройка = КомпоновщикНастроек.ПользовательскиеНастройки.Элементы.Найти(Элемент.ИдентификаторПользовательскойНастройки);
            //Настройка.ВидСравнения   = ВидСравненияКомпоновкиДанных.Равно;
            Настройка.ПравоеЗначение = ЗначениеПараметра;
            Настройка.Использование  = Истина;
        КонецЕсли;        
    КонецЦикла;  
    КомпоновщикНастроек.ПользовательскиеНастройки.ДополнительныеСвойства.Очистить(); 
КонецПроцедуры

Скачать пример данного СКД отчета можно в конце статьи.

Также пробовала передавать параметры в СКД вот так:

&НаКлиенте
Процедура ОткрытьВнешнийОтчетСКДсПараметром(Команда)  
    // установка параметров отбора
    Отбор = Новый Структура;
    Отбор.Вставить(НазваниеПараметра, ЗначениеПараметра);
    ПараметрыОтчета = Новый Структура;
    ПараметрыОтчета.Вставить(""Отбор"", Отбор);
    ПараметрыОтчета.Вставить(""СформироватьПриОткрытии"", Истина);
    ОткрытьВнешнийОтчетОбработкуПоИмениСДопПараметрами (""ВнешнийОтчетСКДПример"", ПараметрыОтчета, Истина);
КонецПроцедуры

Однако возникала ошибка:
Невозможно применить фиксированные настройки. Пересекаются элементы отбора."}
},
{0,
{"ВнешняяОбработкаОткрытьФорму",0,0,"","&НаКлиенте
Процедура ВнешняяОбработкаОткрытьФорму(пНаименованиеОбработки, пИмяФормы = ""Форма"")
	
	лВнешняяОбработка = ДополнительныеОтчетыИОбработкиНайтиПоНаименованию(пНаименованиеОбработки);
	Если лВнешняяОбработка.Пустая() Тогда // Значит печать надо обычными средствами
		Возврат;
	КонецЕсли;
	
	//лОбъектыНазначения = Новый Массив;
	//лОбъектыНазначения.Добавить(Объект.Ссылка);
	
	лИмяОбработкиСлужебное 	= ДополнительныеОтчетыИОбработкиВызовСервера.ПодключитьВнешнююОбработку(лВнешняяОбработка);
	лВнешняяОбработкаФормы 	= ПолучитьФорму(""ВнешняяОбработка."" + лИмяОбработкиСлужебное + ""."" + пИмяФормы);
	
	лВнешняяОбработкаФормы.ВыполнитьКоманду(""Идентификатор"", лОбъектыНазначения,);
	
	лВнешняяОбработкаФормы.Открыть();
	
КонецПроцедуры

&НаСервереБезКонтекста
Функция ДополнительныеОтчетыИОбработкиНайтиПоНаименованию(пНаименованиеОбработки)
	лДополнительныеОтчетыИОбработки = Справочники.ДополнительныеОтчетыИОбработки.НайтиПоНаименованию(пНаименованиеОбработки);
	Возврат лДополнительныеОтчетыИОбработки;
КонецФункции"}
},
{0,
{"ВПФ через ООП",0,0,"","#Область ОписаниеИзменений
// hrm.3.ssa.base-3.1.4.164-1.0.0.0 KVADRUM<avb@1c89.ru> #1 Добавить печатную форму трудового договора
// hrm.3.ssa.base-3.1.6.6-1.0.3.0 KVADRUM<avb@1c89.ru> #5 Изменить печатные формы по приложенным шаблонам
// hrm.3.ssa.base-3.1.6.6-1.0.3.1 KVADRUM<avb@1c89.ru> #6 В место работы добавить территорию, на которую принимается сотрудник
// hrm.3.ssa.base-3.1.6.6-1.0.3.1 KVADRUM<avb@1c89.ru> #8 Изменить способ отображения длительности испытательного срока если он не кратен месяцу
// hrm.3.ssa.base-3.1.6.6-1.0.3.1 KVADRUM<avb@1c89.ru> #7 Неверно указываются даты начала и окончания действия договора
// hrm.3.ssa.base-3.1.6.6-1.0.3.1 KVADRUM<avb@1c89.ru> #9 Неправильно формируется п. 5.5.6
// hrm.3.ssa.base-3.1.6.6-1.0.3.1 KVADRUM<avb@1c89.ru> #10 Не формируется значение ОГРН
#КонецОбласти
#Область ОбластьОпределенияПеременных

#Область ОпределениеПеременных_ООП

Перем ООП_Classes; // Коллекция зарегистрированных классов используемых в обработке
Перем ООП_ClassInstances; // Коллекция созданных экземпляров классов

#КонецОбласти //ОпределениеПеременных_ООП//

Перем мДлинаЗемныхСуток;

#КонецОбласти //ОбластьОпределенияПеременных//
#Область ПрограммныйИнтерфейс

// Интерфейс для регистрации обработки.
// Вызывается при добавлении обработки в справочник ""ВнешниеОбработки""
//
// Возвращаемое значение:
// Структура:
// Вид - строка - возможные значения:	""ДополнительнаяОбработка""
//										""ДополнительныйОтчет""
//										""ЗаполнениеОбъекта""
//										""Отчет""
//										""ПечатнаяФорма""
//										""СозданиеСвязанныхОбъектов""
//
// Назначение - массив строк имен объектов метаданных в формате:
//			<ИмяКлассаОбъектаМетаданного>.[ * | <ИмяОбъектаМетаданных>]
//			Например, ""Документ.СчетЗаказ"" или ""Справочник.*""
//			Прим. параметр имеет смысл только для назначаемых обработок
//
// Наименование - строка - наименование обработки, которым будет заполнено
//						наименование справочника по умолчанию - краткая строка для
//						идентификации обработки администратором
//
// Версия - строка - версия обработки в формате <старший номер>.<младший номер>
//					используется при загрузке обработок в информационную базу
// БезопасныйРежим – Булево – Если истина, обработка будет запущена в безопасном режиме.
//							Более подбробная информация в справке.
//
// Информация - Строка- краткая информация по обработке, описание обработки
//
// ВерсияБСП - Строка - Минимальная версия БСП, на которую рассчитывает код
// дополнительной обработки. Номер версии БСП задается в формате «РР.ПП.ВВ.СС»
// (РР – старший номер редакции; ПП – младший номер ре-дакции; ВВ – номер версии; СС – номер сборки).
//
// Команды - ТаблицаЗначений - команды, поставляемые обработкой, одная строка таблицы соотвествует
//							одной команде
//				колонки: 
//				 - Представление - строка - представление команды конечному пользователю
//				 - Идентификатор - строка - идентефикатор команды. В случае печатных форм
//											перечисление через запятую списка макетов
//				 - Использование - строка - варианты запуска обработки:
//						""ОткрытиеФормы"" - открыть форму обработки
//						""ВызовКлиентскогоМетода"" - вызов клиентского экспортного метода из формы обработки
//						""ВызовСерверногоМетода"" - вызов серверного экспортного метода из модуля объекта обработки
//				 - ПоказыватьОповещение – Булево – если Истина, требуется оказывать оповещение при начале
//								и при окончании запуска обработки. Прим. Имеет смысл только
//								при запуске обработки без открытия формы.
//				 - Модификатор – строка - для печатных форм MXL, которые требуется
//										отображать в форме ПечатьДокументов подсистемы Печать
//										требуется установить как ""ПечатьMXL""
//
Функция СведенияОВнешнейОбработке() Экспорт
	
	Перем СведенияОВнешнейОбработке;
	
	СведенияОВнешнейОбработке = ДополнительныеОтчетыИОбработки.СведенияОВнешнейОбработке(""2.4.4.106"");
	
	СведенияОВнешнейОбработке.Вид              = ДополнительныеОтчетыИОбработкиКлиентСервер.ВидОбработкиПечатнаяФорма();
	СведенияОВнешнейОбработке.Версия           = ""1.0.3.1"";
	СведенияОВнешнейОбработке.БезопасныйРежим  = Ложь;
	СведенияОВнешнейОбработке.Назначение.Добавить(""Документ.ПриемНаРаботу"");
	
	НоваяКоманда = СведенияОВнешнейОбработке.Команды.Добавить();
	НоваяКоманда.Представление         = НСтр(""ru = 'Печатная форма: Трудовой договор (вредники)'"");
	НоваяКоманда.Идентификатор         = ""ПФ_MXL_ТрудовойДоговорВредники"";
	НоваяКоманда.Использование         = ДополнительныеОтчетыИОбработкиКлиентСервер.ТипКомандыВызовСерверногоМетода();
	НоваяКоманда.Модификатор           = ""ПечатьMXL"";
	НоваяКоманда.ПоказыватьОповещение  = Ложь;
	
	НоваяКоманда = СведенияОВнешнейОбработке.Команды.Добавить();
	НоваяКоманда.Представление         = НСтр(""ru = 'Печатная форма: Трудовой договор (вредники-льготники)'"");
	НоваяКоманда.Идентификатор         = ""ПФ_MXL_ТрудовойДоговорВредникиЛьготники"";
	НоваяКоманда.Использование         = ДополнительныеОтчетыИОбработкиКлиентСервер.ТипКомандыВызовСерверногоМетода();
	НоваяКоманда.Модификатор           = ""ПечатьMXL"";
	НоваяКоманда.ПоказыватьОповещение  = Ложь;
	
	НоваяКоманда = СведенияОВнешнейОбработке.Команды.Добавить();
	НоваяКоманда.Представление         = НСтр(""ru = 'Печатная форма: Трудовой договор (ИТР вахта РКС)'"");
	НоваяКоманда.Идентификатор         = ""ПФ_MXL_ТрудовойДоговорИТРВахтаРКС"";
	НоваяКоманда.Использование         = ДополнительныеОтчетыИОбработкиКлиентСервер.ТипКомандыВызовСерверногоМетода();
	НоваяКоманда.Модификатор           = ""ПечатьMXL"";
	НоваяКоманда.ПоказыватьОповещение  = Ложь;
	
	НоваяКоманда = СведенияОВнешнейОбработке.Команды.Добавить();
	НоваяКоманда.Представление         = НСтр(""ru = 'Печатная форма: Трудовой договор (ИТР основной график РКС)'"");
	НоваяКоманда.Идентификатор         = ""ПФ_MXL_ТрудовойДоговорИТРОсновнойГрафикРКС"";
	НоваяКоманда.Использование         = ДополнительныеОтчетыИОбработкиКлиентСервер.ТипКомандыВызовСерверногоМетода();
	НоваяКоманда.Модификатор           = ""ПечатьMXL"";
	НоваяКоманда.ПоказыватьОповещение  = Ложь;
	
	НоваяКоманда = СведенияОВнешнейОбработке.Команды.Добавить();
	НоваяКоманда.Представление         = НСтр(""ru = 'Печатная форма: Трудовой договор (ИТР совместительство РКС)'"");
	НоваяКоманда.Идентификатор         = ""ПФ_MXL_ТрудовойДоговорИТРСовместительствоРКС"";
	НоваяКоманда.Использование         = ДополнительныеОтчетыИОбработкиКлиентСервер.ТипКомандыВызовСерверногоМетода();
	НоваяКоманда.Модификатор           = ""ПечатьMXL"";
	НоваяКоманда.ПоказыватьОповещение  = Ложь;
	
	НоваяКоманда = СведенияОВнешнейОбработке.Команды.Добавить();
	НоваяКоманда.Представление         = НСтр(""ru = 'Печатная форма: Трудовой договор (рабочие вахта РКС)'"");
	НоваяКоманда.Идентификатор         = ""ПФ_MXL_ТрудовойДоговорРабочиеВахтаРКС"";
	НоваяКоманда.Использование         = ДополнительныеОтчетыИОбработкиКлиентСервер.ТипКомандыВызовСерверногоМетода();
	НоваяКоманда.Модификатор           = ""ПечатьMXL"";
	НоваяКоманда.ПоказыватьОповещение  = Ложь;
	
	НоваяКоманда = СведенияОВнешнейОбработке.Команды.Добавить();
	НоваяКоманда.Представление         = НСтр(""ru = 'Печатная форма: Трудовой договор (рабочие основной график РКС)'"");
	НоваяКоманда.Идентификатор         = ""ПФ_MXL_ТрудовойДоговорРабочиеОсновнойГрафикРКС"";
	НоваяКоманда.Использование         = ДополнительныеОтчетыИОбработкиКлиентСервер.ТипКомандыВызовСерверногоМетода();
	НоваяКоманда.Модификатор           = ""ПечатьMXL"";
	НоваяКоманда.ПоказыватьОповещение  = Ложь;
	
	НоваяКоманда = СведенияОВнешнейОбработке.Команды.Добавить();
	НоваяКоманда.Представление         = НСтр(""ru = 'Печатная форма: Трудовой договор (сдельные расценки)'"");
	НоваяКоманда.Идентификатор         = ""ПФ_MXL_ТрудовойДоговорСдельныеРасценки"";
	НоваяКоманда.Использование         = ДополнительныеОтчетыИОбработкиКлиентСервер.ТипКомандыВызовСерверногоМетода();
	НоваяКоманда.Модификатор           = ""ПечатьMXL"";
	НоваяКоманда.ПоказыватьОповещение  = Ложь;

	
	Возврат СведенияОВнешнейОбработке;
	
КонецФункции

Функция Печать(МассивОбъектов, КоллекцияПечатныхФорм, ОбъектыПечати, ПараметрыВывода = Неопределено) Экспорт
	Перем Печать;
	
	ИменаМакетов = Новый Массив;
	Для каждого ПечатнаяФорма Из КоллекцияПечатныхФорм Цикл
		ИменаМакетов.Добавить(ПечатнаяФорма.ИмяМакета);	
	КонецЦикла;
	
	МакетыИДанные  = ООП_Новый(""МакетыИДанные"");
	МакетыИДанные  = МакетыИДанные_Создать(МакетыИДанные, МассивОбъектов, ИменаМакетов);
	
	Для каждого ИмяМакета Из ИменаМакетов Цикл
		
		Если УправлениеПечатью.НужноПечататьМакет(КоллекцияПечатныхФорм, ИмяМакета) Тогда
			
			ТабличныйДокумент = Новый ТабличныйДокумент;
			
			НомерТипаДокумента = 0;
			Для каждого СсылкаНаОбъект Из МассивОбъектов Цикл
				
				НомерТипаДокумента = НомерТипаДокумента + 1;
				Если НомерТипаДокумента > 1 Тогда
					ТабличныйДокумент.ВывестиГоризонтальныйРазделительСтраниц();
				КонецЕсли;
				
				ТабличныйДокумент.Вывести(МакетыИДанные_ПечатьМакетаОбъекта(МакетыИДанные, СсылкаНаОбъект, ИмяМакета)); //исполняющая функция (в этом же модуле)	
				
			КонецЦикла; 
			
			ТабличныйДокумент.АвтоМасштаб = Истина;
			ТабличныйДокумент.ИмяПараметровПечати = ""ПАРАМЕТРЫ_ПЕЧАТИ_"" + ИмяМакета;
			ТабличныйДокумент.ОтображатьГруппировки = Ложь;
			ТабличныйДокумент.ОтображатьЗаголовки = Ложь;
			ТабличныйДокумент.ОтображатьСетку = Ложь;
			ТабличныйДокумент.ТолькоПросмотр = Истина;
			ТабличныйДокумент.ПолеСверху = 5;
			ТабличныйДокумент.ПолеСнизу = 5;
			ТабличныйДокумент.ПолеСлева = 20;
			ТабличныйДокумент.ПолеСнизу = 5;
			ТабличныйДокумент.ОриентацияСтраницы = ОриентацияСтраницы.Портрет;
			
			
			УправлениеПечатью.ВывестиТабличныйДокументВКоллекцию(КоллекцияПечатныхФорм
			, ИмяМакета //тот же - что и в функции ""СведенияОВнешнейОбработке""! 
			, ""Печатная форма: Акт передачи материалов в эксплуатацию""
			, ТабличныйДокумент
			);	
			
		КонецЕсли;
		
	КонецЦикла; 
	
	Если ( 0 <> КоллекцияПечатныхФорм.Количество() ) Тогда
		Печать = КоллекцияПечатныхФорм[0].ТабличныйДокумент;
	Иначе
		Печать = Новый ТабличныйДокумент;
	КонецЕсли; 
	
	Возврат Печать;
	
КонецФункции

#КонецОбласти

#Область class_Документ_ПриемНаРаботу

// public
Функция Документ_ПриемНаРаботу_Создать(Знач Документ_ПриемНаРаботу, Знач СсылкаНаОбъект, Знач ИменаМакетов) Экспорт
	
	Перем Документ_ПриемНаРаботу_Создать; // Возвращаемое значение
	Перем ПараметрыЗапроса;
	Перем СведенияОбОрганизации;
	
	Перем Документ_ДанныеИзБД;
	Перем Организация, Спецификация;
	Перем Руководитель;
	Перем Сотрудники;
	
	Перем Регистратор;
	Перем ТерриториальныеУсловия;
	
	Документ_ПриемНаРаботу_Создать = Неопределено;
	
	МассивОбъектов = Новый Массив;
	МассивОбъектов.Добавить(СсылкаНаОбъект);
	Документ_ДанныеИзБД = Запрос_Создать(Новый Запрос(), ""Объект"", Новый Структура(""Ссылка"", СсылкаНаОбъект)).Выполнить().Выбрать();
	
	Если ( Ложь = Документ_ДанныеИзБД.Следующий() ) Тогда
		Возврат Документ_ПриемНаРаботу_Создать;
	КонецЕсли; 
	
	Договор = Документ_ПриемНаРаботу;
	Организация = Договор.Организация;
	Руководитель = Организация.ОтветственныеЛица[""Руководитель""];
	Сотрудник = Договор.Сотрудник;
	УсловияТрудаНаРабочемМесте = Договор.УсловияТрудаНаРабочемМесте;
	ОплатаТруда = Договор.ОплатаТруда;
	РасчетныйСчет = Организация.РасчетныйСчет;
	Банк = РасчетныйСчет.Банк;
	
	Организация.Ссылка = Документ_ДанныеИзБД.Организация;
	Сотрудник.Ссылка = Документ_ДанныеИзБД.Сотрудник;
	Руководитель.Ссылка = Документ_ДанныеИзБД.Руководитель;
	Руководитель.Должность.Ссылка = Документ_ДанныеИзБД.ДолжностьРуководителя;
	
	КадровыеДанныеСотрудников = Документ_ПриемНаРаботу_КадровыеДанныеСотрудников(ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(Сотрудник.Ссылка), Документ_ДанныеИзБД.Дата);
	КадровыеДанныеСотрудника = КадровыеДанныеСотрудников.Найти(Сотрудник.Ссылка);
	Если (Неопределено = КадровыеДанныеСотрудника) Тогда
		ВызватьИсключение ""Для сотрудника "" + Сотрудник.Ссылка + "" отсутствуют кадровые данные"";
	КонецЕсли; 
	
	Начисления = Документ_ПриемНаРаботу_НачисленияСотрудника(Сотрудник.Ссылка, КонецДня(Документ_ДанныеИзБД.ДатаПриема));

#Область Договор
	
	Договор.НомерТрудовогоДоговора = Документ_ДанныеИзБД.ТрудовойДоговорНомер;
	Договор.ДатаТрудовогоДоговора = Документ_ДанныеИзБД.ТрудовойДоговорДата;
	Договор.ВидЗанятости = Документ_ДанныеИзБД.ВидЗанятости;
	Договор.ДатаПриема = Документ_ДанныеИзБД.ДатаПриема;
	
	ТерриториальныеУсловия = Документ_ПриемНаРаботу_ТерриториальныеУсловияПФРПСтруктурнойЕдиницы(Документ_ДанныеИзБД.Территория, Договор.ДатаТрудовогоДоговора);
	Договор.ТерриториальныеУсловия = ?(Неопределено = Договор.ТерриториальныеУсловия, ТерриториальныеУсловия, Договор.ТерриториальныеУсловия);
	ТерриториальныеУсловия = Документ_ПриемНаРаботу_ТерриториальныеУсловияПФРПСтруктурнойЕдиницы(Документ_ДанныеИзБД.Подразделение, Договор.ДатаТрудовогоДоговора);
	Договор.ТерриториальныеУсловия = ?(Неопределено = Договор.ТерриториальныеУсловия, ТерриториальныеУсловия, Договор.ТерриториальныеУсловия);
	ТерриториальныеУсловия = Документ_ПриемНаРаботу_ТерриториальныеУсловияПФРПСтруктурнойЕдиницы(Документ_ДанныеИзБД.Организация, Договор.ДатаТрудовогоДоговора);
	Договор.ТерриториальныеУсловия = ?(Неопределено = Договор.ТерриториальныеУсловия, ТерриториальныеУсловия, Договор.ТерриториальныеУсловия);
	
	Договор.ДлительностьИспытательногоСрока = Документ_ДанныеИзБД.ДлительностьИспытательногоСрока;
	Договор.ДатаНачала = КадровыеДанныеСотрудника.ДатаНачала;
	Договор.ДатаОкончания = КадровыеДанныеСотрудника.ДатаОкончания;

#КонецОбласти
	#Область Организация
	СведенияОбОрганизации = Документ_ПриемНаРаботу_СведенияОбОрганизации(Организация.Ссылка, Документ_ДанныеИзБД.Дата);
		
	Организация.Наименования[""Полное""] = СведенияОбОрганизации.НаименованиеПолное;
	Организация.Наименования[""Краткое""] = СведенияОбОрганизации.НаименованиеКраткое;
	Организация.Адреса[""Юридический""] = СведенияОбОрганизации.АдресЮридический;
	Организация.Адреса[""Почтовый""] = СведенияОбОрганизации.АдресПочтовый;
	Организация.Факс = СведенияОбОрганизации.Факс;
	Организация.Телефон = СведенияОбОрганизации.Телефон;
	Организация.Email = СведенияОбОрганизации.Email;
	Организация.ИНН = СведенияОбОрганизации.ИНН;
	Организация.КПП = СведенияОбОрганизации.КПП;
	Организация.ОГРН = СведенияОбОрганизации.ОГРН;
	                                
	#КонецОбласти 	
	#Область РасчетныйСчетБанк
	
	РасчетныйСчет_ДанныеИзБД = Запрос_Создать(Новый Запрос(), ""РасчетныйСчет"", Новый Структура(""Ссылка"", КадровыеДанныеСотрудника.ЗарплатныйПроект)).Выполнить().Выбрать();
		
	Если (РасчетныйСчет_ДанныеИзБД.Следующий()) Тогда
		
		РасчетныйСчет.Номер = РасчетныйСчет_ДанныеИзБД.Номер;
		Банк.Наименование = РасчетныйСчет_ДанныеИзБД.БанкНаименование;
		Банк.Город = РасчетныйСчет_ДанныеИзБД.БанкГород;
		Банк.КорреспондентскийСчет = РасчетныйСчет_ДанныеИзБД.БанкКорреспондентскийСчет;
		Банк.БИК = РасчетныйСчет_ДанныеИзБД.БанкБИК;
		
	КонецЕсли; 
		

	#КонецОбласти
	#Область Руководитель
	
	КадровыеДанныеФизическихЛиц = Документ_ПриемНаРаботу_КадровыеДанныеФизическихЛиц(ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(Руководитель.Ссылка), Документ_ДанныеИзБД.Дата);
	КадровыеДанныеРуководителя = КадровыеДанныеФизическихЛиц.Найти(Руководитель.Ссылка);
	Если (НЕ Неопределено = КадровыеДанныеРуководителя) Тогда
		
		Руководитель.Пол = КадровыеДанныеРуководителя.Пол;
		
		Стандартные_Должность_Наименование(Руководитель.Должность, Строка(Руководитель.Должность.Ссылка));
		
		Стандартные_ФИО_Установить(Руководитель.ФИО, КадровыеДанныеРуководителя);
		Если (ПустаяСтрока(Стандартные_ФИО_ФамилияИмяОтчество(Руководитель.ФИО))) Тогда
			Стандартные_ФИО_Установить(Руководитель.ФИО, КадровыеДанныеРуководителя.ФИО);
		КонецЕсли; 
		
	КонецЕсли; 
	
	#КонецОбласти 
	#Область Сотрудник
		
	Стандартные_Должность_Наименование(Сотрудник.Должность, Документ_ДанныеИзБД.ДолжностьНаименование);
	Стандартные_Подразделение_Наименование(Сотрудник.Подразделение, Документ_ДанныеИзБД.ПодразделениеНаименование);
	Сотрудник.ТерриторияВыполненияРабот = Документ_ДанныеИзБД.Территория;
	Сотрудник.ДатаРождения = КадровыеДанныеСотрудника.ДатаРождения;
	Сотрудник.УдостоверениеЛичности.Представление = КадровыеДанныеСотрудника.ДокументПредставление;
	Сотрудник.УдостоверениеЛичности.Серия = КадровыеДанныеСотрудника.ДокументСерия;
	Сотрудник.УдостоверениеЛичности.Номер = КадровыеДанныеСотрудника.ДокументНомер;
	Сотрудник.УдостоверениеЛичности.КемВыдан = КадровыеДанныеСотрудника.ДокументКемВыдан;
	Сотрудник.УдостоверениеЛичности.ДатаВыдачи = КадровыеДанныеСотрудника.ДокументДатаВыдачи;
	Сотрудник.УдостоверениеЛичности.КодПодразделения = КадровыеДанныеСотрудника.ДокументКодПодразделения;
	Сотрудник.АдресРегистрации = КадровыеДанныеСотрудника.АдресПоПропискеПредставление;
	Сотрудник.ИНН = КадровыеДанныеСотрудника.ИНН; 
	Сотрудник.СНИЛС = КадровыеДанныеСотрудника.СтраховойНомерПФР; 
	Сотрудник.ТелефонМобильный = КадровыеДанныеСотрудника.ТелефонМобильныйПредставление; 
	Сотрудник.Страна = КадровыеДанныеСотрудника.Страна; 
	
	Стандартные_ФИО_Установить(Сотрудник.ФИО, КадровыеДанныеСотрудника);
	Если (ПустаяСтрока(Стандартные_ФИО_ФамилияИмяОтчество(Сотрудник.ФИО))) Тогда
			Стандартные_ФИО_Установить(Сотрудник.ФИО, КадровыеДанныеСотрудника.ФИО);
	КонецЕсли; 
	

	#КонецОбласти 
	#Область ОплатаТруда
		
	ОплатаТруда.ОкладСтавка = ?(Неопределено = Начисления.ОсновноеНачисление, 0, Начисления.ОсновноеНачисление.ЗначениеОсновногоПоказателя);
	ОплатаТруда.ОсновнойПоказатель = ?(Неопределено = Начисления.ОсновноеНачисление, Справочники.ПоказателиРасчетаЗарплаты.ПустаяСсылка(), Начисления.ОсновноеНачисление.ОсновнойПоказатель);
	ОплатаТруда.СтавкаНДФЛ = УчетНДФЛ.СтавкаНДФЛ(Перечисления.НДФЛСтавкиНалогообложенияРезидента.Ставка13, Справочники.ВидыДоходовНДФЛ.КодДоходаПоУмолчанию, КадровыеДанныеСотрудника.СтатусНалогоплательщика, Год(Договор.ДатаТрудовогоДоговора));
	ОплатаТруда.РайонныйКоэффициент = ?(Неопределено = Начисления.РайонныйКоэффициент, 0, Начисления.РайонныйКоэффициент.ЗначениеОсновногоПоказателя);;
	
	#КонецОбласти	
	#Область УсловияТрудаНаРабочемМесте
		
	УсловияТрудаНаРабочемМесте.Вид = КадровыеДанныеСотрудника.КлассУсловийТруда;
		
	#КонецОбласти	
	
  	Документ_ПриемНаРаботу_Создать = Документ_ПриемНаРаботу;
	
	Возврат Документ_ПриемНаРаботу_Создать;
	
КонецФункции // Документ_ПриемНаРаботу_Создать

// protected
Функция Документ_ПриемНаРаботу_КадровыеДанныеСотрудников(Знач Сотрудники, Знач Дата)

	Перем Документ_ПриемНаРаботу_КадровыеДанныеСотрудников; // Возвращаемое значение
		
	ТребуемыеКадровыеДанные = Новый Массив();
	ТребуемыеКадровыеДанные.Добавить(""ФИО"");
	ТребуемыеКадровыеДанные.Добавить(""Фамилия"");
	ТребуемыеКадровыеДанные.Добавить(""Имя"");
	ТребуемыеКадровыеДанные.Добавить(""Отчество"");
	ТребуемыеКадровыеДанные.Добавить(""ВидЗанятости"");
	ТребуемыеКадровыеДанные.Добавить(""Страна"");
	ТребуемыеКадровыеДанные.Добавить(""ДатаРождения"");
	ТребуемыеКадровыеДанные.Добавить(""КлассУсловийТруда"");
	ТребуемыеКадровыеДанные.Добавить(""Организация"");
	ТребуемыеКадровыеДанные.Добавить(""Подразделение"");
	ТребуемыеКадровыеДанные.Добавить(""Территория"");
	ТребуемыеКадровыеДанные.Добавить(""СтатусНалогоплательщика"");
	ТребуемыеКадровыеДанные.Добавить(""ДокументПредставление"");
	ТребуемыеКадровыеДанные.Добавить(""ДокументСерия"");
	ТребуемыеКадровыеДанные.Добавить(""ДокументНомер"");
	ТребуемыеКадровыеДанные.Добавить(""ДокументКемВыдан"");
	ТребуемыеКадровыеДанные.Добавить(""ДокументДатаВыдачи"");
	ТребуемыеКадровыеДанные.Добавить(""ДокументКодПодразделения"");
	ТребуемыеКадровыеДанные.Добавить(""АдресПоПропискеПредставление"");
	ТребуемыеКадровыеДанные.Добавить(""ИНН"");
	ТребуемыеКадровыеДанные.Добавить(""СтраховойНомерПФР"");
	ТребуемыеКадровыеДанные.Добавить(""ЗарплатныйПроект"");
	ТребуемыеКадровыеДанные.Добавить(""ТарифнаяСтавка"");
	ТребуемыеКадровыеДанные.Добавить(""ПроцентСевернойНадбавки"");
	ТребуемыеКадровыеДанные.Добавить(""ТелефонМобильныйПредставление"");
	ТребуемыеКадровыеДанные.Добавить(""ДатаНачала"");
	ТребуемыеКадровыеДанные.Добавить(""ДатаОкончания"");
	
	
	Документ_ПриемНаРаботу_КадровыеДанныеСотрудников = КадровыйУчет.КадровыеДанныеСотрудников(Истина, Сотрудники, ТребуемыеКадровыеДанные, Дата);
		
	Возврат Документ_ПриемНаРаботу_КадровыеДанныеСотрудников;

КонецФункции // Документ_ПриемНаРаботу_КадровыеДанныеСотрудников()
Функция Документ_ПриемНаРаботу_КадровыеДанныеФизическихЛиц(Знач ФизическиеЛица, Знач ДатаДолученияДанных)

	Перем Документ_ПриемНаРаботу_КадровыеДанныеФизическихЛиц; // Возвращаемое значение
		
	ТребуемыеКадровыеДанные = Новый Массив();
	ТребуемыеКадровыеДанные.Добавить(""ФИО"");
	ТребуемыеКадровыеДанные.Добавить(""Фамилия"");
	ТребуемыеКадровыеДанные.Добавить(""Имя"");
	ТребуемыеКадровыеДанные.Добавить(""Отчество"");
	ТребуемыеКадровыеДанные.Добавить(""Пол"");
	
	Документ_ПриемНаРаботу_КадровыеДанныеФизическихЛиц = КадровыйУчет.КадровыеДанныеФизическихЛиц(Истина, ФизическиеЛица, ТребуемыеКадровыеДанные, ДатаДолученияДанных);
		
	Возврат Документ_ПриемНаРаботу_КадровыеДанныеФизическихЛиц;

КонецФункции // Документ_ПриемНаРаботу_КадровыеДанныеСотрудников()
Функция Документ_ПриемНаРаботу_СведенияОбОрганизации(Знач Организация, Знач ДатаПолученияДанных)

	Перем Документ_ПриемНаРаботу_СведенияОбОрганизации;
	
	СведенияОбОрганизации = Новый Структура;
	
	Сведения = Новый СписокЗначений;
	Сведения.Добавить("""", ""НаимЮЛПол"");
	Сведения.Добавить("""", ""НаимЮЛкрат"");
	Сведения.Добавить("""", ""ИННЮЛ"");
	Сведения.Добавить("""", ""КППЮЛ"");
	Сведения.Добавить("""", ""ФаксОрганизации"");
	Сведения.Добавить("""", ""ТелОрганизации"");
	Сведения.Добавить("""", ""АдресЭлектроннойПочтыОрганизации"");
	
	УстановитьПривилегированныйРежим(Истина);
	//ОргСведения = ЗарплатаКадры.ПолучитьСведенияОбОрганизации(Организация, ДатаПолученияДанных, Сведения);
	ОргСведения = ЗарплатаКадры.ПолучитьСведенияОбОрганизации(Организация, ДатаПолученияДанных, Неопределено);
	УстановитьПривилегированныйРежим(Ложь);
	
	СведенияОбОрганизации.Вставить(""НаименованиеПолное"", ОргСведения.НаимЮЛПол);
	СведенияОбОрганизации.Вставить(""НаименованиеКраткое"", Организация.Наименование);
	СведенияОбОрганизации.Вставить(""ИНН"",  ОргСведения.ИННЮЛ);
	СведенияОбОрганизации.Вставить(""КПП"", ОргСведения.КППЮЛ);
	СведенияОбОрганизации.Вставить(""ОГРН"", ОргСведения.ОГРН);
	СведенияОбОрганизации.Вставить(""Факс"", ОргСведения.ФаксОрганизации);
	СведенияОбОрганизации.Вставить(""Телефон"", ОргСведения.ТелОрганизации);
	СведенияОбОрганизации.Вставить(""Email"", ОргСведения.АдресЭлектроннойПочтыОрганизации);
	
	ВидыКонтактнойИнформации = Новый Массив();
	ВидыКонтактнойИнформации.Добавить(Справочники.ВидыКонтактнойИнформации.ЮрАдресОрганизации);
	ВидыКонтактнойИнформации.Добавить(Справочники.ВидыКонтактнойИнформации.ПочтовыйАдресОрганизации);
	АдресаОрганизации = УправлениеКонтактнойИнформацией.КонтактнаяИнформацияОбъектов(ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(Организация)
	, ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(Перечисления.ТипыКонтактнойИнформации.Адрес)
	, ВидыКонтактнойИнформации
	, ДатаПолученияДанных);
	
	ОписаниеЮридическогоАдреса = АдресаОрганизации.Найти(Справочники.ВидыКонтактнойИнформации.ЮрАдресОрганизации, ""Вид"");
	ОписаниеПочтовогоАдреса = АдресаОрганизации.Найти(Справочники.ВидыКонтактнойИнформации.ПочтовыйАдресОрганизации, ""Вид"");
	
	СведенияОбОрганизации.Вставить(""АдресЮридический"", ?((Неопределено = ОписаниеЮридическогоАдреса), """", ОписаниеЮридическогоАдреса.Представление));
	СведенияОбОрганизации.Вставить(""АдресПочтовый"", ?((Неопределено = ОписаниеПочтовогоАдреса), """", ОписаниеПочтовогоАдреса.Представление));
	
	Документ_ПриемНаРаботу_СведенияОбОрганизации = СведенияОбОрганизации;
	
	Возврат Документ_ПриемНаРаботу_СведенияОбОрганизации;
		
КонецФункции // Документ_ПриемНаРаботу_СведенияОбОрганизации()
Функция Документ_ПриемНаРаботу_НачисленияСотрудника(Знач Сотрудник, Знач ДатаПолученияДанных)
	
	Перем Документ_ПриемНаРаботу_НачисленияСотрудника;
	
	Документ_ПриемНаРаботу_ТаблицаНачисленийСотрудника = Новый Структура();
	
	Запрос = Новый Запрос();
	Запрос.МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
	Запрос.УстановитьПараметр(""Сотрудник"", Сотрудник);
	Запрос.УстановитьПараметр(""Период"", ДатаПолученияДанных);
	Запрос.Текст = ""ВЫБРАТЬ РАЗРЕШЕННЫЕ РАЗЛИЧНЫЕ
	               |	&Сотрудник КАК Сотрудник,
	               |	&Период КАК Период
	               |ПОМЕСТИТЬ ВТСотрудникиПериоды"";
	Запрос.Выполнить();
	
	ЗапросНачислений = КадровыйУчет.ЗапросВТПлановыеНачисленияСотрудников(Истина, ""ВТПлановыеНачисления"", ""ВТСотрудникиПериоды"");
	ЗапросНачислений.МенеджерВременныхТаблиц = Запрос.МенеджерВременныхТаблиц;
	ЗапросНачислений.Выполнить();
	
	ЗапросНачислений.Текст = ""ВЫБРАТЬ
	                         |	ВТПлановыеНачисления.Начисление КАК Начисление,
	                         |	ВТПлановыеНачисления.ОсновнойПоказатель КАК ОсновнойПоказатель,
	                         |	ВТПлановыеНачисления.НачислениеТарифнойСтавки КАК НачислениеТарифнойСтавки,
	                         |	ВЫБОР
	                         |		КОГДА ВТПлановыеНачисления.Начисление.КатегорияНачисленияИлиНеоплаченногоВремени = ЗНАЧЕНИЕ(Перечисление.КатегорииНачисленийИНеоплаченногоВремени.РайонныйКоэффициент)
	                         |			ТОГДА ИСТИНА
	                         |		ИНАЧЕ ЛОЖЬ
	                         |	КОНЕЦ КАК НачислениеРайонногоКоэффициента,
	                         |	ВЫБОР
	                         |		КОГДА ВТПлановыеНачисления.Начисление.КатегорияНачисленияИлиНеоплаченногоВремени = ЗНАЧЕНИЕ(Перечисление.КатегорииНачисленийИНеоплаченногоВремени.СевернаяНадбавка)
	                         |			ТОГДА ИСТИНА
	                         |		ИНАЧЕ ЛОЖЬ
	                         |	КОНЕЦ КАК НачислениеСевернойНадбавки,
	                         |	ЕСТЬNULL(ВТПлановыеНачисления.ЗначениеОсновногоПоказателя, 0) КАК ЗначениеОсновногоПоказателя,
	                         |	ВТПлановыеНачисления.Размер КАК Размер
	                         |ИЗ
	                         |	ВТПлановыеНачисления КАК ВТПлановыеНачисления"";
	
	
	ТаблицаНачислений = ЗапросНачислений.Выполнить().Выгрузить();
	
	// Основное начисление
	Начисления = ТаблицаНачислений.НайтиСтроки(Новый Структура(""НачислениеТарифнойСтавки"", Истина));
	Документ_ПриемНаРаботу_ТаблицаНачисленийСотрудника.Вставить(""ОсновноеНачисление"", ?(0 = Начисления.Количество(), Неопределено, Начисления[0]));
		
	// Районный коэффициент
	Начисления = ТаблицаНачислений.НайтиСтроки(Новый Структура(""НачислениеРайонногоКоэффициента"", Истина));
	Документ_ПриемНаРаботу_ТаблицаНачисленийСотрудника.Вставить(""РайонныйКоэффициент"", ?(0 = Начисления.Количество(), Неопределено, Начисления[0]));
		
	// Северная надбавка
	Начисления = ТаблицаНачислений.НайтиСтроки(Новый Структура(""НачислениеСевернойНадбавки"", Истина));
	Документ_ПриемНаРаботу_ТаблицаНачисленийСотрудника.Вставить(""СевернаяНадбавка"", ?(0 = Начисления.Количество(), Неопределено, Начисления[0]));
	
	// Надбавка за разъездной характер работ
	Начисления = ТаблицаНачислений.НайтиСтроки(Новый Структура(""Начисление"", ПланыВидовРасчета.Начисления.НайтиПоКоду(""КРХР"")));
	Документ_ПриемНаРаботу_ТаблицаНачисленийСотрудника.Вставить(""НадбавкаЗаРазъезднойХарактерРабот"", ?(0 = Начисления.Количество(), Неопределено, Начисления[0]));

	Возврат Документ_ПриемНаРаботу_ТаблицаНачисленийСотрудника;
	
КонецФункции // Документ_ПриемНаРаботу_ТаблицаНачисленийСотрудника()
  
Функция Документ_ПриемНаРаботу(Документ_ПриемНаРаботу) Экспорт
	
	ООП_parent(Документ_ПриемНаРаботу);
	
	Документ_ПриемНаРаботу.Вставить(""НомерТрудовогоДоговора"");
	Документ_ПриемНаРаботу.Вставить(""ДатаТрудовогоДоговора"");
	Документ_ПриемНаРаботу.Вставить(""ТерриториальныеУсловия"", Неопределено);
	Документ_ПриемНаРаботу.Вставить(""Организация"", ООП_Новый(""Стандартные.ЮрФизЛицо""));
	Документ_ПриемНаРаботу.Организация.Вставить(""Ссылка"");
	Документ_ПриемНаРаботу.Организация.Вставить(""Факс"");
	Документ_ПриемНаРаботу.Организация.Вставить(""Телефон"");
	Документ_ПриемНаРаботу.Организация.Вставить(""Email"");
	Документ_ПриемНаРаботу.Организация.ОтветственныеЛица[""Руководитель""].Вставить(""Основание"");
	
	Документ_ПриемНаРаботу.Вставить(""Сотрудник"", ООП_Новый(""Стандартные.ФизическоеЛицо""));
	Документ_ПриемНаРаботу.Сотрудник.Вставить(""Ссылка"");
	Документ_ПриемНаРаботу.Сотрудник.Вставить(""ТерриторияВыполненияРабот"", Справочники.ТерриторииВыполненияРабот.ПустаяСсылка());
	Документ_ПриемНаРаботу.Сотрудник.Вставить(""УдостоверениеЛичности"", ООП_Новый(""Стандартные.ДокументУдостоверяющийЛичность""));
	Документ_ПриемНаРаботу.Сотрудник.Вставить(""АдресРегистрации"", """");
	Документ_ПриемНаРаботу.Сотрудник.Вставить(""ИНН"");
	Документ_ПриемНаРаботу.Сотрудник.Вставить(""СНИЛС"");
	Документ_ПриемНаРаботу.Сотрудник.Вставить(""ТелефонМобильный"");
	Документ_ПриемНаРаботу.Сотрудник.Вставить(""Подразделение"", ООП_Новый(""Стандартные.Подразделение""));
	Документ_ПриемНаРаботу.Сотрудник.Вставить(""ДатаРождения"");
	Документ_ПриемНаРаботу.Сотрудник.Вставить(""Страна"");
	
	Документ_ПриемНаРаботу.Сотрудник.УдостоверениеЛичности.Вставить(""КодПодразделения"");
	
	Документ_ПриемНаРаботу.Вставить(""ОплатаТруда"", ООП_Новый(""ОплатаТруда""));
	Документ_ПриемНаРаботу.Вставить(""УсловияТрудаНаРабочемМесте"", ООП_Новый(""УсловияТрудаНаРабочемМесте""));
	
	Документ_ПриемНаРаботу.Вставить(""ВидЗанятости"");
	Документ_ПриемНаРаботу.Вставить(""ДатаПриема"");
	Документ_ПриемНаРаботу.Вставить(""РазъезднойХарактерРаботы"");
	Документ_ПриемНаРаботу.Вставить(""ВахтовыйМетодРаботы"");
	Документ_ПриемНаРаботу.Вставить(""ДлительностьИспытательногоСрока"");
	Документ_ПриемНаРаботу.Вставить(""ДатаНачала"");
	Документ_ПриемНаРаботу.Вставить(""ДатаОкончания"");
	
	Возврат Документ_ПриемНаРаботу;
	
КонецФункции // Документ_ПриемНаРаботу_Include
Функция Документ_ПриемНаРаботу_Include()
	
	Перем Документ_ПриемНаРаботу_Include;
	
	ООП_Include(""Стандартные.Документ"");
	ООП_Include(""Стандартные.ЮрФизЛицо"");
	ООП_Include(""Стандартные.Подразделение"");
	ООП_Include(""Стандартные.ДокументУдостоверяющийЛичность"");
	ООП_Include(""ОплатаТруда"");
	ООП_Include(""УсловияТрудаНаРабочемМесте"");
	
	ООП_ЗарегистрироватьКласс(""Документ.ПриемНаРаботу"", ""Структура"", ""Стандартные.Документ"");
	
	Возврат Документ_ПриемНаРаботу_Include;
	
КонецФункции

// private
Функция Документ_ПриемНаРаботу_ТерриториальныеУсловияПФРПСтруктурнойЕдиницы(СтруктурнаяЕдиница, ДатаСведений)
	
	Перем ТерриториальныеУсловияПФРПСтруктурнойЕдиницы;
	
	ТерриториальныеУсловияПФРПСтруктурнойЕдиницы = Неопределено;
	
	Запрос = Новый запрос;
	Запрос.МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
	
	Запрос.УстановитьПараметр(""ДатаСведений"", ДатаСведений);
	Запрос.УстановитьПараметр(""СтруктурнаяЕдиница"", СтруктурнаяЕдиница);
	
	Запрос.Текст =
		""ВЫБРАТЬ
		|	&ДатаСведений КАК Период,
		|	&СтруктурнаяЕдиница КАК СтруктурнаяЕдиница
		|ПОМЕСТИТЬ ВТИзмеренияДаты"";
		
	Запрос.Выполнить();
		
	ЗарплатаКадрыОбщиеНаборыДанных.СоздатьВТИмяРегистраСрезПоследних(
		""ТерриториальныеУсловияПФР"",
		Запрос.МенеджерВременныхТаблиц,
		Истина,
		ЗарплатаКадрыОбщиеНаборыДанных.ОписаниеФильтраДляСоздатьВТИмяРегистра(
			""ВТИзмеренияДаты"",
			""СтруктурнаяЕдиница""));
	
	Запрос.Текст =
		""ВЫБРАТЬ
		|	ТерриториальныеУсловия.ТерриториальныеУсловияПФР
		|ИЗ
		|	ВТТерриториальныеУсловияПФРСрезПоследних КАК ТерриториальныеУсловия"";
		
	РезультатЗапроса = Запрос.Выполнить();
	Если НЕ РезультатЗапроса.Пустой() Тогда
		
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		ТерриториальныеУсловияПФРПСтруктурнойЕдиницы = Выборка.ТерриториальныеУсловияПФР;
		
	КонецЕсли; 
	
	Возврат ТерриториальныеУсловияПФРПСтруктурнойЕдиницы;
	
КонецФункции

#Область Запросы

#Область ШаблонОписанияЗапроса
//Функция Запрос_<ЗапросИмя>(Запрос, ОбъектИДанные)
//
//  Объект = ОбъектИДанные.Объект;
//		
//	Запрос.УстановитьПараметр(""СсылкаНаОбъект"", Объект.Ссылка);
//	Запрос.УстановитьПараметр(<""ИмяПараметра"">,	<ЗначениеПараметра>);
//
//  <Алгоритм формирования запроса 1>
//  Запрос.Текст = Запрос_Текст(<""ИмяЗапроса"">, <""ИмяТекстаЗапроса"">)
//  
//  <Алгоритм формирования запроса 2>
//  ТекстЗапрос = """";
//  ТекстЗапрос = Запрос_Текст(<""ИмяЗапроса"">, <""ИмяТекстаЗапроса1"">, ТекстЗапроса)
//  ТекстЗапрос = Запрос_Текст(<""ИмяЗапроса"">, <""ИмяТекстаЗапроса2"">, ТекстЗапроса)
//  ...
//	Запрос.Текст = ТекстЗапроса;
//
//  Возврат Запрос;
//
//КонецФункции
//Функция Запрос_<ЗапросИмя>_Текст(ИмяТекстаЗапроса)
//	Запрос_Текст = """";
//
//	<Алгоритм_Формирования_Текста_Запроса>
//  Если ( <""ИмяТекстаЗапроса 1""> = ИмяТекстаЗапроса ) Тогда
//		Возврат
//		<""ТекстЗапроса 1"">;
//	КонецЕсли
//  Если ( <""ИмяТекстаЗапроса 2""> = ИмяТекстаЗапроса ) Тогда
//		Возврат
//		<""ТекстЗапроса 2"">;
//	КонецЕсли
//	...
//
//	Возврат Неопределено;
//	
//КонецФункции

#КонецОбласти //НаименованиеОбласти//

// Формирует запрос
//
// Параметры: 
//  ЗапросИмя    - имя запроса, если не указано - возвращается пустой запрос
//  ДанныеОбъекта - структура - параметры устанавливаемые в запросе
//  Запрос       - Запрос - запрос, который модифицируется, если значение не определено - создается новый запрос
//
// Возвращаемое значение:
//  Запрос
//
Функция Запрос_Создать(Знач Запрос, Знач ИмяЗапроса, Знач Параметры)
	
	Перем Запрос_Создать;
	
	Если ( Неопределено = Запрос ИЛИ Неопределено = ИмяЗапроса ИЛИ """" = ИмяЗапроса ) Тогда
		Возврат Неопределено
	КонецЕсли; 
	
	Код = ""Запрос_Создать = Запрос_"" + ИмяЗапроса + ""(Запрос, Параметры)"";
	Выполнить(Код);
	
	Возврат Запрос_Создать;
	
КонецФункции
Функция Запрос_Выполнить(Знач Запрос, Знач ИмяЗапроса, Знач Параметры)
	
	Перем Запрос_Выполнить; // Возвращаемое значение
	
	Запрос            = Запрос_Создать(Новый Запрос, ИмяЗапроса, Параметры);
	Запрос_Выполнить  = ?(Неопределено = Запрос, Неопределено, Запрос.Выполнить());
	
	Возврат Запрос_Выполнить;
	
КонецФункции
Функция Запрос_Текст(Знач ИмяЗапроса, Знач ИмяТекстаЗапроса = Неопределено, Знач ТекстЗапроса = Неопределено)
	
	Перем Запрос_Текст; // Возвращаемое значение
	Перем Результат;
	
	Код = "" Результат = Запрос_"" + ИмяЗапроса + ""_Текст(ИмяТекстаЗапроса)"";
	Выполнить(Код);
	
	Если ( Неопределено = ТекстЗапроса ИЛИ Тип(""Строка"") <> ТипЗнч(ТекстЗапроса) ИЛИ """" = ТекстЗапроса ) Тогда
		Запрос_Текст = Результат;
	Иначе
		Запрос_Текст = ТекстЗапроса + ""
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|"" + Результат;
	КонецЕсли; 
	
	Возврат Запрос_Текст;
	
КонецФункции // Запрос_Текст

// Функция - формирование запроса на получение данных по объекту
// Параметры:
//  Запрос			 - Запрос	 - Формируемый запрос
//  ДанныеОбъекта	 - Структура - Структура данныз
// 
// Возвращаемое значение:
//   - подготовленный запрос Запрос
//
Функция Запрос_Объект(Знач Запрос, Знач Параметры)
	
	Запрос.УстановитьПараметр(""Ссылка"", Параметры.Ссылка);
	Запрос.Текст = Запрос_Текст(""Объект"");
	
	Возврат Запрос;
	
КонецФункции
// Функция - Запрос объект текст
//
// Параметры:
//  ЗапросТекстИмя	 - 	 - 
// 
// Возвращаемое значение:
//   - 
//
Функция Запрос_Объект_Текст(Знач ИмяТекстаЗапроса)
	
	Возврат	
	""ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Документ_ПриемНаРаботу.Ссылка КАК Ссылка,
	|	Документ_ПриемНаРаботу.Номер КАК Номер,
	|	Документ_ПриемНаРаботу.Дата КАК Дата,
	|	Документ_ПриемНаРаботу.Организация КАК Организация,
	|	Документ_ПриемНаРаботу.Сотрудник КАК Сотрудник,
	|	Документ_ПриемНаРаботу.Должность КАК Должность,
	|	Документ_ПриемНаРаботу.Должность.Наименование КАК ДолжностьНаименование,
	|	Документ_ПриемНаРаботу.Подразделение КАК Подразделение,
	|	Документ_ПриемНаРаботу.Подразделение.Наименование КАК ПодразделениеНаименование,
	|	Документ_ПриемНаРаботу.Территория КАК Территория,
	|	Документ_ПриемНаРаботу.Руководитель КАК Руководитель,
	|	Документ_ПриемНаРаботу.ДолжностьРуководителя КАК ДолжностьРуководителя,
	|	Документ_ПриемНаРаботу.ОснованиеПредставителяНанимателя КАК ОснованиеПредставителяНанимателя,
	|	Документ_ПриемНаРаботу.ДлительностьИспытательногоСрока КАК ДлительностьИспытательногоСрока,
	|	Документ_ПриемНаРаботу.ТрудовойДоговорНомер КАК ТрудовойДоговорНомер,
	|	Документ_ПриемНаРаботу.ТрудовойДоговорДата КАК ТрудовойДоговорДата,
	|	Документ_ПриемНаРаботу.ВидЗанятости КАК ВидЗанятости,
	|	Документ_ПриемНаРаботу.ДатаПриема КАК ДатаПриема,
	|	Документ_ПриемНаРаботу.ГрафикРаботы.СпособЗаполнения = ЗНАЧЕНИЕ(Перечисление.СпособыЗаполненияГрафикаРаботы.ПоЦикламПроизвольнойДлины) КАК ВахтовыйМетодРаботы
	|ИЗ
	|	Документ.ПриемНаРаботу КАК Документ_ПриемНаРаботу
	|ГДЕ
	|	Документ_ПриемНаРаботу.Ссылка = &Ссылка"";
	
КонецФункции

Функция Запрос_РасчетныйСчет(Знач Запрос, Знач Параметры)
	
	Запрос.УстановитьПараметр(""Ссылка"", Параметры.Ссылка);
	Запрос.Текст = Запрос_Текст(""РасчетныйСчет"");
	
	Возврат Запрос;
	
КонецФункции
Функция Запрос_РасчетныйСчет_Текст(Знач ИмяТекстаЗапроса)
	
	Возврат	
	""ВЫБРАТЬ ПЕРВЫЕ 1
	|	ЗарплатныеПроекты.Банк.Наименование КАК БанкНаименование,
	|	ЗарплатныеПроекты.Банк.КоррСчет КАК БанкКорреспондентскийСчет,
	|	ЗарплатныеПроекты.Банк.Город КАК БанкГород,
	|	ЗарплатныеПроекты.Банк.Код КАК БанкБИК,
	|	ЗарплатныеПроекты.РасчетныйСчет КАК Номер
	|ИЗ
	|	Справочник.ЗарплатныеПроекты КАК ЗарплатныеПроекты"";
	
КонецФункции

#КонецОбласти //Запросы//

#КонецОбласти
#Область class_ОплатаТруда

// public
Функция ОплатаТруда_ФорматОсновнойПоказатель(Знач ОсновнойПоказатель)

	Перем ФорматОсновнойПоказатель;                                                   

	ФорматОсновнойПоказатель = """";
	
	Если (Справочники.ПоказателиРасчетаЗарплаты.Оклад = ОсновнойПоказатель) Тогда
		ФорматОсновнойПоказатель = ""должностного оклада"";
	ИначеЕсли (Справочники.ПоказателиРасчетаЗарплаты.ТарифнаяСтавкаЧасовая = ОсновнойПоказатель) Тогда
		ФорматОсновнойПоказатель = ""часовой тарифной ставки"";
	Иначе
		ВызватьИсключение ""Недопустимое значение основного показателя """""" + ОсновнойПоказатель + """""" у выбранного сотрудника."";
	КонецЕсли;
	
	Возврат ФорматОсновнойПоказатель;
	
КонецФункции // ОплатаТруда_ФорматОсновнойПоказатель()
 
// protected
Функция ОплатаТруда(Знач ОплатаТруда)
	
	ОплатаТруда.Вставить(""Вид"");
	ОплатаТруда.Вставить(""ОкладСтавка"");
	ОплатаТруда.Вставить(""СтавкаНДФЛ"");
	ОплатаТруда.Вставить(""РайонныйКоэффициент"");
	ОплатаТруда.Вставить(""ПроцентСевернойНадбавки"");
	ОплатаТруда.Вставить(""ОсновнойПоказатель"");
	
	Возврат ОплатаТруда;
	
КонецФункции
Функция ОплатаТруда_Include()
	
	Перем ОплатаТруда_Include; // Возвращаемое значение
	
	ООП_ЗарегистрироватьКласс(""ОплатаТруда"", ""Структура"");		
	
	Возврат ОплатаТруда_Include;
	
КонецФункции // ОплатаТруда_Include

#КонецОбласти //class_ОплатаТруда//
#Область class_УсловияТрудаНаРабочемМесте
// public
Функция УсловияТрудаНаРабочемМесте_Представление(Знач this)
	
	Перем Представление;
	
	УсловияТрудаНаРабочемМестеПредставления = Новый Соответствие();
	УсловияТрудаНаРабочемМестеПредставления.Вставить(Перечисления.КлассыУсловийТрудаПоРезультатамСпециальнойОценки.ПустаяСсылка(), ""в нормальных условиях"");
	УсловияТрудаНаРабочемМестеПредставления.Вставить(Перечисления.КлассыУсловийТрудаПоРезультатамСпециальнойОценки.Вредный3, ""во вредных условиях труда (3 класс)"");
	 
	Представление = УсловияТрудаНаРабочемМестеПредставления.Получить(this.Вид);
	
	Возврат Представление;
	
КонецФункции

// protected
Функция УсловияТрудаНаРабочемМесте(Знач УсловияТрудаНаРабочемМесте)
	
	УсловияТрудаНаРабочемМесте.Вставить(""Вид"", Перечисления.КлассыУсловийТрудаПоРезультатамСпециальнойОценки.ПустаяСсылка());
	
	Возврат УсловияТрудаНаРабочемМесте;
	
КонецФункции
Функция УсловияТрудаНаРабочемМесте_Include()
	
	Перем УсловияТрудаНаРабочемМесте_Include; // Возвращаемое значение
	
	ООП_ЗарегистрироватьКласс(""УсловияТрудаНаРабочемМесте"", ""Структура"");		
	
	Возврат УсловияТрудаНаРабочемМесте_Include;
	
КонецФункции // УсловияТрудаНаРабочемМесте_Include

#КонецОбласти //class_УсловияТрудаНаРабочемМесте//
#Область class_ПФ_MXL_ТрудовойДоговор

// public
Процедура ПФ_MXL_ТрудовойДоговор_ВТабличныйДокумент(ЗначенияПараметровМакета, Знач Макет, Знач ОписанияОбластей, Знач ПечатнаяФорма) Экспорт
	
	
	Макет_Макет_ВТабличныйДокументПрисоединитьОбластьИЗаполнитьПараметры(ЗначенияПараметровМакета, Макет, ОписанияОбластей[""Договор""], ПечатнаяФорма);
	
КонецПроцедуры                   
Функция ПФ_MXL_ТрудовойДоговор_ЗначенияПараметров(Знач Макет, Знач Данные) Экспорт
	
	Перем ПФ_MXL_ТрудовойДоговор_ЗначенияПараметров; // Возвращаемое значение
	
	Перем ЗначенияПараметров;
	Перем ЗначенияПараметровСпецификации, ЗначенияПараметровСтрокиСпецификации;
	Перем ЗначенияПараметровКомиссии, ЗначенияПараметровЧленаКомиссии;
	
	Перем Организация, Руководитель, Сотрудник, Приказ;
	
	ЗначенияПараметров = Новый Структура;
	Договор = Данные;
	Организация = Договор.Организация;
	Сотрудник = Договор.Сотрудник;
	УсловияТрудаНаРабочемМесте = Договор.УсловияТрудаНаРабочемМесте;
	ОплатаТруда = Договор.ОплатаТруда;
	Руководитель = Организация.ОтветственныеЛица[""Руководитель""];
	РасчетныйСчет = Организация.РасчетныйСчет;
	Банк = РасчетныйСчет.Банк;

	#Область Договор
	ЗначенияПараметров.Вставить(""Договор_ДатаЛокальныйФормат"", ?(ЗначениеЗаполнено(Договор.ДатаТрудовогоДоговора), Формат(Договор.ДатаТрудовогоДоговора, ""ДЛФ=DD""), """"));
	
	ЗначенияПараметров.Вставить(""Договор_ДатаНачалаЛокальныйФормат"", """");
	Если (ЗначениеЗаполнено(Договор.ДатаПриема)) Тогда
		
		ЗначенияПараметров.Договор_ДатаНачалаЛокальныйФормат = Формат(Договор.ДатаПриема, ""ДЛФ=DD"");
		Если (Договор.ДатаТрудовогоДоговора = NULL) Тогда
			ЗначенияПараметров.Договор_ДатаЛокальныйФормат = ЗначенияПараметров.Договор_ДатаНачалаЛокальныйФормат;
		КонецЕсли;
		
	Иначе
		ЗначенияПараметров.Договор_ДатаНачала = ЗначенияПараметров.Договор_Дата;
	КонецЕсли;
	
	Договор_ДлительностьИспытательногоСрока = """";
	ДлительностьИспытательногоСрокаМесяцы = Цел(Договор.ДлительностьИспытательногоСрока);
	ДлительностьИспытательногоСрокаНедели = Цел(4*(Договор.ДлительностьИспытательногоСрока - Цел(Договор.ДлительностьИспытательногоСрока)));
	
	ДлительностьИспытательногоСрокаМесяцыСтрокой = ?(0 = ДлительностьИспытательногоСрокаМесяцы, """", СтрокаСЧислом("";%1 месяц;;%1 месяца;%1 месяцев;%1 месяца"", ДлительностьИспытательногоСрокаМесяцы, ВидЧисловогоЗначения.Количественное, ""L=ru""));
	ДлительностьИспытательногоСрокаНеделиСтрокой = ?(0 = ДлительностьИспытательногоСрокаНедели, """", СтрокаСЧислом("";%1 неделя;;%1 недели;%1 недель;%1 недели"", ДлительностьИспытательногоСрокаНедели, ВидЧисловогоЗначения.Количественное, ""L=ru""));
	ДлительностьИспытательногоСрокаРазделитель = ?(0 = ДлительностьИспытательногоСрокаМесяцы ИЛИ 0 = ДлительностьИспытательногоСрокаНедели, """", "" "");
	
	Договор_ДлительностьИспытательногоСрока = """"
	+ ДлительностьИспытательногоСрокаМесяцыСтрокой
	+ ДлительностьИспытательногоСрокаРазделитель
	+ ДлительностьИспытательногоСрокаНеделиСтрокой
	+ """";
	
	ЗначенияПараметров.Вставить(""Договор_ДлительностьИспытательногоСрока"", Договор_ДлительностьИспытательногоСрока);
	ЗначенияПараметров.Вставить(""Договор_ДатаОкончанияЛокальныйФормат"", Формат(Договор.ДатаОкончания, ""ДЛФ=DD""));

	ЗначенияПараметров.Вставить(""Договор_Номер"", Договор.НомерТрудовогоДоговора);
	ЗначенияПараметров.Вставить(""Договор_ВидЗанятости"", ПФ_MXL_ТрудовойДоговор_ФорматВидЗанятости(Договор.ВидЗанятости));
	ЗначенияПараметров.Вставить(""Договор_МестоВыполненияРабот"", ПФ_MXL_ТрудовойДоговор_ФорматТерриториальныеУсловия(Договор.ТерриториальныеУсловия));
	
	#КонецОбласти
	#Область Организация
	
	ЗначенияПараметров.Вставить(""Организация_АдресЮридический"", Организация.Адреса[""Юридический""]);
	ЗначенияПараметров.Вставить(""Организация_ОГРН"", Организация.ОГРН);
	ЗначенияПараметров.Вставить(""Организация_ИНН"", Организация.ИНН);
	ЗначенияПараметров.Вставить(""Организация_КПП"", Организация.КПП);
	ЗначенияПараметров.Вставить(""Организация_НаименованиеКраткое"", Стандартные_ЮрФизЛицо_Наименование(Организация, ""Краткое""));
	ЗначенияПараметров.Вставить(""Организация_НаименованиеСокращенное"", Стандартные_ЮрФизЛицо_Наименование(Организация, ""Краткое""));
	ЗначенияПараметров.Вставить(""Организация_НаименованиеПолное"", Стандартные_ЮрФизЛицо_Наименование(Организация, ""Полное""));
	ЗначенияПараметров.Вставить(""Организация_Телефон"", Организация.Телефон);
	
	#КонецОбласти
	#Область Банк
	ЗначенияПараметров.Вставить(""Банк_Наименование"", Банк.Наименование);
	ЗначенияПараметров.Вставить(""Банк_Город"", Банк.Город);
	ЗначенияПараметров.Вставить(""Банк_КорреспондентскийСчет"", Банк.КорреспондентскийСчет);
	ЗначенияПараметров.Вставить(""Банк_БИК"", Банк.БИК);
	#КонецОбласти
	#Область Руководитель
	
	ЗначенияПараметров.Вставить(""Руководитель_Должность_Наименование"", Стандартные_Должность_Представление(Руководитель.Должность));
	ЗначенияПараметров.Вставить(""Руководитель_Должность_НаименованиеРодительныйПадеж"", Стандартные_Должность_Склонение(Руководитель.Должность, 2, Руководитель.Должность.Ссылка));
	ЗначенияПараметров.Вставить(""Руководитель_ОснованиеРодительныйПадеж"", ?(ЗначениеЗаполнено(Руководитель.Основание), Руководитель.Основание, ""Устава""));
	ЗначенияПараметров.Вставить(""Руководитель_ФИО_ФамилияИмяОтчествоРодительныйПадеж"", Стандартные_ФИО_Склонение(Руководитель.ФИО, 2, Руководитель.Ссылка, Руководитель.Пол));
	ЗначенияПараметров.Вставить(""Руководитель_ФИО_ФамилияИО"", Стандартные_ФИО_ФамилияИО(Руководитель.ФИО));
	
	#КонецОбласти 
	#Область Сотрудник
	
	ЗначенияПараметров.Вставить(""Сотрудник_АдресРегистрации"", Сотрудник.АдресРегистрации);
	ЗначенияПараметров.Вставить(""Сотрудник_ДатаРождения"", Сотрудник.ДатаРождения);
	//ЗначенияПараметров.Вставить(""Сотрудник_Должность_Наименование"", Стандартные_Должность_Наименование(Сотрудник.Должность));
	ЗначенияПараметров.Вставить(""Сотрудник_Должность_НаименованиеРодительныйПадеж"", НРег(Стандартные_Должность_Склонение(Сотрудник.Должность, 2, Сотрудник.Должность.Ссылка)));
	ЗначенияПараметров.Вставить(""Сотрудник_Должность_НаименованиеТворительныйПадеж"", НРег(Стандартные_Должность_Склонение(Сотрудник.Должность, 5, Сотрудник.Должность.Ссылка)));
	ЗначенияПараметров.Вставить(""Сотрудник_ИНН"", Сотрудник.ИНН);
	
	Сотрудник_Подразделение_Наименование = НРег(Стандартные_Подразделение_Наименование(Сотрудник.Подразделение));
	Если (НЕ Сотрудник.ТерриторияВыполненияРабот.Пустая()) Тогда
		ТерриторияВыполненияРаботНаименование = УправлениеСвойствами.ЗначениеСвойства(Сотрудник.ТерриторияВыполненияРабот, ""НаименованиеРодительныйПадеж"");
		Сотрудник_Подразделение_Наименование = Сотрудник_Подразделение_Наименование + ?(ПустаяСтрока(ТерриторияВыполненияРаботНаименование), """", "" "" + ТерриторияВыполненияРаботНаименование);
	КонецЕсли;
	
	ЗначенияПараметров.Вставить(""Сотрудник_Подразделение_Наименование"", Сотрудник_Подразделение_Наименование);
	
	ЗначенияПараметров.Вставить(""Сотрудник_СНИЛС"", Сотрудник.СНИЛС);
	ЗначенияПараметров.Вставить(""Сотрудник_УдостоверениеЛичности_Представление"", Стандартные_ДокументУдостоверяющийЛичность_Представление(Сотрудник.УдостоверениеЛичности));
	ЗначенияПараметров.Вставить(""Сотрудник_УдостоверениеЛичности_ДатаВыдачи"", Формат(Сотрудник.УдостоверениеЛичности.ДатаВыдачи, ""ДФ=dd.MM.yyyy""));
	ЗначенияПараметров.Вставить(""Сотрудник_УдостоверениеЛичности_КемВыдано"", Сотрудник.УдостоверениеЛичности.КемВыдан);
	ЗначенияПараметров.Вставить(""Сотрудник_УдостоверениеЛичности_КодПодразделения"", Сотрудник.УдостоверениеЛичности.КодПодразделения);
	ЗначенияПараметров.Вставить(""Сотрудник_УдостоверениеЛичности_Номер"", Сотрудник.УдостоверениеЛичности.Номер);
	ЗначенияПараметров.Вставить(""Сотрудник_УдостоверениеЛичности_Серия"", Сотрудник.УдостоверениеЛичности.Серия);
	ЗначенияПараметров.Вставить(""Сотрудник_ФИО_ФамилияИмяОтчество"", Стандартные_ФИО_ФамилияИмяОтчество(Сотрудник.ФИО));
	ЗначенияПараметров.Вставить(""Сотрудник_ФИО_ФамилияИО"", Стандартные_ФИО_ФамилияИО(Сотрудник.ФИО));
	
	#КонецОбласти
	#Область ОплатаТруда
	
	ЗначенияПараметров.Вставить(""ОплатаТруда_ОкладСтавка"", ОплатаТруда.ОкладСтавка);
	ЗначенияПараметров.Вставить(""ОплатаТруда_НДФЛ"", ОплатаТруда.СтавкаНДФЛ);
	ЗначенияПараметров.Вставить(""ОплатаТруда_Вид"", ОплатаТруда_ФорматОсновнойПоказатель(ОплатаТруда.ОсновнойПоказатель));
	ЗначенияПараметров.Вставить(""ОплатаТруда_РайонныйКоэффициент"", ОплатаТруда.РайонныйКоэффициент);
	//ЗначенияПараметров.Вставить(""ОплатаТруда_ПроцентСевернойНадбавки"", Формат(ОплатаТруда.ПроцентСевернойНадбавки, ""ЧН=0; ЧГ=""));
	
	#КонецОбласти	
	#Область УсловияТрудаНаРабочемМесте
	
	ЗначенияПараметров.Вставить(""УсловияТрудаНаРабочемМесте_Вид"", УсловияТрудаНаРабочемМесте_Представление(УсловияТрудаНаРабочемМесте));
	
	#КонецОбласти
	#Область Приказы
	
	ЗначенияПараметров.Вставить(""ПриказВнутреннегоТрудовогоРаспорядка_Номер"", 3);
	ЗначенияПараметров.Вставить(""ПриказВнутреннегоТрудовогоРаспорядка_Дата"", Формат('20170901', ""ДФ=dd.MM.yyyy""));
	ЗначенияПараметров.Вставить(""ПриказПоложениеОбОплатеТрудаИМатСтимулировании_Номер"", 3);
	ЗначенияПараметров.Вставить(""ПриказПоложениеОбОплатеТрудаИМатСтимулировании_Дата"", Формат('20170901', ""ДФ=dd.MM.yyyy""));
	ЗначенияПараметров.Вставить(""ПриказПоложениеОХраненииИИспользованииПерсональныхДанных_Номер"", 3);
	ЗначенияПараметров.Вставить(""ПриказПоложениеОХраненииИИспользованииПерсональныхДанных_Дата"", Формат('20170901', ""ДФ=dd.MM.yyyy""));
	ЗначенияПараметров.Вставить(""ПриказПоложениеОВахтовомМетодеОрганизацииРабот_Номер"", 3);
	ЗначенияПараметров.Вставить(""ПриказПоложениеОВахтовомМетодеОрганизацииРабот_Дата"", Формат('20170901', ""ДФ=dd.MM.yyyy""));
	ЗначенияПараметров.Вставить(""ПриказПоложениеОСлужебныхКомандировках_Номер"", 3);
	ЗначенияПараметров.Вставить(""ПриказПоложениеОСлужебныхКомандировках_Дата"", Формат('20170901', ""ДФ=dd.MM.yyyy""));
	
	#КонецОбласти
	
	ПФ_MXL_ТрудовойДоговор_ЗначенияПараметров = ЗначенияПараметров;       
	
	Возврат ПФ_MXL_ТрудовойДоговор_ЗначенияПараметров;                  
	
КонецФункции                                                                                        
Функция ПФ_MXL_ТрудовойДоговор_ОписаниеОбластей(Знач this) Экспорт
	
	Перем ПФ_MXL_ТрудовойДоговор_ОписаниеОбластей;
	
	ПФ_MXL_ТрудовойДоговор_ОписаниеОбластей = Новый Структура;

	#Область ПФ_MXL_ТрудовойДоговор_Области
	
	#Область ПФ_MXL_ТрудовойДоговор_Область_Договор
	//TODO: Для макетов MXL предусмотреть получение параметров области непосредственно из макета. Получать области и сохранять в описании областей
	
	ИмяОбласти        = ""Договор"";
	ТипОбласти        = ""Общая"";
	
	ПараметрыОбласти  = Новый Массив;
	
	#Область Договор
	
	ПараметрыОбласти.Добавить(""Договор_ДатаЛокальныйФормат"");
	ПараметрыОбласти.Добавить(""Договор_ДатаНачалаЛокальныйФормат"");
	ПараметрыОбласти.Добавить(""Договор_ДатаОкончанияЛокальныйФормат"");
	ПараметрыОбласти.Добавить(""Договор_ДлительностьИспытательногоСрока"");
	ПараметрыОбласти.Добавить(""Договор_Номер"");
	ПараметрыОбласти.Добавить(""Договор_ВидЗанятости"");
	ПараметрыОбласти.Добавить(""Договор_МестоВыполненияРабот"");
	
	
	#КонецОбласти
	#Область Организация
	
	ПараметрыОбласти.Добавить(""Организация_АдресЮридический"");
	ПараметрыОбласти.Добавить(""Организация_ОГРН"");
	ПараметрыОбласти.Добавить(""Организация_ИНН"");
	ПараметрыОбласти.Добавить(""Организация_КПП"");
	ПараметрыОбласти.Добавить(""Организация_НаименованиеКраткое"");
	ПараметрыОбласти.Добавить(""Организация_НаименованиеСокращенное"");
	ПараметрыОбласти.Добавить(""Организация_НаименованиеПолное"");
	ПараметрыОбласти.Добавить(""Организация_Телефон"");
	
	#КонецОбласти
	#Область Руководитель
	
	ПараметрыОбласти.Добавить(""Руководитель_Должность_Наименование"");
	ПараметрыОбласти.Добавить(""Руководитель_Должность_НаименованиеРодительныйПадеж"");
	ПараметрыОбласти.Добавить(""Руководитель_ОснованиеРодительныйПадеж"");
	ПараметрыОбласти.Добавить(""Руководитель_ФИО_ФамилияИмяОтчествоРодительныйПадеж"");
	ПараметрыОбласти.Добавить(""Руководитель_ФИО_ФамилияИО"");
	
	#КонецОбласти 
	#Область Сотрудник
	
	ПараметрыОбласти.Добавить(""Сотрудник_АдресРегистрации"");
	ПараметрыОбласти.Добавить(""Сотрудник_ДатаРождения"");
	ПараметрыОбласти.Добавить(""Сотрудник_ГрафикРаботы"");
	//ПараметрыОбласти.Добавить(""Сотрудник_Должность_Наименование"");
	ПараметрыОбласти.Добавить(""Сотрудник_Должность_НаименованиеРодительныйПадеж"");
	ПараметрыОбласти.Добавить(""Сотрудник_Должность_НаименованиеТворительныйПадеж"");
	ПараметрыОбласти.Добавить(""Сотрудник_ИНН"");
	ПараметрыОбласти.Добавить(""Сотрудник_Подразделение_Наименование"");
	ПараметрыОбласти.Добавить(""Сотрудник_СНИЛС"");
	ПараметрыОбласти.Добавить(""Сотрудник_УдостоверениеЛичности_Представление"");
	ПараметрыОбласти.Добавить(""Сотрудник_УдостоверениеЛичности_ДатаВыдачи"");
	ПараметрыОбласти.Добавить(""Сотрудник_УдостоверениеЛичности_КемВыдано"");
	ПараметрыОбласти.Добавить(""Сотрудник_УдостоверениеЛичности_КодПодразделения"");
	ПараметрыОбласти.Добавить(""Сотрудник_УдостоверениеЛичности_Номер"");
	ПараметрыОбласти.Добавить(""Сотрудник_УдостоверениеЛичности_Серия"");
	ПараметрыОбласти.Добавить(""Сотрудник_ФИО_ФамилияИмяОтчество"");
	ПараметрыОбласти.Добавить(""Сотрудник_ФИО_ФамилияИО"");
	
	#КонецОбласти
	#Область ОплатаТруда
	
	ПараметрыОбласти.Добавить(""ОплатаТруда_Вид"");
	ПараметрыОбласти.Добавить(""ОплатаТруда_ОкладСтавка"");
	ПараметрыОбласти.Добавить(""ОплатаТруда_РайонныйКоэффициент"");
	ПараметрыОбласти.Добавить(""ОплатаТруда_Форма"");
	ПараметрыОбласти.Добавить(""ОплатаТруда_НДФЛ"");
	
//	ПараметрыОбласти.Добавить(""ОплатаТруда_ПроцентСевернойНадбавки"");

	#КонецОбласти	
	#Область УсловияТрудаНаРабочемМесте

	ПараметрыОбласти.Добавить(""УсловияТрудаНаРабочемМесте_Вид"");

	#КонецОбласти	
	#Область Банк
	
	ПараметрыОбласти.Добавить(""Банк_Наименование"");
	ПараметрыОбласти.Добавить(""Банк_Город"");
	ПараметрыОбласти.Добавить(""Банк_КорреспондентскийСчет"");
	ПараметрыОбласти.Добавить(""Банк_БИК"");
	
	#КонецОбласти
	#Область Приказы
	
	ПараметрыОбласти.Добавить(""ПриказВнутреннегоТрудовогоРаспорядка_Номер"");
	ПараметрыОбласти.Добавить(""ПриказВнутреннегоТрудовогоРаспорядка_Дата"");
	ПараметрыОбласти.Добавить(""ПриказПоложениеОбОплатеТрудаИМатСтимулировании_Номер"");
	ПараметрыОбласти.Добавить(""ПриказПоложениеОбОплатеТрудаИМатСтимулировании_Дата"");
	ПараметрыОбласти.Добавить(""ПриказПоложениеОХраненииИИспользованииПерсональныхДанных_Номер"");
	ПараметрыОбласти.Добавить(""ПриказПоложениеОХраненииИИспользованииПерсональныхДанных_Дата"");
	ПараметрыОбласти.Добавить(""ПриказПоложениеОВахтовомМетодеОрганизацииРабот_Номер"");
	ПараметрыОбласти.Добавить(""ПриказПоложениеОВахтовомМетодеОрганизацииРабот_Дата"");
	ПараметрыОбласти.Добавить(""ПриказПоложениеОСлужебныхКомандировках_Номер"");
	ПараметрыОбласти.Добавить(""ПриказПоложениеОСлужебныхКомандировках_Дата"");
		
	#КонецОбласти 
	Макет_Макет_ДобавитьОписаниеОбласти(ПФ_MXL_ТрудовойДоговор_ОписаниеОбластей, ИмяОбласти, ТипОбласти, ПараметрыОбласти);
	
	ПараметрыОбласти = Неопределено;
	
	#КонецОбласти
	
	#КонецОбласти
	
	Возврат ПФ_MXL_ТрудовойДоговор_ОписаниеОбластей;
	
КонецФункции 
Функция ПФ_MXL_ТрудовойДоговор(Знач this) Экспорт
	
	ООП_parent(this);
		
	this.Имя      = ""ПФ_MXL_ТрудовойДоговор"";
	this.Тип      = ""MXL"";
	this.Области  = ПФ_MXL_ТрудовойДоговор_ОписаниеОбластей(this);
	
	Возврат this;
	
КонецФункции //ПФ_MXL_ТрудовойДоговор

// private
Функция ПФ_MXL_ТрудовойДоговор_Include()
	
	ООП_Include(""Макет.Макет"");
	
	ООП_ЗарегистрироватьКласс(""ПФ_MXL_ТрудовойДоговор"", ""Структура"", ""Макет.Макет"");
	
КонецФункции
Функция ПФ_MXL_ТрудовойДоговор_ФорматВидЗанятости(Знач ВидЗанятости)

	Перем ФорматВидЗанятости;
	
	ФорматВидЗанятости = """";
	
	Если (Перечисления.ВидыЗанятости.ОсновноеМестоРаботы = ВидЗанятости) Тогда
		ФорматВидЗанятости = ""основной работой"";
	ИначеЕсли (Перечисления.ВидыЗанятости.ВнутреннееСовместительство = ВидЗанятости) Тогда
		ФорматВидЗанятости = ""работой по внутреннему совместительству"";
	ИначеЕсли (Перечисления.ВидыЗанятости.Совместительство = ВидЗанятости) Тогда
		ФорматВидЗанятости = ""работой по внешнему совместительству"";
	ИначеЕсли (Перечисления.ВидыЗанятости.Подработка = ВидЗанятости) Тогда
		ФорматВидЗанятости = ""подработкой"";
	Иначе
		ВызватьИсключение ""ВидЗанятости содержит недопустимое значение """""" + ВидЗанятости +""""""."";
	КонецЕсли;
	
	Возврат ФорматВидЗанятости;

КонецФункции
Функция ПФ_MXL_ТрудовойДоговор_ФорматТерриториальныеУсловия(Знач ТерриториальныеУсловия)

	Перем ФорматТерриториальныеУсловия; // Возвращаемое значение
	
	ФорматТерриториальныеУсловия = """";
	
	Если (Справочники.ТерриториальныеУсловияПФР.РКС = ТерриториальныеУсловия) Тогда
		ФорматТерриториальныеУсловия = ""относится к районам Крайнего Севера"";
	ИначеЕсли (Справочники.ТерриториальныеУсловияПФР.МКС = ТерриториальныеУсловия) Тогда 
		ФорматТерриториальныеУсловия = ""относится к местностям приравненным к районам Крайнего Севера"";	
	Иначе
		ФорматТерриториальныеУсловия = ""не относится к районам Крайнего Севера и местностям приравненным к районам Крайнего Севера"";
	КонецЕсли; 

	Возврат ФорматТерриториальныеУсловия;
 
КонецФункции
 
#КонецОбласти
#Область class_ПФ_MXL_ТрудовойДоговорИТРВахтаРКС

// public
Процедура ПФ_MXL_ТрудовойДоговорИТРВахтаРКС_ВТабличныйДокумент(ЗначенияПараметровМакета, Знач Макет, Знач ОписанияОбластей, Знач ПечатнаяФорма) Экспорт
	
	ПФ_MXL_ТрудовойДоговор_ВТабличныйДокумент(ЗначенияПараметровМакета, Макет, ОписанияОбластей, ПечатнаяФорма);
	
КонецПроцедуры                   
Функция ПФ_MXL_ТрудовойДоговорИТРВахтаРКС_ЗначенияПараметров(Знач Макет, Знач Данные) Экспорт
	
	Перем ПФ_MXL_ТрудовойДоговорИТРВахтаРКС_ЗначенияПараметров; // Возвращаемое значение
	
	Перем ЗначенияПараметров;
	
	ЗначенияПараметров = ПФ_MXL_ТрудовойДоговор_ЗначенияПараметров(Макет, Данные);
	//ЗначенияПараметров.Вставить(""Сотрудник_ГрафикРаботы"", Данные.Сотрудник.ГрафикРаботы);
	ЗначенияПараметров.Вставить(""Сотрудник_ГрафикРаботы"", ""вахтовый метод работы, продолжительность вахты составляет 2 месяца, продолжительность междувахтового отдыха составляет 1 месяц"");
	ЗначенияПараметров.Вставить(""ОплатаТруда_Форма"", ""повременно-премиальная форма оплаты труда"");

	ПФ_MXL_ТрудовойДоговорИТРВахтаРКС_ЗначенияПараметров = ЗначенияПараметров;       
	
	Возврат ПФ_MXL_ТрудовойДоговорИТРВахтаРКС_ЗначенияПараметров;                  
	
КонецФункции                                                                                        
Функция ПФ_MXL_ТрудовойДоговорИТРВахтаРКС_ОписаниеОбластей(Знач this) Экспорт
	
	Перем ПФ_MXL_ТрудовойДоговорИТРВахтаРКС_ОписаниеОбластей;
	
	ПФ_MXL_ТрудовойДоговорИТРВахтаРКС_ОписаниеОбластей = ПФ_MXL_ТрудовойДоговор_ОписаниеОбластей(this);

	#Область ПФ_MXL_ТрудовойДоговорИТРВахтаРКС_Области
	
	#КонецОбласти
	
	Возврат ПФ_MXL_ТрудовойДоговорИТРВахтаРКС_ОписаниеОбластей;
	
КонецФункции 
Функция ПФ_MXL_ТрудовойДоговорИТРВахтаРКС(Знач this) Экспорт
	
	Перем ПФ_MXL_ТрудовойДоговорИТРВахтаРКС;
	
	ООП_parent(this);
	
	this.Имя = ""ПФ_MXL_ТрудовойДоговорИТРВахтаРКС"";
	this.Тип = ""MXL"";
	this.Области = ПФ_MXL_ТрудовойДоговорИТРВахтаРКС_ОписаниеОбластей(this);
	
	ПФ_MXL_ТрудовойДоговорИТРВахтаРКС = this;
	
	Возврат ПФ_MXL_ТрудовойДоговорИТРВахтаРКС;
	
КонецФункции //ПФ_MXL_ТрудовойДоговорИТРВахтаРКС

// private
Функция ПФ_MXL_ТрудовойДоговорИТРВахтаРКС_Include()
	
	ООП_Include(""ПФ_MXL_ТрудовойДоговор"");
	
	ООП_ЗарегистрироватьКласс(""ПФ_MXL_ТрудовойДоговорИТРВахтаРКС"", ""Структура"", ""Макет.Макет"");
	
КонецФункции

#КонецОбласти
#Область class_ПФ_MXL_ТрудовойДоговорИТРОсновнойГрафикРКС

// public
Процедура ПФ_MXL_ТрудовойДоговорИТРОсновнойГрафикРКС_ВТабличныйДокумент(ЗначенияПараметровМакета, Знач Макет, Знач ОписанияОбластей, Знач ПечатнаяФорма) Экспорт
	
	ПФ_MXL_ТрудовойДоговор_ВТабличныйДокумент(ЗначенияПараметровМакета, Макет, ОписанияОбластей, ПечатнаяФорма);
	
КонецПроцедуры                   
Функция ПФ_MXL_ТрудовойДоговорИТРОсновнойГрафикРКС_ЗначенияПараметров(Знач Макет, Знач Данные) Экспорт
	
	Перем ПФ_MXL_ТрудовойДоговорИТРОсновнойГрафикРКС_ЗначенияПараметров; // Возвращаемое значение
	
	Перем ЗначенияПараметров;
	
	ЗначенияПараметров = ПФ_MXL_ТрудовойДоговор_ЗначенияПараметров(Макет, Данные);
	//ЗначенияПараметров.Вставить(""Сотрудник_ГрафикРаботы"", Данные.Сотрудник.ГрафикРаботы);
	ЗначенияПараметров.Вставить(""Сотрудник_ГрафикРаботы"", ""основной с 5-ти дневной рабочей неделей и 2-мя выходными днями – суббота, воскресенье"");
	ЗначенияПараметров.Вставить(""ОплатаТруда_Форма"", ""повременно-премиальная форма оплаты труда"");

	ПФ_MXL_ТрудовойДоговорИТРОсновнойГрафикРКС_ЗначенияПараметров = ЗначенияПараметров;       
	
	Возврат ПФ_MXL_ТрудовойДоговорИТРОсновнойГрафикРКС_ЗначенияПараметров;                  
	
КонецФункции                                                                                        
Функция ПФ_MXL_ТрудовойДоговорИТРОсновнойГрафикРКС_ОписаниеОбластей(Знач this) Экспорт
	
	Перем ПФ_MXL_ТрудовойДоговорИТРОсновнойГрафикРКС_ОписаниеОбластей;
	
	ПФ_MXL_ТрудовойДоговорИТРОсновнойГрафикРКС_ОписаниеОбластей = ПФ_MXL_ТрудовойДоговор_ОписаниеОбластей(this);

	#Область ПФ_MXL_ТрудовойДоговорИТРОсновнойГрафикРКС_Области
	
	#КонецОбласти
	
	Возврат ПФ_MXL_ТрудовойДоговорИТРОсновнойГрафикРКС_ОписаниеОбластей;
	
КонецФункции 
Функция ПФ_MXL_ТрудовойДоговорИТРОсновнойГрафикРКС(Знач this) Экспорт
	
	Перем ПФ_MXL_ТрудовойДоговорИТРОсновнойГрафикРКС;
	
	ООП_parent(this);
	
	this.Имя = ""ПФ_MXL_ТрудовойДоговорИТРОсновнойГрафикРКС"";
	this.Тип = ""MXL"";
	this.Области = ПФ_MXL_ТрудовойДоговорИТРОсновнойГрафикРКС_ОписаниеОбластей(this);
	
	ПФ_MXL_ТрудовойДоговорИТРОсновнойГрафикРКС = this;
	
	Возврат ПФ_MXL_ТрудовойДоговорИТРОсновнойГрафикРКС;
	
КонецФункции //ПФ_MXL_ТрудовойДоговорИТРОсновнойГрафикРКС

// private
Функция ПФ_MXL_ТрудовойДоговорИТРОсновнойГрафикРКС_Include()
	
	ООП_Include(""ПФ_MXL_ТрудовойДоговор"");
	
	ООП_ЗарегистрироватьКласс(""ПФ_MXL_ТрудовойДоговорИТРОсновнойГрафикРКС"", ""Структура"", ""Макет.Макет"");
	
КонецФункции

#КонецОбласти
#Область class_ПФ_MXL_ТрудовойДоговорИТРСовместительствоРКС

// public
Процедура ПФ_MXL_ТрудовойДоговорИТРСовместительствоРКС_ВТабличныйДокумент(ЗначенияПараметровМакета, Знач Макет, Знач ОписанияОбластей, Знач ПечатнаяФорма) Экспорт
	
	ПФ_MXL_ТрудовойДоговор_ВТабличныйДокумент(ЗначенияПараметровМакета, Макет, ОписанияОбластей, ПечатнаяФорма);
	
КонецПроцедуры                   
Функция ПФ_MXL_ТрудовойДоговорИТРСовместительствоРКС_ЗначенияПараметров(Знач Макет, Знач Данные) Экспорт
	
	Перем ПФ_MXL_ТрудовойДоговорИТРСовместительствоРКС_ЗначенияПараметров; // Возвращаемое значение
	
	Перем ЗначенияПараметров;
	
	ЗначенияПараметров = ПФ_MXL_ТрудовойДоговор_ЗначенияПараметров(Макет, Данные);
	//ЗначенияПараметров.Вставить(""Сотрудник_ГрафикРаботы"", Данные.Сотрудник.ГрафикРаботы);
	ЗначенияПараметров.Вставить(""Сотрудник_ГрафикРаботы"", ""основной с 5-ти дневной рабочей неделей и 2-мя выходными днями – суббота, воскресенье,""
	+ "" продолжительность рабочего времени – 20 часов в неделю/4 часа в день (для мужчин) и 18 часов в неделю/3 часа 35 минут для женщин. Начало работы 08 часов 30 минут"");
	ЗначенияПараметров.Вставить(""ОплатаТруда_Форма"", ""повременно-премиальная форма оплаты труда"");

	ПФ_MXL_ТрудовойДоговорИТРСовместительствоРКС_ЗначенияПараметров = ЗначенияПараметров;       
	
	Возврат ПФ_MXL_ТрудовойДоговорИТРСовместительствоРКС_ЗначенияПараметров;                  
	
КонецФункции                                                                                        
Функция ПФ_MXL_ТрудовойДоговорИТРСовместительствоРКС_ОписаниеОбластей(Знач this) Экспорт
	
	Перем ПФ_MXL_ТрудовойДоговорИТРСовместительствоРКС_ОписаниеОбластей;
	
	ПФ_MXL_ТрудовойДоговорИТРСовместительствоРКС_ОписаниеОбластей = ПФ_MXL_ТрудовойДоговор_ОписаниеОбластей(this);

	#Область ПФ_MXL_ТрудовойДоговорИТРСовместительствоРКС_Области
	
	#КонецОбласти
	
	Возврат ПФ_MXL_ТрудовойДоговорИТРСовместительствоРКС_ОписаниеОбластей;
	
КонецФункции 
Функция ПФ_MXL_ТрудовойДоговорИТРСовместительствоРКС(Знач this) Экспорт
	
	Перем ПФ_MXL_ТрудовойДоговорИТРСовместительствоРКС;
	
	ООП_parent(this);
	
	this.Имя = ""ПФ_MXL_ТрудовойДоговорИТРСовместительствоРКС"";
	this.Тип = ""MXL"";
	this.Области = ПФ_MXL_ТрудовойДоговорИТРСовместительствоРКС_ОписаниеОбластей(this);
	
	ПФ_MXL_ТрудовойДоговорИТРСовместительствоРКС = this;
	
	Возврат ПФ_MXL_ТрудовойДоговорИТРСовместительствоРКС;
	
КонецФункции //ПФ_MXL_ТрудовойДоговорИТРСовместительствоРКС

// private
Функция ПФ_MXL_ТрудовойДоговорИТРСовместительствоРКС_Include()
	
	ООП_Include(""ПФ_MXL_ТрудовойДоговор"");
	
	ООП_ЗарегистрироватьКласс(""ПФ_MXL_ТрудовойДоговорИТРСовместительствоРКС"", ""Структура"", ""Макет.Макет"");
	
КонецФункции

#КонецОбласти
#Область class_ПФ_MXL_ТрудовойДоговорРабочиеВахтаРКС

// public
Процедура ПФ_MXL_ТрудовойДоговорРабочиеВахтаРКС_ВТабличныйДокумент(ЗначенияПараметровМакета, Знач Макет, Знач ОписанияОбластей, Знач ПечатнаяФорма) Экспорт
	
	ПФ_MXL_ТрудовойДоговор_ВТабличныйДокумент(ЗначенияПараметровМакета, Макет, ОписанияОбластей, ПечатнаяФорма);
	
КонецПроцедуры                   
Функция ПФ_MXL_ТрудовойДоговорРабочиеВахтаРКС_ЗначенияПараметров(Знач Макет, Знач Данные) Экспорт
	
	Перем ПФ_MXL_ТрудовойДоговорРабочиеВахтаРКС_ЗначенияПараметров; // Возвращаемое значение
	
	Перем ЗначенияПараметров;
	
	ЗначенияПараметров = ПФ_MXL_ТрудовойДоговор_ЗначенияПараметров(Макет, Данные);
	//ЗначенияПараметров.Вставить(""Сотрудник_ГрафикРаботы"", Данные.Сотрудник.ГрафикРаботы);
	ЗначенияПараметров.Вставить(""Сотрудник_ГрафикРаботы"", ""вахтовый метод работы, продолжительность вахты составляет 2 месяца, продолжительность междувахтового отдыха составляет 1 месяц. Характер работы – разъездной"");
	ЗначенияПараметров.Вставить(""ОплатаТруда_Форма"", ""повременно-премиальная форма оплаты труда"");

	ПФ_MXL_ТрудовойДоговорРабочиеВахтаРКС_ЗначенияПараметров = ЗначенияПараметров;       
	
	Возврат ПФ_MXL_ТрудовойДоговорРабочиеВахтаРКС_ЗначенияПараметров;                  
	
КонецФункции                                                                                        
Функция ПФ_MXL_ТрудовойДоговорРабочиеВахтаРКС_ОписаниеОбластей(Знач this) Экспорт
	
	Перем ПФ_MXL_ТрудовойДоговорРабочиеВахтаРКС_ОписаниеОбластей;
	
	ПФ_MXL_ТрудовойДоговорРабочиеВахтаРКС_ОписаниеОбластей = ПФ_MXL_ТрудовойДоговор_ОписаниеОбластей(this);

	#Область ПФ_MXL_ТрудовойДоговорРабочиеВахтаРКС_Области
	
	#КонецОбласти
	
	Возврат ПФ_MXL_ТрудовойДоговорРабочиеВахтаРКС_ОписаниеОбластей;
	
КонецФункции 
Функция ПФ_MXL_ТрудовойДоговорРабочиеВахтаРКС(Знач this) Экспорт
	
	Перем ПФ_MXL_ТрудовойДоговорРабочиеВахтаРКС;
	
	ООП_parent(this);
	
	this.Имя = ""ПФ_MXL_ТрудовойДоговорРабочиеВахтаРКС"";
	this.Тип = ""MXL"";
	this.Области = ПФ_MXL_ТрудовойДоговорРабочиеВахтаРКС_ОписаниеОбластей(this);
	
	ПФ_MXL_ТрудовойДоговорРабочиеВахтаРКС = this;
	
	Возврат ПФ_MXL_ТрудовойДоговорРабочиеВахтаРКС;
	
КонецФункции //ПФ_MXL_ТрудовойДоговорРабочиеВахтаРКС

// private
Функция ПФ_MXL_ТрудовойДоговорРабочиеВахтаРКС_Include()
	
	ООП_Include(""ПФ_MXL_ТрудовойДоговор"");
	
	ООП_ЗарегистрироватьКласс(""ПФ_MXL_ТрудовойДоговорРабочиеВахтаРКС"", ""Структура"", ""Макет.Макет"");
	
КонецФункции

#КонецОбласти
#Область class_ПФ_MXL_ТрудовойДоговорРабочиеОсновнойГрафикРКС

// public
Процедура ПФ_MXL_ТрудовойДоговорРабочиеОсновнойГрафикРКС_ВТабличныйДокумент(ЗначенияПараметровМакета, Знач Макет, Знач ОписанияОбластей, Знач ПечатнаяФорма) Экспорт
	
	ПФ_MXL_ТрудовойДоговор_ВТабличныйДокумент(ЗначенияПараметровМакета, Макет, ОписанияОбластей, ПечатнаяФорма);
	
КонецПроцедуры                   
Функция ПФ_MXL_ТрудовойДоговорРабочиеОсновнойГрафикРКС_ЗначенияПараметров(Знач Макет, Знач Данные) Экспорт
	
	Перем ПФ_MXL_ТрудовойДоговорРабочиеОсновнойГрафикРКС_ЗначенияПараметров; // Возвращаемое значение
	
	Перем ЗначенияПараметров;
	
	ЗначенияПараметров = ПФ_MXL_ТрудовойДоговор_ЗначенияПараметров(Макет, Данные);
	//ЗначенияПараметров.Вставить(""Сотрудник_ГрафикРаботы"", Данные.Сотрудник.ГрафикРаботы);
	ЗначенияПараметров.Вставить(""Сотрудник_ГрафикРаботы"", ""основной с 5-ти дневной рабочей неделей и 2-мя выходными днями – суббота, воскресенье. Характер работы – разъездной"");
	ЗначенияПараметров.Вставить(""ОплатаТруда_Форма"", ""повременно-премиальная форма оплаты труда"");

	ПФ_MXL_ТрудовойДоговорРабочиеОсновнойГрафикРКС_ЗначенияПараметров = ЗначенияПараметров;       
	
	Возврат ПФ_MXL_ТрудовойДоговорРабочиеОсновнойГрафикРКС_ЗначенияПараметров;                  
	
КонецФункции                                                                                        
Функция ПФ_MXL_ТрудовойДоговорРабочиеОсновнойГрафикРКС_ОписаниеОбластей(Знач this) Экспорт
	
	Перем ПФ_MXL_ТрудовойДоговорРабочиеОсновнойГрафикРКС_ОписаниеОбластей;
	
	ПФ_MXL_ТрудовойДоговорРабочиеОсновнойГрафикРКС_ОписаниеОбластей = ПФ_MXL_ТрудовойДоговор_ОписаниеОбластей(this);

	#Область ПФ_MXL_ТрудовойДоговорРабочиеОсновнойГрафикРКС_Области
	
	#КонецОбласти
	
	Возврат ПФ_MXL_ТрудовойДоговорРабочиеОсновнойГрафикРКС_ОписаниеОбластей;
	
КонецФункции 
Функция ПФ_MXL_ТрудовойДоговорРабочиеОсновнойГрафикРКС(Знач this) Экспорт
	
	Перем ПФ_MXL_ТрудовойДоговорРабочиеОсновнойГрафикРКС;
	
	ООП_parent(this);
	
	this.Имя = ""ПФ_MXL_ТрудовойДоговорРабочиеОсновнойГрафикРКС"";
	this.Тип = ""MXL"";
	this.Области = ПФ_MXL_ТрудовойДоговорРабочиеОсновнойГрафикРКС_ОписаниеОбластей(this);
	
	ПФ_MXL_ТрудовойДоговорРабочиеОсновнойГрафикРКС = this;
	
	Возврат ПФ_MXL_ТрудовойДоговорРабочиеОсновнойГрафикРКС;
	
КонецФункции //ПФ_MXL_ТрудовойДоговорРабочиеОсновнойГрафикРКС

// private
Функция ПФ_MXL_ТрудовойДоговорРабочиеОсновнойГрафикРКС_Include()
	
	ООП_Include(""ПФ_MXL_ТрудовойДоговор"");
	
	ООП_ЗарегистрироватьКласс(""ПФ_MXL_ТрудовойДоговорРабочиеОсновнойГрафикРКС"", ""Структура"", ""Макет.Макет"");
	
КонецФункции

#КонецОбласти
#Область class_ПФ_MXL_ТрудовойДоговорСдельныеРасценки

// public
Процедура ПФ_MXL_ТрудовойДоговорСдельныеРасценки_ВТабличныйДокумент(ЗначенияПараметровМакета, Знач Макет, Знач ОписанияОбластей, Знач ПечатнаяФорма) Экспорт
	
	ПФ_MXL_ТрудовойДоговор_ВТабличныйДокумент(ЗначенияПараметровМакета, Макет, ОписанияОбластей, ПечатнаяФорма);
	
КонецПроцедуры                   
Функция ПФ_MXL_ТрудовойДоговорСдельныеРасценки_ЗначенияПараметров(Знач Макет, Знач Данные) Экспорт
	
	Перем ПФ_MXL_ТрудовойДоговорСдельныеРасценки_ЗначенияПараметров; // Возвращаемое значение
	
	Перем ЗначенияПараметров;
	
	ЗначенияПараметров = ПФ_MXL_ТрудовойДоговор_ЗначенияПараметров(Макет, Данные);
	//ЗначенияПараметров.Вставить(""Сотрудник_ГрафикРаботы"", Данные.Сотрудник.ГрафикРаботы);
	ЗначенияПараметров.Вставить(""Сотрудник_ГрафикРаботы"", ""вахтовый метод работы, продолжительность вахты составляет 2 месяца, продолжительность междувахтового отдыха составляет 1 месяц. Характер работы – разъездной"");
	ЗначенияПараметров.Вставить(""ОплатаТруда_Форма"", ""сдельно-повременная форма оплаты труда"");

	ПФ_MXL_ТрудовойДоговорСдельныеРасценки_ЗначенияПараметров = ЗначенияПараметров;       
	
	Возврат ПФ_MXL_ТрудовойДоговорСдельныеРасценки_ЗначенияПараметров;                  
	
КонецФункции                                                                                        
Функция ПФ_MXL_ТрудовойДоговорСдельныеРасценки_ОписаниеОбластей(Знач this) Экспорт
	
	Перем ПФ_MXL_ТрудовойДоговорСдельныеРасценки_ОписаниеОбластей;
	
	ПФ_MXL_ТрудовойДоговорСдельныеРасценки_ОписаниеОбластей = ПФ_MXL_ТрудовойДоговор_ОписаниеОбластей(this);

	#Область ПФ_MXL_ТрудовойДоговорСдельныеРасценки_Области
	
	#КонецОбласти
	
	Возврат ПФ_MXL_ТрудовойДоговорСдельныеРасценки_ОписаниеОбластей;
	
КонецФункции 
Функция ПФ_MXL_ТрудовойДоговорСдельныеРасценки(Знач this) Экспорт
	
	Перем ПФ_MXL_ТрудовойДоговорСдельныеРасценки;
	
	ООП_parent(this);
	
	this.Имя = ""ПФ_MXL_ТрудовойДоговорСдельныеРасценки"";
	this.Тип = ""MXL"";
	this.Области = ПФ_MXL_ТрудовойДоговорСдельныеРасценки_ОписаниеОбластей(this);
	
	ПФ_MXL_ТрудовойДоговорСдельныеРасценки = this;
	
	Возврат ПФ_MXL_ТрудовойДоговорСдельныеРасценки;
	
КонецФункции //ПФ_MXL_ТрудовойДоговорСдельныеРасценки

// private
Функция ПФ_MXL_ТрудовойДоговорСдельныеРасценки_Include()
	
	ООП_Include(""ПФ_MXL_ТрудовойДоговор"");
	
	ООП_ЗарегистрироватьКласс(""ПФ_MXL_ТрудовойДоговорСдельныеРасценки"", ""Структура"", ""Макет.Макет"");
	
КонецФункции

#КонецОбласти
#Область class_ПФ_MXL_ТрудовойДоговорВредники

// public
Процедура ПФ_MXL_ТрудовойДоговорВредники_ВТабличныйДокумент(ЗначенияПараметровМакета, Знач Макет, Знач ОписанияОбластей, Знач ПечатнаяФорма) Экспорт
	
	ПФ_MXL_ТрудовойДоговор_ВТабличныйДокумент(ЗначенияПараметровМакета, Макет, ОписанияОбластей, ПечатнаяФорма);
	
КонецПроцедуры                   
Функция ПФ_MXL_ТрудовойДоговорВредники_ЗначенияПараметров(Знач Макет, Знач Данные) Экспорт
	
	Перем ПФ_MXL_ТрудовойДоговорВредники_ЗначенияПараметров; // Возвращаемое значение
	
	Перем ЗначенияПараметров;
	
	ЗначенияПараметров = ПФ_MXL_ТрудовойДоговор_ЗначенияПараметров(Макет, Данные);
	//ЗначенияПараметров.Вставить(""Сотрудник_ГрафикРаботы"", Данные.Сотрудник.ГрафикРаботы);
	ЗначенияПараметров.Вставить(""Сотрудник_ГрафикРаботы"", ""вахтовый метод работы, продолжительность вахты составляет 2 месяца, продолжительность междувахтового отдыха составляет 1 месяц. Характер работы – разъездной"");
	ЗначенияПараметров.Вставить(""ОплатаТруда_Форма"", ""повременно-премиальная форма оплаты труда"");
	
	ЗначенияПараметров.Вставить(""УсловияТрудаНаРабочемМесте_Вид"", ""во вредных условиях труда (3 класс)"");

	ПФ_MXL_ТрудовойДоговорВредники_ЗначенияПараметров = ЗначенияПараметров;       
	
	Возврат ПФ_MXL_ТрудовойДоговорВредники_ЗначенияПараметров;                  
	
КонецФункции                                                                                        
Функция ПФ_MXL_ТрудовойДоговорВредники_ОписаниеОбластей(Знач this) Экспорт
	
	Перем ПФ_MXL_ТрудовойДоговорВредники_ОписаниеОбластей;
	
	ПФ_MXL_ТрудовойДоговорВредники_ОписаниеОбластей = ПФ_MXL_ТрудовойДоговор_ОписаниеОбластей(this);

	#Область ПФ_MXL_ТрудовойДоговорВредники_Области
	
	#КонецОбласти
	
	Возврат ПФ_MXL_ТрудовойДоговорВредники_ОписаниеОбластей;
	
КонецФункции 
Функция ПФ_MXL_ТрудовойДоговорВредники(Знач this) Экспорт
	
	Перем ПФ_MXL_ТрудовойДоговорВредники;
	
	ООП_parent(this);
	
	this.Имя = ""ПФ_MXL_ТрудовойДоговорВредники"";
	this.Тип = ""MXL"";
	this.Области = ПФ_MXL_ТрудовойДоговорВредники_ОписаниеОбластей(this);
	
	ПФ_MXL_ТрудовойДоговорВредники = this;
	
	Возврат ПФ_MXL_ТрудовойДоговорВредники;
	
КонецФункции //ПФ_MXL_ТрудовойДоговорВредники

// private
Функция ПФ_MXL_ТрудовойДоговорВредники_Include()
	
	ООП_Include(""ПФ_MXL_ТрудовойДоговор"");
	
	ООП_ЗарегистрироватьКласс(""ПФ_MXL_ТрудовойДоговорВредники"", ""Структура"", ""Макет.Макет"");
	
КонецФункции

#КонецОбласти
#Область class_ПФ_MXL_ТрудовойДоговорВредникиЛьготники

// public
Процедура ПФ_MXL_ТрудовойДоговорВредникиЛьготники_ВТабличныйДокумент(ЗначенияПараметровМакета, Знач Макет, Знач ОписанияОбластей, Знач ПечатнаяФорма) Экспорт
	
	ПФ_MXL_ТрудовойДоговор_ВТабличныйДокумент(ЗначенияПараметровМакета, Макет, ОписанияОбластей, ПечатнаяФорма);
	
КонецПроцедуры                   
Функция ПФ_MXL_ТрудовойДоговорВредникиЛьготники_ЗначенияПараметров(Знач Макет, Знач Данные) Экспорт
	
	Перем ПФ_MXL_ТрудовойДоговорВредникиЛьготники_ЗначенияПараметров; // Возвращаемое значение
	
	Перем ЗначенияПараметров;
	
	ЗначенияПараметров = ПФ_MXL_ТрудовойДоговор_ЗначенияПараметров(Макет, Данные);
	//ЗначенияПараметров.Вставить(""Сотрудник_ГрафикРаботы"", Данные.Сотрудник.ГрафикРаботы);
	ЗначенияПараметров.Вставить(""Сотрудник_ГрафикРаботы"", ""вахтовый метод работы, продолжительность вахты составляет 2 месяца, продолжительность междувахтового отдыха составляет 1 месяц. Работнику устанавливается сокращенная 36-ти часовая рабочая неделя"");
	ЗначенияПараметров.Вставить(""ОплатаТруда_Форма"", ""повременно-премиальная форма оплаты труда"");
	
	ЗначенияПараметров.Вставить(""УсловияТрудаНаРабочемМесте_Вид"", ""во вредных условиях труда (3 класс)"");

	ПФ_MXL_ТрудовойДоговорВредникиЛьготники_ЗначенияПараметров = ЗначенияПараметров;       
	
	Возврат ПФ_MXL_ТрудовойДоговорВредникиЛьготники_ЗначенияПараметров;                  
	
КонецФункции                                                                                        
Функция ПФ_MXL_ТрудовойДоговорВредникиЛьготники_ОписаниеОбластей(Знач this) Экспорт
	
	Перем ПФ_MXL_ТрудовойДоговорВредникиЛьготники_ОписаниеОбластей;
	
	ПФ_MXL_ТрудовойДоговорВредникиЛьготники_ОписаниеОбластей = ПФ_MXL_ТрудовойДоговор_ОписаниеОбластей(this);

	#Область ПФ_MXL_ТрудовойДоговорВредникиЛьготники_Области
	
	#КонецОбласти
	
	Возврат ПФ_MXL_ТрудовойДоговорВредникиЛьготники_ОписаниеОбластей;
	
КонецФункции 
Функция ПФ_MXL_ТрудовойДоговорВредникиЛьготники(Знач this) Экспорт
	
	Перем ПФ_MXL_ТрудовойДоговорВредникиЛьготники;
	
	ООП_parent(this);
	
	this.Имя = ""ПФ_MXL_ТрудовойДоговорВредникиЛьготники"";
	this.Тип = ""MXL"";
	this.Области = ПФ_MXL_ТрудовойДоговорВредникиЛьготники_ОписаниеОбластей(this);
	
	ПФ_MXL_ТрудовойДоговорВредникиЛьготники = this;
	
	Возврат ПФ_MXL_ТрудовойДоговорВредникиЛьготники;
	
КонецФункции //ПФ_MXL_ТрудовойДоговорВредникиЛьготники

// private
Функция ПФ_MXL_ТрудовойДоговорВредникиЛьготники_Include()
	
	ООП_Include(""ПФ_MXL_ТрудовойДоговор"");
	
	ООП_ЗарегистрироватьКласс(""ПФ_MXL_ТрудовойДоговорВредникиЛьготники"", ""Структура"", ""Макет.Макет"");
	
КонецФункции

#КонецОбласти

#Область class_МакетыИДанные

// public
Функция МакетыИДанные_Создать(МакетыИДанные, Знач Объекты, Знач ИменаМакетов) Экспорт
	
	Для Каждого ОбъектСсылка Из Объекты Цикл
		
		ДанныеОбъекта = МакетыИДанные_ДанныеОбъекта(ОбъектСсылка, ИменаМакетов);
		
		ДанныеОбъектаПоМакетам = Новый Соответствие;
		Для Каждого ИмяМакета Из ИменаМакетов Цикл
			ДанныеОбъектаПоМакетам.Вставить(ИмяМакета, МакетыИДанные_ЗначенияПараметровМакета(ДанныеОбъекта, ИмяМакета));
		КонецЦикла;
		
		МакетыИДанные.Данные.Вставить(ОбъектСсылка, ДанныеОбъектаПоМакетам);
	КонецЦикла;
	
	Для Каждого ИмяМакета Из ИменаМакетов Цикл
		
		Макет = ООП_Новый(ИмяМакета);
		Макет_Макет_Создать(Макет, ИмяМакета);
		
		МакетыИДанные.Макеты.ИсточникиМакетов.Вставить(ИмяМакета, Макет.Источник);
		МакетыИДанные.Макеты.ТипыМакетов.Вставить(ИмяМакета, Макет.Тип);
		МакетыИДанные.Макеты.ОбластиМакетов.Вставить(ИмяМакета, Макет.Области);
		
	КонецЦикла;
	
	Возврат МакетыИДанные;
	
КонецФункции
Функция МакетыИДанные_ПечатьМакетаОбъекта(МакетыИДанные, Знач ОбъектСсылка, Знач ИмяМакета) Экспорт
	
	ЗначенияПараметровМакета  = МакетыИДанные.Данные[ОбъектСсылка][ИмяМакета];
	ИсточникМакета            = МакетыИДанные.Макеты.ИсточникиМакетов[ИмяМакета];
	ТипМакета                 = МакетыИДанные.Макеты.ТипыМакетов[ИмяМакета];
	ОбластиМакета             = МакетыИДанные.Макеты.ОбластиМакетов[ИмяМакета];
	
	Если ( ( ""DOC"" = ТипМакета )
		ИЛИ ( ""ODT"" = ТипМакета ) ) Тогда
		//МакетыИДанные_ВОфисныйДокумент(ЗначенияПараметровМакета, ИмяМакета, ИсточникМакета, ТипМакета, ОбластиМакета);
		Возврат Неопределено;
	Иначе
		Возврат МакетыИДанные_ВТабличныйДокумент(ЗначенияПараметровМакета, ИмяМакета, ИсточникМакета, ТипМакета, ОбластиМакета);
	КонецЕсли; 
	
КонецФункции
//Функция МакетыИДанные_ВОфисныйДокумент(Знач ЗначенияПараметровМакета, Знач ИмяМакета, Знач ИсточникМакета, Знач ТипМакета, Знач ОбластиМакета) Экспорт
//	
//	// Для бибилиотеки стандартных подсистем <= 2.1 
//	Макет = УправлениеПечатьюКлиент.ИнициализироватьМакет(ИсточникМакета, ТипМакета, , ИмяМакета);
//	Макет = УправлениеПечатьюВызовСервера.ИнициализироватьМакет(ИсточникМакета, ТипМакета, , ИмяМакета);
//	// Для бибилиотеки стандартных подсистем > 2.1 
//	// Макет = УправлениеПечатьюКлиент.ИнициализироватьМакетОфисногоДокумента(ИсточникМакета, ТипМакета, ИмяМакета);
//	
//	Если Макет = Неопределено Тогда
//		Возврат Неопределено;
//	КонецЕсли;
//	
//	ЗакрытьОкноПечатнойФормы = Ложь;
//	Попытка
//		ПечатнаяФорма = УправлениеПечатьюКлиент.ИнициализироватьПечатнуюФорму(ТипМакета, Макет.НастройкиСтраницыМакета);
//		Если Неопределено = ПечатнаяФорма Тогда
//			УправлениеПечатьюКлиент.ОчиститьСсылки(Макет);
//			Возврат Неопределено;
//		КонецЕсли;
//		
//		Макет_Макет_ВОфисныйДокумент(ЗначенияПараметровМакета, ИмяМакета, Макет, ОбластиМакета, ПечатнаяФорма);
//		
//		УправлениеПечатьюКлиент.ПоказатьДокумент(ПечатнаяФорма);
//	Исключение
//		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
//		ЗакрытьОкноПечатнойФормы = Истина;
//	КонецПопытки;
//	
//	УправлениеПечатьюКлиент.ОчиститьСсылки(ПечатнаяФорма, ЗакрытьОкноПечатнойФормы);
//	УправлениеПечатьюКлиент.ОчиститьСсылки(Макет);
//	
//	Возврат Неопределено;
//КонецФункции
Функция МакетыИДанные_ВТабличныйДокумент(Знач ЗначенияПараметровМакета, Знач ИмяМакета, Знач ИсточникМакета, Знач ТипМакета, Знач ОбластиМакета) Экспорт
	
	Перем МакетыИДанные_ВТабличныйДокумент;
	
	Если ( Тип(""ТабличныйДокумент"") = ТипЗнч(ИсточникМакета) ) Тогда
		Макет = ИсточникМакета;
	Иначе
		Макет = ПолучитьМакет(ИмяМакета);
	КонецЕсли; 
	
	Если Макет = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ПечатнаяФорма = Новый ТабличныйДокумент;
	
	Макет_Макет_ВТабличныйДокумент(ЗначенияПараметровМакета, ИмяМакета, Макет, ОбластиМакета, ПечатнаяФорма);
	
	МакетыИДанные_ВТабличныйДокумент = ПечатнаяФорма;
	Возврат МакетыИДанные_ВТабличныйДокумент;
	
КонецФункции
// protected
Функция МакетыИДанные(Знач МакетыИДанные)
	
	Перем Макеты, Данные;
	
	//-------------------------------------------------------------
	// Макеты
	
	Макеты = Новый Структура;
	Макеты.Вставить(""ИсточникиМакетов"", Новый Соответствие());
	Макеты.Вставить(""ТипыМакетов"", Новый Структура());
	Макеты.Вставить(""ОбластиМакетов"", Новый Структура());
	
	//-------------------------------------------------------------
	// Данные
	Данные = Новый Соответствие;
	
	//МакетыИДанные = Новый Структура;
	МакетыИДанные.Вставить(""Макеты"", Макеты);
	МакетыИДанные.Вставить(""Данные"", Данные);
	
	Возврат МакетыИДанные;
	
КонецФункции
Функция МакетыИДанные_Include()
	
	Перем МакетыИДанные_Include;
	
	ООП_ЗарегистрироватьКласс(""МакетыИДанные"", ""Структура"");
	
	Возврат МакетыИДанные_Include;
	
КонецФункции
// private
Функция МакетыИДанные_ДанныеОбъекта(Знач ОбъектСсылка, Знач ИменаМакетов)
	
	Перем МакетИДанные_ДанныеОбъекта; // Возвращаемое значение
	
	ПолноеИмяКласса = Метаданные.НайтиПоТипу(ТипЗнч(ОбъектСсылка)).ПолноеИмя();
	ДанныеОбъекта = ООП_Новый(ПолноеИмяКласса);
	Код = ""МакетИДанные_ДанныеОбъекта = "" + СтрЗаменить(ПолноеИмяКласса, ""."", ""_"") + ""_Создать(ДанныеОбъекта, ОбъектСсылка, ИменаМакетов);"";
	Выполнить(Код);
	
	Возврат МакетИДанные_ДанныеОбъекта;
	
КонецФункции // МакетИДанные_ДанныеОбъекта
Функция МакетыИДанные_ЗначенияПараметровМакета(Знач ДанныеОбъекта, Знач ИмяМакета)
	
	Перем МакетИДанные_ЗначенияПараметровМакета; // Возвращаемое значение
	
	Код = ""МакетИДанные_ЗначенияПараметровМакета = "" + ИмяМакета + ""_ЗначенияПараметров(ИмяМакета, ДанныеОбъекта)"";
	Выполнить(Код);
	
	Возврат МакетИДанные_ЗначенияПараметровМакета;
	
КонецФункции // МакетИДанные_ЗначенияПараметровМакета

#КонецОбласти //class_МакетыИДанные//
#Область namespace_Макет

#Область ШаблонОписанияМакета

//#Область class_<ИмяМакета>
//
//Процедура Макет_<ИмяМакета>_Include()
//	
//	namespace = ""Макет"";
//	classname = <ИмяМакета>;
//	
//	#Область class_<ИмяМакета>_Области
//	
//	ОписаниеОбластей = Новый Структура;
//	
//	<ОписаниеПараметровОбластиМакета_1>
//	<ОписаниеПараметровОбластиМакета_2>
//	.....
//	<ОписаниеПараметровОбластиМакета_N>
//	
//	#КонецОбласти //class_<ИмяМакета>_Области//
//	
//	Макет      = ООП_Новый(""Макет.Макет"");
//	Макет.Имя      = classname;
//	Макет.Тип      = <ТипМакета>;
//	Макет.Области  = ОписаниеОбластей;
//	
//	ООП_ЗарегистрироватьКласс(classname, namespace, Новый ФиксированнаяСтруктура(Макет));
//
//КонецПроцедуры
//
//#КонецОбласти //class_<ИмяМакета>//

#КонецОбласти //ШаблонОписанияМакета//
#Область ШаблонОписанияПараметровОбластиМакета

//#Область class_<ИмяМакета>_Область_<ИмяОбласти>
//
// ИмяОбласти        = <ИмяОбласти>
// ТипОбласти        = <ТипОбласти>
// ПараметрыОбласти  = Новый Массив;
//
// ПараметрыОбласти.Добавить(<ИмяПараметра>);
// Макеты_Макет_ДобавитьОписаниеОбласти(ОписаниеОбластей, ИмяОбласти, ТипОбласти, ПараметрыОбласти);
//
//#КонецОбласти //class_<ИмяМакета>_Область_<ИмяОбласти>//

#КонецОбласти //#Область ШаблонОписанияПараметровОбластиМакета

#Область class_Макет

// public
Функция Макет_Макет_Создать(Макет, Знач ИмяМакета = Неопределено, Знач ТипМакета = Неопределено)
	
	Если ( Неопределено = Макет ) Тогда
		Возврат Неопределено;
	КонецЕсли; 
	
	Если ( Неопределено = Макет.Имя ИЛИ """" = Макет.Имя ) Тогда
		Если ( Неопределено = ИмяМакета ИЛИ """" = ИмяМакета ) Тогда
			ВызватьИсключение ""Не задано имя макета"";
		Иначе
			Макет.Имя = ИмяМакета;
		КонецЕсли;
	КонецЕсли;
	
	Если ( Неопределено = Макет.Тип ИЛИ """" = Макет.Тип ) Тогда
		Макет.Тип = ТипМакета;
	КонецЕсли; 
	
	Если ( Неопределено = Макет.Источник ) Тогда
		Если ( Макет.Общий ) Тогда
			Макет.Источник  = ПолучитьОбщийМакет(Макет.Имя);
		Иначе
			Макет.Источник  = ЭтотОбъект.ПолучитьМакет(Макет.Имя);
		КонецЕсли; 
	КонецЕсли; 
	
	Если ( Неопределено = Макет.Области ) Тогда
		Макет.Области   = ООП_Новый(""Макеты."" + Макет.Имя + "".Области"");
	КонецЕсли; 
	
	Возврат Макет;
	
КонецФункции
//Процедура Макет_Макет_ВОфисныйДокумент(ЗначенияПараметровМакета, Знач ИмяМакета, Знач Макет, Знач ОбластиМакета, Знач ПечатнаяФорма) Экспорт
//	
//	Перем Область, ОписаниеОбласти, Параметры, ПараметрыОбласти;
//	
//	Выполнить(""Макет_"" + ИмяМакета + ""_ВОфисныйДокумент(ЗначенияПараметровМакета, Макет, ОбластиМакета, ПечатнаяФорма)"");
//	
//КонецПроцедуры
//Процедура Макет_Макет_ВОфисныйДокумент_ПрисоединитьОбластьИЗаполнитьПараметры(ЗначенияПараметровМакета, Знач Макет, Знач ОписаниеОбласти, Знач ПечатнаяФорма) Экспорт
//	
//	Перем Область, ПараметрыОбласти;
//	
//	Область = УправлениеПечатьюКлиент.ПолучитьОбласть(Макет, ОписаниеОбласти);
//	
//	ЗначенияПараметровОбласти = Новый Структура;
//	Для каждого Параметр Из ОписаниеОбласти.ПараметрыОбласти Цикл
//		
//		Если ( ЗначенияПараметровМакета.Свойство(Параметр) ) Тогда
//			ЗначенияПараметровОбласти.Вставить(Параметр, ЗначенияПараметровМакета[Параметр]);	
//		КонецЕсли; 
//		
//	КонецЦикла; 
//	
//	УправлениеПечатьюКлиент.ПрисоединитьОбластьИЗаполнитьПараметры(ПечатнаяФорма, Область, ЗначенияПараметровОбласти, Ложь);
//	
//КонецПроцедуры
//Процедура Макет_Макет_ВОфисныйДокумент_ВывестиКоллекцию(ЗначенияПараметровМакета, Знач Макет, Знач ОписаниеОбласти, Знач ПечатнаяФорма) Экспорт
//КонецПроцедуры
Процедура Макет_Макет_ВТабличныйДокумент(ЗначенияПараметровМакета, Знач ИмяМакета, Знач Макет, Знач ОбластиМакета, Знач ПечатнаяФорма) Экспорт
	
	Перем Область, ОписаниеОбласти, Параметры, ПараметрыОбласти;
	
	Выполнить(ИмяМакета + ""_ВТабличныйДокумент(ЗначенияПараметровМакета, Макет, ОбластиМакета, ПечатнаяФорма)"");
	
КонецПроцедуры

Функция Макет_Макет_ВТабличныйДокументПолучитьОбластьИЗаполнитьПараметры(Знач ЗначенияПараметровМакета, Знач Макет, Знач ОписаниеОбласти) Экспорт
	
	Перем Макет_Макет_ВТабличныйДокументПолучитьОбласть;
	
	Перем Область;
	
	#Если (Сервер И НЕ Сервер) Тогда
		Макет = Новый ТабличныйДокумент;
		ПечатнаяФорма = Новый ТабличныйДокумент;
	#КонецЕсли
	
	Область = ЭтотОбъект.Макет_Макет_ВТабличныйДокументПолучитьОбласть(Макет, ОписаниеОбласти);
	ЭтотОбъект.Макет_Макет_ВТабличныйДокументЗаполнитьПараметрыОбласти(ЗначенияПараметровМакета, Область, ОписаниеОбласти);
	
	Макет_Макет_ВТабличныйДокументПолучитьОбласть = Область;
	
	Возврат Макет_Макет_ВТабличныйДокументПолучитьОбласть;
	
КонецФункции
Функция Макет_Макет_ВТабличныйДокументПолучитьИВывестиОбласть(Знач Макет, Знач ОписаниеОбласти, Знач ПечатнаяФорма, Знач ВыводитьКонецСтраницы = Истина) Экспорт
	
	Перем Макет_Макет_ВТабличныйДокументПолучитьИВывестиОбласть;
	Перем Область;
	
	#Если Не (НаКлиенте ИЛИ НаСервере ИЛИ ТолстыйКлиентОбычноеПриложение ИЛИ ТолстыйКлиентУправляемоеПриложение ИЛИ Клиент ИЛИ Сервер ИЛИ ВнешнееСоединение) Тогда
		Макет = Новый ТабличныйДокумент;
		ПечатнаяФорма = Новый ТабличныйДокумент;
	#КонецЕсли
	
	Область = ЭтотОбъект.Макет_Макет_ВТабличныйДокументПолучитьОбласть(Макет, ОписаниеОбласти);
	Макет_Макет_ВТабличныйДокументПолучитьИВывестиОбласть = ЭтотОбъект.Макет_Макет_ВТабличныйДокументВывестиОбласть(ПечатнаяФорма, Область, ВыводитьКонецСтраницы);
	
	Возврат Макет_Макет_ВТабличныйДокументПолучитьИВывестиОбласть;
	
КонецФункции

Процедура Макет_Макет_ВТабличныйДокументПрисоединитьОбластьИЗаполнитьПараметры(Знач ЗначенияПараметровМакета, Знач Макет, Знач ОписаниеОбласти, Знач ПечатнаяФорма, Знач ВыводитьКонецСтраницы = Истина) Экспорт
	
	Перем Область;
	
	#Если Не (НаКлиенте ИЛИ НаСервере ИЛИ ТолстыйКлиентОбычноеПриложение ИЛИ ТолстыйКлиентУправляемоеПриложение ИЛИ Клиент ИЛИ Сервер ИЛИ ВнешнееСоединение) Тогда
		Макет = Новый ТабличныйДокумент;
		ПечатнаяФорма = Новый ТабличныйДокумент;
	#КонецЕсли
	
	Область = Макет_Макет_ВТабличныйДокументПолучитьОбласть(Макет, ОписаниеОбласти);
	Макет_Макет_ВТабличныйДокументЗаполнитьПараметрыОбласти(ЗначенияПараметровМакета, Область, ОписаниеОбласти);
	Макет_Макет_ВТабличныйДокументВывестиОбласть(ПечатнаяФорма, Область, ВыводитьКонецСтраницы);
	
КонецПроцедуры
Процедура Макет_Макет_ВТабличныйДокументПрисоединитьИЗаполнитьКоллекцию(КоллекцияЗначенийПараметров, Знач Макет, Знач ОписаниеОбласти, Знач ПечатнаяФорма) Экспорт
	
	Перем Область, ПараметрыОбласти;
	
	#Если Не (НаКлиенте ИЛИ НаСервере ИЛИ ТолстыйКлиентОбычноеПриложение ИЛИ ТолстыйКлиентУправляемоеПриложение ИЛИ Клиент ИЛИ Сервер ИЛИ ВнешнееСоединение) Тогда
		Макет = Новый ТабличныйДокумент;
		ПечатнаяФорма = Новый ТабличныйДокумент;
	#КонецЕсли
	
	Область = Макет.ПолучитьОбласть(ОписаниеОбласти.ИмяОбласти);
	
	ЗначенияПараметровОбласти = Новый Структура;
	
	Для каждого СтрокаКоллекцииЗначений Из КоллекцияЗначенийПараметров Цикл
		
		Для каждого Параметр Из ОписаниеОбласти.ПараметрыОбласти Цикл
			
			Если ( СтрокаКоллекцииЗначений.Свойство(Параметр) ) Тогда
				ЗначенияПараметровОбласти.Вставить(Параметр, СтрокаКоллекцииЗначений[Параметр]);	
			КонецЕсли; 
			
		КонецЦикла; 
		ЗаполнитьЗначенияСвойств(Область.Параметры, ЗначенияПараметровОбласти);
		
		ПечатнаяФорма.Вывести(Область);
		
	КонецЦикла; 
	
КонецПроцедуры

Функция Макет_Макет(Знач Макет_Макет)
	
	Макет_Макет.Вставить(""Имя"", """");
	Макет_Макет.Вставить(""Тип"", ""MXL"");   // MXL - документ типа ""ТабличныйДокумент"", DOC - документ MSOffice, ODT - документ OpenOffice
	Макет_Макет.Вставить(""Общий"", Ложь); // Истина - Общий макет, Ложь - макет объекта
	Макет_Макет.Вставить(""Источник"");
	Макет_Макет.Вставить(""Области"");
	
	Возврат Макет_Макет;
	
КонецФункции // Макет_Макет
Функция Макет_Макет_Include()
	
	Перем Макет_Макет_Include;
	
	ООП_ЗарегистрироватьКласс(""Макет.Макет"", ""Структура"");
	
	Возврат Макет_Макет_Include;
	
КонецФункции

// protected
Функция Макет_Макет_ДобавитьОписаниеОбласти(Знач ОписаниеОбластей, Знач ИмяОбласти, Знач ТипОбласти, Знач ПараметрыОбласти = Неопределено) Экспорт
	
	Перем ОписаниеОбласти;
	
	УправлениеПечатью.ДобавитьОписаниеОбласти(ОписаниеОбластей, ИмяОбласти, ТипОбласти);
	
	ОписаниеОбласти = ОписаниеОбластей[ИмяОбласти];
	ОписаниеОбласти.Вставить(""ПараметрыОбласти"", ?(Неопределено = ПараметрыОбласти, Новый Массив, ПараметрыОбласти));
	
	Возврат ОписаниеОбласти;
	
КонецФункции
Функция Макет_Макет_ВТабличныйДокументПолучитьОбласть(Знач Макет, Знач ОписаниеОбласти) Экспорт
	
	Перем Макет_Макет_ВТабличныйДокументПолучитьОбласть;
	
	Перем Область, ПараметрыОбласти;
	
	#Если Не (НаКлиенте ИЛИ НаСервере ИЛИ ТолстыйКлиентОбычноеПриложение ИЛИ ТолстыйКлиентУправляемоеПриложение ИЛИ Клиент ИЛИ Сервер ИЛИ ВнешнееСоединение) Тогда
		Макет = Новый ТабличныйДокумент;
	#КонецЕсли
	
	Область = Макет.ПолучитьОбласть(ОписаниеОбласти.ИмяОбласти);
	
	Макет_Макет_ВТабличныйДокументПолучитьОбласть = Область;
	
	Возврат Макет_Макет_ВТабличныйДокументПолучитьОбласть;
	
КонецФункции
Функция Макет_Макет_ВТабличныйДокументЗаполнитьПараметрыОбласти(Знач ЗначенияПараметровМакета, Знач Область, Знач ОписаниеОбласти) Экспорт
	
	Перем Макет_Макет_ВТабличныйДокументЗаполнитьПараметрыОбласти;
	
	Перем ЗначенияПараметровОбласти;
	
	#Если Не (НаКлиенте ИЛИ НаСервере ИЛИ ТолстыйКлиентОбычноеПриложение ИЛИ ТолстыйКлиентУправляемоеПриложение ИЛИ Клиент ИЛИ Сервер ИЛИ ВнешнееСоединение) Тогда
		Область = Новый ТабличныйДокумент;
	#КонецЕсли
	
	ЗначенияПараметровОбласти = Новый Структура;
	Для каждого Параметр Из ОписаниеОбласти.ПараметрыОбласти Цикл
		
		Если ( ЗначенияПараметровМакета.Свойство(Параметр) ) Тогда
			ЗначенияПараметровОбласти.Вставить(Параметр, ЗначенияПараметровМакета[Параметр]);	
		КонецЕсли; 
		
	КонецЦикла; 
	ЗаполнитьЗначенияСвойств(Область.Параметры, ЗначенияПараметровОбласти);
	
	
	Макет_Макет_ВТабличныйДокументЗаполнитьПараметрыОбласти = Область;
	
	Возврат Макет_Макет_ВТабличныйДокументЗаполнитьПараметрыОбласти;
	
КонецФункции
Функция Макет_Макет_ВТабличныйДокументВывестиОбласть(Знач ПечатнаяФорма, Знач Область, Знач ВыводитьКонецСтраницы = Истина) Экспорт
	
	Перем Макет_Макет_ВТабличныйДокументВывестиОбласть; // Возвращаемое значение
	
	#Если Не (НаКлиенте ИЛИ НаСервере ИЛИ ТолстыйКлиентОбычноеПриложение ИЛИ ТолстыйКлиентУправляемоеПриложение ИЛИ Клиент ИЛИ Сервер ИЛИ ВнешнееСоединение) Тогда
		Область = Новый ТабличныйДокумент;
		ПечатнаяФорма = Новый ТабличныйДокумент;
	#КонецЕсли
	
	Если ( ВыводитьКонецСтраницы ) Тогда
		Макет_Макет_ВТабличныйДокументПроверитьВыводОбластиИВывестиКонецСтраницы(ПечатнаяФорма, Область);
	КонецЕсли;
	
	ПечатнаяФорма.Вывести(Область);
	
	Макет_Макет_ВТабличныйДокументВывестиОбласть = ПечатнаяФорма;
	
	Возврат Макет_Макет_ВТабличныйДокументВывестиОбласть;
	
КонецФункции // Макет_Макет_ВТабличныйДокументВывестиОюбласть()

Функция Макет_Макет_ВТабличныйДокументПроверитьВыводОбластиИВывестиКонецСтраницы(Знач ПечатнаяФорма, Знач Область, Знач ВыводитьКонецСтраницы = Истина) Экспорт
	
	Перем Макет_Макет_ВТабличныйДокументПроверитьВыводОбластиИВывестиКонецСтраницы; // Возвращаемое значение
	
	#Если Не (НаКлиенте ИЛИ НаСервере ИЛИ ТолстыйКлиентОбычноеПриложение ИЛИ ТолстыйКлиентУправляемоеПриложение ИЛИ Клиент ИЛИ Сервер ИЛИ ВнешнееСоединение) Тогда
		ПечатнаяФорма = Новый ТабличныйДокумент;
	#КонецЕсли
	
	Если ( НЕ Макет_Макет_ВТабличныйДокументПроверитьВыводОбласти(ПечатнаяФорма, Область) ) Тогда
		Макет_Макет_ВТабличныйДокументПроверитьВыводОбластиИВывестиКонецСтраницы = Ложь;
	Иначе
		Если ( ВыводитьКонецСтраницы ) Тогда
			Макет_Макет_ВТабличныйДокументВставитьКонецСтраницы(ПечатнаяФорма);
		КонецЕсли;
		Макет_Макет_ВТабличныйДокументПроверитьВыводОбластиИВывестиКонецСтраницы = Истина;
	КонецЕсли;
	
	Возврат Макет_Макет_ВТабличныйДокументПроверитьВыводОбластиИВывестиКонецСтраницы;
	
КонецФункции
Функция Макет_Макет_ВТабличныйДокументПроверитьВыводОбласти(Знач ПечатнаяФорма, Знач Область, Знач РезультатПриОшибке = Истина) Экспорт
	
	Перем Макет_Макет_ВТабличныйДокументПроверитьВывод; // Возвращаемое значение
	
	#Если Не (НаКлиенте ИЛИ НаСервере ИЛИ ТолстыйКлиентОбычноеПриложение ИЛИ ТолстыйКлиентУправляемоеПриложение ИЛИ Клиент ИЛИ Сервер ИЛИ ВнешнееСоединение) Тогда
		ПечатнаяФорма = Новый ТабличныйДокумент;
	#КонецЕсли
	
	Попытка
		Макет_Макет_ВТабличныйДокументПроверитьВывод = ПечатнаяФорма.ПроверитьВывод(Область);
	Исключение
		
		Макет_Макет_ВТабличныйДокументПроверитьВывод = РезультатПриОшибке;
		ВызватьИсключение ""Ошибка при проверке вывода в таблычный документ""; // TODO: первого случая... чтоб понимть в каком случае вызникает. После 
		
	КонецПопытки;
	
	Возврат Макет_Макет_ВТабличныйДокументПроверитьВывод;
	
КонецФункции
Функция Макет_Макет_ВТабличныйДокументПроверитьВыводОбластей(Знач ПечатнаяФорма, Знач Области, Знач РезультатПриОшибке = Истина) Экспорт
	
	Перем Макет_Макет_ВТабличныйДокументПроверитьВывод; // Возвращаемое значение
	
	#Если Не (НаКлиенте ИЛИ НаСервере ИЛИ ТолстыйКлиентОбычноеПриложение ИЛИ ТолстыйКлиентУправляемоеПриложение ИЛИ Клиент ИЛИ Сервер ИЛИ ВнешнееСоединение) Тогда
		ПечатнаяФорма = Новый ТабличныйДокумент;
	#КонецЕсли
	
	Попытка
		Макет_Макет_ВТабличныйДокументПроверитьВывод = ПечатнаяФорма.ПроверитьВывод(Области);
	Исключение
	
		Макет_Макет_ВТабличныйДокументПроверитьВывод = РезультатПриОшибке;
		ВызватьИсключение ""Ошибка при проверке вывода в табличный документ""; // TODO: до первого случая... чтоб понимть в каком случае вызникает. После 
	
	КонецПопытки;
	
	Возврат Макет_Макет_ВТабличныйДокументПроверитьВывод;
	
КонецФункции

Функция Макет_Макет_ВТабличныйДокументВставитьКонецСтраницы(Знач ПечатнаяФорма) Экспорт
	
	Перем Макет_Макет_ВТабличныйДокументВставитьКонецСтраницы; // Возвращаемое значение
	
	ПечатнаяФорма.ВывестиВертикальныйРазделительСтраниц();
	
	Возврат Макет_Макет_ВТабличныйДокументВставитьКонецСтраницы;
	
КонецФункции

// private 

#КонецОбласти //classname_Макет//

#КонецОбласти //namespace_Макет//
#Область namespace_Стандартные
// Helpers
#Область class_Дата


#КонецОбласти

#Область class_Период
Функция Период_ИндексМесяца(Знач Период)
	
	Индексы = Новый Соответствие();
	Индексы.Вставить(""ЯНВАРЬ"", 0);
	Возврат Период
	
	
КонецФункции // Период_ИндексМесяца()
Функция Период_СклонениеМесяца(Знач Период, Знач Падеж)
	
	Перем Период_СклонениеМесяца;
	
	Перем ТипСтрока, ТипДата, ТипЧисло;
	Перем ПериодТип, ПадежТип;
	
	Перем ИндексМесяца, ИндексПадежа;
	
	Перем Склонения;
	
	Склонения = Склонения();
	
	ТипСтрока = Тип(""Строка"");
	ТипДата = Тип(""Дата"");
	ТипЧисло = Тип(""Число"");
	ПериодТип = ТипЗнч(Период); 
	ПадежТип = ТипЗнч(Падеж);
	Если ( ТипДата = ПериодТип ) Тогда
		ИндексМесяца = Месяц(Период) - 1;
	ИначеЕсли ( ТипСтрока = ПериодТип ) Тогда
		ИндексМесяца = Период_ИндексМесяца(Период);
	ИначеЕсли ( ТипЧисло = ПериодТип ) Тогда
		
		Если ( НЕ (ИСТИНА
			И (1 > Период)
			И (12 < Период)
			) ) Тогда
			ВызватьИсключение ""Неверное значение параметра """"Период"""": """""" + Период + """""""";
		КонецЕсли; 
		
		ИндексМесяца = Период - 1;
		
	Иначе
		ВызватьИсключение ""Неожидаемый тип значения параметра """"Период""""("" + ПериодТип + ""): """""" + Период + """""""";
	КонецЕсли; 
	
	Если ( ТипЧисло = ПадежТип ) Тогда
		
		Если ( НЕ (ИСТИНА
			И (1 <= Падеж)
			И (6 >= Падеж)
			) ) Тогда
			ВызватьИсключение ""Неверное значение параметра """"Падеж"""": """""" + Падеж + """""""";
		КонецЕсли;
		
		ИндексПадежа = Падеж - 1;
		
	Иначе
		ВызватьИсключение  ""Неожидаемый тип значения параметра """"Падеж""""("" + ПадежТип + ""): """""" + Падеж + """""" ""
	КонецЕсли; 
	
	Период_СклонениеМесяца = Склонения[ИндексМесяца][ИндексПадежа];
	
	Возврат Период_СклонениеМесяца;
	
КонецФункции // Период_СклонениеМесяца()

#КонецОбласти 
#Область static_class_Склонения

// protected
Функция Склонения() Экспорт
	
	Перем Склонения;
	
	Склонения = Новый Массив();
	
	Склонения.Добавить(Склонения_ДобавитьСклонение(Новый Массив(7), ""январь"",   ""января"",   ""январю"", ""январь"", ""январем"", ""январе"", ""январе""));
	Склонения.Добавить(Склонения_ДобавитьСклонение(Новый Массив(7), ""февраль"",  ""февраля"",  ""февралю"", ""февраль"", ""февралем"", ""феврале"", ""феврале""));
	Склонения.Добавить(Склонения_ДобавитьСклонение(Новый Массив(7), ""март"",     ""марта"",    ""марту"", ""март"", ""мартом"", ""марте"", ""марте""));
	Склонения.Добавить(Склонения_ДобавитьСклонение(Новый Массив(7), ""апрель"",   ""апреля"",   ""апрелю"", ""апрель"", ""апрелем"", ""апреле"", ""апреле""));
	Склонения.Добавить(Склонения_ДобавитьСклонение(Новый Массив(7), ""май"",      ""мая"",      ""маю"", ""май"", ""маем"", ""мае"", ""мае""));
	Склонения.Добавить(Склонения_ДобавитьСклонение(Новый Массив(7), ""июнь"",     ""июня"",     ""июню"", ""июнь"", ""июнем"", ""июне"", ""июне""));
	Склонения.Добавить(Склонения_ДобавитьСклонение(Новый Массив(7), ""июль"",     ""июля"",     ""июлю"", ""июль"", ""июлем"", ""июле"", ""июле""));
	Склонения.Добавить(Склонения_ДобавитьСклонение(Новый Массив(7), ""август"",   ""августа"",  ""августу"", ""август"", ""августом"", ""августе"", ""августе""));
	Склонения.Добавить(Склонения_ДобавитьСклонение(Новый Массив(7), ""сентябрь"", ""сентября"", ""сентябрю"", ""сентябрь"", ""сентябрем"", ""сентябре"", ""сентябре""));
	Склонения.Добавить(Склонения_ДобавитьСклонение(Новый Массив(7), ""октябрь"",  ""октября"",  ""октябрю"", ""октябрь"", ""октябрем"", ""октябре"", ""октябре""));
	Склонения.Добавить(Склонения_ДобавитьСклонение(Новый Массив(7), ""ноябрь"",   ""ноября"",   ""ноябрю"", ""ноябрь"", ""ноябрем"", ""ноябре"", ""ноябре""));
	Склонения.Добавить(Склонения_ДобавитьСклонение(Новый Массив(7), ""декабрь"",  ""декабря"",  ""декабрю"", ""декабрь"", ""декабрем"", ""декабре"", ""декабре""));
	
	Возврат Склонения;
	
КонецФункции
Функция Склонения_ДобавитьСклонение(Знач Склонение, Знач Именительный, Знач Родительный, Знач Дательный, Знач Винительный, Знач Творительный, Знач Предложный, Знач Местный) Экспорт
	
	Перем Склонения_ДобавитьСклонение;
	
	Склонение[0] = Именительный;
	Склонение[1] = Родительный;
	Склонение[2] = Дательный;
	Склонение[3] = Винительный;
	Склонение[4] = Винительный;
	Склонение[5] = Творительный;
	Склонение[6] = Предложный;
	
	Склонения_ДобавитьСклонение = Склонение;
	
	Возврат Склонения_ДобавитьСклонение;
	
КонецФункции

#КонецОбласти 

// Структуры
#Область class_Стандартные_Адрес

// protected
Функция Стандартные_Адрес(Знач Стандартные_Адрес)
	
	Стандартные_Адрес.Вставить(""Представление"");
	
	Возврат Стандартные_Адрес;
	
КонецФункции
Функция Стандартные_Адрес_Include()
	
	Перем Стандартные_Адрес_Include; // Возвращаемое значение
	
	ООП_ЗарегистрироватьКласс(""Стандартные.Адрес"", ""Структура"");
	
	Возврат Стандартные_Адрес_Include;
	
КонецФункции // Стандартные_Адрес_Include

#КонецОбласти //class_Стандартные_Адрес//
#Область class_Стандартные_Документ

// protected
Функция Стандартные_Документ(Знач Стандартные_Документ)
	
	Стандартные_Документ.Вставить(""Ссылка"");
	Стандартные_Документ.Вставить(""Номер"");
	Стандартные_Документ.Вставить(""Дата"");
	
	Возврат Стандартные_Документ;
	
КонецФункции
Функция Стандартные_Документ_Include()
	
	Перем Стандартные_Договор_Include; // Возвращаемое значение
	
	ООП_ЗарегистрироватьКласс(""Стандартные.Документ"", ""Структура"");
	
	Возврат Стандартные_Договор_Include;
	
КонецФункции // Стандартные_Договор_Include

#КонецОбласти //class_Стандартные_Договор//
#Область class_Стандартные_Договор

// protected
Функция Стандартные_Договор(Знач Стандартные_Договор)
	
	ООП_parent(Стандартные_Договор);
	
	Возврат Стандартные_Договор;
	
КонецФункции
Функция Стандартные_Договор_Include()
	
	Перем Стандартные_Договор_Include; // Возвращаемое значение
	
	ООП_include(""Стандартные.Документ"");
	ООП_ЗарегистрироватьКласс(""Стандартные.Договор"", ""Структура"", ""Стандартные.Документ"");
	
	Возврат Стандартные_Договор_Include;
	
КонецФункции // Стандартные_Договор_Include

#КонецОбласти //class_Стандартные_Договор//
#Область class_Стандартные_ДокументУдостоверяющийЛичность

// public
Функция Стандартные_ДокументУдостоверяющийЛичность_Представление(Знач this)
	
	Перем Стандартные_ДокументУдостоверяющийЛичность_Представление;
	
	Стандартные_ДокументУдостоверяющийЛичность_Представление = this.Представление;
	
	Возврат Стандартные_ДокументУдостоверяющийЛичность_Представление;
	
КонецФункции	
// protected
Функция Стандартные_ДокументУдостоверяющийЛичность(Знач Стандартные_ДокументУдостоверяющийЛичность)
	
	Стандартные_ДокументУдостоверяющийЛичность.Вставить(""Ссылка"");
	Стандартные_ДокументУдостоверяющийЛичность.Вставить(""Представление"");
	Стандартные_ДокументУдостоверяющийЛичность.Вставить(""Вид"");
	Стандартные_ДокументУдостоверяющийЛичность.Вставить(""Серия"");
	Стандартные_ДокументУдостоверяющийЛичность.Вставить(""Номер"");
	Стандартные_ДокументУдостоверяющийЛичность.Вставить(""КемВыдан"");
	Стандартные_ДокументУдостоверяющийЛичность.Вставить(""ДатаВыдачи"");
	
	Возврат Стандартные_ДокументУдостоверяющийЛичность;
	
КонецФункции
Функция Стандартные_ДокументУдостоверяющийЛичность_Include()
	
	Перем Стандартные_ДокументУдостоверяющийЛичность_Include; // Возвращаемое значение
	
	ООП_ЗарегистрироватьКласс(""Стандартные.ДокументУдостоверяющийЛичность"", ""Структура"");
	
	Возврат Стандартные_ДокументУдостоверяющийЛичность_Include;
	
КонецФункции // Стандартные_ДокументУдостоверяющийЛичность_Include

#КонецОбласти //class_Стандартные_ДокументУдостоверяющийЛичность//
#Область class_Стандартные_Должность

// public
Функция Стандартные_Должность_Наименование(Знач Должность, Значение = Неопределено) Экспорт
	
	Перем Стандартные_Должность_Наименование; // Возвращаемое значение
	
	Если ( Неопределено <> Значение ) Тогда
		
		Должность.Наименование = Значение;
		
		Стандартные_Должность_Обновить(Должность);
		
	КонецЕсли;	
	
	Стандартные_Должность_Наименование = Должность.Наименование;
	
	Возврат Стандартные_Должность_Наименование;
	
КонецФункции
Функция Стандартные_Должность_Представление(Знач Должность) Экспорт
	
	Перем Стандартные_Должность_Представление; // Возвращаемое значение
	
	Стандартные_Должность_Представление = Стандартные_Должность_Наименование(Должность);
	
	Возврат Стандартные_Должность_Представление;
	
КонецФункции
Функция Стандартные_Должность_Склонение(Знач Должность, Знач Падеж = Неопределено, Знач Объект = Неопределено) Экспорт
	
	Перем Стандартные_Должность_Склонение; // Возвращаемое значение
	
	Наименование = Стандартные_Должность_Наименование(Должность);
	
	Стандартные_Должность_Склонение = СклонениеПредставленийОбъектов.ПросклонятьПредставление(Наименование, Падеж, Объект);
	
	Возврат Стандартные_Должность_Склонение;
	
КонецФункции // Стандартные_Должность_Установить()

// protected
Функция Стандартные_Должность(Знач Стандартные_Должность)
	
	Стандартные_Должность.Вставить(""Ссылка"", Неопределено);
	Стандартные_Должность.Вставить(""Представление"", """");
	Стандартные_Должность.Вставить(""Наименование"", """");
	
	Возврат Стандартные_Должность;
	
КонецФункции
Функция Стандартные_Должность_Include()
	
	Перем Стандартные_Должность_Include; // Возвращаемое значение
	
	ООП_ЗарегистрироватьКласс(""Стандартные.Должность"", ""Структура"");		
	
	Возврат Стандартные_Должность_Include;
	
КонецФункции // Стандартные_Должность_Include
Функция Стандартные_Должность_Обновить(Знач Должность)
	
	Перем Стандартные_Должность_Обновить; // Возвращаемое значение
	
	Стандартные_Должность_Обновить = Истина;
	
	Возврат Стандартные_Должность_Обновить;
	
КонецФункции

#КонецОбласти //class_Стандартные_Должность//
#Область class_Стандартные_ЕГРИП

// protected
Функция Стандартные_ЕГРИП(Знач Стандартные_ЕГРИП)
	
	Стандартные_ЕГРИП.Вставить(""НомерИП"");
	Стандартные_ЕГРИП.Вставить(""ДатаВыдачи"");
	Стандартные_ЕГРИП.Вставить(""СерияНомер"");
	
	Возврат Стандартные_ЕГРИП;
	
КонецФункции
Функция Стандартные_ЕГРИП_Include()
	
	Перем Стандартные_ЕГРИП_Include; // Возвращаемое значение
	
	ООП_ЗарегистрироватьКласс(""Стандартные.ЕГРИП"", ""Структура"");
	
	Возврат Стандартные_ЕГРИП_Include;
	
КонецФункции // Стандартные_ЕГРИП_Include

#КонецОбласти //class_Стандартные_ЕГРИП//
#Область class_Стандартные_Номенклатура

// public

Функция Стандартные_Номенклатура(Знач Стандартные_Номенклатура)
	
	Стандартные_Номенклатура.Вставить(""Ссылка"");
	Стандартные_Номенклатура.Вставить(""Код"");
	Стандартные_Номенклатура.Вставить(""Наименование"");
	Стандартные_Номенклатура.Вставить(""ЕдиницаИзмерения"", ООП_new(""Стандартные.ЕдиницаИзмерения""));
	
	Возврат Стандартные_Номенклатура;
	
КонецФункции

Функция Стандартные_Номенклатура_Представление(Знач this) Экспорт
	
	Перем Стандартные_Номенклатура_Представление;
	
	Стандартные_Номенклатура_Представление = ЭтотОбъект.Стандартные_Подразделение_Наименование(this);
	
	Возврат Стандартные_Номенклатура_Представление;
	
КонецФункции
Функция Стандартные_Номенклатура_Код(Знач this) Экспорт
	
	Перем Стандартные_Номенклатура_Представление;
	
	Стандартные_Номенклатура_Представление = this.Код;
	
	Возврат Стандартные_Номенклатура_Представление;
	
КонецФункции
Функция Стандартные_Номенклатура_Наименование(Знач this) Экспорт
	
	Перем Стандартные_Номенклатура_Представление;
	
	Стандартные_Номенклатура_Представление = this.Наименование;
	
	Возврат Стандартные_Номенклатура_Представление;
	
КонецФункции
// protected
Функция Стандартные_Номенклатура_Include()
	
	Перем Стандартные_Номенклатура_Include; // Возвращаемое значение
	
	ООП_include(""Стандартные.ЕдиницаИзмерения"");
	
	ООП_ЗарегистрироватьКласс(""Стандартные.Номенклатура"", ""Структура"");
	
	Возврат Стандартные_Номенклатура_Include;
	
КонецФункции // Стандартные_Номенклатура_Include

#КонецОбласти //class_Стандартные_Номенклатура//
#Область class_Стандартные_ЕдиницаИзмерения

// protected
Функция Стандартные_ЕдиницаИзмерения(Знач Стандартные_ЕдиницаИзмерения)
	
	Стандартные_ЕдиницаИзмерения.Вставить(""Ссылка"");
	Стандартные_ЕдиницаИзмерения.Вставить(""Код"", """");
	Стандартные_ЕдиницаИзмерения.Вставить(""Наименование"", """");
	
	Возврат Стандартные_ЕдиницаИзмерения;
	
КонецФункции
Функция Стандартные_ЕдиницаИзмерения_Include()
	
	Перем Стандартные_ЕдиницаИзмерения_Include; // Возвращаемое значение
	
	ООП_ЗарегистрироватьКласс(""Стандартные.ЕдиницаИзмерения"", ""Структура"");		
	
	Возврат Стандартные_ЕдиницаИзмерения_Include;
	
КонецФункции // Стандартные_ЕдиницаИзмерения_Include

#КонецОбласти //class_Стандартные_ЕдиницаИзмерения//
#Область class_Стандартные_Подразделение
// public
Функция Стандартные_Подразделение_Наименование(Знач Подразделение, Значение = Неопределено) Экспорт
	
	Перем Стандартные_Подразделение_Наименование; // Возвращаемое значение
	
	Если ( Неопределено <> Значение ) Тогда
		Подразделение.Наименование = Значение;
	КонецЕсли; 
	
	Стандартные_Подразделение_Наименование = Подразделение.Наименование;
	
	Возврат Стандартные_Подразделение_Наименование;
	
КонецФункции
Функция Стандартные_Подразделение_Представление(Знач Подразделение) Экспорт
	
	Перем Стандартные_Подразделение_Представление; // Возвращаемое значение
	
	Стандартные_Подразделение_Представление = ЭтотОбъект.Стандартные_Подразделение_Наименование(Подразделение);
	
	Возврат Стандартные_Подразделение_Представление;
	
КонецФункции
// protected
Функция Стандартные_Подразделение(Знач Стандартные_Подразделение)
	
	Стандартные_Подразделение.Вставить(""Ссылка"");
	Стандартные_Подразделение.Вставить(""Наименование"");
	
	Возврат Стандартные_Подразделение;
	
КонецФункции
Функция Стандартные_Подразделение_Include()
	
	Перем Стандартные_Подразделение_Include; // Возвращаемое значение
	
	ООП_ЗарегистрироватьКласс(""Стандартные.Подразделение"", ""Структура"");		
	
	Возврат Стандартные_Подразделение_Include;
	
КонецФункции // Стандартные_Подразделение_Include

#КонецОбласти //class_Стандартные_Подразделение//
#Область class_Стандартные_ФизическоеЛицо

// public
Функция Стандартные_ФизическоеЛицо(Знач Стандартные_ФизическоеЛицо) Экспорт
	
	Стандартные_ФизическоеЛицо.Вставить(""Ссылка"");
	Стандартные_ФизическоеЛицо.Вставить(""Должность"",  ООП_new(""Стандартные.Должность""));
	Стандартные_ФизическоеЛицо.Вставить(""ФИО"",        ООП_new(""Стандартные.ФИО""));
	Стандартные_ФизическоеЛицо.Вставить(""Пол"");
	
	Возврат Стандартные_ФизическоеЛицо;
	
КонецФункции
Функция Стандартные_ФизическоеЛицо_Представление(Знач this)
	Перем Стандартные_ФизическоеЛицо_Представление; // Возвращаемое значение
	
	Стандартные_ФизическоеЛицо_Представление = Стандартные_ФИО_ФамилияИмяОтчество(this.ФИО);
	
	Возврат Стандартные_ФизическоеЛицо_Представление;
	
КонецФункции

Функция Стандартные_ФизическоеЛицо_Include()
	
	Перем Стандартные_ФизическоеЛицо_Include; // Возвращаемое значение
	
	ООП_include(""Стандартные.Должность"");
	ООП_include(""Стандартные.ФИО"");
	
	ООП_ЗарегистрироватьКласс(""Стандартные.ФизическоеЛицо"", ""Структура"");		
	
	Возврат Стандартные_ФизическоеЛицо_Include;
	
КонецФункции // Стандартные_ФизическоеЛицо_Include

#КонецОбласти //class_Стандартные_ФизическоеЛицо//
#Область class_Стандартные_РасчетныйСчет

// protected
Функция Стандартные_РасчетныйСчет(Знач Стандартные_РасчетныйСчет)
	
	Стандартные_РасчетныйСчет.Вставить(""Номер"");
	Стандартные_РасчетныйСчет.Вставить(""Банк"", ООП_new(""Стандартные.Банк""));
	
	Возврат Стандартные_РасчетныйСчет;
	
КонецФункции
Функция Стандартные_РасчетныйСчет_Include()
	
	Перем Стандартные_РасчетныйСчет_Include; // Возвращаемое значение
	
	ООП_include(""Стандартные.Банк"");
	
	ООП_ЗарегистрироватьКласс(""Стандартные.РасчетныйСчет"", ""Структура"");		
	
	Возврат Стандартные_РасчетныйСчет_Include;
	
КонецФункции // Стандартные_РасчетныйСчет_Include

#КонецОбласти //class_Стандартные_РасчетныйСчет//
#Область class_Стандартные_Банк

// protected
Функция Стандартные_Банк(Знач Стандартные_Банк)
	
	Стандартные_Банк.Вставить(""Наименование"");
	Стандартные_Банк.Вставить(""БИК"");
	Стандартные_Банк.Вставить(""Город"");
	Стандартные_Банк.Вставить(""КорреспондентскийСчет"");
	
	Возврат Стандартные_Банк;
	
КонецФункции
Функция Стандартные_Банк_Include()
	
	Перем Стандартные_Банк_Include; // Возвращаемое значение
	
	ООП_ЗарегистрироватьКласс(""Стандартные.Банк"", ""Структура"");		
	
	Возврат Стандартные_Банк_Include;
	
КонецФункции // Стандартные_Банк_Include

#КонецОбласти //class_Стандартные_Банк//
#Область class_Стандартные_Спецификация

// protected
Функция Стандартные_Спецификация(Знач Стандартные_Спецификация)
	
	Стандартные_Спецификация.Вставить(""Строки"", Новый Массив);
	
	Возврат Стандартные_Спецификация;
	
КонецФункции
Функция Стандартные_Спецификация_Include()
	
	Перем Стандартные_Спецификация_Include; // Возвращаемое значение
	
	ООП_include(""Стандартные.СтрокаСпецификации"");
	ООП_ЗарегистрироватьКласс(""Стандартные.Спецификация"", ""Структура"");		
	
	Возврат Стандартные_Спецификация_Include;
	
КонецФункции // Стандартные_Спецификация_Include

#КонецОбласти //class_Стандартные_Спецификация//
#Область class_Стандартные_СтрокаСпецификации

// protected
Функция Стандартные_СтрокаСпецификации(Знач Стандартные_СтрокаСпецификации)
	
	Стандартные_СтрокаСпецификации.Вставить(""НомерСтроки"");
	Стандартные_СтрокаСпецификации.Вставить(""Наименование"");
	Стандартные_СтрокаСпецификации.Вставить(""ЕдиницаИзмерения"");
	Стандартные_СтрокаСпецификации.Вставить(""Цена"");
	Стандартные_СтрокаСпецификации.Вставить(""Количество"");
	Стандартные_СтрокаСпецификации.Вставить(""Сумма"");
	
	Возврат Стандартные_СтрокаСпецификации;
	
КонецФункции
Функция Стандартные_СтрокаСпецификации_Include()
	
	Перем Стандартные_СтрокаСпецификации_Include; // Возвращаемое значение
	
	ООП_ЗарегистрироватьКласс(""Стандартные.СтрокаСпецификации"", ""Структура"");		
	
	Возврат Стандартные_СтрокаСпецификации_Include;
	
КонецФункции // Стандартные_СпецификацияСтрока_Include

#КонецОбласти //class_Стандартные_СтрокаСпецификации/
#Область class_Стандартные_ФИО
// public
Функция Стандартные_ФИО_Фамилия(Знач ФИО, Значение = Неопределено) Экспорт
	
	Перем Стандартные_ФИО_Фамилия; // Возвращаемое значение
	
	Если ( Неопределено <> Значение ) Тогда
		
		ФИО.Фамилия = Значение;
		
		Стандартные_ФИО_Обновить(ФИО);
		
	КонецЕсли;	
	
	Стандартные_ФИО_Фамилия = ФИО.Фамилия;
	
	Возврат Стандартные_ФИО_Фамилия;
	
КонецФункции
Функция Стандартные_ФИО_Имя(Знач ФИО, Значение = Неопределено) Экспорт
	
	Перем Стандартные_ФИО_Имя; // Возвращаемое значение
	
	Если ( Неопределено <> Значение ) Тогда
		
		ФИО.Имя = Значение;
		
		Стандартные_ФИО_Обновить(ФИО);
		
	КонецЕсли;	
	
	Стандартные_ФИО_Имя = ФИО.Имя;
	
	Возврат Стандартные_ФИО_Имя;
	
КонецФункции
Функция Стандартные_ФИО_Отчество(Знач ФИО, Значение = Неопределено) Экспорт
	
	Перем Стандартные_ФИО_Отчество; // Возвращаемое значение
	
	Если ( Неопределено <> Значение ) Тогда
		
		ФИО.Отчество = Значение;
		
		Стандартные_ФИО_Обновить(ФИО);
		
	КонецЕсли;	
	
	Стандартные_ФИО_Отчество = ФИО.Отчество;
	
	Возврат Стандартные_ФИО_Отчество;
	
КонецФункции
Функция Стандартные_ФИО_ФамилияИО(Знач ФИО) Экспорт
	
	Перем Стандартные_ФИО_ФамилияИО; // Возвращаемое значение
	
	Стандартные_ФИО_ФамилияИО = ФИО.ФамилияИО;
	
	Возврат Стандартные_ФИО_ФамилияИО;
	
КонецФункции
Функция Стандартные_ФИО_ИОФамилия(Знач ФИО) Экспорт 
	
	Перем Стандартные_ФИО_ИОФамилия; // Возвращаемое значение
	
	Стандартные_ФИО_ИОФамилия = ФИО.ИОФамилия;
	
	Возврат Стандартные_ФИО_ИОФамилия;
	
КонецФункции
Функция Стандартные_ФИО_ФамилияИмяОтчество(Знач ФИО) Экспорт
	
	Перем Стандартные_ФИО_ФамилияИмяОтчество; // Возвращаемое значение
	
	Стандартные_ФИО_ФамилияИмяОтчество = ФИО.ФамилияИмяОтчество;
	
	Возврат Стандартные_ФИО_ФамилияИмяОтчество;
	
КонецФункции
Функция Стандартные_ФИО_Установить(Знач ФИО, Знач Значение) Экспорт
	
	Перем Стандартные_ФИО_Установить; // Возвращаемое значение
	Перем ЗначениеТип;
	Перем Части, КоличествоЧастей;
	
	Стандартные_ФИО_Установить = ФИО;
	
	Если ( Неопределено = Значение ) Тогда
		Возврат Стандартные_ФИО_Установить;
	КонецЕсли; 
	
	ЗначениеТип = ТипЗнч(Значение);
	ТипСтрока = Тип(""Строка"");
	ТипСтруктура = Тип(""Структура"");
	ТипСтрокаТаблицаЗначений = Тип(""СтрокаТаблицыЗначений"");
	
	Если (
		ЛОЖЬ
		ИЛИ ( ТипСтруктура = ЗначениеТип )
		ИЛИ ( ТипСтрокаТаблицаЗначений = ЗначениеТип ) )Тогда
		
		ФИО.Фамилия   = ?(Неопределено = Значение.Фамилия, """", Значение.Фамилия);
		ФИО.Имя       = ?(Неопределено = Значение.Имя, """", Значение.Имя);
		ФИО.Отчество  = ?(Неопределено = Значение.Отчество, """", Значение.Отчество);
		
	ИначеЕсли ( ТипСтрока = ЗначениеТип ) Тогда
		
		ФИО.Фамилия   = """";
		ФИО.Имя       = """";
		ФИО.Отчество  = """";

		Части = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивСлов(Значение, "" .""); // Версия < 8.3.6
		//Части = СтрРазделить(Значение, "" ."", Истина); // Версия >= 8.3.6
		
		КоличествоЧастей = Части.Количество();
		Если ( 0 < КоличествоЧастей ) Тогда
			ФИО.Фамилия = Части[0];
			Если ( 1 < КоличествоЧастей ) Тогда
				ФИО.Имя = Части[1];
				Если ( 2 < КоличествоЧастей ) Тогда
					ФИО.Отчество = Части[2];
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли;
		
	Иначе
		ВызватьИсключение ""Отсутствует реализация функции """"Стандартные_ФИО_Установить"""" для типа """""" + ЗначениеТип + """"""переменной """"Значение""""."";
	КонецЕсли; 
	
	Стандартные_ФИО_Обновить(ФИО);
	Стандартные_ФИО_Установить = ФИО;
	
	Возврат Стандартные_ФИО_Установить;
	
КонецФункции // Стандартные_ФИО_Установить()
Функция Стандартные_ФИО_Склонение(Знач ФИО, Знач Падеж = Неопределено, Знач Объект = Неопределено, Знач Пол = Неопределено) Экспорт

	Перем Стандартные_ФИО_Склонение; // Возвращаемое значение
	Перем Фамилия, Имя, Отчество;
	
	Стандартные_ФИО_Склонение = СклонениеПредставленийОбъектов.ПросклонятьФИО(Стандартные_ФИО_ФамилияИмяОтчество(ФИО), Падеж, Объект, Перечисления.ПолФизическогоЛица.Индекс(Пол) + 1); // accounting 3.0
	
	Возврат Стандартные_ФИО_Склонение;
	
КонецФункции // Стандартные_ФИО_Установить()
// protected
Функция Стандартные_ФИО(Знач ФИО)
	
	ФИО.Вставить(""Фамилия"", """");
	ФИО.Вставить(""Имя"", """");
	ФИО.Вставить(""Отчество"", """");
	ФИО.Вставить(""ФамилияИмяОтчество"", """");
	ФИО.Вставить(""ФамилияИО"", """");
	ФИО.Вставить(""ИОФамилия"", """");
	
	Возврат ФИО;
	
КонецФункции
Функция Стандартные_ФИО_Include()
	
	Перем Стандартные_Спецификация_Include; // Возвращаемое значение
	
	ООП_ЗарегистрироватьКласс(""Стандартные.ФИО"", ""Структура"");
	
	Возврат Стандартные_Спецификация_Include;
	
КонецФункции // Стандартные_Спецификация_Include
Функция Стандартные_ФИО_Обновить(Знач ФИО)
	
	Перем Стандартные_ФИО_Обновить; // Возвращаемое значение
	
	Перем ЕстьФамилия;
	Перем ЕстьИмя;
	Перем ЕстьОтчество;
	
	Стандартные_ФИО_Обновить = Истина;
	
	ЕстьФамилия    = НЕ ПустаяСтрока(ФИО.Фамилия);
	ЕстьИмя       = НЕ ПустаяСтрока(ФИО.Имя);
	ЕстьОтчество  = НЕ ПустаяСтрока(ФИО.Отчество);
	
	ФИО.ФамилияИО = """"
	+ ?(ЕстьФамилия, ФИО.Фамилия, """")
	+ ?(ЕстьИмя, ?(ЕстьФамилия, "" "", """") + Лев(ФИО.Имя, 1) + ""."", """")
	+ ?(ЕстьОтчество, ?(ЕстьИмя, """", ?(ЕстьФамилия, "" "", """")) + Лев(ФИО.Отчество, 1) + ""."", """")
	; 
	
	ФИО.ИОФамилия = """"
	+ ?(ЕстьИмя, Лев(ФИО.Имя, 1) + ""."", """")
	+ ?(ЕстьОтчество, Лев(ФИО.Отчество, 1) + ""."", """")
	+ ?(ЕстьФамилия, ?(ЕстьФамилия ИЛИ ЕстьОтчество, "" "", """") + ФИО.Фамилия, """")
	; 
	
	ФИО.ФамилияИмяОтчество = """"
	+ ?(ЕстьФамилия, ФИО.Фамилия, """")
	+ ?(ЕстьИмя, ?(ЕстьФамилия, "" "", """") + ФИО.Имя, """")
	+ ?(ЕстьОтчество, ?(ЕстьФамилия ИЛИ ЕстьИмя, "" "", """") + ФИО.Отчество, """")
	; 
	
	Возврат Стандартные_ФИО_Обновить;
	
КонецФункции

#КонецОбласти //class_Стандартные_ФИО//
#Область class_Стандартные_ЮрФизЛицо
// public
Функция Стандартные_ЮрФизЛицо_Наименование(Знач this, Знач Вид = ""Краткое"")

	Перем Стандартные_ЮрФизЛицо_Наименование; // Возвращаемое значение
	
	Стандартные_ЮрФизЛицо_Наименование = this.Наименования[Вид];
	
	Возврат Стандартные_ЮрФизЛицо_Наименование;
	
КонецФункции // Стандартные_ЮрФизЛицо_Представление()
Функция Стандартные_ЮрФизЛицо_Представление(Знач this)
	
	Перем Стандартные_ЮрФизЛицо_Представление; // Возвращаемое значение
	
	Если ( Неопределено = this.Представление) Тогда
		Стандартные_ЮрФизЛицо_Представление = Стандартные_ЮрФизЛицо_Наименование(this, this.ВидПредставления);
	Иначе
		Стандартные_ЮрФизЛицо_Представление = this.Представление;
	КонецЕсли; 
	
	Возврат Стандартные_ЮрФизЛицо_Представление;
	
КонецФункции // Стандартные_ЮрФизЛицо_Представление()

// protected
Функция Стандартные_ЮрФизЛицо(Знач this)
	
	this.Вставить(""Ссылка"");
	this.Вставить(""Представление"", Неопределено);
	
	this.Вставить(""Описание"");
	this.Вставить(""ИНН"");
	this.Вставить(""КПП"");
	this.Вставить(""КодПоОКПО"");
	this.Вставить(""ОГРН"");
	this.Вставить(""ЕГРИП"",              ООП_new(""Стандартные.ЕГРИП""));
	this.Вставить(""Наименования"",       ООП_new(""Стандартные.НаименованияЮрФизЛица""));
	
	this.Вставить(""ОтветственныеЛица"",  ООП_new(""Стандартные.ФизическиеЛица""));
	this.ОтветственныеЛица.Вставить(""Руководитель"", ООП_new(""Стандартные.ФизическоеЛицо""));
	this.ОтветственныеЛица.Вставить(""ГлавныйБухгалтер"", ООП_new(""Стандартные.ФизическоеЛицо""));
	
	this.Вставить(""Адреса"",             ООП_new(""Стандартные.Адреса""));
	this.Вставить(""РасчетныйСчет"",      ООП_new(""Стандартные.РасчетныйСчет""));
	this.Вставить(""ВидПредставления"", ""Краткое"");
	Возврат this;
	
КонецФункции
Функция Стандартные_ЮрФизЛицо_Include()
	
	Перем Стандартные_ЮрФизЛицо_Include; // Возвращаемое значение
	
	ООП_include(""Стандартные.ЕГРИП"");
	ООП_include(""Стандартные.НаименованияЮрФизЛица"");
	ООП_include(""Стандартные.ФизическиеЛица"");
	ООП_include(""Стандартные.Адреса"");
	ООП_include(""Стандартные.РасчетныйСчет"");
	
	ООП_ЗарегистрироватьКласс(""Стандартные.ЮрФизЛицо"", ""Структура"");
	
	Возврат Стандартные_ЮрФизЛицо_Include;
	
КонецФункции // Стандартные_ЮрФизЛицо_Include

#КонецОбласти //class_Стандартные_ЮрФизЛицо//
#Область class_Стандартные_ТранспортноеСредство

// public
Функция Стандартные_ТранспортноеСредство_Представление(Знач ТранспортноеСредство)
	
	Перем Стандартные_ТранспортноеСредство_Представление; // Возвращаемое значение
	
	Стандартные_ТранспортноеСредство_Представление = """" + ТранспортноеСредство.Марка + "", гос. номер "" + ТранспортноеСредство.РегистрационныйЗнак;
	
	Возврат Стандартные_ТранспортноеСредство_Представление;
	
КонецФункции // Стандартные_ТранспортноеСредство_Представление()

// protected
Функция Стандартные_ТранспортноеСредство(Знач ТранспортноеСредство)
	
	ТранспортноеСредство.Вставить(""Марка"", """");
	ТранспортноеСредство.Вставить(""РегистрационныйЗнак"", """");
	
	Возврат ТранспортноеСредство;
	
КонецФункции
Функция Стандартные_ТранспортноеСредство_Include()
	
	Перем Стандартные_Спецификация_Include; // Возвращаемое значение
	
	ООП_ЗарегистрироватьКласс(""Стандартные.ТранспортноеСредство"", ""Структура"");
	
	Возврат Стандартные_Спецификация_Include;
	
КонецФункции // Стандартные_Спецификация_Include
Функция Стандартные_ТранспортноеСредство_Обновить(Знач ТранспортноеСредство)
	
	Перем Стандартные_ТранспортноеСредство_Обновить; // Возвращаемое значение
	
	Перем ЕстьФамилия;
	Перем ЕстьИмя;
	Перем ЕстьОтчество;
	
	Стандартные_ТранспортноеСредство_Обновить = Истина;
	
	ЕстьФамилия    = НЕ (0 = СтрДлина(ТранспортноеСредство.Фамилия));
	ЕстьИмя       = НЕ (0 = СтрДлина(ТранспортноеСредство.Имя));
	ЕстьОтчество  = НЕ (0 = СтрДлина(ТранспортноеСредство.Отчество));
	
	ТранспортноеСредство.ФамилияИО =    """"
	+ ?(ЕстьФамилия, ТранспортноеСредство.Фамилия, """")
	+ ?(ЕстьИмя, ?(ЕстьФамилия, "" "", """") + Лев(ТранспортноеСредство.Имя, 1) + ""."", """")
	+ ?(ЕстьОтчество, ?(ЕстьИмя, """", ?(ЕстьФамилия, "" "", """")) + Лев(ТранспортноеСредство.Отчество, 1) + ""."", """")
	; 
	
	ТранспортноеСредство.ИОФамилия = """"
	+ ?(ЕстьИмя, Лев(ТранспортноеСредство.Имя, 1) + ""."", """")
	+ ?(ЕстьОтчество, Лев(ТранспортноеСредство.Отчество, 1) + ""."", """")
	+ ?(ЕстьФамилия, ?(ЕстьФамилия ИЛИ ЕстьОтчество, "" "", """") + ТранспортноеСредство.Фамилия, """")
	; 
	
	ТранспортноеСредство.ФамилияИмяОтчество = """"
	+ ?(ЕстьФамилия, ТранспортноеСредство.Фамилия, """")
	+ ?(ЕстьИмя, ?(ЕстьФамилия, "" "", """") + ТранспортноеСредство.Имя, """")
	+ ?(ЕстьОтчество, ?(ЕстьФамилия ИЛИ ЕстьИмя, "" "", """") + ТранспортноеСредство.Отчество, """")
	; 
	
	Возврат Стандартные_ТранспортноеСредство_Обновить;
	
КонецФункции

#КонецОбласти //class_Стандартные_ТранспортноеСредство//

// Соответствия
#Область class_Стандартные_Адреса

// protected
Функция Стандартные_Адреса(Знач Стандартные_Адреса)
	
	Стандартные_Адреса.Вставить(""Юридический"",  ООП_Новый(""Стандартные.Адрес""));
	//Стандартные_Адреса.Вставить(""Фактический"",  ООП_Новый(""Стандартные.Адрес""));
	Стандартные_Адреса.Вставить(""Почтовый"",     ООП_Новый(""Стандартные.Адрес""));
	//Стандартные_Адреса.Вставить(""Регистрации"",  ООП_Новый(""Стандартные.Адрес""));
	
	Возврат Стандартные_Адреса;
	
КонецФункции
Функция Стандартные_Адреса_Include()
	
	Перем Стандартные_Адреса_Include; // Возвращаемое значение
	
	ООП_include(""Стандартные.Адрес"");
	
	ООП_ЗарегистрироватьКласс(""Стандартные.Адреса"", ""Соответствие"");
	
	Возврат Стандартные_Адреса_Include;
	
КонецФункции // Стандартные_Адреса_Include

#КонецОбласти //class_Стандартные_Адреса//
#Область class_Стандартные_НаименованияЮрФизЛица

// protected
Функция Стандартные_НаименованияЮрФизЛица(Знач Стандартные_НаименованияЮрФизЛица)
	
	Стандартные_НаименованияЮрФизЛица.Вставить(""Полное"", """");
	Стандартные_НаименованияЮрФизЛица.Вставить(""Сокращенное"", """");
	Стандартные_НаименованияЮрФизЛица.Вставить(""Краткое"", """");
	
	Возврат Стандартные_НаименованияЮрФизЛица;
	
КонецФункции
Функция Стандартные_НаименованияЮрФизЛица_Include()
	
	Перем Стандартные_НаименованияЮрФизЛица_Include; // Возвращаемое значение
	
	ООП_ЗарегистрироватьКласс(""Стандартные.НаименованияЮрФизЛица"", ""Соответствие"");
	
	Возврат Стандартные_НаименованияЮрФизЛица_Include;
	
КонецФункции // Стандартные_НаименованияЮрФизЛица_Include

#КонецОбласти //class_Стандартные_НаименованияЮрФизЛица//
#Область class_Стандартные_ФизическиеЛица

// protected
Функция Стандартные_ФизическиеЛица(Знач Стандартные_ФизическиеЛица)
	
	Возврат Стандартные_ФизическиеЛица;
	
КонецФункции
Функция Стандартные_ФизическиеЛица_Include()
	
	Перем Стандартные_ФизическиеЛица_Include; // Возвращаемое значение
	
	ООП_include(""Стандартные.ФизическоеЛицо"");
	
	ООП_ЗарегистрироватьКласс(""Стандартные.ФизическиеЛица"", ""Соответствие"");
	
	Возврат Стандартные_ФизическиеЛица_Include;
	
КонецФункции // Стандартные_ФизическиеЛица_Include

#КонецОбласти //class_Стандартные_ФизическиеЛица//

#КонецОбласти //namespace_Стандартные//
#Область namespace_ООП

Функция ООП_Новый(Знач classname) Экспорт
	
	Перем ООП_Новый;
	
	ООП_Новый = ООП_new(classname);
	Возврат ООП_Новый;
	
КонецФункции	
Функция ООП_new(val classname)
	
	var ООП_new;
	
	if( Undefined = classname ) then
		return Undefined;		
	endif;
	
	ООП_validateclassname(classname);
	
	// Создадим объект соответствующего типа
	
	code = ""ООП_new = new "" + ООП_Classes[classname].type + "";"";
	execute(code);
	
	ООП_ClassInstances.Insert(ООП_new, new structure(""classname"", classname));
	
	ООП_new = ООП_constructor(ООП_new, classname);
	
	return ООП_new;
	
КонецФункции	
Функция ООП_validateclassname(Знач classname)
	
	Перем ООП_validateclassname; // Возвращаемое значение
	
	Если ( Неопределено = ООП_Classes[classname] ) Тогда
		ВызватьИсключение ""Неизвестный класс """""" + classname + """""""";	
	КонецЕсли; 
	
	Возврат ООП_validateclassname;
	
КонецФункции // ООП_validateclassname
Функция ООП_validateobject(Знач object)
	
	Перем ООП_validateobject; // Возвращаемое значение
	
	Если ( Неопределено = ООП_ClassInstances[object] ) Тогда
		ВызватьИсключение ""Объект """""" + Строка(object) + """""" незарегистрирован"";	
	КонецЕсли;
	
	Возврат ООП_validateobject;
	
КонецФункции // ООП_validateobject
Function ООП_validateclasshierarchy(val childclassname, val baseclassname)

	var ООП_validateclasshierarchy; // Return value
	var classname;
	
	classname = childclassname;
	while( true ) do
		
		if( baseclassname = classname ) then
			return true;
		endif;
		
		classname = ООП_Classes[classname].parentclassname;
		if( undefined = classname ) then
			break;
		endif
		
	enddo; 
	
	raise ""Класс """""" + childclassname + """""" не является потомком класса """""" + baseclassname+ """"""."";
	
	return ООП_validateclasshierarchy;

EndFunction // ООП_ischild() 
Функция ООП_ЗарегистрироватьКласс(classname, type, parentclassname = Неопределено)
	
	Перем ООП_ЗарегистрироватьКласс;
	
	Если ( Неопределено <> ООП_Classes.Получить(classname) ) Тогда
		ВызватьИсключение ""Объект с именем """""" + classname + """""" уже зарегистрирован."";
	Иначе
		ООП_Classes.Вставить(classname, Новый Структура(""classname, type, parentclassname"", classname, type, parentclassname));
	КонецЕсли; 
	
	Возврат ООП_ЗарегистрироватьКласс;
	
КонецФункции
Функция ООП_ДеревоКлассов(Знач classname);
	ВызватьИсключение ""Метод не реализован"";
	Возврат Неопределено;
КонецФункции
Функция ООП_include(Знач classname)
	
	Перем ООП_Include;
	
	Если ( Неопределено = ООП_Classes.Получить(classname) ) Тогда
		
		Код = ""ООП_Include = "" + ООП_ИмяКласса1С(classname) + ""_Include()"";
		Выполнить(Код);
		
	КонецЕсли;
	
	Возврат ООП_Include;
	
КонецФункции
function ООП_method(val object, val classname, val methodname = Undefined, val params = Undefined)

	var ООП_method; // Return value
	var index, paramsstring;
	
	paramsstring = ""object"";
	
	if( Undefined <> params ) then
		
		if( Type(""array"") <> TypeOf(params) ) then
			raise ""Неверный тип параметра params"";	
		endif;
		
		for index = 0 To params.UBound() do
			paramsstring = paramsstring + "", params["" + index + ""]"";
		enddo; 
		
	endif;
	
	code = ""ООП_method = ""
	+ СтрЗаменить(classname, ""."", ""_"") + ?(Undefined = methodname, """", ""_"" + methodname)
	+ ""("" + paramsstring + "")"";
	Execute(code);
	
	return ООП_method;

endfunction // ООП_method()
Функция ООП_constructor(Знач object, Знач classname)
	
	Перем ООП_constructor; // Возвращаемое значение
	
	Код = ""ООП_constructor = "" + СтрЗаменить(classname, ""."", ""_"") + ""(object)"";
	Выполнить(Код);
	
	Возврат ООП_constructor;
	
КонецФункции // ООП_constructor
Функция ООП_parent(val object, val baseclassname = undefined, val methodname = Undefined, val params = Undefined)
	// TODO: расширить возможность использования не только в конструкторе
	
	var ООП_parent;
	var classname, parentclassname;
	
	ООП_validateobject(object);
	
	classname = ООП_ClassInstances[object].classname;
	ООП_validateclassname(classname);
	if( undefined = baseclassname ) then
		baseclassname = classname;
	else
		ООП_validateclassname(baseclassname);
	endif;
	ООП_validateclasshierarchy(classname, baseclassname);
	
	parentclassname = ООП_Classes[baseclassname].parentclassname;
	if( Undefined = parentclassname ) then
		return Undefined;
	endif; 
	ООП_validateclassname(parentclassname);
	
	if( ТипЗнч(object) <> Тип(ООП_Classes[parentclassname].type) ) then
		raise ""Вызов конструктора несовместимого типа"";
	endif;
	
	ООП_method(object, parentclassname, methodname, params);
	
	return ООП_parent;
	
КонецФункции
Функция ООП_ИмяКласса1С(Знач classname)
	
	Перем ООП_ИмяКласса1С; // Возвращаемое значение
	
	ООП_ИмяКласса1С = СтрЗаменить(classname, ""."", ""_"");
	
	Возврат ООП_ИмяКласса1С;
	
КонецФункции // ООП_ИмяКласса1С

#КонецОбласти //namespace_ООП//
#Область СлужебныеПроцедурыИФункции

#Область СлужебныеПроцедурыИФункции_ОбщегоНазначения

Функция ЕстьЦифры(СтрокаПроверки)
	
	Для НомерСимвола = 1 По СтрДлина(СтрокаПроверки) Цикл
		КодСимвола = КодСимвола(СтрокаПроверки, НомерСимвола);
		Если КодСимвола >= 48 И КодСимвола <= 57 Тогда
			Возврат Истина;
		КонецЕсли; 		
	КонецЦикла; 
	
	Возврат Ложь;
	
КонецФункции
Функция ОтветственныеЛица(Организация, ДатаСреза, Подразделение = Неопределено)
	
	Перем ОтветственныеЛица;
	
	Если (Истина) Тогда // Для arautomation.1_1
		ОтветственныеЛица = ОбщегоНазначения.ОтветственныеЛица(Организация, ДатаСреза, Подразделение);
	КонецЕсли; 
	Если (Ложь) Тогда
		//Если (Истина) Тогда
		//
		//СобиратьПоОрганизации = Истина;
		//ОтветственныеЛица = Новый Структура(""Руководитель, РуководительДолжность, РуководительФИО, РуководительПредставление, 
		//|ГлавныйБухгалтер, ГлавныйБухгалтерДолжность, ГлавныйБухгалтерФИО, ГлавныйБухгалтерПредставление, 
		//|Кассир, КассирДолжность, КассирФИО, КассирПредставление,  
		//|ОтветственныйЗаРегистры, ОтветственныйЗаРегистрыДолжность, ОтветственныйЗаРегистрыФИО, ОтветственныйЗаРегистрыПредставление"");
		//
		//Если Организация <> Неопределено тогда
		//	
		//	ЗапросПоЛицам = Новый Запрос();
		//	ЗапросПоЛицам.УстановитьПараметр(""ДатаСреза"",   ДатаСреза);
		//	ЗапросПоЛицам.УстановитьПараметр(""Организация"", Организация);
		//	ЗапросПоЛицам.УстановитьПараметр(""ПризнакФизЛица"",   Перечисления.ЮрФизЛицо.ФизЛицо);
		//	
		//	ЗапросПоЛицам.Текст = ""ВЫБРАТЬ
		//	|   ФИОФизЛицСрезПоследних.Фамилия,
		//	|   ФИОФизЛицСрезПоследних.Имя,
		//	|   ФИОФизЛицСрезПоследних.Отчество,
		//	|   ФИОФизЛицСрезПоследних.ФизЛицо КАК ФизическоеЛицо
		//	|ИЗ
		//	|   РегистрСведений.ФИОФизЛиц.СрезПоследних(&ДатаСреза, ) КАК ФИОФизЛицСрезПоследних
		//	|       ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.Организации КАК Организации
		//	|       ПО ФИОФизЛицСрезПоследних.ФизЛицо = Организации.ИндивидуальныйПредприниматель
		//	|           И (Организации.Ссылка = &Организация)
		//	|           И (Организации.ЮрФизЛицо = &ПризнакФизЛица)"";
		//	
		//	Руководители = ЗапросПоЛицам.Выполнить().Выбрать();
		//	
		//	Пока Руководители.Следующий() Цикл
		//		
		//		ФИО = Новый Структура(""Фамилия, Имя, Отчество, Представление"");
		//		Если НЕ (НЕ ЗначениеЗаполнено(Руководители.Фамилия) или Руководители.Фамилия = NULL) Тогда
		//			ФИО.Фамилия = Руководители.Фамилия;
		//		КонецЕсли;
		//		Если НЕ (НЕ ЗначениеЗаполнено(Руководители.Имя) или Руководители.Имя = NULL) Тогда
		//			ФИО.Имя = Руководители.Имя;
		//		КонецЕсли;
		//		Если НЕ (НЕ ЗначениеЗаполнено(Руководители.Отчество) или Руководители.Отчество = NULL) Тогда
		//			ФИО.Отчество = Руководители.Отчество;
		//		КонецЕсли;
		//		//Представление = ОбщегоНазначения.ПолучитьФамилиюИмяОтчество(ФИО.Фамилия, ФИО.Имя, ФИО.Отчество);
		//		Представление = ПолучитьФамилиюИмяОтчество(ФИО.Фамилия, ФИО.Имя, ФИО.Отчество);
		//		
		//		ОтветственныеЛица.Руководитель               = Руководители.ФизическоеЛицо;
		//		ОтветственныеЛица.РуководительДолжность      = """";
		//		ОтветственныеЛица.РуководительФИО            = ФИО;
		//		ОтветственныеЛица.РуководительПредставление  = Представление;
		//		
		//	КонецЦикла;
		//	
		//	Если СобиратьПоОрганизации Тогда
		//		
		//		ЗапросПоЛицам.Текст = 
		//		""ВЫБРАТЬ
		//		|   ОтветственныеЛицаОрганизацийСрезПоследних.ОтветственноеЛицо,
		//		|   ОтветственныеЛицаОрганизацийСрезПоследних.ФизическоеЛицо,
		//		|   ОтветственныеЛицаОрганизацийСрезПоследних.Должность,
		//		|   ФИОФизЛицСрезПоследних.Фамилия,
		//		|   ФИОФизЛицСрезПоследних.Имя,
		//		|   ФИОФизЛицСрезПоследних.Отчество
		//		|ИЗ
		//		|   РегистрСведений.ОтветственныеЛицаОрганизаций.СрезПоследних(&ДатаСреза, СтруктурнаяЕдиница = &Организация) КАК ОтветственныеЛицаОрганизацийСрезПоследних
		//		|       ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ФИОФизЛиц.СрезПоследних(&ДатаСреза, ФизЛицо ССЫЛКА Справочник.ФизическиеЛица) КАК ФИОФизЛицСрезПоследних
		//		|       ПО ОтветственныеЛицаОрганизацийСрезПоследних.ФизическоеЛицо = ФИОФизЛицСрезПоследних.ФизЛицо"";
		//		Руководители = ЗапросПоЛицам.Выполнить().Выбрать();
		//	КонецЕсли;
		//	
		//	Пока Руководители.Следующий() Цикл
		//		
		//		ФИО = Новый Структура(""Фамилия, Имя, Отчество, Представление"");
		//		Если НЕ (НЕ ЗначениеЗаполнено(Руководители.Фамилия) или Руководители.Фамилия = NULL) Тогда
		//			ФИО.Фамилия = Руководители.Фамилия;
		//		КонецЕсли;
		//		Если НЕ (НЕ ЗначениеЗаполнено(Руководители.Имя) или Руководители.Имя = NULL) Тогда
		//			ФИО.Имя = Руководители.Имя;
		//		КонецЕсли;
		//		Если НЕ (НЕ ЗначениеЗаполнено(Руководители.Отчество) или Руководители.Отчество = NULL) Тогда
		//			ФИО.Отчество = Руководители.Отчество;
		//		КонецЕсли;
		//		//Представление = ОбщегоНазначения.ПолучитьФамилиюИмяОтчество(ФИО.Фамилия, ФИО.Имя, ФИО.Отчество);
		//		Представление = ПолучитьФамилиюИмяОтчество(ФИО.Фамилия, ФИО.Имя, ФИО.Отчество);
		//		
		//		Если Руководители.ОтветственноеЛицо      = Перечисления.ОтветственныеЛицаОрганизаций.Руководитель Тогда
		//			ОтветственныеЛица.Руководитель               = Руководители.ФизическоеЛицо;
		//			ОтветственныеЛица.РуководительДолжность      = Руководители.Должность;
		//			ОтветственныеЛица.РуководительФИО            = ФИО;
		//			ОтветственныеЛица.РуководительПредставление  = Представление;
		//			
		//		ИначеЕсли Руководители.ОтветственноеЛицо = Перечисления.ОтветственныеЛицаОрганизаций.ГлавныйБухгалтер Тогда
		//			ОтветственныеЛица.ГлавныйБухгалтер           = Руководители.ФизическоеЛицо;
		//			ОтветственныеЛица.ГлавныйБухгалтерДолжность  = Руководители.Должность;
		//			ОтветственныеЛица.ГлавныйБухгалтерФИО        = ФИО;
		//			ОтветственныеЛица.ГлавныйБухгалтерПредставление  = Представление;
		//			
		//		ИначеЕсли Руководители.ОтветственноеЛицо = Перечисления.ОтветственныеЛицаОрганизаций.Кассир Тогда
		//			ОтветственныеЛица.Кассир                     = Руководители.ФизическоеЛицо;
		//			ОтветственныеЛица.КассирДолжность            = Руководители.Должность;
		//			ОтветственныеЛица.КассирФИО                  = ФИО;
		//			ОтветственныеЛица.КассирПредставление  = Представление;
		//			
		//		ИначеЕсли Руководители.ОтветственноеЛицо = Перечисления.ОтветственныеЛицаОрганизаций.ОтветственныйЗаНалоговыеРегистры Тогда
		//			ОтветственныеЛица.ОтветственныйЗаРегистры    = Руководители.ФизическоеЛицо;
		//			ОтветственныеЛица.ОтветственныйЗаРегистрыДолжность      = Руководители.Должность;
		//			ОтветственныеЛица.ОтветственныйЗаРегистрыФИО = ФИО;
		//			ОтветственныеЛица.ОтветственныйЗаРегистрыПредставление  = Представление;
		//			
		//		КонецЕсли;
		//		
		//	КонецЦикла;
		//	
		//КонецЕсли; 
		//	
		//КонецЕсли;
	КонецЕсли;
	
	Возврат ОтветственныеЛица;

КонецФункции
Функция ПросклонятьФразу(Знач Фраза, Знач Падеж, Знач Пол)
	
	Перем ПодстрокаВПадеже;
	
	МассивПодстрок = РазложитьСтрокуВМассивПодстрок(Фраза, "" "");
	
	Результат = """";
	Для каждого Подстрока Из МассивПодстрок Цикл
		
		ПодстрокаВПадеже = """";
		Если Найти(Подстрока, ""."") > 0 ИЛИ ЕстьЦифры(Подстрока) Тогда
			ПодстрокаВПадеже = Подстрока;
		Иначе 
			ОбщегоНазначения.Просклонять(Подстрока, Падеж, ПодстрокаВПадеже, Пол)
			//УниверсальныеМеханизмы.Просклонять(глЗначениеПеременной(""глКомпонентаСклоненияФИО""), Подстрока, Падеж, Пол, ПодстрокаВПадеже); // hrmcorp.2.5
		КонецЕсли; 
		
		Результат = Результат + "" "" + ПодстрокаВПадеже;
		
	КонецЦикла;
	
	Возврат СокрЛП(Результат);
КонецФункции
Функция ПолучитьМакетПараметрыМассивИмен(ОбластьТабДокумента)
	МакетПараметрыМассивИмен = Новый Массив;
	Для НомерСтроки = 1 По ОбластьТабДокумента.ВысотаТаблицы Цикл
		Для НомерКолонки = 1 По ОбластьТабДокумента.ШиринаТаблицы Цикл
			Ячейка = ОбластьТабДокумента.Область(НомерСтроки, НомерКолонки, НомерСтроки, НомерКолонки);
			Если Ячейка.Заполнение = ТипЗаполненияОбластиТабличногоДокумента.Параметр Тогда
				//если такого параметра еще нет, то добавим его
				
				Если МакетПараметрыМассивИмен.Найти(Ячейка.Параметр) = Неопределено тогда
					МакетПараметрыМассивИмен.Добавить(Ячейка.Параметр);
				КонецЕсли;
			ИначеЕсли Ячейка.Заполнение = ТипЗаполненияОбластиТабличногоДокумента.Шаблон Тогда
				//выделим все параметры в шаблоне в отдельные строки
				
				ТекстШаблона = Ячейка.Текст;
				ТекстШаблона = СтрЗаменить(ТекстШаблона, ""["", Символы.ПС + ""["");
				ТекстШаблона = СтрЗаменить(ТекстШаблона, ""]"", Символы.ПС);
				Для Счетчик = 1 По СтрЧислоСтрок(ТекстШаблона) Цикл
					ТекСтрока = СтрПолучитьСтроку(ТекстШаблона, Счетчик);
					Если Лев(ТекСтрока, 1) = ""["" тогда
						ИмяПараметра = Сред(ТекСтрока, 2);
						//если такого параметра еще нет, то добавим его
						
						Если МакетПараметрыМассивИмен.Найти(ИмяПараметра) = Неопределено тогда
							МакетПараметрыМассивИмен.Добавить(ИмяПараметра);
						КонецЕсли;
					КонецЕсли;
				КонецЦикла; 
			КонецЕсли;//конец проверки, что в ячейке - текст, параметр или шаблон
			
		КонецЦикла;//конец обхода по колонкам
		
	КонецЦикла;//конец обхода по строкам
	
	Возврат МакетПараметрыМассивИмен;
КонецФункции	

#Область РаботаСоСтроками

Функция ДокументУдостоверяющийЛичностьВСтроку(ДокументУдостоверяющийЛичность)
	Возврат """"
	+ """"          + ДокументУдостоверяющийЛичность.Вид + "",""
	+ "" серия ""   + ДокументУдостоверяющийЛичность.Серия
	+ "" № ""       + ДокументУдостоверяющийЛичность.Номер + "",""
	+ "" выданный "" + Формат(ДокументУдостоверяющийЛичность.ДатаВыдачи, ""ДФ=dd.MM.yyyy"")
	+ "" ""         + ДокументУдостоверяющийЛичность.КемВыдан;
КонецФункции
Функция ПредметИсчисленияПрописью(Знач Число, Знач Валюта, Знач ФорматЧисла = """")
	Перем Результат;
	
	Если ПустаяСтрока(ФорматЧисла) Тогда
		Результат = """";
	Иначе
		Результат = Формат(Число, ""ЧН=0"" + ФорматЧисла) + "" "";
	КонецЕсли;
	
	Если Тип(""Строка"") = ТипЗнч(Валюта) Тогда
		ПараметрыПредметаИсчисления = Валюта;
	Иначе
		ПараметрыПредметаИсчисления = Валюта.ПараметрыПрописиНаРусском;
	КонецЕсли; 
	
	МассивПредставлений = Новый Массив;
	
	Позиция = Найти(ПараметрыПредметаИсчисления, "","");
	Пока Позиция > 0 Цикл
		Значение = СокрЛП(Лев(ПараметрыПредметаИсчисления, Позиция-1));
		ПараметрыПредметаИсчисления = Сред(ПараметрыПредметаИсчисления, Позиция + 1);
		МассивПредставлений.Добавить(Значение);
		Позиция = Найти(ПараметрыПредметаИсчисления, "","");
	КонецЦикла;
	
	Если СтрДлина(ПараметрыПредметаИсчисления) > 0 Тогда
		Значение = СокрЛП(ПараметрыПредметаИсчисления);
		МассивПредставлений.Добавить(Значение);
	КонецЕсли;	
	
	Если Число >= 100 Тогда
		Число = Число - Цел(Число / 100)*100;
	КонецЕсли;
	
	Если Число > 20 Тогда
		Число = Число - Цел(Число/10)*10;
	КонецЕсли;
	
	Если Число = 1 Тогда
		Результат = Результат + МассивПредставлений[0];
	ИначеЕсли Число > 1 и Число < 5 Тогда
		Результат = Результат + МассивПредставлений[1];
	Иначе
		Результат = Результат + МассивПредставлений[2];
	КонецЕсли;
	
	Возврат Результат;	
	
КонецФункции
Функция РазложитьСтрокуВМассивПодстрок(Знач Стр, Разделитель = "","") Экспорт
	
	Возврат СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Стр, Разделитель);
	
КонецФункции // глРазложить

#КонецОбласти //РаботаСоСтроками//
#Область ФорматированиеСумм

// Функция формирует представление суммы прописью в указанной валюте
//
// Возвращаемое значение:
//  Строка - сумма прописью
//
Функция СформироватьСуммуПрописью(Сумма, Валюта) Экспорт
	
	Если Тип(""Строка"") = ТипЗнч(Валюта) Тогда
		ПараметрыПрописиВалюты = Валюта;
	Иначе
		ПараметрыПрописиВалюты = Валюта.ПараметрыПрописиНаРусском;
	КонецЕсли; 
	
	Если """" = ПараметрыПрописиВалюты Тогда
		Возврат ФорматСумм(Сумма);
	Иначе
		Возврат ЧислоПрописью(Сумма, ""L=ru_RU"", ПараметрыПрописиВалюты);
	КонецЕсли;
	
КонецФункции // СформироватьСуммуПрописью()

// Стандартная для данной конфигурации функция форматирования сумм
//
// Параметры: 
//  Сумма  - число, которое мы хотим форматировать, 
//  Валюта - ссылка на элемент справочника валют, если задан, то к в результирующую строку
//           будет добавлено представление валюты
//  ЧН     - строка, представляющая нулевое значение числа,
//  ЧРГ    - символ-разделитель групп целой части числа.
//
// Возвращаемое значение:
//  Отформатированная должным образом строковое представление суммы.
//
Функция ФорматСумм(Сумма, Валюта = Неопределено, ЧН = """", ЧРГ = """") Экспорт
	
	ФорматнаяСтрока = ""ЧЦ=15;ЧДЦ=2"" +
	?(ПустаяСтрока(ЧН), """", "";"" + ""ЧН="" + ЧН) +
	?(ПустаяСтрока(ЧРГ),"""", "";"" + ""ЧРГ="" + ЧРГ);
	РезультирующаяСтрока = СокрЛ(Формат(Сумма, ФорматнаяСтрока));
	
	Если Валюта <> Неопределено Тогда
		РезультирующаяСтрока = РезультирующаяСтрока + "" "" + СокрП(Валюта);
	КонецЕсли;
	
	Возврат РезультирующаяСтрока;
	
КонецФункции // ФорматСумм()

Функция ФорматСуммаПредметИсчисленияПрописью(Знач Сумма, Знач Валюта = Неопределено)
	Возврат
	ФорматСумм(Сумма, , ""0"") + "" "" + ПредметИсчисленияПрописью(Сумма, Валюта);
КонецФункции

Функция ФорматСуммаПредметИсчисленияПрописьюСуммаПрописью(Знач Сумма, Знач Валюта = Неопределено)
	Возврат
	ФорматСуммаПредметИсчисленияПрописью(Сумма, Валюта) + "" ("" + СформироватьСуммуПрописью(Сумма, Валюта) + "")"";
КонецФункции

#КонецОбласти //ФорматированиеСумм//

#КонецОбласти //СлужебныеПроцедурыИФункции_ОбщегоНазначения//

#КонецОбласти //СлужебныеПроцедурыИФункции//
#Область ОбластьОсновнойПрограммы

мДлинаЗемныхСуток = 24*60*60;

#Область ОбластьОсновнойПрограммы_ООП

ООП_Classes = new Map;
ООП_ClassInstances = new Map;

#КонецОбласти //ОбластьОсновнойПрограммы_ООП//

//ООП_Include(""ДополнительныеОтчетыИОбработки.СведенияОВнешнейОбработке"");
//ООП_Include(""ДополнительныеОтчетыИОбработки.КомандыПоставляемыеОбработкой"");
ООП_include(""МакетыИДанные"");
ООП_include(""Документ_ПриемНаРаботу"");
ООП_include(""ПФ_MXL_ТрудовойДоговорИТРВахтаРКС"");
ООП_include(""ПФ_MXL_ТрудовойДоговорИТРОсновнойГрафикРКС"");
ООП_include(""ПФ_MXL_ТрудовойДоговорИТРСовместительствоРКС"");
ООП_include(""ПФ_MXL_ТрудовойДоговорРабочиеВахтаРКС"");
ООП_include(""ПФ_MXL_ТрудовойДоговорРабочиеОсновнойГрафикРКС"");
ООП_include(""ПФ_MXL_ТрудовойДоговорСдельныеРасценки"");
ООП_include(""ПФ_MXL_ТрудовойДоговорВредники"");
ООП_include(""ПФ_MXL_ТрудовойДоговорВредникиЛьготники"");
#КонецОбласти //ОбластьОсновнойПрограммы//
"}
},
{0,
{"ДополнительныеОтчетыИОбработки Модуль Типовое",0,0,"","#Область ПрограммныйИнтерфейс

// Подключает и возвращает имя, под которым подключен внешний отчет или обработка.
// После подключения отчет или обработка регистрируется в программе под определенным именем,
// используя которое можно создавать объект или открывать формы отчета или обработки.
//
// Важно: проверка функциональной опции ""ИспользоватьДополнительныеОтчетыИОбработки""
// должна выполняться вызывающим кодом.
//
// Параметры:
//   Ссылка - СправочникСсылка.ДополнительныеОтчетыИОбработки - Подключаемая обработка.
//
// Возвращаемое значение: 
//   * Строка       - Имя подключенного отчета или обработки.
//   * Неопределено - Если передана некорректная ссылка.
//
Функция ПодключитьВнешнююОбработку(Ссылка) Экспорт
	
	СтандартнаяОбработка = Истина;
	Результат = Неопределено;
	
	ИнтеграцияСТехнологиейСервиса.ПриПодключенииВнешнейОбработки(Ссылка, СтандартнаяОбработка, Результат);
	Если Не СтандартнаяОбработка Тогда
		Возврат Результат;
	КонецЕсли;
		
	// Проверка корректности переданных параметров.
	Если ТипЗнч(Ссылка) <> Тип(""СправочникСсылка.ДополнительныеОтчетыИОбработки"") 
		Или Ссылка = Справочники.ДополнительныеОтчетыИОбработки.ПустаяСсылка() Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Подключение
	#Если ТолстыйКлиентОбычноеПриложение Тогда
		ИмяОбработки = ПолучитьИмяВременногоФайла();
		ХранилищеОбработки = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Ссылка, ""ХранилищеОбработки"");
		ДвоичныеДанные = ХранилищеОбработки.Получить();
		ДвоичныеДанные.Записать(ИмяОбработки);
		Возврат ИмяОбработки;
	#КонецЕсли
	
	Вид = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Ссылка, ""Вид"");
	Если Вид = Перечисления.ВидыДополнительныхОтчетовИОбработок.Отчет
		Или Вид = Перечисления.ВидыДополнительныхОтчетовИОбработок.ДополнительныйОтчет Тогда
		Менеджер = ВнешниеОтчеты;
	Иначе
		Менеджер = ВнешниеОбработки;
	КонецЕсли;
	
	ПараметрыЗапуска = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Ссылка, ""БезопасныйРежим, ХранилищеОбработки"");
	АдресВоВременномХранилище = ПоместитьВоВременноеХранилище(ПараметрыЗапуска.ХранилищеОбработки.Получить());
	
	Если ОбщегоНазначения.ПодсистемаСуществует(""СтандартныеПодсистемы.ПрофилиБезопасности"") Тогда
		МодульРаботаВБезопасномРежиме = ОбщегоНазначения.ОбщийМодуль(""РаботаВБезопасномРежиме"");
		ИспользуютсяПрофилиБезопасности = МодульРаботаВБезопасномРежиме.ИспользуютсяПрофилиБезопасности();
	Иначе
		ИспользуютсяПрофилиБезопасности = Ложь;
	КонецЕсли;
	
	Если ИспользуютсяПрофилиБезопасности Тогда
		
		МодульРаботаВБезопасномРежимеСлужебный = ОбщегоНазначения.ОбщийМодуль(""РаботаВБезопасномРежимеСлужебный"");
		БезопасныйРежим = МодульРаботаВБезопасномРежимеСлужебный.РежимПодключенияВнешнегоМодуля(Ссылка);
		
		Если БезопасныйРежим = Неопределено Тогда
			БезопасныйРежим = Истина;
		КонецЕсли;
		
	Иначе
		
		БезопасныйРежим = ПолучитьФункциональнуюОпцию(""СтандартныеПодсистемыВМоделиСервиса"") Или ПараметрыЗапуска.БезопасныйРежим;
		
		Если БезопасныйРежим Тогда
			ЗапросРазрешений = Новый Запрос(
				""ВЫБРАТЬ ПЕРВЫЕ 1
				|	ДополнительныеОтчетыИОбработкиРазрешения.НомерСтроки,
				|	ДополнительныеОтчетыИОбработкиРазрешения.ВидРазрешения
				|ИЗ
				|	Справочник.ДополнительныеОтчетыИОбработки.Разрешения КАК ДополнительныеОтчетыИОбработкиРазрешения
				|ГДЕ
				|	ДополнительныеОтчетыИОбработкиРазрешения.Ссылка = &Ссылка"");
			ЗапросРазрешений.УстановитьПараметр(""Ссылка"", Ссылка);
			ЕстьРазрешений = Не ЗапросРазрешений.Выполнить().Пустой();
			
			РежимСовместимости = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Ссылка, ""РежимСовместимостиРазрешений"");
			Если РежимСовместимости = Перечисления.РежимыСовместимостиРазрешенийДополнительныхОтчетовИОбработок.Версия_2_2_2
				И ЕстьРазрешений Тогда
				БезопасныйРежим = Ложь;
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
	ЗаписатьПримечание(Ссылка, НСтр(""ru = 'Подключение, БезопасныйРежим = """"%1"""".'""), БезопасныйРежим);
	
	Если ОбщегоНазначения.ЕстьЗащитаОтОпасныхДействий() Тогда
		ИмяОбработки = Менеджер.Подключить(АдресВоВременномХранилище, , БезопасныйРежим,
			ОбщегоНазначения.ОписаниеЗащитыБезПредупреждений());
	Иначе
		ИмяОбработки = Менеджер.Подключить(АдресВоВременномХранилище, , БезопасныйРежим);
	КонецЕсли;
	
	Возврат ИмяОбработки;
	
КонецФункции

// Возвращает объект внешнего отчета или обработки.
//
// Важно: проверка функциональной опции ""ИспользоватьДополнительныеОтчетыИОбработки""
// должна выполняться вызывающим кодом.
//
// Параметры:
//   Ссылка - СправочникСсылка.ДополнительныеОтчетыИОбработки - Подключаемый отчет или обработка.
//
// Возвращаемое значение: 
//   * ВнешняяОбработкаОбъект - Объект подключенной обработки.
//   * ВнешнийОтчетОбъект     - Объект подключенного отчета.
//   * Неопределено           - Если передана некорректная ссылка.
//
Функция ОбъектВнешнейОбработки(Ссылка) Экспорт
	
	СтандартнаяОбработка = Истина;
	Результат = Неопределено;
	
	ИнтеграцияСТехнологиейСервиса.ПриСозданииВнешнейОбработки(Ссылка, СтандартнаяОбработка, Результат);
	Если Не СтандартнаяОбработка Тогда
		Возврат Результат;
	КонецЕсли;
	
	// Подключение
	ИмяОбработки = ПодключитьВнешнююОбработку(Ссылка);
	
	// Проверка корректности переданных параметров.
	Если ИмяОбработки = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Получение экземпляра объекта.
	Если Ссылка.Вид = Перечисления.ВидыДополнительныхОтчетовИОбработок.Отчет
		ИЛИ Ссылка.Вид = Перечисления.ВидыДополнительныхОтчетовИОбработок.ДополнительныйОтчет Тогда
		Менеджер = ВнешниеОтчеты;
	Иначе
		Менеджер = ВнешниеОбработки;
	КонецЕсли;
	
	Возврат Менеджер.Создать(ИмяОбработки);
	
КонецФункции

// Формирует печатную форму по внешнему источнику.
//
// Параметры:
//   ДополнительнаяОбработкаСсылка - СправочникСсылка.ДополнительныеОтчетыИОбработки - внешняя обработка.
//   ПараметрыИсточника            - Структура - структура со свойствами:
//       * ИдентификаторКоманды - Строка - список макетов, перечисленных через запятую.
//       * ОбъектыНазначения    - Массив
//   КоллекцияПечатныхФорм - ТаблицаЗначений - сформированные табличные документы (возвращаемый параметр).
//   ОбъектыПечати         - СписокЗначений  - соответствие между объектами и именами областей печати
//                                             табличного документа. Значение - Объект, представление - имя области,
//                                             в которой был выведен объект (возвращаемый параметр).
//   ПараметрыВывода       - Структура       - дополнительные параметры сформированных табличных документов
//                                             (возвращаемый параметр).
//
Процедура ПечатьПоВнешнемуИсточнику(ДополнительнаяОбработкаСсылка, ПараметрыИсточника, КоллекцияПечатныхФорм,
	ОбъектыПечати, ПараметрыВывода) Экспорт
	
	Если ОбщегоНазначения.ПодсистемаСуществует(""СтандартныеПодсистемы.Печать"") Тогда
		МодульУправлениеПечатью = ОбщегоНазначения.ОбщийМодуль(""УправлениеПечатью"");
		МодульУправлениеПечатью.ПечатьПоВнешнемуИсточнику(
			ДополнительнаяОбработкаСсылка,
			ПараметрыИсточника,
			КоллекцияПечатныхФорм,
			ОбъектыПечати,
			ПараметрыВывода);
	КонецЕсли;
	
КонецПроцедуры

// Формирует шаблон сведений о внешнем отчете или обработке для последующего заполнения.
//
// Параметры:
//   ВерсияБСП - Строка - версия Библиотеки стандартных подсистем, на которую рассчитывают механизмы внешней обработки
//                        или отчета. См. СтандартныеПодсистемыСервер.ВерсияБиблиотеки.
//
// Возвращаемое значение:
//   Структура - параметры внешнего отчета или обработки:
//       * Вид - Строка - Вид внешнего отчета или обработки. Для указания вида рекомендуется использовать функции
//           ДополнительныеОтчетыИОбработкиКлиентСервер.ВидОбработки<ИмяВида>.
//           Также вид можно указать явно:
//           ""ПечатнаяФорма"",
//           ""ЗаполнениеОбъекта"",
//           ""СозданиеСвязанныхОбъектов"",
//           ""Отчет"",
//           ""ШаблонСообщения"",
//           ""ДополнительнаяОбработка"" или
//           ""ДополнительныйОтчет"".
//       
//       * Версия - Строка - Версия отчета или обработки (далее - обработки).
//           Задается в формате: ""<Старший номер>.<Младший номер>"".
//       
//       * Назначение - Массив - Полные имена объектов конфигурации (Строка), для которых предназначен эта обработка.
//                               Необязательное свойство.
//       
//       * Наименование - Строка - Представление для администратора (наименование элемента справочника).
//                                 Если не заполнено, то берется представление объекта метаданных внешней обработки.
//                                 Необязательное свойство. 
//       
//       * БезопасныйРежим - Булево - Признак подключения внешней обработки в безопасном режиме.
//                                    Значение по умолчанию Истина (обработка будет выполняться безопасно).
//                                    В безопасном режиме:
//                                    Игнорируется привилегированный режим.
//                                    Запрещены внешние по отношению к платформе 1С:Предприятия действия:
//                                      COM;
//                                      Загрузка внешних компонентов;
//                                      Запуск внешних приложений и команд операционной системы;
//                                      Доступ к файловой системе, кроме временных файлов;
//                                      Доступ к Интернету.
//                                    Необязательное свойство.
//       
//       * Разрешения - Массив - Дополнительные разрешения, необходимые внешней обработке при работе в безопасном режиме.
//                               Элемент массива - ОбъектXDTO - разрешение типа
//                               {http://www.1c.ru/1cFresh/ApplicationExtensions/Permissions/a.b.c.d}PermissionBase.
//                               Для формирования описания разрешения рекомендуется использовать функции
//                               РаботаВБезопасномРежиме.Разрешение<ВидРазрешения>(<ПараметрыРазрешения>).
//                               Необязательное свойство.
//       
//       * Информация - Строка - Краткая информация о внешней обработке.
//                               В этом параметре для администратора рекомендуется дать описание ее возможностей.
//                               Если не заполнено, то берется комментарий объекта метаданных внешней обработки.
//       
//       * ВерсияБСП - Строка - Необязательный. Версия библиотеки, на которую рассчитывают механизмы внешней обработки.
//                              См. СтандартныеПодсистемыСервер.ВерсияБиблиотеки.
//                              Необязательное свойство.
//       
//       * ОпределитьНастройкиФормы - Булево - только для дополнительных отчетов, подключенных к общей форме ФормаОтчета.
//                                             Позволяет переопределять некоторые настройки общей формы отчета и 
//                                             подписываться на ее события.
//                                             Если Истина, то в модуле объекта отчета следует определить процедуру по шаблону:
//           
//           // Настройки общей формы отчета подсистемы ""Варианты отчетов"".
//           //
//           // Параметры:
//           //   Форма - УправляемаяФорма, Неопределено - Форма отчета или форма настроек отчета.
//           //       Неопределено когда вызов без контекста.
//           //   КлючВарианта - Строка, Неопределено - Имя предопределенного
//           //       или уникальный идентификатор пользовательского варианта отчета.
//           //       Неопределено когда вызов без контекста.
//           //   Настройки - Структура - см. возвращаемое значение
//           //       ОтчетыКлиентСервер.ПолучитьНастройкиОтчетаПоУмолчанию().
//           //
//           Процедура ОпределитьНастройкиФормы(Форма, КлючВарианта, Настройки) Экспорт
//           	// Код процедуры.
//           КонецПроцедуры
//           
//           Подробнее см. в документации к подсистемам ""Дополнительные отчеты и обработки"" и ""Варианты отчетов"".
//           Необязательное свойство.
//       
//       * Команды - ТаблицаЗначений - Настройки команд, поставляемых внешней обработкой (необязательно для отчетов):
//           ** Идентификатор - Строка - Внутреннее имя команды. Для внешних печатных форм (когда Вид = ""ПечатнаяФорма""):
//                 Идентификатор может содержать имена одной или нескольких команд печати,
//                 разделенных запятыми. Подробнее см. описание колонки Идентификатор
//                 в функции СоздатьКоллекциюКомандПечати() общего модуля УправлениеПечатью.
//           ** Представление - Строка - Пользовательское представление команды.
//           ** Использование - Строка - Тип команды:
//               ""ВызовКлиентскогоМетода"",
//               ""ВызовСерверногоМетода"",
//               ""ЗаполнениеФормы"",
//               ""ОткрытиеФормы"" или
//               ""СценарийВБезопасномРежиме"".
//               Для получения типов команд рекомендуется использовать функции
//               ДополнительныеОтчетыИОбработкиКлиентСервер.ТипКоманды<ИмяТипа>.
//               В комментариях к этим функциям также даны шаблоны процедур-обработчиков команд.
//           ** ПоказыватьОповещение - Булево - если Истина, то при запуске команды выводится оповещение ""Команда выполняется..."".
//              Действует для всех типов команд, кроме команд по открытию формы (Использование = ""ОткрытиеФормы"").
//           ** Модификатор - Строка - Дополнительная классификация команды.
//               Для внешних печатных форм (когда Вид = ""ПечатнаяФорма""):
//                 ""ПечатьMXL"" - для печатных форм на основе табличных макетов.
//               Для загрузки данных из файла (когда Вид = ""ПечатнаяФорма"" и Использование = ""ЗагрузкаДанныхИзФайла""):
//                 Модификатор является обязательным для заполнения
//                 и должен содержать полное имя объекта метаданных (справочника),
//                 для которого выполняется загрузка данных.
//           ** Скрыть - Булево - Необязательный. Признак того, что это служебная команда.
//               Если установить в значение Истина, то команда скрывается в карточке дополнительного объекта.
//
Функция СведенияОВнешнейОбработке(ВерсияБСП = """") Экспорт
	ПараметрыРегистрации = Новый Структура;
	
	ПараметрыРегистрации.Вставить(""Вид"", """");
	ПараметрыРегистрации.Вставить(""Версия"", ""0.0"");
	ПараметрыРегистрации.Вставить(""Назначение"", Новый Массив);
	ПараметрыРегистрации.Вставить(""Наименование"", Неопределено);
	ПараметрыРегистрации.Вставить(""БезопасныйРежим"", Истина);
	ПараметрыРегистрации.Вставить(""Информация"", Неопределено);
	ПараметрыРегистрации.Вставить(""ВерсияБСП"", ВерсияБСП);
	ПараметрыРегистрации.Вставить(""ОпределитьНастройкиФормы"", Ложь);
	
	РеквизитыТабличнойЧасти = Метаданные.Справочники.ДополнительныеОтчетыИОбработки.ТабличныеЧасти.Команды.Реквизиты;
	
	ТаблицаКоманд = Новый ТаблицаЗначений;
	ТаблицаКоманд.Колонки.Добавить(""Представление"", РеквизитыТабличнойЧасти.Представление.Тип);
	ТаблицаКоманд.Колонки.Добавить(""Идентификатор"", РеквизитыТабличнойЧасти.Идентификатор.Тип);
	ТаблицаКоманд.Колонки.Добавить(""Использование"", Новый ОписаниеТипов(""Строка""));
	ТаблицаКоманд.Колонки.Добавить(""ПоказыватьОповещение"", РеквизитыТабличнойЧасти.ПоказыватьОповещение.Тип);
	ТаблицаКоманд.Колонки.Добавить(""Модификатор"", РеквизитыТабличнойЧасти.Модификатор.Тип);
	ТаблицаКоманд.Колонки.Добавить(""Скрыть"",      РеквизитыТабличнойЧасти.Скрыть.Тип);
	ТаблицаКоманд.Колонки.Добавить(""ЗаменяемыеКоманды"", РеквизитыТабличнойЧасти.ЗаменяемыеКоманды.Тип);
	
	ПараметрыРегистрации.Вставить(""Команды"", ТаблицаКоманд);
	ПараметрыРегистрации.Вставить(""Разрешения"", Новый Массив);
	
	Возврат ПараметрыРегистрации;
КонецФункции

// Выполняет команду обработки и возвращает результат ее выполнения.
//
// Важно: проверка функциональной опции ""ИспользоватьДополнительныеОтчетыИОбработки""
// должна выполняться вызывающим кодом.
//
// Параметры:
//   ПараметрыКоманды - Структура - Параметры, с которыми выполняется команда.
//       * ДополнительнаяОбработкаСсылка - СправочникСсылка.ДополнительныеОтчетыИОбработки - Элемент справочника.
//       * ИдентификаторКоманды - Строка - Имя выполняемой команды.
//       * ОбъектыНазначения    - Массив - Ссылки объектов, для которых выполняется обработка. Обязательный для
//                                         назначаемых обработок.
//   АдресРезультата - Строка - Необязательный. Адрес временного хранилища по которому будет размещен результат
//                              выполнения.
//
// Возвращаемое значение:
//   Структура - Результат выполнения, который далее передается на клиент.
//   Неопределено - Если был передан АдресРезультата.
//
Функция ВыполнитьКоманду(ПараметрыКоманды, АдресРезультата = Неопределено) Экспорт
	
	Если ТипЗнч(ПараметрыКоманды.ДополнительнаяОбработкаСсылка) <> Тип(""СправочникСсылка.ДополнительныеОтчетыИОбработки"")
		Или ПараметрыКоманды.ДополнительнаяОбработкаСсылка = Справочники.ДополнительныеОтчетыИОбработки.ПустаяСсылка() Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ВнешнийОбъект = ОбъектВнешнейОбработки(ПараметрыКоманды.ДополнительнаяОбработкаСсылка);
	ИдентификаторКоманды = ПараметрыКоманды.ИдентификаторКоманды;
	РезультатВыполнения = ВыполнитьКомандуВнешнегоОбъекта(ВнешнийОбъект, ИдентификаторКоманды, ПараметрыКоманды, АдресРезультата);
	
	Возврат РезультатВыполнения;
	
КонецФункции

// Выполняет команду обработки напрямую из формы внешнего объекта и возвращает результат ее выполнения.
// Пример использования - см. ДополнительныеОтчетыИОбработкиКлиент.ВыполнитьКомандуВФоне().
//
// Важно: проверка функциональной опции ""ИспользоватьДополнительныеОтчетыИОбработки""
// должна выполняться вызывающим кодом.
//
// Параметры:
//   ИдентификаторКоманды - Строка    - Имя команды как оно задано в функции СведенияОВнешнейОбработке() модуля объекта.
//   ПараметрыКоманды     - Структура - Параметры выполнения команды.
//                                      См. ДополнительныеОтчетыИОбработкиКлиент.ВыполнитьКомандуВФоне().
//   Форма                - УправляемаяФорма - Форма, в которую необходимо вернуть результат.
//
// Возвращаемое значение:
//   Структура - для служебного использования.
//
Функция ВыполнитьКомандуИзФормыВнешнегоОбъекта(ИдентификаторКоманды, ПараметрыКоманды, Форма) Экспорт
	
	ВнешнийОбъект = Форма.РеквизитФормыВЗначение(""Объект"");
	РезультатВыполнения = ВыполнитьКомандуВнешнегоОбъекта(ВнешнийОбъект, ИдентификаторКоманды, ПараметрыКоманды, Неопределено);
	Возврат РезультатВыполнения;
	
КонецФункции

// Формирует список разделов, в которых доступна команда вызова дополнительных отчетов.
//
// Возвращаемое значение: 
//   Массив - массив объектов метаданных Подсистема - метаданные разделов, в которые выведен список команд
//                                                    дополнительных отчетов.
//
Функция РазделыДополнительныхОтчетов() Экспорт
	РазделыМетаданные = Новый Массив;
	
	ДополнительныеОтчетыИОбработкиПереопределяемый.ОпределитьРазделыСДополнительнымиОтчетами(РазделыМетаданные);
	
	Если ОбщегоНазначения.ПодсистемаСуществует(""СтандартныеПодсистемы.НастройкиПрограммы"") Тогда
		МодульОбработкиПанельАдминистрированияБСП = ОбщегоНазначения.ОбщийМодуль(""Обработки.ПанельАдминистрированияБСП"");
		МодульОбработкиПанельАдминистрированияБСП.ПриОпределенииРазделовСДополнительнымиОтчетами(РазделыМетаданные);
	КонецЕсли;
	
	Возврат РазделыМетаданные;
КонецФункции

// Формирует список разделов, в которых доступна команда вызова дополнительных обработок.
//
// Возвращаемое значение: 
//   Массив - массив объектов метаданных Подсистема - метаданные разделов, в которые выведен список команд дополнительных
//   обработок.
//
Функция РазделыДополнительныхОбработок() Экспорт
	РазделыМетаданные = Новый Массив;
	
	Если ОбщегоНазначения.ПодсистемаСуществует(""СтандартныеПодсистемы.НастройкиПрограммы"") Тогда
		МодульОбработкиПанельАдминистрированияБСП = ОбщегоНазначения.ОбщийМодуль(""Обработки.ПанельАдминистрированияБСП"");
		МодульОбработкиПанельАдминистрированияБСП.ПриОпределенииРазделовСДополнительнымиОбработками(РазделыМетаданные);
	КонецЕсли;
	
	ДополнительныеОтчетыИОбработкиПереопределяемый.ОпределитьРазделыСДополнительнымиОбработками(РазделыМетаданные);
	
	Возврат РазделыМетаданные;
КонецФункции

#Область УстаревшиеПроцедурыИФункции

// Устарела. Следует использовать ОбъектВнешнейОбработки.
//
// Важно: проверка функциональной опции ""ИспользоватьДополнительныеОтчетыИОбработки""
// должна выполняться вызывающим кодом.
//
// Параметры:
//   Ссылка - СправочникСсылка.ДополнительныеОтчетыИОбработки - Подключаемый отчет или обработка.
//
// Возвращаемое значение: 
//   * ВнешняяОбработкаОбъект - Объект подключенной обработки.
//   * ВнешнийОтчетОбъект     - Объект подключенного отчета.
//   * Неопределено           - Если передана некорректная ссылка.
//
Функция ПолучитьОбъектВнешнейОбработки(Ссылка) Экспорт
	
	Возврат ОбъектВнешнейОбработки(Ссылка);
	
КонецФункции

// Устарела. Следует использовать ПодключаемыеКоманды.ПриСозданииНаСервере.
//
// Параметры:
//   Форма - УправляемаяФорма - Форма.
//   ТипФормы - Строка - Тип формы.
//
Процедура ПриСозданииНаСервере(Форма, ТипФормы = Неопределено) Экспорт
	Возврат;
КонецПроцедуры

// Устарела. Следует использовать ПодключаемыеКоманды.ВыполнитьКоманду.
//
// Выполняет назначаемую команду контекстно из формы объекта назначения.
// Предназначена для вызова кодом этой подсистемы из формы элемента назначаемого объекта 
// (например, справочника или документа).
//
// Важно: проверка функциональной опции ""ИспользоватьДополнительныеОтчетыИОбработки""
// должна выполняться вызывающим кодом.
//
// Параметры:
//   Форма               - УправляемаяФорма - Форма, из которой вызвана команда.
//   ИмяЭлемента         - Строка           - Имя команды формы, которая была нажата.
//   РезультатВыполнения - Структура        - для служебного использования.
//
Процедура ВыполнитьНазначаемуюКомандуНаСервере(Форма, ИмяЭлемента, РезультатВыполнения = Неопределено) Экспорт
	
	Возврат;
	
КонецПроцедуры

#КонецОбласти

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

// Определяет список объектов метаданных, к которым может быть применена назначаемая обработка переданного вида.
//
// Параметры:
//   Вид - ПеречислениеСсылка.ВидыДополнительныхОтчетовИОбработок - Вид внешней обработки.
//
// Возвращаемое значение:
//   ТаблицаЗначений - Описание объектов метаданных.
//       * Метаданные - ОбъектМетаданных - Объект метаданных, подключенный к данному виду.
//       * ПолноеИмя  - Строка - Полное имя объекта метаданных, например ""Справочник.Валюты"".
//       * Ссылка     - СправочникСсылка.ИдентификаторыОбъектовМетаданных - Ссылка объекта метаданных.
//       * Вид        - Строка - Вид объекта метаданных.
//       * Представление       - Строка - Представление объекта метаданных.
//       * ПолноеПредставление - Строка - Представление имени и вида объекта метаданных.
//   Неопределено - Если передан некорректный Вид.
//
Функция ПодключенныеОбъектыМетаданных(Вид) Экспорт
	Результат = Новый ТаблицаЗначений;
	Результат.Колонки.Добавить(""Метаданные"");
	Результат.Колонки.Добавить(""ПолноеИмя"", Новый ОписаниеТипов(""Строка""));
	Результат.Колонки.Добавить(""Ссылка"", Новый ОписаниеТипов(""СправочникСсылка.ИдентификаторыОбъектовМетаданных, СправочникСсылка.ИдентификаторыОбъектовРасширений""));
	Результат.Колонки.Добавить(""Вид"", Новый ОписаниеТипов(""Строка""));
	Результат.Колонки.Добавить(""Представление"", Новый ОписаниеТипов(""Строка""));
	Результат.Колонки.Добавить(""ПолноеПредставление"", Новый ОписаниеТипов(""Строка""));
	
	Результат.Индексы.Добавить(""Ссылка"");
	Результат.Индексы.Добавить(""Вид"");
	Результат.Индексы.Добавить(""ПолноеИмя"");
	
	МассивТиповИлиМетаданных = Новый Массив;
	
	Если Вид = Перечисления.ВидыДополнительныхОтчетовИОбработок.ЗаполнениеОбъекта
		Или Вид = Перечисления.ВидыДополнительныхОтчетовИОбработок.Отчет
		Или Вид = Перечисления.ВидыДополнительныхОтчетовИОбработок.СозданиеСвязанныхОбъектов Тогда
		
		МассивТиповИлиМетаданных = Метаданные.ОпределяемыеТипы.ОбъектСДополнительнымиКомандами.Тип.Типы();
		
	ИначеЕсли Вид = Перечисления.ВидыДополнительныхОтчетовИОбработок.ШаблонСообщения Тогда
		
		Если ОбщегоНазначения.ПодсистемаСуществует(""СтандартныеПодсистемы.ШаблоныСообщений"") Тогда
			МодульШаблоныСообщенийСлужебный = ОбщегоНазначения.ОбщийМодуль(""ШаблоныСообщенийСлужебный"");
			МассивТиповИлиМетаданных = МодульШаблоныСообщенийСлужебный.ИсточникиШаблоновСообщений()
		Иначе
			Возврат Результат;
		КонецЕсли;
		
	ИначеЕсли Вид = Перечисления.ВидыДополнительныхОтчетовИОбработок.ПечатнаяФорма Тогда
		
		Если ОбщегоНазначения.ПодсистемаСуществует(""СтандартныеПодсистемы.Печать"") Тогда
			МодульУправлениеПечатью = ОбщегоНазначения.ОбщийМодуль(""УправлениеПечатью"");
			МассивТиповИлиМетаданных = МодульУправлениеПечатью.ИсточникиКомандПечати()
		Иначе
			Возврат Результат;
		КонецЕсли;
		
	ИначеЕсли Вид = Перечисления.ВидыДополнительныхОтчетовИОбработок.ДополнительнаяОбработка Тогда
		
		МассивТиповИлиМетаданных = РазделыДополнительныхОбработок();
		
	ИначеЕсли Вид = Перечисления.ВидыДополнительныхОтчетовИОбработок.ДополнительныйОтчет Тогда
		
		МассивТиповИлиМетаданных = РазделыДополнительныхОтчетов();
		
	Иначе
		
		Возврат Неопределено;
		
	КонецЕсли;
	
	Для Каждого ТипИлиМетаданные Из МассивТиповИлиМетаданных Цикл
		Если ТипЗнч(ТипИлиМетаданные) = Тип(""Тип"") Тогда
			ОбъектМетаданных = Метаданные.НайтиПоТипу(ТипИлиМетаданные);
			Если ОбъектМетаданных = Неопределено Тогда
				Продолжить;
			КонецЕсли;
		Иначе
			ОбъектМетаданных = ТипИлиМетаданные;
		КонецЕсли;
		
		СтрокаТаблицы = Результат.Добавить();
		СтрокаТаблицы.Метаданные = ОбъектМетаданных;
		
		Если ОбъектМетаданных = ДополнительныеОтчетыИОбработкиКлиентСервер.ИдентификаторРабочегоСтола() Тогда
			СтрокаТаблицы.ПолноеИмя = ДополнительныеОтчетыИОбработкиКлиентСервер.ИдентификаторРабочегоСтола();
			СтрокаТаблицы.Ссылка = Справочники.ИдентификаторыОбъектовМетаданных.ПустаяСсылка();
			СтрокаТаблицы.Вид = ""Подсистема"";
			СтрокаТаблицы.Представление = НСтр(""ru = 'Начальная страница'"");
		Иначе
			СтрокаТаблицы.ПолноеИмя = ОбъектМетаданных.ПолноеИмя();
			СтрокаТаблицы.Ссылка = ОбщегоНазначения.ИдентификаторОбъектаМетаданных(ОбъектМетаданных);
			СтрокаТаблицы.Вид = Лев(СтрокаТаблицы.ПолноеИмя, СтрНайти(СтрокаТаблицы.ПолноеИмя, ""."") - 1);
			СтрокаТаблицы.Представление = ОбъектМетаданных.Представление();
		КонецЕсли;
		
		СтрокаТаблицы.ПолноеПредставление = СтрокаТаблицы.Представление + "" ("" + СтрокаТаблицы.Вид + "")"";
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

// Формирует запрос для получения таблицы команд дополнительных отчетов или обработок.
//
// Параметры:
//   ВидОбработок - ПеречислениеСсылка.ВидыДополнительныхОтчетовИОбработок - Вид обработки.
//   Размещение - СправочникСсылка.ИдентификаторыОбъектовМетаданных, Строка - Ссылка или полное имя объекта метаданных,
//       к которому привязаны искомые дополнительные отчеты и обработки.
//       Глобальные обработки размещаются в разделах, контекстные - в справочниках и документах.
//   ЭтоФормаОбъекта - Булево - Необязательный.
//       Тип форм, в которых размещены контекстные дополнительные отчеты и обработки.
//       Истина - только отчеты и обработки, привязанные к формам объектов.
//       Ложь - только отчеты и обработки, привязанные к формам списков.
//   ТипыКоманд - ПеречислениеСсылка.ВариантыПубликацииДополнительныхОтчетовИОбработок - Тип получаемых команд.
//       - Массив - Типы команд, которые необходимо получить.
//           * ПеречислениеСсылка.ВариантыПубликацииДополнительныхОтчетовИОбработок
//   ТолькоВключенные - Булево - Необязательный.
//       Тип форм, в которых размещены контекстные дополнительные отчеты и обработки.
//       Истина - только отчеты и обработки, привязанные к формам объектов.
//       Ложь - только отчеты и обработки, привязанные к формам списков.
//
// Возвращаемое значение:
//   ТаблицаЗначений - Команды дополнительных отчетов или обработок.
//       * Ссылка - СправочникСсылка.ДополнительныеОтчетыИОбработки - Ссылка дополнительного отчета или обработки.
//       * Идентификатор - Строка - Идентификатор команды, как он задан разработчиком дополнительного объекта.
//       * ВариантЗапуска - ПеречислениеСсылка.СпособыВызоваДополнительныхОбработок -
//           Способ вызова команды дополнительного объекта.
//       * Представление - Строка - Наименование команды в пользовательском интерфейсе.
//       * ПоказыватьОповещение - Булево - Показывать оповещение пользователю после выполнения команды.
//       * Модификатор - Строка - Модификатор команды.
//
Функция НовыйЗапросПоДоступнымКомандам(ВидОбработок, Размещение, ЭтоФормаОбъекта = Неопределено, ТипыКоманд = Неопределено, ТолькоВключенные = Истина) Экспорт
	Запрос = Новый Запрос;
	
	Если ТипЗнч(Размещение) = Тип(""СправочникСсылка.ИдентификаторыОбъектовМетаданных"") Тогда
		СсылкаРодителяИлиРаздела = Размещение;
	Иначе
		Если ЗначениеЗаполнено(Размещение) Тогда
			СсылкаРодителяИлиРаздела = СтандартныеПодсистемыСервер.ИдентификаторОбъектаМетаданных(Размещение);
		Иначе
			СсылкаРодителяИлиРаздела = Неопределено;
		КонецЕсли;
	КонецЕсли;
	
	Если СсылкаРодителяИлиРаздела <> Неопределено Тогда // Есть фильтр по родителю.
		ЭтоГлобальныеОбработки = (
			ВидОбработок = Перечисления.ВидыДополнительныхОтчетовИОбработок.ДополнительныйОтчет
			Или ВидОбработок = Перечисления.ВидыДополнительныхОтчетовИОбработок.ДополнительнаяОбработка);
		
		// Запросы принципиально отличаются для глобальных обработок и назначаемых.
		Если ЭтоГлобальныеОбработки Тогда
			ТекстЗапроса =
			""ВЫБРАТЬ РАЗРЕШЕННЫЕ РАЗЛИЧНЫЕ
			|	ДопОтчетыИОбработки.Ссылка
			|ПОМЕСТИТЬ втСсылки
			|ИЗ
			|	Справочник.ДополнительныеОтчетыИОбработки.Разделы КАК ТаблицаРазделы
			|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ДополнительныеОтчетыИОбработки КАК ДопОтчетыИОбработки
			|		ПО (ТаблицаРазделы.Раздел = &СсылкаРаздела)
			|			И ТаблицаРазделы.Ссылка = ДопОтчетыИОбработки.Ссылка
			|ГДЕ
			|	ДопОтчетыИОбработки.Вид = &Вид
			|	И НЕ ДопОтчетыИОбработки.ПометкаУдаления
			|	И ДопОтчетыИОбработки.Публикация = &Публикация
			|;
			|
			|////////////////////////////////////////////////////////////////////////////////
			|ВЫБРАТЬ РАЗРЕШЕННЫЕ
			|	ТаблицаКоманды.Ссылка,
			|	ТаблицаКоманды.Идентификатор,
			|	ТаблицаКоманды.ЗаменяемыеКоманды,
			|	ТаблицаКоманды.ВариантЗапуска,
			|	ТаблицаКоманды.Представление,
			|	ТаблицаКоманды.ПоказыватьОповещение,
			|	ТаблицаКоманды.Модификатор,
			|	ЕСТЬNULL(БыстрыйДоступ.Доступно, ЛОЖЬ) КАК Использование
			|ПОМЕСТИТЬ ИтоговаяТаблица
			|ИЗ
			|	втСсылки КАК ТаблицаСсылки
			|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ДополнительныеОтчетыИОбработки.Команды КАК ТаблицаКоманды
			|		ПО ТаблицаСсылки.Ссылка = ТаблицаКоманды.Ссылка
			|			И (ТаблицаКоманды.Скрыть = ЛОЖЬ)
			|			И (ТаблицаКоманды.ВариантЗапуска В (&ТипыКоманд))
			|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ПользовательскиеНастройкиДоступаКОбработкам КАК БыстрыйДоступ
			|		ПО (ТаблицаКоманды.Ссылка = БыстрыйДоступ.ДополнительныйОтчетИлиОбработка)
			|			И (ТаблицаКоманды.Идентификатор = БыстрыйДоступ.ИдентификаторКоманды)
			|			И (БыстрыйДоступ.Пользователь = &ТекущийПользователь)
			|ГДЕ
			|	ЕСТЬNULL(БыстрыйДоступ.Доступно, ЛОЖЬ)"";
			Запрос.УстановитьПараметр(""СсылкаРаздела"", СсылкаРодителяИлиРаздела);
			
			Если Не ТолькоВключенные Тогда
				ТекстЗапроса = СтрЗаменить(ТекстЗапроса,
					""ГДЕ
					|	ЕСТЬNULL(БыстрыйДоступ.Доступно, ЛОЖЬ)"",
					"""");
			КонецЕсли;
			
		Иначе
			
			ТекстЗапроса =
			""ВЫБРАТЬ РАЗРЕШЕННЫЕ РАЗЛИЧНЫЕ
			|	ТаблицаНазначение.Ссылка
			|ПОМЕСТИТЬ втСсылки
			|ИЗ
			|	Справочник.ДополнительныеОтчетыИОбработки.Назначение КАК ТаблицаНазначение
			|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ДополнительныеОтчетыИОбработки КАК ДопОтчетыИОбработки
			|		ПО (ТаблицаНазначение.ОбъектНазначения = &СсылкаРодителя)
			|			И ТаблицаНазначение.Ссылка = ДопОтчетыИОбработки.Ссылка
			|			И (ДопОтчетыИОбработки.ПометкаУдаления = ЛОЖЬ)
			|			И (ДопОтчетыИОбработки.Вид = &Вид)
			|			И (ДопОтчетыИОбработки.Публикация = &Публикация)
			|			И (ДопОтчетыИОбработки.ИспользоватьДляФормыСписка = ИСТИНА)
			|			И (ДопОтчетыИОбработки.ИспользоватьДляФормыОбъекта = ИСТИНА)
			|;
			|
			|////////////////////////////////////////////////////////////////////////////////
			|ВЫБРАТЬ РАЗРЕШЕННЫЕ
			|	ТаблицаКоманды.Ссылка,
			|	ТаблицаКоманды.Идентификатор,
			|	ТаблицаКоманды.ЗаменяемыеКоманды,
			|	ТаблицаКоманды.ВариантЗапуска,
			|	ТаблицаКоманды.Представление,
			|	ТаблицаКоманды.ПоказыватьОповещение,
			|	ТаблицаКоманды.Модификатор,
			|	НЕОПРЕДЕЛЕНО КАК Использование
			|ПОМЕСТИТЬ ИтоговаяТаблица
			|ИЗ
			|	втСсылки КАК ТаблицаСсылки
			|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ДополнительныеОтчетыИОбработки.Команды КАК ТаблицаКоманды
			|		ПО ТаблицаСсылки.Ссылка = ТаблицаКоманды.Ссылка
			|			И (ТаблицаКоманды.Скрыть = ЛОЖЬ)
			|			И (ТаблицаКоманды.ВариантЗапуска В (&ТипыКоманд))"";
			
			Запрос.УстановитьПараметр(""СсылкаРодителя"", СсылкаРодителяИлиРаздела);
			
		КонецЕсли;
		
	Иначе
		
		ТекстЗапроса =
		""ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	ТаблицаКоманды.Ссылка,
		|	ТаблицаКоманды.Идентификатор,
		|	ТаблицаКоманды.ЗаменяемыеКоманды,
		|	ТаблицаКоманды.ВариантЗапуска,
		|	ТаблицаКоманды.Представление КАК Представление,
		|	ТаблицаКоманды.ПоказыватьОповещение,
		|	ТаблицаКоманды.Модификатор,
		|	НЕОПРЕДЕЛЕНО КАК Использование
		|ПОМЕСТИТЬ ИтоговаяТаблица
		|ИЗ
		|	Справочник.ДополнительныеОтчетыИОбработки.Команды КАК ТаблицаКоманды
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ДополнительныеОтчетыИОбработки КАК ДопОтчетыИОбработки
		|		ПО ТаблицаКоманды.Ссылка = ДопОтчетыИОбработки.Ссылка
		|			И (ДопОтчетыИОбработки.Вид = &Вид)
		|			И (ТаблицаКоманды.ВариантЗапуска В (&ТипыКоманд))
		|			И (ДопОтчетыИОбработки.Публикация = &Публикация)
		|			И (ДопОтчетыИОбработки.ПометкаУдаления = ЛОЖЬ)
		|			И (ДопОтчетыИОбработки.ИспользоватьДляФормыСписка = ИСТИНА)
		|			И (ДопОтчетыИОбработки.ИспользоватьДляФормыОбъекта = ИСТИНА)
		|			И (ТаблицаКоманды.Скрыть = ЛОЖЬ)"";
		
	КонецЕсли;
	
	// Отключение отборов по форме списка и объекта.
	Если ЭтоФормаОбъекта <> Истина Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, ""И (ДопОтчетыИОбработки.ИспользоватьДляФормыОбъекта = ИСТИНА)"", """");
	КонецЕсли;
	Если ЭтоФормаОбъекта <> Ложь Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, ""И (ДопОтчетыИОбработки.ИспользоватьДляФормыСписка = ИСТИНА)"", """");
	КонецЕсли;
	
	Если ТипыКоманд = Неопределено Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, ""И (ТаблицаКоманды.ВариантЗапуска В (&ТипыКоманд))"", """");
	Иначе
		Запрос.УстановитьПараметр(""ТипыКоманд"", ТипыКоманд);
	КонецЕсли;
	
	Запрос.УстановитьПараметр(""Вид"", ВидОбработок);
	Если ПравоДоступа(""Изменение"", Метаданные.Справочники.ДополнительныеОтчетыИОбработки) Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, ""Публикация = &Публикация"", ""Публикация <> &Публикация"");
		Запрос.УстановитьПараметр(""Публикация"", Перечисления.ВариантыПубликацииДополнительныхОтчетовИОбработок.Отключена);
	Иначе
		Запрос.УстановитьПараметр(""Публикация"", Перечисления.ВариантыПубликацииДополнительныхОтчетовИОбработок.Используется);
	КонецЕсли;
	Запрос.УстановитьПараметр(""ТекущийПользователь"", ПользователиКлиентСервер.АвторизованныйПользователь());
	Запрос.Текст = ТекстЗапроса;
	
	Если ИспользуетсяТеснаяИнтеграцияСПодсистемойВМоделиСервиса() Тогда
		АдаптироватьЗапросПоДоступнымКомандамКМоделиСервиса(Запрос);
	Иначе
		Запрос.Текст = СтрЗаменить(Запрос.Текст, ""ПОМЕСТИТЬ ИтоговаяТаблица"", """");
		Запрос.Текст = Запрос.Текст + ""
		|
		|УПОРЯДОЧИТЬ ПО
		|	Представление"";
	КонецЕсли;
	
	Возврат Запрос;
КонецФункции

// Обработчик подключенной команды заполнения.
//
// Параметры
//   МассивСсылок - Массив - Массив ссылок выбранных объектов, для которых выполняется команда.
//   ПараметрыВыполнения - Структура - Контекст команды.
//       * ОписаниеКоманды - Структура - Сведения о выполняемой команде.
//          ** Идентификатор - Строка - Идентификатор команды.
//          ** Представление - Строка - Представление команды в форме.
//          ** Имя - Строка - Имя команды в форме.
//       * Форма - УправляемаяФорма - Форма, из которой была вызвана команда.
//       * Источник - ДанныеФормыСтруктура, ТаблицаФормы - Объект или список формы с полем ""Ссылка"".
//
Процедура ОбработчикКомандыЗаполнения(Знач МассивСсылок, Знач ПараметрыВыполнения) Экспорт
	ВыполняемаяКоманда = ПараметрыВыполнения.ОписаниеКоманды.ДополнительныеПараметры;
	
	ВнешнийОбъект = ОбъектВнешнейОбработки(ВыполняемаяКоманда.Ссылка);
	
	ПараметрыКоманды = Новый Структура;
	ПараметрыКоманды.Вставить(""ЭтаФорма"", ПараметрыВыполнения.Форма);
	ПараметрыКоманды.Вставить(""ДополнительнаяОбработкаСсылка"", ВыполняемаяКоманда.Ссылка);
	
	ВыполнитьКомандуВнешнегоОбъекта(ВнешнийОбъект, ВыполняемаяКоманда.Идентификатор, ПараметрыКоманды, Неопределено);
КонецПроцедуры

Функция ИспользуютсяДополнительныеОтчетыИОбработки() Экспорт
	Возврат ПолучитьФункциональнуюОпцию(""ИспользоватьДополнительныеОтчетыИОбработки"");
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Обработчики подписок на события.

// Удаление ссылок подсистем перед их удалением.
Процедура ПередУдалениемИдентификатораОбъектаМетаданных(ИОМОбъект, Отказ) Экспорт
	Если ИОМОбъект.ОбменДанными.Загрузка Тогда
		Возврат;
	КонецЕсли;
	
	ИОМСсылка = ИОМОбъект.Ссылка;
	
	ТекстЗапроса =
	""ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	РазделыОтчетовИОбработок.Ссылка
	|ПОМЕСТИТЬ втСсылки
	|ИЗ
	|	Справочник.ДополнительныеОтчетыИОбработки.Разделы КАК РазделыОтчетовИОбработок
	|ГДЕ
	|	РазделыОтчетовИОбработок.Раздел = &ИОМСсылка
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	РазделыОтчетовИОбработок.Ссылка
	|ИЗ
	|	Справочник.ДополнительныеОтчетыИОбработки.Назначение КАК РазделыОтчетовИОбработок
	|ГДЕ
	|	РазделыОтчетовИОбработок.ОбъектНазначения = &ИОМСсылка
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	втСсылки.Ссылка
	|ИЗ
	|	втСсылки КАК втСсылки"";
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр(""ИОМСсылка"", ИОМСсылка);
	Запрос.Текст = ТекстЗапроса;
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		СправочникОбъект = Выборка.Ссылка.ПолучитьОбъект();
		
		Найденные = СправочникОбъект.Разделы.НайтиСтроки(Новый Структура(""Раздел"", ИОМСсылка));
		Для Каждого СтрокаТаблицы Из Найденные Цикл
			СправочникОбъект.Разделы.Удалить(СтрокаТаблицы);
		КонецЦикла;
		
		Найденные = СправочникОбъект.Назначение.НайтиСтроки(Новый Структура(""ОбъектНазначения"", ИОМСсылка));
		Для Каждого СтрокаТаблицы Из Найденные Цикл
			СправочникОбъект.Назначение.Удалить(СтрокаТаблицы);
		КонецЦикла;
		
		СправочникОбъект.Записать();
	КонецЦикла;
КонецПроцедуры

// Обновляет отчеты и обработки в справочнике из общих макетов.
//
// Параметры:
//   ОтчетыИОбработки - ТаблицаЗначений - Таблица отчетов и обработок в общих макетах.
//       * ОбъектМетаданных - ОбъектМетаданных - Отчет или обработка из конфигурации.
//       * СтарыеИменаОбъектов - Массив - Старые имена объектов для поиска старых версий этого отчета или обработки.
//           ** Строка - Старое имя объекта.
//       * СтарыеИменаФайлов - Массив - Старые имена файлов для поиска старых версий этого отчета или обработки.
//           ** Строка - Старое имя файла.
//
Процедура ЗагрузитьДополнительныеОтчетыИОбработкиИзМетаданных(ОтчетыИОбработки) Экспорт
	Если Не ПолучитьФункциональнуюОпцию(""ИспользоватьДополнительныеОтчетыИОбработки"") Тогда
		Возврат;
	КонецЕсли;
	
	СопоставитьОбработкиКонфигурацииСОбработкамиСправочника(ОтчетыИОбработки);
	Если ОтчетыИОбработки.Количество() = 0 Тогда
		Возврат; // Обновление не требуется.
	КонецЕсли;
	
	ВыгрузитьОтчетыИОбработкиВФайлы(ОтчетыИОбработки);
	Если ОтчетыИОбработки.Количество() = 0 Тогда
		Возврат; // Выгрузка провалилась.
	КонецЕсли;
	
	ЗарегистрироватьОтчетыИОбработки(ОтчетыИОбработки);
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обработчики событий подсистем конфигурации.

// См. ОбновлениеИнформационнойБазыБСП.ПриДобавленииОбработчиковОбновления.
Процедура ПриДобавленииОбработчиковОбновления(Обработчики) Экспорт
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = ""1.0.7.1"";
	Обработчик.Процедура = ""ДополнительныеОтчетыИОбработки.ОбновитьПользовательскиеНастройкиДоступаКОбработкам"";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = ""2.0.1.4"";
	Обработчик.Процедура = ""ДополнительныеОтчетыИОбработки.ЗаполнитьИменаОбъектов"";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = ""2.1.3.2"";
	Обработчик.Процедура = ""ДополнительныеОтчетыИОбработки.ЗаменитьИменаОбъектовМетаданныхНаСсылки"";
	
	Если НЕ ОбщегоНазначения.РазделениеВключено() Тогда
		Обработчик = Обработчики.Добавить();
		Обработчик.ВыполнятьВГруппеОбязательных = Истина;
		Обработчик.ОбщиеДанные                  = Истина;
		Обработчик.УправлениеОбработчиками      = Ложь;
		Обработчик.МонопольныйРежим             = Истина;
		Обработчик.Версия    = ""2.1.3.22"";
		Обработчик.Процедура = ""ДополнительныеОтчетыИОбработки.ВключитьФункциональнуюОпцию"";
	КонецЕсли;
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = ""2.2.2.25"";
	Обработчик.Процедура = ""ДополнительныеОтчетыИОбработки.ЗаполнитьРежимСовместимостиРазрешений"";
	
КонецПроцедуры

// См. ОбщегоНазначенияПереопределяемый.ПриДобавленииПереименованийОбъектовМетаданных.
Процедура ПриДобавленииПереименованийОбъектовМетаданных(Итог) Экспорт
	
	Библиотека = ""СтандартныеПодсистемы"";
	
	ОбщегоНазначения.ДобавитьПереименование(
		Итог, ""2.3.3.3"", ""Роль.ИспользованиеДополнительныхОтчетовИОбработок"", ""Роль.ЧтениеДополнительныхОтчетовИОбработок"", Библиотека);
	
КонецПроцедуры

// См. СтандартныеПодсистемыСервер.ПриПолученииДанныхОтПодчиненного.
Процедура ПриПолученииДанныхОтПодчиненного(ЭлементДанных, ПолучениеЭлемента, ОтправкаНазад, Отправитель) Экспорт
	
	ПриПолученииДополнительнойОбработки(ЭлементДанных, ПолучениеЭлемента);
	
КонецПроцедуры

// См. СтандартныеПодсистемыСервер.ПриПолученииДанныхОтГлавного.
Процедура ПриПолученииДанныхОтГлавного(ЭлементДанных, ПолучениеЭлемента, ОтправкаНазад, Отправитель) Экспорт
	
	ПриПолученииДополнительнойОбработки(ЭлементДанных, ПолучениеЭлемента);
	
КонецПроцедуры

// См. ТекущиеДелаПереопределяемый.ПриОпределенииОбработчиковТекущихДел.
Процедура ПриЗаполненииСпискаТекущихДел(ТекущиеДела) Экспорт
	Если ОбщегоНазначения.РазделениеВключено()
		Или Не ПравоДоступа(""Редактирование"", Метаданные.Справочники.ДополнительныеОтчетыИОбработки)
		Или Не ПолучитьФункциональнуюОпцию(""ИспользоватьДополнительныеОтчетыИОбработки"") Тогда
		Возврат;
	КонецЕсли;
	
	МодульТекущиеДелаСервер = ОбщегоНазначения.ОбщийМодуль(""ТекущиеДелаСервер"");
	Если МодульТекущиеДелаСервер.ДелоОтключено(""ДополнительныеОтчетыИОбработки"") Тогда
		Возврат; // Дело отключено в переопределяемом модуле.
	КонецЕсли;
	
	Подсистема = Метаданные.Подсистемы.Найти(""Администрирование"");
	Если Подсистема = Неопределено
		Или Не ПравоДоступа(""Просмотр"", Подсистема)
		Или Не ОбщегоНазначения.ОбъектМетаданныхДоступенПоФункциональнымОпциям(Подсистема) Тогда
		Разделы = МодульТекущиеДелаСервер.РазделыДляОбъекта(""Справочник.ДополнительныеОтчетыИОбработки"");
	Иначе
		Разделы = Новый Массив;
		Разделы.Добавить(Подсистема);
	КонецЕсли;
	
	ВывестиДело = Истина;
	ПровереноНаВерсию = ХранилищеОбщихНастроек.Загрузить(""ТекущиеДела"", ""ДополнительныеОтчетыИОбработки"");
	Если ПровереноНаВерсию <> Неопределено Тогда
		ВерсияМассив  = СтрРазделить(Метаданные.Версия, ""."", Истина);
		ТекущаяВерсия = ВерсияМассив[0] + ВерсияМассив[1] + ВерсияМассив[2];
		Если ПровереноНаВерсию = ТекущаяВерсия Тогда
			ВывестиДело = Ложь; // Дополнительные отчеты и обработки проверены на текущей версии.
		КонецЕсли;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	""ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	КОЛИЧЕСТВО(РАЗЛИЧНЫЕ ДополнительныеОтчетыИОбработки.Ссылка) КАК Количество
	|ИЗ
	|	Справочник.ДополнительныеОтчетыИОбработки КАК ДополнительныеОтчетыИОбработки
	|ГДЕ
	|	ДополнительныеОтчетыИОбработки.Публикация = ЗНАЧЕНИЕ(Перечисление.ВариантыПубликацииДополнительныхОтчетовИОбработок.Используется)
	|	И ДополнительныеОтчетыИОбработки.ПометкаУдаления = ЛОЖЬ
	|	И ДополнительныеОтчетыИОбработки.ЭтоГруппа = ЛОЖЬ"";
	Количество = Запрос.Выполнить().Выгрузить()[0].Количество;
	
	Для Каждого Раздел Из Разделы Цикл
		ИдентификаторРаздела = ""ПроверитьСовместимостьСТекущейВерсией"" + СтрЗаменить(Раздел.ПолноеИмя(), ""."", """");
		
		Дело = ТекущиеДела.Добавить();
		Дело.Идентификатор = ""ДополнительныеОтчетыИОбработки"";
		Дело.ЕстьДела      = ВывестиДело И Количество > 0;
		Дело.Представление = НСтр(""ru = 'Дополнительные отчеты и обработки'"");
		Дело.Количество    = Количество;
		Дело.Форма         = ""Справочник.ДополнительныеОтчетыИОбработки.Форма.ПроверкаДополнительныхОтчетовИОбработок"";
		Дело.Владелец      = ИдентификаторРаздела;
		
		// Проверка наличия группы дела. Если группа отсутствует - добавляем.
		ГруппаДела = ТекущиеДела.Найти(ИдентификаторРаздела, ""Идентификатор"");
		Если ГруппаДела = Неопределено Тогда
			ГруппаДела = ТекущиеДела.Добавить();
			ГруппаДела.Идентификатор = ИдентификаторРаздела;
			ГруппаДела.ЕстьДела      = Дело.ЕстьДела;
			ГруппаДела.Представление = НСтр(""ru = 'Проверить совместимость'"");
			Если Дело.ЕстьДела Тогда
				ГруппаДела.Количество = Дело.Количество;
			КонецЕсли;
			ГруппаДела.Владелец = Раздел;
		Иначе
			Если Не ГруппаДела.ЕстьДела Тогда
				ГруппаДела.ЕстьДела = Дело.ЕстьДела;
			КонецЕсли;
			
			Если Дело.ЕстьДела Тогда
				ГруппаДела.Количество = ГруппаДела.Количество + Дело.Количество;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// См. УправлениеДоступомПереопределяемый.ПриЗаполненииВидовДоступа.
Процедура ПриЗаполненииВидовДоступа(ВидыДоступа) Экспорт
	
	ВидДоступа = ВидыДоступа.Добавить();
	ВидДоступа.Имя = ""ДополнительныеОтчетыИОбработки"";
	ВидДоступа.Представление = НСтр(""ru = 'Дополнительные отчеты и обработки'"");
	ВидДоступа.ТипЗначений   = Тип(""СправочникСсылка.ДополнительныеОтчетыИОбработки"");
	
КонецПроцедуры

// См. УправлениеДоступомПереопределяемый.ПриЗаполненииИспользованияВидаДоступа.
Процедура ПриЗаполненииИспользованияВидаДоступа(ВидДоступа, Использование) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если ВидДоступа = ""ДополнительныеОтчетыИОбработки"" Тогда
		Использование = Константы.ИспользоватьДополнительныеОтчетыИОбработки.Получить();
	КонецЕсли;
	
КонецПроцедуры

// См. УправлениеДоступомПереопределяемый.ПриЗаполненииВидовОграниченийПравОбъектовМетаданных.
Процедура ПриЗаполненииВидовОграниченийПравОбъектовМетаданных(Описание) Экспорт
	
	Если НЕ ОбщегоНазначения.ПодсистемаСуществует(""СтандартныеПодсистемы.УправлениеДоступом"") Тогда
		Возврат;
	КонецЕсли;
	
	МодульУправлениеДоступомСлужебный = ОбщегоНазначения.ОбщийМодуль(""УправлениеДоступомСлужебный"");
	Если МодульУправлениеДоступомСлужебный.ВидДоступаСуществует(""ДополнительныеОтчетыИОбработки"") Тогда
		
		Описание = Описание + ""
		|
		|Справочник.ДополнительныеОтчетыИОбработки.Чтение.ДополнительныеОтчетыИОбработки
		|"";
	КонецЕсли;
	
КонецПроцедуры

// См. ПользователиПереопределяемый.ПриОпределенииНазначенияРолей.
Процедура ПриОпределенииНазначенияРолей(НазначениеРолей) Экспорт
	
	// СовместноДляПользователейИВнешнихПользователей.
	НазначениеРолей.СовместноДляПользователейИВнешнихПользователей.Добавить(
		Метаданные.Роли.ЧтениеДополнительныхОтчетовИОбработок.Имя);
	
КонецПроцедуры

// См. ПользователиПереопределяемый.ПриПолученииПрочихНастроек.
Процедура ПриПолученииПрочихНастроек(СведенияОПользователе, Настройки) Экспорт
	
	// Получает настройки дополнительных отчетов и обработок для переданного пользователя.
	
	Если Не ПолучитьФункциональнуюОпцию(""ИспользоватьДополнительныеОтчетыИОбработки"")
		Или Не ПравоДоступа(""Изменение"", Метаданные.РегистрыСведений.ПользовательскиеНастройкиДоступаКОбработкам) Тогда
		Возврат;
	КонецЕсли;
	
	// Название строки настроек, отображаемое в дереве настроек обработки.
	НазваниеНастройки = НСтр(""ru = 'Настройки быстрого доступа к дополнительным отчетам и обработкам'"");
	
	// Картинка строки настроек
	КартинкаНастройки = """";
	
	// Список дополнительных отчетов и обработок, находящихся в быстром доступе у пользователя.
	Запрос = Новый Запрос;
	Запрос.Текст = 
	""ВЫБРАТЬ
	|	ПользовательскиеНастройкиДоступаКОбработкам.ДополнительныйОтчетИлиОбработка КАК Объект,
	|	ПользовательскиеНастройкиДоступаКОбработкам.ИдентификаторКоманды КАК Идентификатор,
	|	ПользовательскиеНастройкиДоступаКОбработкам.Пользователь КАК Пользователь
	|ИЗ
	|	РегистрСведений.ПользовательскиеНастройкиДоступаКОбработкам КАК ПользовательскиеНастройкиДоступаКОбработкам
	|ГДЕ
	|	Пользователь = &Пользователь"";
	
	Запрос.Параметры.Вставить(""Пользователь"", СведенияОПользователе.ПользовательСсылка);
	
	РезультатЗапроса = Запрос.Выполнить().Выгрузить();
	
	НастройкаБыстрогоДоступа = Новый Структура;
	НастройкаБыстрогоДоступа.Вставить(""НазваниеНастройки"", НазваниеНастройки);
	НастройкаБыстрогоДоступа.Вставить(""КартинкаНастройки"", КартинкаНастройки);
	НастройкаБыстрогоДоступа.Вставить(""СписокНастроек"",    РезультатЗапроса);
	
	Настройки.Вставить(""НастройкаБыстрогоДоступа"", НастройкаБыстрогоДоступа);
	
КонецПроцедуры

// См. ПользователиПереопределяемый.ПриСохраненииПрочихНастроек.
Процедура ПриСохраненииПрочихНастроек(СведенияОПользователе, Настройки) Экспорт
	
	// Сохраняет команды дополнительных отчетов и обработок указанным пользователям.
	
	Если Не ПолучитьФункциональнуюОпцию(""ИспользоватьДополнительныеОтчетыИОбработки"") Тогда
		Возврат;
	КонецЕсли;
	
	Если Настройки.ИдентификаторНастройки <> ""НастройкаБыстрогоДоступа"" Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого ЭлементСтрока Из Настройки.ЗначениеНастройки Цикл
		
		Запись = РегистрыСведений.ПользовательскиеНастройкиДоступаКОбработкам.СоздатьМенеджерЗаписи();
		
		Запись.ДополнительныйОтчетИлиОбработка  = ЭлементСтрока.Значение;
		Запись.ИдентификаторКоманды             = ЭлементСтрока.Представление;
		Запись.Пользователь                     = СведенияОПользователе.ПользовательСсылка;
		Запись.Доступно                         = Истина;
		
		Запись.Записать(Истина);
		
	КонецЦикла;
	
КонецПроцедуры

// См. ПользователиПереопределяемый.ПриУдаленииПрочихНастроек.
Процедура ПриУдаленииПрочихНастроек(СведенияОПользователе, Настройки) Экспорт
	
	// Очищает команды дополнительных отчетов и обработок у указанного пользователя.
	
	Если Не ПолучитьФункциональнуюОпцию(""ИспользоватьДополнительныеОтчетыИОбработки"") Тогда
		Возврат;
	КонецЕсли;
	
	Если Настройки.ИдентификаторНастройки <> ""НастройкаБыстрогоДоступа"" Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого ЭлементСтрока Из Настройки.ЗначениеНастройки Цикл
		
		Запись = РегистрыСведений.ПользовательскиеНастройкиДоступаКОбработкам.СоздатьМенеджерЗаписи();
		
		Запись.ДополнительныйОтчетИлиОбработка  = ЭлементСтрока.Значение;
		Запись.ИдентификаторКоманды             = ЭлементСтрока.Представление;
		Запись.Пользователь                     = СведенияОПользователе.ПользовательСсылка;
		
		Запись.Прочитать();
		
		Запись.Удалить();
		
	КонецЦикла;
	
КонецПроцедуры

// См. ГрупповоеИзменениеОбъектовПереопределяемый.ПриОпределенииОбъектовСРедактируемымиРеквизитами.
Процедура ПриОпределенииОбъектовСРедактируемымиРеквизитами(Объекты) Экспорт
	Объекты.Вставить(Метаданные.Справочники.ДополнительныеОтчетыИОбработки.ПолноеИмя(), ""РеквизитыРедактируемыеВГрупповойОбработке"");
КонецПроцедуры

// См. ПодключаемыеКомандыПереопределяемый.ПриОпределенииВидовПодключаемыхКоманд.
Процедура ПриОпределенииВидовПодключаемыхКоманд(ВидыПодключаемыхКоманд) Экспорт
	Если ВидыПодключаемыхКоманд.Найти(""ЗаполнениеОбъектов"", ""Имя"") = Неопределено Тогда
		Вид = ВидыПодключаемыхКоманд.Добавить();
		Вид.Имя         = ""ЗаполнениеОбъектов"";
		Вид.ИмяПодменю  = ""ПодменюЗаполнить"";
		Вид.Заголовок   = НСтр(""ru = 'Заполнить'"");
		Вид.Картинка    = БиблиотекаКартинок.ЗаполнитьФорму;
		Вид.Отображение = ОтображениеКнопки.Картинка;
	КонецЕсли;
КонецПроцедуры

// См. ПодключаемыеКомандыПереопределяемый.ПриОпределенииКомандПодключенныхКОбъекту.
Процедура ПриОпределенииКомандПодключенныхКОбъекту(НастройкиФормы, Источники, ПодключенныеОтчетыИОбработки, Команды) Экспорт
	
	Если Не ПравоДоступа(""Чтение"", Метаданные.РегистрыСведений.НазначениеДополнительныхОбработок) Тогда 
		Возврат;
	КонецЕсли;
	
	Если НастройкиФормы.ЭтоФормаОбъекта Тогда
		ТипФормы = ДополнительныеОтчетыИОбработкиКлиентСервер.ТипФормыОбъекта();
	Иначе
		ТипФормы = ДополнительныеОтчетыИОбработкиКлиентСервер.ТипФормыСписка();
	КонецЕсли;
	
	УстанавливатьПараметрыФО = (Метаданные.ОбщиеКоманды.Найти(""СозданиеСвязанныхОбъектов"") <> Неопределено);
	Если УстанавливатьПараметрыФО Тогда
		НастройкиФормы.ФункциональныеОпции.Вставить(""ДополнительныеОтчетыИОбработкиОбъектНазначения"", Справочники.ИдентификаторыОбъектовМетаданных.ПустаяСсылка());
		НастройкиФормы.ФункциональныеОпции.Вставить(""ДополнительныеОтчетыИОбработкиТипФормы"",         ТипФормы);
	КонецЕсли;
	
	Если Не ПолучитьФункциональнуюОпцию(""ИспользоватьДополнительныеОтчетыИОбработки"") Тогда
		Возврат;
	КонецЕсли;
	
	ИОМы = Новый Массив;
	БыстрыйПоискПоИОМам = Новый Соответствие;
	Для Каждого Источник Из Источники.Строки Цикл
		Для Каждого ДокументРегистратор Из Источник.Строки Цикл
			ИОМы.Добавить(ДокументРегистратор.СсылкаМетаданных);
			БыстрыйПоискПоИОМам.Вставить(ДокументРегистратор.СсылкаМетаданных, ДокументРегистратор);
		КонецЦикла;
		ИОМы.Добавить(Источник.СсылкаМетаданных);
		БыстрыйПоискПоИОМам.Вставить(Источник.СсылкаМетаданных, Источник);
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	""ВЫБРАТЬ
	|	Назначение.ОбъектНазначения,
	|	Назначение.ИспользоватьЗаполнениеОбъекта КАК ИспользоватьЗаполнениеОбъекта,
	|	Назначение.ИспользоватьОтчеты КАК ИспользоватьОтчеты,
	|	Назначение.ИспользоватьСозданиеСвязанныхОбъектов КАК ИспользоватьСозданиеСвязанныхОбъектов
	|ИЗ
	|	РегистрСведений.НазначениеДополнительныхОбработок КАК Назначение
	|ГДЕ
	|	Назначение.ОбъектНазначения В(&ИОМы)
	|	И Назначение.ТипФормы = &ТипФормы"";
	Запрос.УстановитьПараметр(""ИОМы"", ИОМы);
	Если ТипФормы = Неопределено Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст, ""И Назначение.ТипФормы = &ТипФормы"", """");
	Иначе
		Запрос.УстановитьПараметр(""ТипФормы"", ТипФормы);
	КонецЕсли;
	
	ТипыЗаполнениеОбъекта = Новый Массив;
	ТипыОтчетов = Новый Массив;
	ТипыСозданияСвязанныхОбъектов = Новый Массив;
	
	ТаблицаРегистра = Запрос.Выполнить().Выгрузить();
	Для Каждого СтрокаТаблицы Из ТаблицаРегистра Цикл
		Источник = БыстрыйПоискПоИОМам[СтрокаТаблицы.ОбъектНазначения];
		Если Источник = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		Если СтрокаТаблицы.ИспользоватьЗаполнениеОбъекта Тогда
			ПодключаемыеКоманды.ДополнитьМассивТипов(ТипыЗаполнениеОбъекта, Источник.ТипСсылкиДанных);
		КонецЕсли;
		Если СтрокаТаблицы.ИспользоватьОтчеты Тогда
			ПодключаемыеКоманды.ДополнитьМассивТипов(ТипыОтчетов, Источник.ТипСсылкиДанных);
		КонецЕсли;
		Если СтрокаТаблицы.ИспользоватьСозданиеСвязанныхОбъектов Тогда
			ПодключаемыеКоманды.ДополнитьМассивТипов(ТипыСозданияСвязанныхОбъектов, Источник.ТипСсылкиДанных);
		КонецЕсли;
	КонецЦикла;
	
	Если ТипыЗаполнениеОбъекта.Количество() > 0 Тогда
		Команда = Команды.Добавить();
		Если ОбщегоНазначения.ПодсистемаСуществует(""СтандартныеПодсистемы.ЗаполнениеОбъектов"") Тогда
			Команда.Вид           = ""ЗаполнениеОбъектов"";
			Команда.Представление = НСтр(""ru = 'Дополнительные обработки заполнения...'"");
			Команда.Важность      = ""СмТакже"";
		Иначе
			Команда.Вид           = ""КоманднаяПанель"";
			Команда.Представление = НСтр(""ru = 'Заполнение...'"");
		КонецЕсли;
		Команда.ИзменяетВыбранныеОбъекты = Истина;
		Команда.Порядок            = 50;
		Команда.Обработчик         = ""ДополнительныеОтчетыИОбработкиКлиент.ОткрытьСписокКоманд"";
		Команда.РежимЗаписи        = ""Записывать"";
		Команда.МножественныйВыбор = Истина;
		Команда.ТипПараметра       = Новый ОписаниеТипов(ТипыЗаполнениеОбъекта);
		Команда.ДополнительныеПараметры = Новый Структура(""Вид, ЭтоОтчет"", ДополнительныеОтчетыИОбработкиКлиентСервер.ВидОбработкиЗаполнениеОбъекта(), Ложь);
	ИначеЕсли НастройкиФормы.ЭтоФормаОбъекта Тогда
		ПриОпределенииКомандЗаполненияПодключенныхКОбъекту(Команды, ИОМы, БыстрыйПоискПоИОМам);
	КонецЕсли;
	
	Если ТипыОтчетов.Количество() > 0 Тогда
		Команда = Команды.Добавить();
		Если ОбщегоНазначения.ПодсистемаСуществует(""СтандартныеПодсистемы.ВариантыОтчетов"") Тогда
			Команда.Вид           = ""Отчеты"";
			Команда.Важность      = ""СмТакже"";
			Команда.Представление = НСтр(""ru = 'Дополнительные отчеты...'"");
		Иначе
			Команда.Вид           = ""КоманднаяПанель"";
			Команда.Представление = НСтр(""ru = 'Отчеты...'"");
		КонецЕсли;
		Команда.Порядок            = 50;
		Команда.Обработчик         = ""ДополнительныеОтчетыИОбработкиКлиент.ОткрытьСписокКоманд"";
		Команда.РежимЗаписи        = ""Записывать"";
		Команда.МножественныйВыбор = Истина;
		Команда.ТипПараметра       = Новый ОписаниеТипов(ТипыОтчетов);
		Команда.ДополнительныеПараметры = Новый Структура(""Вид, ЭтоОтчет"", ДополнительныеОтчетыИОбработкиКлиентСервер.ВидОбработкиОтчет(), Истина);
	КонецЕсли;
	
	Если ТипыСозданияСвязанныхОбъектов.Количество() > 0 Тогда
		Если УстанавливатьПараметрыФО И ИОМы.Количество() = 1 Тогда
			НастройкиФормы.ФункциональныеОпции.Вставить(""ДополнительныеОтчетыИОбработкиОбъектНазначения"", ИОМы[0]);
		Иначе
			Команда = Команды.Добавить();
			Команда.Вид                = ?(УстанавливатьПараметрыФО, ""КоманднаяПанель"", ""СозданиеНаОсновании"");
			Команда.Представление      = НСтр(""ru = 'Создание связанных объектов...'"");
			Команда.Картинка           = БиблиотекаКартинок.ВводНаОсновании;
			Команда.Порядок            = 50;
			Команда.Обработчик         = ""ДополнительныеОтчетыИОбработкиКлиент.ОткрытьСписокКоманд"";
			Команда.РежимЗаписи        = ""Записывать"";
			Команда.МножественныйВыбор = Истина;
			Команда.ТипПараметра       = Новый ОписаниеТипов(ТипыСозданияСвязанныхОбъектов);
			Команда.ДополнительныеПараметры = Новый Структура(""Вид, ЭтоОтчет"", ДополнительныеОтчетыИОбработкиКлиентСервер.ВидОбработкиСозданиеСвязанныхОбъектов(), Ложь);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Добавляет отчеты подсистемы ""Дополнительные отчеты и обработки"",
//   в модулях объектов которых есть процедура ОпределитьНастройкиФормы().
//
// Параметры:
//   ОтчетыСНастройками - Массив - Ссылки отчетов, в модулях объектов которых есть процедура ОпределитьНастройкиФормы().
//
// Места использования:
//   ВариантыОтчетовПовтИсп.Параметры().
//
Процедура ПриОпределенииОтчетовСНастройками(ОтчетыСНастройками) Экспорт
	Если Не ПолучитьФункциональнуюОпцию(""ИспользоватьДополнительныеОтчетыИОбработки"") Тогда
		Возврат;
	КонецЕсли;
	Если НЕ ПравоДоступа(""Чтение"", Метаданные.Справочники.ДополнительныеОтчетыИОбработки) Тогда
		Возврат;
	КонецЕсли;
	ИспользуетсяТеснаяИнтеграцияСПодсистемойВМоделиСервиса = ИспользуетсяТеснаяИнтеграцияСПодсистемойВМоделиСервиса();
	Если ИспользуетсяТеснаяИнтеграцияСПодсистемойВМоделиСервиса Тогда
		МодульДополнительныеОтчетыИОбработкиВМоделиСервиса = ОбщегоНазначения.ОбщийМодуль(""ДополнительныеОтчетыИОбработкиВМоделиСервиса"");
	КонецЕсли;
	Запрос = Новый Запрос;
	Запрос.Текст =
	""ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	ДополнительныеОтчетыИОбработки.Ссылка
	|ИЗ
	|	Справочник.ДополнительныеОтчетыИОбработки КАК ДополнительныеОтчетыИОбработки
	|ГДЕ
	|	ДополнительныеОтчетыИОбработки.ИспользуетХранилищеВариантов
	|	И ДополнительныеОтчетыИОбработки.ТеснаяИнтеграцияСФормойОтчета
	|	И НЕ ДополнительныеОтчетыИОбработки.ПометкаУдаления
	|	И ДополнительныеОтчетыИОбработки.Вид В(&ВидыОтчетов)"";
	ВидыОтчетов = Новый Массив;
	ВидыОтчетов.Добавить(Перечисления.ВидыДополнительныхОтчетовИОбработок.ДополнительныйОтчет);
	ВидыОтчетов.Добавить(Перечисления.ВидыДополнительныхОтчетовИОбработок.Отчет);
	Запрос.УстановитьПараметр(""ВидыОтчетов"", ВидыОтчетов);
	УстановитьПривилегированныйРежим(Истина);
	ДопОтчетыСНастройками = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку(""Ссылка"");
	Для Каждого Ссылка Из ДопОтчетыСНастройками Цикл
		Если ИспользуетсяТеснаяИнтеграцияСПодсистемойВМоделиСервиса
			И Не МодульДополнительныеОтчетыИОбработкиВМоделиСервиса.ЭтоПоставляемаяОбработка(Ссылка) Тогда
			Продолжить;
		КонецЕсли;
		ОтчетыСНастройками.Добавить(Ссылка);
	КонецЦикла;
КонецПроцедуры

// Получает ссылку дополнительного отчета, если он подключен к хранилищу подсистемы Варианты отчетов.
//
// Параметры:
//   ОтчетИнформация - Структура - См. ВариантыОтчетов.СформироватьИнформациюОбОтчетеПоПолномуИмени().
//
Процедура ПриОпределенииТипаИСсылкиЕслиОтчетДополнительный(ОтчетИнформация) Экспорт
	Если Не ПолучитьФункциональнуюОпцию(""ИспользоватьДополнительныеОтчетыИОбработки"") Тогда
		Возврат;
	КонецЕсли;
	Если Не ПравоДоступа(""Чтение"", Метаданные.Справочники.ДополнительныеОтчетыИОбработки) Тогда
		Возврат;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	""ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	ДополнительныеОтчетыИОбработки.Ссылка
	|ИЗ
	|	Справочник.ДополнительныеОтчетыИОбработки КАК ДополнительныеОтчетыИОбработки
	|ГДЕ
	|	ДополнительныеОтчетыИОбработки.ИмяОбъекта = &ИмяОбъекта
	|	И ДополнительныеОтчетыИОбработки.ПометкаУдаления = ЛОЖЬ
	|	И ДополнительныеОтчетыИОбработки.ИспользуетХранилищеВариантов = ИСТИНА
	|	И ДополнительныеОтчетыИОбработки.Вид В (&ВидДополнительныйОтчет, &ВидОтчет)
	|	И ДополнительныеОтчетыИОбработки.Публикация = &ПубликацияИспользуется"";
	Если ОтчетИнформация.ПоУмолчаниюВсеПодключеныКХранилищу Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст, ""И ДополнительныеОтчетыИОбработки.ИспользуетХранилищеВариантов = ИСТИНА"", """");
	КонецЕсли;
	Запрос.УстановитьПараметр(""ИмяОбъекта"", ОтчетИнформация.ОтчетИмя);
	Запрос.УстановитьПараметр(""ВидОтчет"",               Перечисления.ВидыДополнительныхОтчетовИОбработок.Отчет);
	Запрос.УстановитьПараметр(""ВидДополнительныйОтчет"", Перечисления.ВидыДополнительныхОтчетовИОбработок.ДополнительныйОтчет);
	Запрос.УстановитьПараметр(""ПубликацияИспользуется"", Перечисления.ВариантыПубликацииДополнительныхОтчетовИОбработок.Используется);
	
	// Необходим для целостности формируемых данных. Права доступа будут применяться на этапе их использования.
	МассивСсылок = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку(""Ссылка"");
	ИспользуетсяТеснаяИнтеграцияСПодсистемойВМоделиСервиса = ИспользуетсяТеснаяИнтеграцияСПодсистемойВМоделиСервиса();
	Если ИспользуетсяТеснаяИнтеграцияСПодсистемойВМоделиСервиса Тогда
		МодульДополнительныеОтчетыИОбработкиВМоделиСервиса = ОбщегоНазначения.ОбщийМодуль(""ДополнительныеОтчетыИОбработкиВМоделиСервиса"");
	КонецЕсли;
	Для Каждого Ссылка Из МассивСсылок Цикл
		Если ИспользуетсяТеснаяИнтеграцияСПодсистемойВМоделиСервиса
			И Не МодульДополнительныеОтчетыИОбработкиВМоделиСервиса.ЭтоПоставляемаяОбработка(Ссылка) Тогда
			Продолжить;
		КонецЕсли;
		ОтчетИнформация.Отчет = Ссылка;
	КонецЦикла;
	
КонецПроцедуры

// Дополняет массив ссылкам дополнительных отчетов, доступных текущему пользователю.
//
// Параметры:
//   Результат - Массив из <см. Справочники.ВариантыОтчетов.Реквизиты.Отчет> -
//       Ссылки отчетов, доступных текущему пользователю.
//
// Места использования:
//   ВариантыОтчетов.ОтчетыТекущегоПользователя().
//
Процедура ПриДобавленииДополнительныхОтчетовДоступныхТекущемуПользователю(ДоступныеОтчеты) Экспорт
	Если Не ПолучитьФункциональнуюОпцию(""ИспользоватьДополнительныеОтчетыИОбработки"") Тогда
		Возврат;
	КонецЕсли;
	Если Не ПравоДоступа(""Чтение"", Метаданные.Справочники.ДополнительныеОтчетыИОбработки) Тогда
		Возврат;
	КонецЕсли;
	ИспользуетсяТеснаяИнтеграцияСПодсистемойВМоделиСервиса = ИспользуетсяТеснаяИнтеграцияСПодсистемойВМоделиСервиса();
	Если ИспользуетсяТеснаяИнтеграцияСПодсистемойВМоделиСервиса Тогда
		МодульДополнительныеОтчетыИОбработкиВМоделиСервиса = ОбщегоНазначения.ОбщийМодуль(""ДополнительныеОтчетыИОбработкиВМоделиСервиса"");
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	""ВЫБРАТЬ РАЗРЕШЕННЫЕ РАЗЛИЧНЫЕ
	|	ДополнительныеОтчетыИОбработки.Ссылка
	|ИЗ
	|	Справочник.ДополнительныеОтчетыИОбработки КАК ДополнительныеОтчетыИОбработки
	|ГДЕ
	|	ДополнительныеОтчетыИОбработки.ИспользуетХранилищеВариантов
	|	И ДополнительныеОтчетыИОбработки.Вид В (&ВидДополнительныйОтчет, &ВидОтчет)
	|	И НЕ ДополнительныеОтчетыИОбработки.Ссылка В (&ДоступныеОтчеты)"";
	
	Запрос.УстановитьПараметр(""ДоступныеОтчеты"", ДоступныеОтчеты);
	Запрос.УстановитьПараметр(""ВидОтчет"",               Перечисления.ВидыДополнительныхОтчетовИОбработок.Отчет);
	Запрос.УстановитьПараметр(""ВидДополнительныйОтчет"", Перечисления.ВидыДополнительныхОтчетовИОбработок.ДополнительныйОтчет);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Если ИспользуетсяТеснаяИнтеграцияСПодсистемойВМоделиСервиса
			И Не МодульДополнительныеОтчетыИОбработкиВМоделиСервиса.ЭтоПоставляемаяОбработка(Выборка.Ссылка) Тогда
			Продолжить;
		КонецЕсли;
		ДоступныеОтчеты.Добавить(Выборка.Ссылка);
	КонецЦикла;
	
КонецПроцедуры

// Подключает отчет подсистемы ""Дополнительные отчеты и обработки"".
//   Обработка исключений производится управляющим кодом.
//
// Параметры:
//   Ссылка - СправочникСсылка.ДополнительныеОтчетыИОбработки - Отчет, который необходимо инициализировать.
//   ПараметрыОтчета - Структура - Набор параметров, получаемый в процессе проверки и подключения отчета.
//       См. РассылкаОтчетов.ИнициализироватьОтчет().
//   Результат - Булево, Неопределено - Результат подключения.
//       Истина - Удалось подключить дополнительный отчет.
//       Ложь   - Не удалось подключить дополнительный отчет.
//
// Места использования:
//   ВариантыОтчетов.ПодключитьОтчетОбъект().
//   РассылкаОтчетов.ИнициализироватьОтчет().
//
Процедура ПриПодключенииДопОтчета(Ссылка, ПараметрыОтчета, Результат, ПолучатьМетаданные) Экспорт
	Если Не ПолучитьФункциональнуюОпцию(""ИспользоватьДополнительныеОтчетыИОбработки"") Тогда
		ПараметрыОтчета.ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр(""ru = 'Элемент """"%1"""" не подключен, потому что подсистема """"%2"""" отключена в настройках программы.
			|Для включения подсистемы обратитесь к администратору программы.'""),
			""'""+ Строка(Ссылка) +""'"",
			ДополнительныеОтчетыИОбработкиКлиентСервер.НаименованиеПодсистемы(Истина));
		Возврат;
	КонецЕсли;
	
	Вид = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Ссылка, ""Вид"");
	Если Вид = Перечисления.ВидыДополнительныхОтчетовИОбработок.Отчет
		ИЛИ Вид = Перечисления.ВидыДополнительныхОтчетовИОбработок.ДополнительныйОтчет Тогда
		
		Попытка
			ПараметрыОтчета.Имя = ПодключитьВнешнююОбработку(Ссылка);
			ПараметрыОтчета.Объект = ВнешниеОтчеты.Создать(ПараметрыОтчета.Имя);
			Если ПолучатьМетаданные Тогда
				ПараметрыОтчета.Метаданные = ПараметрыОтчета.Объект.Метаданные();
			КонецЕсли;
			Результат = Истина;
		Исключение
			ПараметрыОтчета.ТекстОшибки = 
				СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр(""ru = 'При подключении дополнительного отчета """"%1"""" возникла ошибка:'""), Строка(Ссылка))
				+ Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			Результат = Ложь;
		КонецПопытки;
		
	Иначе
		
		ПараметрыОтчета.ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр(""ru = 'Элемент %1 не является дополнительным отчетом'""),
			""'""+ Строка(Ссылка) +""'"");
		
		Результат = Ложь;
		
	КонецЕсли;
	
КонецПроцедуры

// Подключает отчет подсистемы ""Дополнительные отчеты и обработки"".
//   Обработка исключений производится управляющим кодом.
//
// Параметры:
//   Контекст - Структура - Набор параметров, получаемый в процессе проверки и подключения отчета.
//       См. ВариантыОтчетов.ПриПодключенииОтчета().
//
// Места использования:
//   ВариантыОтчетов.ПриПодключенииОтчета().
//
Процедура ПриПодключенииОтчета(Контекст) Экспорт
	Ссылка = ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(Контекст, ""Отчет"");
	Если ТипЗнч(Ссылка) <> Тип(""СправочникСсылка.ДополнительныеОтчетыИОбработки"") Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр(""ru = 'В процедуру """"%1"""" не передан отчет'""),
			""ДополнительныеОтчетыИОбработки.ПриПодключенииОтчета"");
	КонецЕсли;
	
	Если Не ПолучитьФункциональнуюОпцию(""ИспользоватьДополнительныеОтчетыИОбработки"") Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр(""ru = 'Функциональная опция """"%2"""" отключена в настройках программы.
			|Обратитесь к администратору программы.'""),
			ДополнительныеОтчетыИОбработкиКлиентСервер.НаименованиеПодсистемы(Истина));
	КонецЕсли;
	
	Вид = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Ссылка, ""Вид"");
	Если Вид = Перечисления.ВидыДополнительныхОтчетовИОбработок.Отчет
		Или Вид = Перечисления.ВидыДополнительныхОтчетовИОбработок.ДополнительныйОтчет Тогда
		
		Контекст.ИмяОтчета = ПодключитьВнешнююОбработку(Ссылка);
		Контекст.Подключен = Истина;
		
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр(""ru = 'Объект """"%1"""" не является дополнительным отчетом'""), Строка(Ссылка));
	КонецЕсли;
	
КонецПроцедуры

Процедура ПриОпределенииДоступностиОтчетов(СсылкиДопОтчетов, Результат) Экспорт
	ПодсистемаВключена = Истина;
	ЕстьПравоЧтения = Истина;
	МодульДополнительныеОтчетыИОбработкиВМоделиСервиса = Неопределено;
	Если Не ПолучитьФункциональнуюОпцию(""ИспользоватьДополнительныеОтчетыИОбработки"") Тогда
		ПодсистемаВключена = Ложь;
	ИначеЕсли Не ПравоДоступа(""Чтение"", Метаданные.Справочники.ДополнительныеОтчетыИОбработки) Тогда
		ЕстьПравоЧтения = Ложь;
	ИначеЕсли ИспользуетсяТеснаяИнтеграцияСПодсистемойВМоделиСервиса() Тогда
		МодульДополнительныеОтчетыИОбработкиВМоделиСервиса = ОбщегоНазначения.ОбщийМодуль(""ДополнительныеОтчетыИОбработкиВМоделиСервиса"");
	КонецЕсли;
	
	Для Каждого Отчет Из СсылкиДопОтчетов Цикл
		ОтчетДоступенВМоделиСервиса = Истина;
		Если МодульДополнительныеОтчетыИОбработкиВМоделиСервиса <> Неопределено
			И Не МодульДополнительныеОтчетыИОбработкиВМоделиСервиса.ЭтоПоставляемаяОбработка(Отчет) Тогда
			ОтчетДоступенВМоделиСервиса = Ложь;
		КонецЕсли;
		Найденные = Результат.НайтиСтроки(Новый Структура(""Отчет"", Отчет));
		Для Каждого СтрокаТаблицы Из Найденные Цикл
			Если Не ПодсистемаВключена Тогда
				СтрокаТаблицы.Представление = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр(""ru = '<Отчет """"%1"""" недоступен, т.к. дополнительные отчеты и обработки отключены в настройках программы.'""),
					СтрокаТаблицы.Представление);
			ИначеЕсли Не ЕстьПравоЧтения Тогда
				СтрокаТаблицы.Представление = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр(""ru = '<Отчет """"%1"""" недоступен, т.к. отсутствует право чтения дополнительных отчетов и обработок.'""),
					СтрокаТаблицы.Представление);
			ИначеЕсли Не ОтчетДоступенВМоделиСервиса Тогда
				СтрокаТаблицы.Представление = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр(""ru = '<Отчет """"%1"""" недоступен в модели сервиса.'""),
					СтрокаТаблицы.Представление);
			Иначе
				СтрокаТаблицы.Доступен = Истина;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
КонецПроцедуры

// Дополняет список команд печати внешними печатными формами.
//
// Параметры:
//   КомандыПечати - ТаблицаЗначений - См. УправлениеПечатью.СоздатьКоллекциюКомандПечати().
//   ИмяОбъекта    - Строка          - Полное имя объекта метаданных, для которого необходимо получить список
//                                     команд печати.
//
// Места использования:
//   УправлениеПечатью.КомандыПечатиФормы().
//
Процедура ПриПолученииКомандПечати(КомандыПечати, ИмяОбъекта) Экспорт
	Если Не ПолучитьФункциональнуюОпцию(""ИспользоватьДополнительныеОтчетыИОбработки"") Тогда
		Возврат;
	КонецЕсли;
	Если Не ПравоДоступа(""Чтение"", Метаданные.Справочники.ДополнительныеОтчетыИОбработки) Тогда
		Возврат;
	КонецЕсли;
	ИспользуетсяТеснаяИнтеграцияСПодсистемойВМоделиСервиса = ИспользуетсяТеснаяИнтеграцияСПодсистемойВМоделиСервиса();
	Если ИспользуетсяТеснаяИнтеграцияСПодсистемойВМоделиСервиса Тогда
		МодульДополнительныеОтчетыИОбработкиВМоделиСервиса = ОбщегоНазначения.ОбщийМодуль(""ДополнительныеОтчетыИОбработкиВМоделиСервиса"");
	КонецЕсли;
	
	Запрос = НовыйЗапросПоДоступнымКомандам(Перечисления.ВидыДополнительныхОтчетовИОбработок.ПечатнаяФорма, ИмяОбъекта);
	ТаблицаКоманд = Запрос.Выполнить().Выгрузить();
	
	Если ТаблицаКоманд.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого СтрокаТаблицы Из ТаблицаКоманд Цикл
		Если ИспользуетсяТеснаяИнтеграцияСПодсистемойВМоделиСервиса
			И Не МодульДополнительныеОтчетыИОбработкиВМоделиСервиса.ЭтоПоставляемаяОбработка(СтрокаТаблицы.Ссылка) Тогда
			Продолжить;
		КонецЕсли;
		КомандаПечати = КомандыПечати.Добавить();
		
		// Обязательные параметры.
		ЗаполнитьЗначенияСвойств(КомандаПечати, СтрокаТаблицы, ""Идентификатор, Представление"");
		// Параметры, идентифицирующие подсистему.
		КомандаПечати.МенеджерПечати = ""СтандартныеПодсистемы.ДополнительныеОтчетыИОбработки"";
		
		// Дополнительные параметры.
		КомандаПечати.ДополнительныеПараметры = Новый Структура(""Ссылка, Модификатор, ВариантЗапуска, ПоказыватьОповещение"");
		ЗаполнитьЗначенияСвойств(КомандаПечати.ДополнительныеПараметры, СтрокаТаблицы);
	КонецЦикла;
	
КонецПроцедуры

// Заполняет список печатных форм из внешних источников.
//
// Параметры:
//   ВнешниеПечатныеФормы - СписокЗначений - Печатные формы.
//       Значение      - Строка - Идентификатор печатной формы.
//       Представление - Строка - Название печатной формы.
//   ПолноеИмяОбъектаМетаданных - Строка - Полное имя объекта метаданных,
//       для которого требуется получить список печатных форм.
//
// Места использования:
//   УправлениеПечатью.ПриПолученииСпискаВнешнихПечатныхФорм().
//
Процедура ПриПолученииСпискаВнешнихПечатныхФорм(ВнешниеПечатныеФормы, ПолноеИмяОбъектаМетаданных) Экспорт
	Если Не ПолучитьФункциональнуюОпцию(""ИспользоватьДополнительныеОтчетыИОбработки"") Тогда
		Возврат;
	КонецЕсли;
	Если НЕ ПравоДоступа(""Чтение"", Метаданные.Справочники.ДополнительныеОтчетыИОбработки) Тогда
		Возврат;
	КонецЕсли;
	ИспользуетсяТеснаяИнтеграцияСПодсистемойВМоделиСервиса = ИспользуетсяТеснаяИнтеграцияСПодсистемойВМоделиСервиса();
	Если ИспользуетсяТеснаяИнтеграцияСПодсистемойВМоделиСервиса Тогда
		МодульДополнительныеОтчетыИОбработкиВМоделиСервиса = ОбщегоНазначения.ОбщийМодуль(""ДополнительныеОтчетыИОбработкиВМоделиСервиса"");
	КонецЕсли;
	
	Запрос = НовыйЗапросПоДоступнымКомандам(Перечисления.ВидыДополнительныхОтчетовИОбработок.ПечатнаяФорма, ПолноеИмяОбъектаМетаданных);
	
	ТаблицаКоманд = Запрос.Выполнить().Выгрузить();
	
	Для Каждого Команда Из ТаблицаКоманд Цикл
		Если ИспользуетсяТеснаяИнтеграцияСПодсистемойВМоделиСервиса
			И Не МодульДополнительныеОтчетыИОбработкиВМоделиСервиса.ЭтоПоставляемаяОбработка(Команда.Ссылка) Тогда
			Продолжить;
		КонецЕсли;
		Если СтрНайти(Команда.Идентификатор, "","") = 0 Тогда // кроме ""комплектов""
			ВнешниеПечатныеФормы.Добавить(Команда.Идентификатор, Команда.Представление);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Возвращает ссылку на объект внешней печатной формы.
//
// Места использования:
//   УправлениеПечатью.ПриПолученииВнешнейПечатнойФормы().
//
Процедура ПриПолученииВнешнейПечатнойФормы(Идентификатор, ПолноеИмяОбъектаМетаданных, ВнешняяПечатнаяФормаСсылка) Экспорт
	Если Не ПолучитьФункциональнуюОпцию(""ИспользоватьДополнительныеОтчетыИОбработки"") Тогда
		Возврат;
	КонецЕсли;
	Если НЕ ПравоДоступа(""Чтение"", Метаданные.Справочники.ДополнительныеОтчетыИОбработки) Тогда
		Возврат;
	КонецЕсли;
	
	Запрос = НовыйЗапросПоДоступнымКомандам(Перечисления.ВидыДополнительныхОтчетовИОбработок.ПечатнаяФорма, ПолноеИмяОбъектаМетаданных);
	
	ТаблицаКоманд = Запрос.Выполнить().Выгрузить();
	
	Команда = ТаблицаКоманд.Найти(Идентификатор, ""Идентификатор"");
	Если Команда <> Неопределено Тогда 
		ВнешняяПечатнаяФормаСсылка = Команда.Ссылка;
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Для вызова из обработчиков обновления.

// [2.0.1] Замена имен рабочих мест на ссылки разделов (справочник ИдентификаторыОбъектовМетаданных).
//
// Параметры:
//   ИменаРазделовИИдентификаторы - Соответствие -
//       * Ключ - Строка - Имя рабочего места (команды), которое ранее указывалось в процедурах:
//             ДополнительныеОтчетыИОбработкиПереопределяемый.ПолучитьОбщиеКомандыДополнительныхОбработок();
//             ДополнительныеОтчетыИОбработкиПереопределяемый.ПолучитьОбщиеКомандыДополнительныхОтчетов().
//       * Значение - ОбъектМетаданных: Подсистема - Раздел командного интерфейса (подсистема первого уровня),
//             в котором размещается данное рабочее место (команда).
//
Процедура ЗаменитьИменаРазделовНаИдентификаторы(ИменаРазделовИИдентификаторы) Экспорт
	ИдентификаторРабочегоСтола = ДополнительныеОтчетыИОбработкиКлиентСервер.ИдентификаторРабочегоСтола();
	
	МассивИменРазделов = Новый Массив;
	Для Каждого КлючИЗначение Из ИменаРазделовИИдентификаторы Цикл
		Если КлючИЗначение.Значение = ИдентификаторРабочегоСтола Тогда
			ИменаРазделовИИдентификаторы.Вставить(КлючИЗначение.Ключ, Справочники.ИдентификаторыОбъектовМетаданных.ПустаяСсылка());
		Иначе
			ИменаРазделовИИдентификаторы.Вставить(КлючИЗначение.Ключ, ОбщегоНазначения.ИдентификаторОбъектаМетаданных(КлючИЗначение.Значение));
		КонецЕсли;
		МассивИменРазделов.Добавить(КлючИЗначение.Ключ);
	КонецЦикла;
	
	ТекстЗапроса =
	""ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ТЧРазделы.Ссылка
	|ИЗ
	|	Справочник.ДополнительныеОтчетыИОбработки.Разделы КАК ТЧРазделы
	|ГДЕ
	|	ТЧРазделы.УдалитьИмяРаздела В (&МассивИменРазделов)"";
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр(""МассивИменРазделов"", МассивИменРазделов);
	Запрос.Текст = ТекстЗапроса;
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		// Получение экземпляра объекта.
		Объект = Выборка.Ссылка.ПолучитьОбъект();
		
		Для Каждого СтрокаРаздел Из Объект.Разделы Цикл
			ИОМ = ИменаРазделовИИдентификаторы.Получить(СтрокаРаздел.УдалитьИмяРаздела);
			Если ИОМ = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			СтрокаРаздел.Раздел = ИОМ;
			СтрокаРаздел.УдалитьИмяРаздела = """";
		КонецЦикла; 
		
		// Запись объекта
		ОбновлениеИнформационнойБазы.ЗаписатьДанные(Объект);
	КонецЦикла;
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

////////////////////////////////////////////////////////////////////////////////
// Обновление информационной базы.

// [1.0.7.1] Процедура обновления записей о доступности дополнительных обработок.
Процедура ОбновитьПользовательскиеНастройкиДоступаКОбработкам() Экспорт
	
	ПользователиСДопОбработками = ПользователиСДоступомКДополнительнымОбработкам();
	
	ТекстЗапроса =
	""ВЫБРАТЬ
	|	ДополнительныеОтчетыИОбработки.Ссылка КАК Обработка,
	|	КомандыДополнительныхОтчетовИОбработок.Идентификатор КАК Идентификатор
	|ИЗ
	|	Справочник.ДополнительныеОтчетыИОбработки КАК ДополнительныеОтчетыИОбработки
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ДополнительныеОтчетыИОбработки.Команды КАК КомандыДополнительныхОтчетовИОбработок
	|		ПО (КомандыДополнительныхОтчетовИОбработок.Ссылка = ДополнительныеОтчетыИОбработки.Ссылка)"";
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	ОбработкиСКомандами = Запрос.Выполнить().Выгрузить();
	
	ТаблицаЗаписей = Новый ТаблицаЗначений;
	ТаблицаЗаписей.Колонки.Добавить(""Обработка"",     Новый ОписаниеТипов(""СправочникСсылка.ДополнительныеОтчетыИОбработки""));
	ТаблицаЗаписей.Колонки.Добавить(""Идентификатор"", Новый ОписаниеТипов(""Строка""));
	ТаблицаЗаписей.Колонки.Добавить(""Пользователь"",  Новый ОписаниеТипов(""СправочникСсылка.Пользователи""));
	ТаблицаЗаписей.Колонки.Добавить(""Доступно"",      Новый ОписаниеТипов(""Булево""));
	
	Для Каждого ОбработкаКоманда Из ОбработкиСКомандами Цикл
		Для Каждого Пользователь Из ПользователиСДопОбработками Цикл
			НоваяСтрока = ТаблицаЗаписей.Добавить();
			НоваяСтрока.Обработка     = ОбработкаКоманда.Обработка;
			НоваяСтрока.Идентификатор = ОбработкаКоманда.Идентификатор;
			НоваяСтрока.Пользователь  = Пользователь;
			НоваяСтрока.Доступно   = Истина;
		КонецЦикла;
	КонецЦикла;
	
	ТекстЗапроса =
	""ВЫБРАТЬ
	|	ДополнительныеОтчетыИОбработки.Ссылка КАК Обработка,
	|	КомандыДополнительныхОтчетовИОбработок.Идентификатор КАК Идентификатор,
	|	Пользователи.Ссылка КАК Пользователь,
	|	ПользовательскиеНастройкиДоступаКОбработкам.Доступно КАК Доступно
	|ИЗ
	|	Справочник.ДополнительныеОтчетыИОбработки КАК ДополнительныеОтчетыИОбработки
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ДополнительныеОтчетыИОбработки.Команды КАК КомандыДополнительныхОтчетовИОбработок
	|		ПО (КомандыДополнительныхОтчетовИОбработок.Ссылка = ДополнительныеОтчетыИОбработки.Ссылка)
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ПользовательскиеНастройкиДоступаКОбработкам КАК ПользовательскиеНастройкиДоступаКОбработкам
	|		ПО (ПользовательскиеНастройкиДоступаКОбработкам.ДополнительныйОтчетИлиОбработка = ДополнительныеОтчетыИОбработки.Ссылка)
	|			И (ПользовательскиеНастройкиДоступаКОбработкам.ИдентификаторКоманды = КомандыДополнительныхОтчетовИОбработок.Идентификатор)
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.Пользователи КАК Пользователи
	|		ПО (Пользователи.Ссылка = ПользовательскиеНастройкиДоступаКОбработкам.Пользователь)"";
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	ИсключенияПерсональногоДоступа = Запрос.Выполнить().Выгрузить();
	
	ПоискСтрок = Новый Структура(""Обработка, Идентификатор, Пользователь"");
	Для Каждого ИсключениеПерсональногоДоступа Из ИсключенияПерсональногоДоступа Цикл
		ЗаполнитьЗначенияСвойств(ПоискСтрок, ИсключениеПерсональногоДоступа);
		Найденные = ТаблицаЗаписей.НайтиСтроки(ПоискСтрок);
		Для Каждого СтрокаТаблицы Из Найденные Цикл
			СтрокаТаблицы.Доступно = НЕ ИсключениеПерсональногоДоступа.Доступно; // Инвертируем исключением доступа.
		КонецЦикла; 
	КонецЦикла;
	
	Для Каждого Пользователь Из ПользователиСДопОбработками Цикл
		НаборЗаписей = РегистрыСведений.ПользовательскиеНастройкиДоступаКОбработкам.СоздатьНаборЗаписей();
		НаборЗаписей.Отбор.Пользователь.Установить(Пользователь);
		ЗаписиПоБыстромуДоступу = ТаблицаЗаписей.НайтиСтроки(Новый Структура(""Пользователь,Доступно"", Пользователь, Истина));
		Для Каждого ЗаписьБыстрогоДоступа Из ЗаписиПоБыстромуДоступу Цикл
			НоваяЗапись = НаборЗаписей.Добавить();
			НоваяЗапись.ДополнительныйОтчетИлиОбработка = ЗаписьБыстрогоДоступа.Обработка;
			НоваяЗапись.ИдентификаторКоманды			= ЗаписьБыстрогоДоступа.Идентификатор;
			НоваяЗапись.Пользователь					= Пользователь;
			НоваяЗапись.Доступно						= Истина;
		КонецЦикла;
		ОбновлениеИнформационнойБазы.ЗаписатьДанные(НаборЗаписей);
	КонецЦикла;
	
КонецПроцедуры

// [2.0.1.4] Заполнение реквизита ""ИмяОбъекта"" (имя, под которыми объект регистрируется в программе).
//   Для объектов с вариантом Публикации ""Используется"" дополнительно проводится 
//   контроль уникальности Имени объекта. В случае нахождения отчетов или обработок 
//   с неуникальными Именами объектов для всех элементов, кроме первого, 
//   вариант Публикации изменяется с ""Используется"" на ""Режим отладки"".
//
Процедура ЗаполнитьИменаОбъектов() Экспорт
	ТекстЗапроса =
	""ВЫБРАТЬ
	|	ДопОтчеты.Ссылка,
	|	ДопОтчеты.ИмяОбъекта,
	|	ДопОтчеты.ХранилищеОбработки,
	|	ВЫБОР
	|		КОГДА ДопОтчеты.Вид В (&ВидыДопОтчетов)
	|			ТОГДА ИСТИНА
	|		ИНАЧЕ ЛОЖЬ
	|	КОНЕЦ КАК ЭтоОтчет,
	|	ВЫБОР
	|		КОГДА ДопОтчеты.Публикация = ЗНАЧЕНИЕ(Перечисление.ВариантыПубликацииДополнительныхОтчетовИОбработок.Используется)
	|			ТОГДА ИСТИНА
	|		ИНАЧЕ ЛОЖЬ
	|	КОНЕЦ КАК Публикуется,
	|	ВЫБОР
	|		КОГДА ДопОтчеты.ИмяОбъекта = """"""""
	|			ТОГДА ИСТИНА
	|		ИНАЧЕ ЛОЖЬ
	|	КОНЕЦ КАК ТребуетсяЗаполнитьИмяОбъекта
	|ИЗ
	|	Справочник.ДополнительныеОтчетыИОбработки КАК ДопОтчеты
	|ГДЕ
	|	ДопОтчеты.ЭтоГруппа = ЛОЖЬ
	|	И НЕ ДопОтчеты.ХранилищеОбработки ЕСТЬ NULL "";
	
	ВидыДопОтчетов = Новый Массив;
	ВидыДопОтчетов.Добавить(Перечисления.ВидыДополнительныхОтчетовИОбработок.Отчет);
	ВидыДопОтчетов.Добавить(Перечисления.ВидыДополнительныхОтчетовИОбработок.ДополнительныйОтчет);
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр(""ВидыДопОтчетов"", ВидыДопОтчетов);
	Запрос.Текст = ТекстЗапроса;
	
	ВсеДопОтчеты = Запрос.Выполнить().Выгрузить();
	
	ПоискДублей = Новый Структура(""ИмяОбъекта, ЭтоОтчет, Публикуется"");
	ПоискДублей.Публикуется = Истина;
	
	// Дополнительные отчеты и обработки, для которых необходимо заполнить имя объекта.
	ДопОтчетыДляЗаполнения = ВсеДопОтчеты.НайтиСтроки(Новый Структура(""ТребуетсяЗаполнитьИмяОбъекта"", Истина));
	Для Каждого СтрокаТаблицы Из ДопОтчетыДляЗаполнения Цикл
		
		// Помещение двоичных данных отчета (обработки) во временное хранилище.
		АдресВоВременномХранилище = ПоместитьВоВременноеХранилище(СтрокаТаблицы.ХранилищеОбработки.Получить());
		
		// Определение менеджера
		Менеджер = ?(СтрокаТаблицы.ЭтоОтчет, ВнешниеОтчеты, ВнешниеОбработки);
		
		// Получение экземпляра объекта.
		Объект = СтрокаТаблицы.Ссылка.ПолучитьОбъект();
		
		// Установка имени объекта
		Если ОбщегоНазначения.ЕстьЗащитаОтОпасныхДействий() Тогда
			Объект.ИмяОбъекта = СокрЛП(Менеджер.Подключить(АдресВоВременномХранилище, , Истина,
				ОбщегоНазначения.ОписаниеЗащитыБезПредупреждений()));
		Иначе
			Объект.ИмяОбъекта = СокрЛП(Менеджер.Подключить(АдресВоВременномХранилище, , Истина));
		КонецЕсли;
		
		// Если имя отчета (обработки) уже используется другим опубликованным отчетом (обработкой),
		// то данный объект является дублем - необходимо сменить его вариант публикации на режим отладки (или отключить).
		Если СтрокаТаблицы.Публикуется Тогда
			ПоискДублей.ИмяОбъекта = Объект.ИмяОбъекта;
			ПоискДублей.ЭтоОтчет   = СтрокаТаблицы.ЭтоОтчет;
			Если ВсеДопОтчеты.НайтиСтроки(ПоискДублей).Количество() > 0 Тогда
				ОтключитьКонфликтующую(Объект);
			КонецЕсли;
		КонецЕсли;
		
		// Регистрация использованного имени объекта в таблице для контроля дублей.
		СтрокаТаблицы.ИмяОбъекта = Объект.ИмяОбъекта;
		
		// Запись объекта
		ОбновлениеИнформационнойБазы.ЗаписатьДанные(Объект);
		
	КонецЦикла;
	
КонецПроцедуры

// [2.1.3.2] Замена имен объектов назначения на ссылки справочника ИдентификаторыОбъектовМетаданных.
Процедура ЗаменитьИменаОбъектовМетаданныхНаСсылки() Экспорт
	
	ТекстЗапроса =
	""ВЫБРАТЬ
	|	ТаблицаНазначение.Ссылка КАК СправочникСсылка,
	|	ТаблицаНазначение.НомерСтроки КАК НомерСтроки,
	|	СправочникИОМ.Ссылка КАК ОбъектНазначения
	|ИЗ
	|	Справочник.ДополнительныеОтчетыИОбработки.Назначение КАК ТаблицаНазначение
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.ИдентификаторыОбъектовМетаданных КАК СправочникИОМ
	|		ПО ТаблицаНазначение.УдалитьПолноеИмяОбъектаМетаданных = СправочникИОМ.ПолноеИмя
	|ИТОГИ ПО
	|	СправочникСсылка"";
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	
	ВыборкаСсылок = Запрос.Выполнить().Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	Пока ВыборкаСсылок.Следующий() Цикл
		СправочникОбъект = ВыборкаСсылок.СправочникСсылка.ПолучитьОбъект();
		МассивСтрокДляУдаления = Новый Массив;
		ВыборкаСтрок = ВыборкаСсылок.Выбрать();
		Пока ВыборкаСтрок.Следующий() Цикл
			СтрокаТабличнойЧасти = СправочникОбъект.Назначение.Получить(ВыборкаСтрок.НомерСтроки - 1);
			СтрокаТабличнойЧасти.ОбъектНазначения = ВыборкаСтрок.ОбъектНазначения;
			Если ЗначениеЗаполнено(СтрокаТабличнойЧасти.ОбъектНазначения) Тогда
				СтрокаТабличнойЧасти.УдалитьПолноеИмяОбъектаМетаданных = """";
			Иначе
				МассивСтрокДляУдаления.Добавить(СтрокаТабличнойЧасти);
			КонецЕсли;
		КонецЦикла;
		Для Каждого СтрокаТабличнойЧасти Из МассивСтрокДляУдаления Цикл
			СправочникОбъект.Назначение.Удалить(СтрокаТабличнойЧасти);
		КонецЦикла;
		ОбновлениеИнформационнойБазы.ЗаписатьДанные(СправочникОбъект);
	КонецЦикла;
	
	РегистрыСведений.НазначениеДополнительныхОбработок.Обновить(Истина);
	
КонецПроцедуры

// [2.1.3.22] Включение функциональной опции ИспользоватьДополнительныеОтчетыИОбработки для локального режима.
Процедура ВключитьФункциональнуюОпцию() Экспорт
	
	Если ОбщегоНазначения.РазделениеВключено() Тогда
		Возврат;
	КонецЕсли;
	
	Константы.ИспользоватьДополнительныеОтчетыИОбработки.Установить(Истина);
	
КонецПроцедуры

// [2.2.2.25] Заполнение реквизита РежимСовместимостиРазрешений для справочника ДополнительныеОтчетыИОбработки.
Процедура ЗаполнитьРежимСовместимостиРазрешений() Экспорт
	
	НачатьТранзакцию();
	
	Попытка
		
		Блокировка = Новый БлокировкаДанных();
		Блокировка.Добавить(""Справочник.ДополнительныеОтчетыИОбработки"");
		Блокировка.Заблокировать();
		
		Выборка = Справочники.ДополнительныеОтчетыИОбработки.Выбрать();
		Пока Выборка.Следующий() Цикл
			
			Если Не Выборка.ЭтоГруппа И Не ЗначениеЗаполнено(Выборка.РежимСовместимостиРазрешений) Тогда
				
				ЗаблокироватьДанныеДляРедактирования(Выборка.Ссылка);
				
				Объект = Выборка.ПолучитьОбъект();
				
				Попытка
					
					ОбъектОбработки = ОбъектВнешнейОбработки(Выборка.Ссылка);
					РегистрационныеДанные = ОбъектОбработки.СведенияОВнешнейОбработке();
					
					Если РегистрационныеДанные.Свойство(""ВерсияБСП"") Тогда
						Если ОбщегоНазначенияКлиентСервер.СравнитьВерсии(РегистрационныеДанные.ВерсияБСП, ""2.2.2.0"") > 0 Тогда
							РежимСовместимости = Перечисления.РежимыСовместимостиРазрешенийДополнительныхОтчетовИОбработок.Версия_2_2_2;
						Иначе
							РежимСовместимости = Перечисления.РежимыСовместимостиРазрешенийДополнительныхОтчетовИОбработок.Версия_2_1_3;
						КонецЕсли;
					Иначе
						РежимСовместимости = Перечисления.РежимыСовместимостиРазрешенийДополнительныхОтчетовИОбработок.Версия_2_1_3;
					КонецЕсли;
					
					Публикация = Объект.Публикация;
					
				Исключение
					
					// При невозможности подключения обработки - установим для нее режим совместимости
					// разрешений с версией БСП 2.1.3 и временно заблокируем.
					ТекстОшибки = """""""" + Объект.Наименование + """""":""
						+ Символы.ПС + НСтр(""ru = 'Не удалось определить режим совместимости разрешений по причине:'"")
						+ Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке())
						+ Символы.ПС
						+ Символы.ПС + НСтр(""ru = 'Объект заблокирован в режиме совместимости с версией 2.1.3.'"");
					ЗаписатьПредупреждение(Объект.Ссылка, ТекстОшибки);
					РежимСовместимости = Перечисления.РежимыСовместимостиРазрешенийДополнительныхОтчетовИОбработок.Версия_2_1_3;
					Публикация = Перечисления.ВариантыПубликацииДополнительныхОтчетовИОбработок.Отключена;
					
				КонецПопытки;
				
				Объект.РежимСовместимостиРазрешений = РежимСовместимости;
				Объект.Публикация = Публикация;
				ОбновлениеИнформационнойБазы.ЗаписатьДанные(Объект);
				
			КонецЕсли;
			
		КонецЦикла;
		
		ЗафиксироватьТранзакцию();
		
	Исключение
		
		ОтменитьТранзакцию();
		ВызватьИсключение;
		
	КонецПопытки;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Регламентные задания

// Обработчик экземпляра регламентного задания ЗапускОбработок.
//   Запускает обработчик глобальной обработки по регламентному заданию,
//   с указанным идентификатором команды.
//
// Параметры:
//   ВнешняяОбработка     - СправочникСсылка.ДополнительныеОтчетыИОбработки - Ссылка выполняемой обработки.
//   ИдентификаторКоманды - Строка - Идентификатор выполняемой команды.
//
Процедура ВыполнитьОбработкуПоРегламентномуЗаданию(ВнешняяОбработка, ИдентификаторКоманды) Экспорт
	
	ОбщегоНазначения.ПриНачалеВыполненияРегламентногоЗадания(Метаданные.РегламентныеЗадания.ЗапускДополнительныхОбработок);
	
	// Запись журнала регистрации
	ЗаписатьИнформацию(ВнешняяОбработка, НСтр(""ru = 'Команда %1: Запуск.'""), ИдентификаторКоманды);
	
	// Выполнение команды
	Попытка
		ВыполнитьКоманду(Новый Структура(""ДополнительнаяОбработкаСсылка, ИдентификаторКоманды"", ВнешняяОбработка, ИдентификаторКоманды), Неопределено);
	Исключение
		ЗаписатьОшибку(
			ВнешняяОбработка,
			НСтр(""ru = 'Команда %1: Ошибка выполнения:%2'""),
			ИдентификаторКоманды,
			Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	
	// Запись журнала регистрации
	ЗаписатьИнформацию(ВнешняяОбработка, НСтр(""ru = 'Команда %1: Завершение.'""), ИдентификаторКоманды);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Экспортные служебные процедуры и функции.

// Возвращает Истина если вид относится к категории глобальных дополнительных отчетов или обработок.
//
// Параметры:
//   Вид - ПеречислениеСсылка.ВидыДополнительныхОтчетовИОбработок - Вид внешней обработки.
//
// Возвращаемое значение: 
//    Истина - обработка относится к категории глобальных.
//    Ложь   - обработка относится к категории назначаемых.
//
Функция ПроверитьГлобальнаяОбработка(Вид) Экспорт
	
	Возврат Вид = Перечисления.ВидыДополнительныхОтчетовИОбработок.ДополнительнаяОбработка
		Или Вид = Перечисления.ВидыДополнительныхОтчетовИОбработок.ДополнительныйОтчет;
	
КонецФункции

// Преобразует вид дополнительных отчетов или обработок из строковой константы в ссылку перечисления.
//
// Параметры:
//   СтроковоеПредставление - Строка - Строковое представление вида.
//
// Возвращаемое значение: 
//   ПеречислениеСсылка.ВидыДополнительныхОтчетовИОбработок - Ссылка вида.
//
Функция ПолучитьВидОбработкиПоСтроковомуПредставлениюВида(СтроковоеПредставление) Экспорт
	
	Если СтроковоеПредставление = ДополнительныеОтчетыИОбработкиКлиентСервер.ВидОбработкиЗаполнениеОбъекта() Тогда
		Возврат Перечисления.ВидыДополнительныхОтчетовИОбработок.ЗаполнениеОбъекта;
	ИначеЕсли СтроковоеПредставление = ДополнительныеОтчетыИОбработкиКлиентСервер.ВидОбработкиОтчет() Тогда
		Возврат Перечисления.ВидыДополнительныхОтчетовИОбработок.Отчет;
	ИначеЕсли СтроковоеПредставление = ДополнительныеОтчетыИОбработкиКлиентСервер.ВидОбработкиПечатнаяФорма() Тогда
		Возврат Перечисления.ВидыДополнительныхОтчетовИОбработок.ПечатнаяФорма;
	ИначеЕсли СтроковоеПредставление = ДополнительныеОтчетыИОбработкиКлиентСервер.ВидОбработкиСозданиеСвязанныхОбъектов() Тогда
		Возврат Перечисления.ВидыДополнительныхОтчетовИОбработок.СозданиеСвязанныхОбъектов;
	ИначеЕсли СтроковоеПредставление = ДополнительныеОтчетыИОбработкиКлиентСервер.ВидОбработкиШаблонСообщения() Тогда
		Возврат Перечисления.ВидыДополнительныхОтчетовИОбработок.ШаблонСообщения;
	ИначеЕсли СтроковоеПредставление = ДополнительныеОтчетыИОбработкиКлиентСервер.ВидОбработкиДополнительнаяОбработка() Тогда
		Возврат Перечисления.ВидыДополнительныхОтчетовИОбработок.ДополнительнаяОбработка;
	ИначеЕсли СтроковоеПредставление = ДополнительныеОтчетыИОбработкиКлиентСервер.ВидОбработкиДополнительныйОтчет() Тогда
		Возврат Перечисления.ВидыДополнительныхОтчетовИОбработок.ДополнительныйОтчет;
	КонецЕсли;
	
КонецФункции

// Преобразует вид дополнительных отчетов или обработок из ссылки перечисления в строковую константу.
Функция ВидВСтроку(СсылкаВида) Экспорт
	
	Если СсылкаВида = Перечисления.ВидыДополнительныхОтчетовИОбработок.ЗаполнениеОбъекта Тогда
		Возврат ДополнительныеОтчетыИОбработкиКлиентСервер.ВидОбработкиЗаполнениеОбъекта();
		
	ИначеЕсли СсылкаВида = Перечисления.ВидыДополнительныхОтчетовИОбработок.Отчет Тогда
		Возврат ДополнительныеОтчетыИОбработкиКлиентСервер.ВидОбработкиОтчет();
		
	ИначеЕсли СсылкаВида = Перечисления.ВидыДополнительныхОтчетовИОбработок.ПечатнаяФорма Тогда
		Возврат ДополнительныеОтчетыИОбработкиКлиентСервер.ВидОбработкиПечатнаяФорма();
		
	ИначеЕсли СсылкаВида = Перечисления.ВидыДополнительныхОтчетовИОбработок.СозданиеСвязанныхОбъектов Тогда
		Возврат ДополнительныеОтчетыИОбработкиКлиентСервер.ВидОбработкиСозданиеСвязанныхОбъектов();
		
	ИначеЕсли СсылкаВида = Перечисления.ВидыДополнительныхОтчетовИОбработок.ШаблонСообщения Тогда
		Возврат ДополнительныеОтчетыИОбработкиКлиентСервер.ВидОбработкиШаблонСообщения();
		
	ИначеЕсли СсылкаВида = Перечисления.ВидыДополнительныхОтчетовИОбработок.ДополнительнаяОбработка Тогда
		Возврат ДополнительныеОтчетыИОбработкиКлиентСервер.ВидОбработкиДополнительнаяОбработка();
		
	ИначеЕсли СсылкаВида = Перечисления.ВидыДополнительныхОтчетовИОбработок.ДополнительныйОтчет Тогда
		Возврат ДополнительныеОтчетыИОбработкиКлиентСервер.ВидОбработкиДополнительныйОтчет();
		
	Иначе
		Возврат """";
	КонецЕсли;
	
КонецФункции

// Возвращает имя рабочего места команды.
Функция ПредставлениеРаздела(Раздел) Экспорт
	Если Раздел = ДополнительныеОтчетыИОбработкиКлиентСервер.ИдентификаторРабочегоСтола()
		Или Раздел = Справочники.ИдентификаторыОбъектовМетаданных.ПустаяСсылка() Тогда
		Возврат НСтр(""ru = 'Начальная страница'"");
	Иначе
		Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр(""ru = 'Раздел """"%1""""'""),
			ПредставлениеОбъектаМетаданных(Раздел));
	КонецЕсли;
КонецФункции

// Возвращает имя рабочего места команды.
Функция ПредставлениеОбъектаМетаданных(Объект) Экспорт
	Если ТипЗнч(Объект) = Тип(""СправочникСсылка.ИдентификаторыОбъектовМетаданных"") Тогда
		ОбъектМетаданных = ОбщегоНазначения.ОбъектМетаданныхПоИдентификатору(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип(""ОбъектМетаданных"") Тогда
		ОбъектМетаданных = Объект;
	Иначе
		ОбъектМетаданных = Метаданные.Подсистемы.Найти(Объект);
	КонецЕсли;
	Возврат ОбъектМетаданных.Представление();
КонецФункции

// Проверяет наличие права добавления дополнительных отчетов и обработок.
Функция ПравоДобавления(Знач ДополнительнаяОбработка = Неопределено) Экспорт
	
	Результат = Ложь;
	СтандартнаяОбработка = Истина;
	
	ИнтеграцияСТехнологиейСервиса.ПриПроверкеПраваДобавления(ДополнительнаяОбработка, Результат, СтандартнаяОбработка);
	
	Если СтандартнаяОбработка Тогда
		
		Если ОбщегоНазначения.РазделениеВключено()
		   И ОбщегоНазначения.ДоступноИспользованиеРазделенныхДанных() Тогда
			
			Результат = Пользователи.ЭтоПолноправныйПользователь(, Истина);
		Иначе
			Результат = ПравоДоступа(""Изменение"", Метаданные.Справочники.ДополнительныеОтчетыИОбработки);
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Проверяет возможность выгрузки дополнительного отчета или обработки из программы в файл.
//
// Параметры:
//   Обработка - СправочникСсылка.ДополнительныеОтчетыИОбработки.
//
// Возвращаемое значение:
//   Булево
//
Функция ВозможнаВыгрузкаОбработкиВФайл(Знач Обработка) Экспорт
	
	Результат = Ложь;
	СтандартнаяОбработка = Истина;
	
	ИнтеграцияСТехнологиейСервиса.ПриПроверкеВозможностиВыгрузкиОбработкиВФайл(Обработка, Результат, СтандартнаяОбработка);
	Если Не СтандартнаяОбработка Тогда
		Возврат Результат;
	КонецЕсли;
		
	Возврат Истина;
	
КонецФункции

// Проверяет возможность загрузки уже существующей в ИБ дополнительной обработки из файла.
//
// Параметры:
//   Обработка - СправочникСсылка.ДополнительныеОтчетыИОбработки.
//
// Возвращаемое значение:
//   Булево
//
Функция ВозможнаЗагрузкаОбработкиИзФайла(Знач Обработка) Экспорт
	
	Результат = Ложь;
	СтандартнаяОбработка = Истина;
	ИнтеграцияСТехнологиейСервиса.ПриПроверкеВозможностиЗагрузкиОбработкиИзФайла(Обработка, Результат, СтандартнаяОбработка);
		
	Если Не СтандартнаяОбработка Тогда
		Возврат Результат;
	КонецЕсли;
		
	Возврат Истина;
	
КонецФункции

// Возвращает флажок отображения пользователю расширенной информации о дополнительном отчете или обработке.
//
// Параметры:
//   Обработка - СправочникСсылка.ДополнительныеОтчетыИОбработки.
//
// Возвращаемое значение:
//   Булево
//
Функция ОтображатьРасширеннуюИнформацию(Знач Обработка) Экспорт
	
	Возврат Истина;
	
КонецФункции

// Виды публикации, недоступные для использования в текущем режиме работы программы.
Функция НедоступныеВидыПубликации() Экспорт
	
	Результат = Новый Массив;
	ИнтеграцияСТехнологиейСервиса.ПриЗаполненииНедоступныхВидовПубликации(Результат);
	Возврат Результат;
	
КонецФункции

// Процедура должна вызываться из события ПередЗаписью справочника.
//  ДополнительныеОтчетыИОбработки, выполняет проверку правомерности изменения реквизитов
//  элементов данного справочника для дополнительных обработок, полученных из
//  каталога дополнительных обработок менеджера сервиса.
//
// Параметры:
//   Источник - СправочникОбъект.ДополнительныеОтчетыИОбработки
//   Отказ - булево, флаг отказа от выполнения записи элемента справочника.
//
Процедура ПередЗаписьюДополнительнойОбработки(Источник, Отказ) Экспорт
	
	ИнтеграцияСТехнологиейСервиса.ПередЗаписьюДополнительнойОбработки(Источник, Отказ);
	
КонецПроцедуры

// Процедура должна вызываться из события ПередУдалением справочника.
//  ДополнительныеОтчетыИОбработки.
//
// Параметры:
//  Источник - СправочникОбъект.ДополнительныеОтчетыИОбработки,
//  Отказ - булево, флаг отказа от выполнения удаления элемента справочника из информационной базы.
//
Процедура ПередУдалениемДополнительнойОбработки(Источник, Отказ) Экспорт
	
	ИнтеграцияСТехнологиейСервиса.ПередУдалениемДополнительнойОбработки(Источник, Отказ);
	
КонецПроцедуры

// Определяет, используется ли в текущем сеансе фильтр подключенных дополнительных отчетов и обработок 
// для модели сервиса.
Функция ИспользуетсяТеснаяИнтеграцияСПодсистемойВМоделиСервиса() Экспорт
	Возврат ОбщегоНазначения.РазделениеВключено()
		И ОбщегоНазначения.ПодсистемаСуществует(""ТехнологияСервиса.РаботаВМоделиСервиса.ДополнительныеОтчетыИОбработкиВМоделиСервиса"");
КонецФункции

// Вызывается при создании запроса для получения таблицы команд дополнительных отчетов или обработок.
Функция АдаптироватьЗапросПоДоступнымКомандамКМоделиСервиса(Запрос)
	ИмяРегистра = ""ИспользованиеПоставляемыхДополнительныхОтчетовИОбработокВОбластяхДанных"";
	Запрос.Текст = Запрос.Текст + "";
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	ИтоговаяТаблица.Ссылка,
	|	ИтоговаяТаблица.Идентификатор,
	|	ИтоговаяТаблица.ЗаменяемыеКоманды,
	|	ИтоговаяТаблица.ВариантЗапуска,
	|	ИтоговаяТаблица.Представление КАК Представление,
	|	ИтоговаяТаблица.ПоказыватьОповещение,
	|	ИтоговаяТаблица.Модификатор,
	|	ИтоговаяТаблица.Использование
	|ИЗ
	|	ИтоговаяТаблица КАК ИтоговаяТаблица
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ &ПолноИмяРегистра КАК Инсталляции
	|		ПО ИтоговаяТаблица.Ссылка = Инсталляции.ИспользуемаяОбработка
	|
	|УПОРЯДОЧИТЬ ПО
	|	Представление"";
	Запрос.Текст = СтрЗаменить(Запрос.Текст, ""&ПолноИмяРегистра"", ""РегистрСведений."" + ИмяРегистра);
	Возврат Истина;
КонецФункции

// Запись ошибки в журнал регистрации по дополнительному отчету или обработке.
Процедура ЗаписатьОшибку(Ссылка, ТекстСообщения, Реквизит1 = Неопределено, Реквизит2 = Неопределено, Реквизит3 = Неопределено) Экспорт
	Уровень = УровеньЖурналаРегистрации.Ошибка;
	ЗаписатьВЖурнал(Уровень, Ссылка, ТекстСообщения, Реквизит1, Реквизит2, Реквизит3);
КонецПроцедуры

// Запись предупреждения в журнал регистрации по дополнительному отчету или обработке.
Процедура ЗаписатьПредупреждение(Ссылка, ТекстСообщения, Реквизит1 = Неопределено, Реквизит2 = Неопределено, Реквизит3 = Неопределено)
	Уровень = УровеньЖурналаРегистрации.Предупреждение;
	ЗаписатьВЖурнал(Уровень, Ссылка, ТекстСообщения, Реквизит1, Реквизит2, Реквизит3);
КонецПроцедуры

// Запись информации в журнал регистрации по дополнительному отчету или обработке.
Процедура ЗаписатьИнформацию(Ссылка, ТекстСообщения, Реквизит1 = Неопределено, Реквизит2 = Неопределено, Реквизит3 = Неопределено)
	Уровень = УровеньЖурналаРегистрации.Информация;
	ЗаписатьВЖурнал(Уровень, Ссылка, ТекстСообщения, Реквизит1, Реквизит2, Реквизит3);
КонецПроцедуры

// Запись примечания в журнал регистрации по дополнительному отчету или обработке.
Процедура ЗаписатьПримечание(Ссылка, ТекстСообщения, Реквизит1 = Неопределено, Реквизит2 = Неопределено, Реквизит3 = Неопределено)
	Уровень = УровеньЖурналаРегистрации.Примечание;
	ЗаписатьВЖурнал(Уровень, Ссылка, ТекстСообщения, Реквизит1, Реквизит2, Реквизит3);
КонецПроцедуры

// Запись события в журнал регистрации по дополнительному отчету или обработке.
Процедура ЗаписатьВЖурнал(Уровень, Ссылка, Текст, Параметр1, Параметр2, Параметр3)
	Текст = СтрЗаменить(Текст, ""%1"", Параметр1); // Переход на СтрШаблон невозможен.
	Текст = СтрЗаменить(Текст, ""%2"", Параметр2);
	Текст = СтрЗаменить(Текст, ""%3"", Параметр3);
	ЗаписьЖурналаРегистрации(
		ДополнительныеОтчетыИОбработкиКлиентСервер.НаименованиеПодсистемы(Ложь),
		Уровень,
		Метаданные.Справочники.ДополнительныеОтчетыИОбработки,
		Ссылка,
		Текст);
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Локальные служебные процедуры и функции.

// Для внутреннего использования.
Функция ПользователиСДоступомКДополнительнымОбработкам()
	
	Результат = Новый Массив;
	
	ПроверяемыеРоли = ""ЧтениеДополнительныхОтчетовИОбработок, ДобавлениеИзменениеДополнительныхОтчетовИОбработок"";
	
	Запрос = Новый Запрос(""ВЫБРАТЬ Ссылка ИЗ Справочник.Пользователи"");
	ВсеПользователи = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку(""Ссылка"");
	
	Для Каждого Пользователь Из ВсеПользователи Цикл
		Если Пользователи.РолиДоступны(ПроверяемыеРоли, Пользователь, Ложь) Тогда
			Результат.Добавить(Пользователь);
		КонецЕсли;
	КонецЦикла;
	
	ТекстЗапроса =
	""ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	НастройкиДоступа.Пользователь
	|ИЗ
	|	РегистрСведений.ПользовательскиеНастройкиДоступаКОбработкам КАК НастройкиДоступа
	|ГДЕ
	|	НЕ НастройкиДоступа.Пользователь В (&УжеДобавленныеПользователи)"";
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.Параметры.Вставить(""УжеДобавленныеПользователи"", Результат);
	ПользователиВРегистре = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку(""Пользователь"");
	
	Для Каждого Пользователь Из ПользователиВРегистре Цикл
		Результат.Добавить(Пользователь);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Для внутреннего использования.
Процедура ВыполнитьКомандуДополнительногоОтчетаИлиОбработки(ВнешнийОбъект, Знач ИдентификаторКоманды, ПараметрыКоманды, Знач СценарийВБезопасномРежиме = Ложь)
	
	Если СценарийВБезопасномРежиме Тогда
		
		ВыполнитьСценарийВБезопасномРежиме(ВнешнийОбъект, ПараметрыКоманды);
		
	Иначе
		
		Если ПараметрыКоманды = Неопределено Тогда
			
			ВнешнийОбъект.ВыполнитьКоманду(ИдентификаторКоманды);
			
		Иначе
			
			ВнешнийОбъект.ВыполнитьКоманду(ИдентификаторКоманды, ПараметрыКоманды);
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Для внутреннего использования.
Процедура ВыполнитьНазначаемуюКомандуДополнительногоОтчетаИлиОбработки(ВнешнийОбъект, Знач ИдентификаторКоманды, ПараметрыКоманды, ОбъектыНазначения, Знач СценарийВБезопасномРежиме = Ложь)
	
	Если СценарийВБезопасномРежиме Тогда
		
		ВыполнитьСценарийВБезопасномРежиме(ВнешнийОбъект, ПараметрыКоманды, ОбъектыНазначения);
		
	Иначе
		
		Если ПараметрыКоманды = Неопределено Тогда
			ВнешнийОбъект.ВыполнитьКоманду(ИдентификаторКоманды, ОбъектыНазначения);
		Иначе
			ВнешнийОбъект.ВыполнитьКоманду(ИдентификаторКоманды, ОбъектыНазначения, ПараметрыКоманды);
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Для внутреннего использования.
Процедура ВыполнитьКомандуСозданияСвязанныхОбъектов(ВнешнийОбъект, Знач ИдентификаторКоманды, ПараметрыКоманды, ОбъектыНазначения, ИзмененныеОбъекты, Знач СценарийВБезопасномРежиме = Ложь)
	
	Если СценарийВБезопасномРежиме Тогда
		
		ПараметрыКоманды.Вставить(""ИзмененныеОбъекты"", ИзмененныеОбъекты);
		
		ВыполнитьСценарийВБезопасномРежиме(ВнешнийОбъект, ПараметрыКоманды, ОбъектыНазначения);
		
	Иначе
		
		Если ПараметрыКоманды = Неопределено Тогда
			ВнешнийОбъект.ВыполнитьКоманду(ИдентификаторКоманды, ОбъектыНазначения, ИзмененныеОбъекты);
		Иначе
			ВнешнийОбъект.ВыполнитьКоманду(ИдентификаторКоманды, ОбъектыНазначения, ИзмененныеОбъекты, ПараметрыКоманды);
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Для внутреннего использования.
Процедура ВыполнитьКомандуФормированияПечатнойФормы(ВнешнийОбъект, Знач ИдентификаторКоманды, ПараметрыКоманды, ОбъектыНазначения, Знач СценарийВБезопасномРежиме = Ложь)
	
	Если СценарийВБезопасномРежиме Тогда
		
		ВыполнитьСценарийВБезопасномРежиме(ВнешнийОбъект, ПараметрыКоманды, ОбъектыНазначения);
		
	Иначе
		
		Если ПараметрыКоманды = Неопределено Тогда
			ВнешнийОбъект.Печать(ИдентификаторКоманды, ОбъектыНазначения);
		Иначе
			ВнешнийОбъект.Печать(ИдентификаторКоманды, ОбъектыНазначения, ПараметрыКоманды);
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Выполняет команду дополнительного отчета или обработки из объекта.
Функция ВыполнитьКомандуВнешнегоОбъекта(ВнешнийОбъект, ИдентификаторКоманды, ПараметрыКоманды, АдресРезультата)
	
	СведенияОВнешнемОбъекте = ВнешнийОбъект.СведенияОВнешнейОбработке();
	
	ВидОбработки = ПолучитьВидОбработкиПоСтроковомуПредставлениюВида(СведенияОВнешнемОбъекте.Вид);
	
	ПередаватьПараметры = (
		СведенияОВнешнемОбъекте.Свойство(""ВерсияБСП"")
		И ОбщегоНазначенияКлиентСервер.СравнитьВерсии(СведенияОВнешнемОбъекте.ВерсияБСП, ""1.2.1.4"") >= 0);
	
	РезультатВыполнения = ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(ПараметрыКоманды, ""РезультатВыполнения"");
	Если ТипЗнч(РезультатВыполнения) <> Тип(""Структура"") Тогда
		ПараметрыКоманды.Вставить(""РезультатВыполнения"", Новый Структура());
	КонецЕсли;
	
	ОписаниеКоманды = СведенияОВнешнемОбъекте.Команды.Найти(ИдентификаторКоманды, ""Идентификатор"");
	Если ОписаниеКоманды = Неопределено Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр(""ru = 'Команда %1 не обнаружена.'""), ИдентификаторКоманды);
	КонецЕсли;
	
	ЭтоСценарийВБезопасномРежиме = (ОписаниеКоманды.Использование = ""СценарийВБезопасномРежиме"");
	
	ИзмененныеОбъекты = Неопределено;
	
	Если ВидОбработки = Перечисления.ВидыДополнительныхОтчетовИОбработок.ДополнительнаяОбработка
		ИЛИ ВидОбработки = Перечисления.ВидыДополнительныхОтчетовИОбработок.ДополнительныйОтчет Тогда
		
		ВыполнитьКомандуДополнительногоОтчетаИлиОбработки(
			ВнешнийОбъект,
			ИдентификаторКоманды,
			?(ПередаватьПараметры, ПараметрыКоманды, Неопределено),
			ЭтоСценарийВБезопасномРежиме);
		
	ИначеЕсли ВидОбработки = Перечисления.ВидыДополнительныхОтчетовИОбработок.СозданиеСвязанныхОбъектов Тогда
		
		ИзмененныеОбъекты = Новый Массив;
		ВыполнитьКомандуСозданияСвязанныхОбъектов(
			ВнешнийОбъект,
			ИдентификаторКоманды,
			?(ПередаватьПараметры, ПараметрыКоманды, Неопределено),
			ПараметрыКоманды.ОбъектыНазначения,
			ИзмененныеОбъекты,
			ЭтоСценарийВБезопасномРежиме);
		
	ИначеЕсли ВидОбработки = Перечисления.ВидыДополнительныхОтчетовИОбработок.ЗаполнениеОбъекта
		ИЛИ ВидОбработки = Перечисления.ВидыДополнительныхОтчетовИОбработок.Отчет
		ИЛИ ВидОбработки = Перечисления.ВидыДополнительныхОтчетовИОбработок.ПечатнаяФорма Тогда
		
		ОбъектыНазначения = Неопределено;
		ПараметрыКоманды.Свойство(""ОбъектыНазначения"", ОбъектыНазначения);
		
		Если ВидОбработки = Перечисления.ВидыДополнительныхОтчетовИОбработок.ПечатнаяФорма Тогда
			
			// Здесь только произвольная печать. Печать в MXL выполняется средствами подсистемы Печать.
			ВыполнитьКомандуФормированияПечатнойФормы(
				ВнешнийОбъект,
				ИдентификаторКоманды,
				?(ПередаватьПараметры, ПараметрыКоманды, Неопределено),
				ОбъектыНазначения,
				ЭтоСценарийВБезопасномРежиме);
			
		Иначе
			
			ВыполнитьНазначаемуюКомандуДополнительногоОтчетаИлиОбработки(
				ВнешнийОбъект,
				ИдентификаторКоманды,
				?(ПередаватьПараметры, ПараметрыКоманды, Неопределено),
				ОбъектыНазначения,
				ЭтоСценарийВБезопасномРежиме);
			
			Если ВидОбработки = Перечисления.ВидыДополнительныхОтчетовИОбработок.ЗаполнениеОбъекта Тогда
				ИзмененныеОбъекты = ОбъектыНазначения;
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
	ПараметрыКоманды.РезультатВыполнения.Вставить(""ОповеститьФормы"", СтандартныеПодсистемыСервер.ПодготовитьОповещениеФормОбИзменении(ИзмененныеОбъекты));
	
	Если ТипЗнч(АдресРезультата) = Тип(""Строка"") И ЭтоАдресВременногоХранилища(АдресРезультата) Тогда
		ПоместитьВоВременноеХранилище(ПараметрыКоманды.РезультатВыполнения, АдресРезультата);
	КонецЕсли;
	
	Возврат ПараметрыКоманды.РезультатВыполнения;
	
КонецФункции

// Для внутреннего использования.
Процедура ВыполнитьСценарийВБезопасномРежиме(ВнешнийОбъект, ПараметрыКоманды, ОбъектыНазначения = Неопределено)
	
	РасширениеБезопасногоРежима = ДополнительныеОтчетыИОбработкиВБезопасномРежимеСлужебный;
	
	ВнешнийОбъект = ОбъектВнешнейОбработки(ПараметрыКоманды.ДополнительнаяОбработкаСсылка);
	ИдентификаторКоманды = ПараметрыКоманды.ИдентификаторКоманды;
	
	Сценарий = ВнешнийОбъект.СформироватьСценарий(ИдентификаторКоманды, ПараметрыКоманды);
	КлючСессии = ДополнительныеОтчетыИОбработкиВБезопасномРежимеСлужебный.СформироватьКлючСессииРасширенияБезопасногоРежима(
		ПараметрыКоманды.ДополнительнаяОбработкаСсылка);
	
	РасширениеБезопасногоРежима.ВыполнитьСценарийБезопасногоРежима(
		КлючСессии, Сценарий, ВнешнийОбъект, ПараметрыКоманды, Неопределено, ОбъектыНазначения);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Процедуры используемые при обмене данными.

// Переопределяет стандартное поведение при загрузке данных.
// Реквизит РегламентноеЗаданиеGUID табличной части Команды не переносится,
// т.к. связан с регламентным заданием текущей базы.
//
Процедура ПриПолученииДополнительнойОбработки(ЭлементДанных, ПолучениеЭлемента)
	
	Если ПолучениеЭлемента = ПолучениеЭлементаДанных.Игнорировать Тогда
		
		// Стандартную обработку не переопределяем.
		
	ИначеЕсли ТипЗнч(ЭлементДанных) = Тип(""СправочникОбъект.ДополнительныеОтчетыИОбработки"")
		И ЭлементДанных.Вид = Перечисления.ВидыДополнительныхОтчетовИОбработок.ДополнительнаяОбработка Тогда
		
		// Таблица уникальных идентификаторов регламентных заданий.
		ТекстЗапроса =
		""ВЫБРАТЬ
		|	Команды.Ссылка КАК Ссылка,
		|	Команды.Идентификатор КАК Идентификатор,
		|	Команды.РегламентноеЗаданиеGUID КАК РегламентноеЗаданиеGUID
		|ИЗ
		|	Справочник.ДополнительныеОтчетыИОбработки.Команды КАК Команды
		|ГДЕ
		|	Команды.Ссылка = &Ссылка"";
		
		Запрос = Новый Запрос(ТекстЗапроса);
		Запрос.Параметры.Вставить(""Ссылка"", ЭлементДанных.Ссылка);
		
		ИдентификаторыРегламентныхЗаданий = Запрос.Выполнить().Выгрузить();
		
		// Заполнение идентификаторов регламентных заданий в таблице команд из данных текущей БД.
		Для Каждого СтрокаКоманда Из ЭлементДанных.Команды Цикл
			Найденные = ИдентификаторыРегламентныхЗаданий.НайтиСтроки(Новый Структура(""Идентификатор"", СтрокаКоманда.Идентификатор));
			Если Найденные.Количество() = 0 Тогда
				СтрокаКоманда.РегламентноеЗаданиеGUID = Новый УникальныйИдентификатор(""00000000-0000-0000-0000-000000000000"");
			Иначе
				СтрокаКоманда.РегламентноеЗаданиеGUID = Найденные[0].РегламентноеЗаданиеGUID;
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Сопоставление элементов справочника объектам метаданных конфигурации.

Процедура СопоставитьОбработкиКонфигурацииСОбработкамиСправочника(ОтчетыИОбработки)
	Запрос = Новый Запрос;
	Запрос.Текст =
	""ВЫБРАТЬ
	|	ДополнительныеОтчетыИОбработки.Ссылка,
	|	ДополнительныеОтчетыИОбработки.Версия,
	|	ДополнительныеОтчетыИОбработки.ИмяОбъекта,
	|	ДополнительныеОтчетыИОбработки.ИмяФайла
	|ИЗ
	|	Справочник.ДополнительныеОтчетыИОбработки КАК ДополнительныеОтчетыИОбработки"";
	
	ОбработкиИзКонфигурации = Запрос.Выполнить().Выгрузить();
	Для Каждого ОбработкаКонфигурации Из ОбработкиИзКонфигурации Цикл
		ОбработкаКонфигурации.ИмяОбъекта = ВРег(ОбработкаКонфигурации.ИмяОбъекта);
		ОбработкаКонфигурации.ИмяФайла   = ВРег(ОбработкаКонфигурации.ИмяФайла);
	КонецЦикла;
	ОбработкиИзКонфигурации.Колонки.Добавить(""Найдена"", Новый ОписаниеТипов(""Булево""));
	
	ОтчетыИОбработки.Колонки.Добавить(""Имя"");
	ОтчетыИОбработки.Колонки.Добавить(""ИмяФайла"");
	ОтчетыИОбработки.Колонки.Добавить(""ПолноеИмя"");
	ОтчетыИОбработки.Колонки.Добавить(""Вид"");
	ОтчетыИОбработки.Колонки.Добавить(""Расширение"");
	ОтчетыИОбработки.Колонки.Добавить(""Менеджер"");
	ОтчетыИОбработки.Колонки.Добавить(""Сведения"");
	ОтчетыИОбработки.Колонки.Добавить(""ДанныеИзСправочника"");
	ОтчетыИОбработки.Колонки.Добавить(""Ссылка"");
	
	ОбратныйИндекс = ОтчетыИОбработки.Количество();
	Пока ОбратныйИндекс > 0 Цикл
		ОбратныйИндекс = ОбратныйИндекс - 1;
		СтрокаТаблицы = ОтчетыИОбработки[ОбратныйИндекс];
		
		СтрокаТаблицы.Имя = СтрокаТаблицы.ОбъектМетаданных.Имя;
		СтрокаТаблицы.ПолноеИмя = СтрокаТаблицы.ОбъектМетаданных.ПолноеИмя();
		СтрокаТаблицы.Вид = ВРег(СтрРазделить(СтрокаТаблицы.ПолноеИмя, ""."")[0]);
		Если СтрокаТаблицы.Вид = ""ОТЧЕТ"" Тогда
			СтрокаТаблицы.Расширение = ""erf"";
			МенеджерИзМетаданныхКонфигурации = Отчеты[СтрокаТаблицы.Имя];
		ИначеЕсли СтрокаТаблицы.Вид = ""ОБРАБОТКА"" Тогда
			СтрокаТаблицы.Расширение = ""epf"";
			МенеджерИзМетаданныхКонфигурации = Обработки[СтрокаТаблицы.Имя];
		Иначе
			ОтчетыИОбработки.Удалить(ОбратныйИндекс);
			Продолжить; // Неподдерживаемый вид объекта метаданных.
		КонецЕсли;
		СтрокаТаблицы.ИмяФайла = СтрокаТаблицы.Имя + ""."" + СтрокаТаблицы.Расширение;
		СтрокаТаблицы.СтарыеИменаФайлов.Вставить(0, СтрокаТаблицы.ИмяФайла);
		СтрокаТаблицы.СтарыеИменаОбъектов.Вставить(0, СтрокаТаблицы.Имя);
		
		СтрокаТаблицы.Сведения = МенеджерИзМетаданныхКонфигурации.Создать().СведенияОВнешнейОбработке();
		
		// Поиск в справочнике.
		ДанныеИзСправочника = Неопределено;
		Для Каждого ИмяФайла Из СтрокаТаблицы.СтарыеИменаФайлов Цикл
			ДанныеИзСправочника = ОбработкиИзКонфигурации.Найти(ВРег(ИмяФайла), ""ИмяФайла"");
			Если ДанныеИзСправочника <> Неопределено Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если ДанныеИзСправочника = Неопределено Тогда
			Для Каждого ИмяОбъекта Из СтрокаТаблицы.СтарыеИменаОбъектов Цикл
				ДанныеИзСправочника = ОбработкиИзКонфигурации.Найти(ВРег(ИмяОбъекта), ""ИмяОбъекта"");
				Если ДанныеИзСправочника <> Неопределено Тогда
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		Если ДанныеИзСправочника = Неопределено Тогда
			Продолжить; // Будет зарегистрирована новая обработка.
		КонецЕсли;
		
		Если ВерсияЧислом(ДанныеИзСправочника.Версия) >= ВерсияЧислом(СтрокаТаблицы.Сведения.Версия)
			И СтрокаТаблицы.Сведения.Версия <> Метаданные.Версия Тогда
			// Обновление не требуется, т.к. в справочнике уже актуальная версия обработки.
			ОтчетыИОбработки.Удалить(ОбратныйИндекс);
		Иначе
			// Регистрация ссылки для последующего обновления.
			СтрокаТаблицы.Ссылка = ДанныеИзСправочника.Ссылка;
		КонецЕсли;
		ОбработкиИзКонфигурации.Удалить(ДанныеИзСправочника);
		
	КонецЦикла;
	
	ОтчетыИОбработки.Колонки.Удалить(""СтарыеИменаФайлов"");
	ОтчетыИОбработки.Колонки.Удалить(""СтарыеИменаОбъектов"");
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Выгрузка отчетов и обработок конфигурации в файлы внешних отчетов и обработок.

Процедура ВыгрузитьОтчетыИОбработкиВФайлы(ОтчетыИОбработки)
	
	ОтчетыИОбработки.Колонки.Добавить(""ДвоичныеДанные"");
	Кавычка = """""""";
	Параметры = Новый Структура;
	Параметры.Вставить(""РабочийКаталог"", ОбщегоНазначения.СоздатьВременныйКаталог(""ARADP""));
	КлючЗапуска = "" /DumpConfigToFiles "" + Кавычка + Параметры.РабочийКаталог + Кавычка;
	Выгрузка = ПакетныйЗапускКонфигуратора(Параметры, КлючЗапуска);
	Если Не Выгрузка.Успех Тогда
		ТекстОшибки = СокрЛП(
			НСтр(""ru = 'Не удалось выгрузить отчеты и обработки конфигурации во внешние файлы:'"")
			+ Символы.ПС + Выгрузка.Кратко
			+ Символы.ПС + Выгрузка.Подробно);
		ЗаписатьПредупреждение(Неопределено, ТекстОшибки);
		ОтчетыИОбработки.Очистить();
	КонецЕсли;
	
	ОбратныйИндекс = ОтчетыИОбработки.Количество();
	Пока ОбратныйИндекс > 0 Цикл
		ОбратныйИндекс = ОбратныйИндекс - 1;
		СтрокаТаблицы = ОтчетыИОбработки[ОбратныйИндекс];
		
		Если СтрокаТаблицы.Вид = ""ОТЧЕТ"" Тогда
			КаталогВида = Параметры.РабочийКаталог + ""Reports"" + ПолучитьРазделительПути();
		ИначеЕсли СтрокаТаблицы.Вид = ""ОБРАБОТКА"" Тогда
			КаталогВида = Параметры.РабочийКаталог + ""DataProcessors"" + ПолучитьРазделительПути();
		Иначе
			ЗаписатьОшибку(СтрокаТаблицы.Ссылка, НСтр(""ru = 'Неподдерживаемый вид объектов метаданных: """"1""""'""), СтрокаТаблицы.Вид);
			ОтчетыИОбработки.Удалить(ОбратныйИндекс);
			Продолжить;
		КонецЕсли;
		
		ПолноеИмяСхемыОбъекта = КаталогВида + СтрокаТаблицы.Имя + "".xml"";
		ТекстСхемы = ПрочитатьТекстовыйФайл(ПолноеИмяСхемыОбъекта);
		Если ТекстСхемы = Неопределено Тогда
			ЗаписатьОшибку(СтрокаТаблицы.Ссылка, НСтр(""ru = 'Не обнаружен файл """"%1"""".'""), ПолноеИмяСхемыОбъекта);
			ОтчетыИОбработки.Удалить(ОбратныйИндекс);
			Продолжить;
		КонецЕсли;
		Если СтрокаТаблицы.Вид = ""ОТЧЕТ"" Тогда
			ТекстСхемы = СтрЗаменить(ТекстСхемы, ""Report"", ""ExternalReport"");
			ТекстСхемы = СтрЗаменить(ТекстСхемы, ""ExternalReportTabularSection"", ""ReportTabularSection"");
		ИначеЕсли СтрокаТаблицы.Вид = ""ОБРАБОТКА"" Тогда
			ТекстСхемы = СтрЗаменить(ТекстСхемы, ""DataProcessor"", ""ExternalDataProcessor"");
		КонецЕсли;
		ЗаписатьТекстовыйФайл(ПолноеИмяСхемыОбъекта, ТекстСхемы);
		
		Если СтрокаТаблицы.Вид = ""ОБРАБОТКА"" Тогда
			ДокументDOM = ПрочитатьДокументDOM(ПолноеИмяСхемыОбъекта);
			Разыменователь = Новый РазыменовательПространствИменDOM(ДокументDOM);
			XMLИзменен = Ложь;
			
			ВыраженияПоискаУдаляемыхУзлов = Новый Массив;
			ВыраженияПоискаУдаляемыхУзлов.Добавить(""//xmlns:Command"");
			ВыраженияПоискаУдаляемыхУзлов.Добавить(""//*[contains(@name, 'ExternalDataProcessorManager.')]"");
			ВыраженияПоискаУдаляемыхУзлов.Добавить(""//xmlns:UseStandardCommands"");
			ВыраженияПоискаУдаляемыхУзлов.Добавить(""//xmlns:IncludeHelpInContents"");
			ВыраженияПоискаУдаляемыхУзлов.Добавить(""//xmlns:ExtendedPresentation"");
			ВыраженияПоискаУдаляемыхУзлов.Добавить(""//xmlns:Explanation"");
			
			Для Каждого Выражение Из ВыраженияПоискаУдаляемыхУзлов Цикл
				РезультатXPath = ВычислитьВыражениеXPath(Выражение, ДокументDOM, Разыменователь);
				ЭлементDOM = РезультатXPath.ПолучитьСледующий();
				Пока ЭлементDOM <> Неопределено Цикл
					ЭлементDOM.РодительскийУзел.УдалитьДочерний(ЭлементDOM);
					XMLИзменен = Истина;
					ЭлементDOM = РезультатXPath.ПолучитьСледующий();
				КонецЦикла;
			КонецЦикла;
			
			Если XMLИзменен Тогда
				ЗаписатьДокументDOM(ДокументDOM, ПолноеИмяСхемыОбъекта);
			КонецЕсли;
		КонецЕсли;
		
		ПолноеИмяФайла = Параметры.РабочийКаталог + СтрокаТаблицы.ИмяФайла;
		КлючЗапуска = "" /LoadExternalDataProcessorOrReportFromFiles "" + Кавычка + ПолноеИмяСхемыОбъекта + Кавычка + "" "" + Кавычка + ПолноеИмяФайла + Кавычка;
		СозданиеОбработки = ПакетныйЗапускКонфигуратора(Параметры, КлючЗапуска);
		Если Не СозданиеОбработки.Успех Тогда
			ТекстОшибки = НСтр(""ru = 'Не удалось создать """"%1"""" из внешнего файла """"%2"""":%3'"");
			ЗаписатьПредупреждение(Неопределено, ТекстОшибки, СтрокаТаблицы.ПолноеИмя, ПолноеИмяСхемыОбъекта, Символы.ПС + СокрЛП(СозданиеОбработки.Кратко + Символы.ПС + СозданиеОбработки.Подробно));
			ОтчетыИОбработки.Удалить(ОбратныйИндекс);
			Продолжить;
		КонецЕсли;
		СтрокаТаблицы.ДвоичныеДанные = Новый ДвоичныеДанные(ПолноеИмяФайла);
	КонецЦикла;
	
	Если Параметры.КаталогКопии1CD <> Неопределено Тогда
		ОбщегоНазначения.УдалитьВременныйКаталог(Параметры.КаталогКопии1CD);
	КонецЕсли;
	ОбщегоНазначения.УдалитьВременныйКаталог(Параметры.РабочийКаталог);
	
КонецПроцедуры

Функция ПакетныйЗапускКонфигуратора(Параметры, КлючЗапуска)
	Результат = Новый Структура(""Успех, Кратко, Подробно"", Ложь, """", """");
	Кавычка = """""""";
	ОбразецПараметров = Новый Структура(""РабочийКаталог, Пользователь, Пароль, КаталогBIN, ПутьККонфигурации, КаталогКопии1CD"");
	ОбщегоНазначенияКлиентСервер.ДополнитьСтруктуру(Параметры, ОбразецПараметров, Ложь);
	Если Не ЗначениеЗаполнено(Параметры.Пользователь) Тогда
		Параметры.Пользователь = ИмяПользователя();
	КонецЕсли;
	Если Не ФайлСуществует(Параметры.РабочийКаталог) Тогда
		СоздатьКаталог(Параметры.РабочийКаталог);
	КонецЕсли;
	Если Не ЗначениеЗаполнено(Параметры.КаталогBIN) Тогда
		Параметры.КаталогBIN = КаталогПрограммы();
	КонецЕсли;
	Если Не ЗначениеЗаполнено(Параметры.ПутьККонфигурации) Тогда
		Параметры.ПутьККонфигурации = СтрокаСоединенияИнформационнойБазы();
		Если ОткрытКонфигуратор() Тогда
			Если ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
				КаталогИнформационнойБазы = СтроковыеФункцииКлиентСервер.ПараметрыИзСтроки(Параметры.ПутьККонфигурации).file;
				Параметры.КаталогКопии1CD = Параметры.РабочийКаталог + ""BaseCopy"" + ПолучитьРазделительПути();
				СоздатьКаталог(Параметры.КаталогКопии1CD);
				КопироватьФайл(КаталогИнформационнойБазы + ""\1Cv8.1CD"", Параметры.КаталогКопии1CD + ""1Cv8.1CD"");
				Параметры.ПутьККонфигурации = ""File="" + Кавычка + Параметры.КаталогКопии1CD + Кавычка + "";"";
			Иначе
				Результат.Кратко = НСтр(""ru = 'Для выгрузки модулей необходимо закрыть конфигуратор.'"");
				Возврат Результат;
			КонецЕсли;
		КонецЕсли;
		Параметры.ПутьККонфигурации = СтрЗаменить(Параметры.ПутьККонфигурации, Кавычка, Кавычка + Кавычка);
	КонецЕсли;
	
	ИмяФайлаСообщений = Параметры.РабочийКаталог + ""Выгрузка.log"";
	
	СтрокаКоманды = Кавычка + Параметры.КаталогBIN + ""1cv8.exe"" + Кавычка + "" DESIGNER""
		+ "" /IBConnectionString "" + Кавычка + Параметры.ПутьККонфигурации + Кавычка
		+ ?(Параметры.Пользователь = """",
			"""",
			"" /N "" + Кавычка + Параметры.Пользователь + Кавычка + "" /P "" + Кавычка + Параметры.Пароль + Кавычка)
		+ КлючЗапуска
		+ "" /Out ""                + Кавычка + ИмяФайлаСообщений + Кавычка
		+ "" /DisableStartupDialogs""   // Без стартового диалога и диалогов аутентификации.
		+ "" /DisableStartupMessages""; // Без стартовых предупреждений.
	
	ПараметрыЗапускаКоманды = ОбщегоНазначенияКлиентСервер.ПараметрыЗапускаПрограммы();
	ПараметрыЗапускаКоманды.ДождатьсяЗавершения = Истина;
	
	РезультатЗапуска = ОбщегоНазначенияКлиентСервер.ЗапуститьПрограмму(СтрокаКоманды, ПараметрыЗапускаКоманды);
	
	КодВозврата = РезультатЗапуска.КодВозврата;
	Если КодВозврата = 0 Тогда
		Результат.Успех = Истина;
		Возврат Результат;
	КонецЕсли;
	
	Результат.Кратко = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр(""ru = 'Не удалось выгрузить конфигурацию в XML (код ошибки """"%1"""")'""),
		КодВозврата);
	Если ФайлСуществует(ИмяФайлаСообщений) Тогда
		ЧтениеТекста = Новый ЧтениеТекста(ИмяФайлаСообщений, , , , Ложь);
		Сообщения = СокрЛП(ЧтениеТекста.Прочитать());
		ЧтениеТекста.Закрыть();
		Если Сообщения <> """" Тогда
			Результат.Подробно = СтрЗаменить(Символы.ПС + Сообщения, Символы.ПС, Символы.ПС + Символы.Таб);
		КонецЕсли;
	КонецЕсли;
	Возврат Результат;
	
КонецФункции

Функция ФайлСуществует(ПолноеИмяФайла)
	Файл = Новый Файл(ПолноеИмяФайла);
	Возврат Файл.Существует();
КонецФункции

Функция ОткрытКонфигуратор()
	Сеансы = ПолучитьСеансыИнформационнойБазы();
	Для Каждого Сеанс Из Сеансы Цикл
		Если ВРег(Сеанс.ИмяПриложения) = ""DESIGNER"" Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат Ложь;
КонецФункции

Функция ПрочитатьТекстовыйФайл(ПолноеИмяФайла)
	Если Не ФайлСуществует(ПолноеИмяФайла) Тогда
		Возврат Неопределено;
	КонецЕсли;
	ЧтениеТекста = Новый ЧтениеТекста(ПолноеИмяФайла);
	Текст = ЧтениеТекста.Прочитать();
	ЧтениеТекста.Закрыть();
	Возврат Текст;
КонецФункции

Процедура ЗаписатьТекстовыйФайл(ПолноеИмяФайла, Текст)
	ЗаписьТекста = Новый ЗаписьТекста(ПолноеИмяФайла, КодировкаТекста.UTF8);
	ЗаписьТекста.Записать(Текст);
	ЗаписьТекста.Закрыть();
КонецПроцедуры

Функция ПрочитатьДокументDOM(ПутьКФайлу)
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.ОткрытьФайл(ПутьКФайлу);
	ПостроительDOM = Новый ПостроительDOM;
	ДокументDOM = ПостроительDOM.Прочитать(ЧтениеXML);
	ЧтениеXML.Закрыть();
	
	Возврат ДокументDOM;
КонецФункции

Функция ВычислитьВыражениеXPath(Выражение, ДокументDOM, Разыменователь)
	Возврат ДокументDOM.ВычислитьВыражениеXPath(Выражение, ДокументDOM, Разыменователь);
КонецФункции

Процедура ЗаписатьДокументDOM(ДокументDOM, ИмяФайла)
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.ОткрытьФайл(ИмяФайла);
	ЗаписьDOM = Новый ЗаписьDOM;
	ЗаписьDOM.Записать(ДокументDOM, ЗаписьXML);
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Пакетная регистрация внешних отчетов и обработок в справочнике.

Процедура ЗарегистрироватьОтчетыИОбработки(ОтчетыИОбработки)
	
	Для Каждого СтрокаТаблицы Из ОтчетыИОбработки Цикл
		// Обновление/добавление.
		Если СтрокаТаблицы.Ссылка = Неопределено Тогда
			СправочникОбъект = Справочники.ДополнительныеОтчетыИОбработки.СоздатьЭлемент();
			СправочникОбъект.ИспользоватьДляФормыОбъекта = Истина;
			СправочникОбъект.ИспользоватьДляФормыСписка  = Истина;
			СправочникОбъект.Ответственный               = Пользователи.ТекущийПользователь();
		Иначе
			СправочникОбъект = СтрокаТаблицы.Ссылка.ПолучитьОбъект();
		КонецЕсли;
		
		ЭтоОтчет      = (СтрокаТаблицы.Вид = ""ОТЧЕТ"");
		АдресДанных   = ПоместитьВоВременноеХранилище(СтрокаТаблицы.ДвоичныеДанные);
		Менеджер      = ?(ЭтоОтчет, ВнешниеОтчеты, ВнешниеОбработки);
		Если ОбщегоНазначения.ЕстьЗащитаОтОпасныхДействий() Тогда
			ИмяОбъекта = Менеджер.Подключить(АдресДанных, , Истина,
				ОбщегоНазначения.ОписаниеЗащитыБезПредупреждений());
		Иначе
			ИмяОбъекта = Менеджер.Подключить(АдресДанных, , Истина);
		КонецЕсли;
		ВнешнийОбъект = Менеджер.Создать(ИмяОбъекта);
		
		ВнешнийОбъектМетаданные = ВнешнийОбъект.Метаданные();
		ОбработкаСведения = СтрокаТаблицы.Сведения;
		Если ОбработкаСведения.Наименование = Неопределено ИЛИ ОбработкаСведения.Информация = Неопределено Тогда
			Если ОбработкаСведения.Наименование = Неопределено Тогда
				ОбработкаСведения.Наименование = ВнешнийОбъектМетаданные.Представление();
			КонецЕсли;
			Если ОбработкаСведения.Информация = Неопределено Тогда
				ОбработкаСведения.Информация = ВнешнийОбъектМетаданные.Комментарий;
			КонецЕсли;
		КонецЕсли;
		
		ЗаполнитьЗначенияСвойств(СправочникОбъект, ОбработкаСведения, ""Наименование, БезопасныйРежим, Версия, Информация"");
		
		// Выгрузка настроек команд, которые переопределяются администратором.
		ПоискЗаданий = Новый Соответствие;
		Для Каждого СтараяКоманда Из СправочникОбъект.Команды Цикл
			Если ЗначениеЗаполнено(СтараяКоманда.РегламентноеЗаданиеGUID) Тогда
				ПоискЗаданий.Вставить(ВРег(СтараяКоманда.Идентификатор), СтараяКоманда.РегламентноеЗаданиеGUID);
			КонецЕсли;
		КонецЦикла;
		
		ПараметрыРегистрации = Новый Структура;
		ПараметрыРегистрации.Вставить(""АдресДанныхОбработки"", АдресДанных);
		ПараметрыРегистрации.Вставить(""ЭтоОтчет"", ЭтоОтчет);
		ПараметрыРегистрации.Вставить(""ОтключатьКонфликтующие"", Ложь);
		ПараметрыРегистрации.Вставить(""ИмяФайла"", СтрокаТаблицы.ИмяФайла);
		ПараметрыРегистрации.Вставить(""ОтключатьПубликацию"", Ложь);
		
		СправочникОбъект.ИмяОбъекта = Неопределено;
		СправочникОбъект.Публикация = Перечисления.ВариантыПубликацииДополнительныхОтчетовИОбработок.Используется;
		СправочникОбъект.Вид        = ПолучитьВидОбработкиПоСтроковомуПредставлениюВида(
			ОбработкаСведения.Вид);
		
		Результат = ЗарегистрироватьОбработку(СправочникОбъект, ПараметрыРегистрации);
		Если Не Результат.Успех И Результат.ИмяОбъектаЗанято Тогда
			ПараметрыРегистрации.Вставить(""ОтключатьКонфликтующие"", Истина);
			ПараметрыРегистрации.Вставить(""Конфликтующие"", Результат.Конфликтующие);
			Результат = ЗарегистрироватьОбработку(СправочникОбъект, ПараметрыРегистрации);
		КонецЕсли;
		Если Не Результат.Успех Тогда
			Если Результат.ИмяОбъектаЗанято Тогда
				Результат.ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр(""ru = 'Имя """"%1"""" занято объектами """"%2""""'""),
					ИмяОбъекта,
					Строка(Результат.Конфликтующие));
			КонецЕсли;
			ЗаписьЖурналаРегистрации(
				ДополнительныеОтчетыИОбработкиКлиентСервер.НаименованиеПодсистемы(Ложь),
				УровеньЖурналаРегистрации.Ошибка,
				Метаданные.ОбщиеМакеты.Найти(СтрокаТаблицы.ИмяМакета),
				,
				Результат.ТекстОшибки);
			Продолжить;
		КонецЕсли;
		
		СправочникОбъект.ХранилищеОбработки = Новый ХранилищеЗначения(СтрокаТаблицы.ДвоичныеДанные);
		СправочникОбъект.ИмяОбъекта         = ВнешнийОбъектМетаданные.Имя;
		СправочникОбъект.ИмяФайла           = СтрокаТаблицы.ИмяФайла;
		
		// Очистка и загрузка новых команд.
		Для Каждого Команда Из СправочникОбъект.Команды Цикл
			РегламентноеЗаданиеGUID = ПоискЗаданий.Получить(ВРег(Команда.Идентификатор));
			Если РегламентноеЗаданиеGUID <> Неопределено Тогда
				Команда.РегламентноеЗаданиеGUID = РегламентноеЗаданиеGUID;
				ПоискЗаданий.Удалить(ВРег(Команда.Идентификатор));
			КонецЕсли;
		КонецЦикла;
		
		// Удаление неактуальных заданий.
		Для Каждого КлючИЗначение Из ПоискЗаданий Цикл
			Попытка
				Задание = РегламентныеЗаданияСервер.Задание(КлючИЗначение.Значение);
				Задание.Удалить();
			Исключение
				ЗаписьЖурналаРегистрации(
					ОбновлениеИнформационнойБазы.СобытиеЖурналаРегистрации(),
					УровеньЖурналаРегистрации.Ошибка,
					Метаданные.Справочники.ДополнительныеОтчетыИОбработки,
					СправочникОбъект.Ссылка,
					СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр(""ru = 'Ошибка при удалении задания """"%1"""":%2'""),
						КлючИЗначение.Значение,
						Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке())));
			КонецПопытки;
		КонецЦикла;
		
		Если ПроверитьГлобальнаяОбработка(СправочникОбъект.Вид) Тогда
			ТаблицаОбъектовМетаданных = ПодключенныеОбъектыМетаданных(СправочникОбъект.Вид);
			Для Каждого СтрокаТаблицы Из ТаблицаОбъектовМетаданных Цикл
				РазделСсылка = СтрокаТаблицы.Ссылка;
				СтрокаРаздела = СправочникОбъект.Разделы.Найти(РазделСсылка, ""Раздел"");
				Если СтрокаРаздела = Неопределено Тогда
					СтрокаРаздела = СправочникОбъект.Разделы.Добавить();
					СтрокаРаздела.Раздел = РазделСсылка;
				КонецЕсли;
			КонецЦикла;
		Иначе
			Для Каждого ОписаниеНазначения Из ОбработкаСведения.Назначение Цикл
				ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(ОписаниеНазначения);
				Если ОбъектМетаданных = Неопределено Тогда
					Продолжить;
				КонецЕсли;
				ОбъектНазначенияСсылка = ОбщегоНазначения.ИдентификаторОбъектаМетаданных(ОбъектМетаданных);
				СтрокаНазначения = СправочникОбъект.Назначение.Найти(ОбъектНазначенияСсылка, ""ОбъектНазначения"");
				Если СтрокаНазначения = Неопределено Тогда
					СтрокаНазначения = СправочникОбъект.Назначение.Добавить();
					СтрокаНазначения.ОбъектНазначения = ОбъектНазначенияСсылка;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		ОбновлениеИнформационнойБазы.ЗаписатьОбъект(СправочникОбъект, , Истина);
	КонецЦикла;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Другие

// Устанавливает обработке вид публикации, использующийся для конфликтующих дополнительных отчетов и обработок.
Процедура ОтключитьКонфликтующую(ОбработкаОбъект)
	ВидРежимОтладки = Перечисления.ВариантыПубликацииДополнительныхОтчетовИОбработок.РежимОтладки;
	ДоступныеВиды = ДополнительныеОтчетыИОбработкиПовтИсп.ДоступныеВидыПубликации();
	Если ДоступныеВиды.Найти(ВидРежимОтладки) Тогда
		ОбработкаОбъект.Публикация = ВидРежимОтладки;
	Иначе
		ОбработкаОбъект.Публикация = Перечисления.ВариантыПубликацииДополнительныхОтчетовИОбработок.Отключена;
	КонецЕсли;
КонецПроцедуры

// Для внутреннего использования.
Функция ЗарегистрироватьОбработку(Знач Объект, Знач ПараметрыРегистрации) Экспорт
	
	ВидДополнительнаяОбработка = Перечисления.ВидыДополнительныхОтчетовИОбработок.ДополнительнаяОбработка;
	ВидДополнительныйОтчет     = Перечисления.ВидыДополнительныхОтчетовИОбработок.ДополнительныйОтчет;
	ВидОтчет                   = Перечисления.ВидыДополнительныхОтчетовИОбработок.Отчет;
	
	// Получает файл обработки из временного хранилища, пытается создать объект
	// обработки (внешнего отчета) и получает информацию из объекта внешней обработки (отчета).
	
	Если ПараметрыРегистрации.ОтключатьКонфликтующие Тогда
		Для Каждого ЭлементСписка Из ПараметрыРегистрации.Конфликтующие Цикл
			КонфликтующийОбъект = ЭлементСписка.Значение.ПолучитьОбъект();
			ОтключитьКонфликтующую(КонфликтующийОбъект);
			КонфликтующийОбъект.Записать();
		КонецЦикла;
	ИначеЕсли ПараметрыРегистрации.ОтключатьПубликацию Тогда
		ОтключитьКонфликтующую(Объект);
	КонецЕсли;
	
	Результат = Новый Структура(""ИмяОбъекта, СтароеИмяОбъекта, Успех, ИмяОбъектаЗанято, Конфликтующие, ТекстОшибки, КраткоеПредставлениеОшибки"");
	Результат.ИмяОбъектаЗанято = Ложь;
	Результат.Успех = Ложь;
	Если Объект.ЭтоНовый() Тогда
		Результат.СтароеИмяОбъекта = Объект.ИмяОбъекта;
	Иначе
		Результат.СтароеИмяОбъекта = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Объект.Ссылка, ""ИмяОбъекта"");
	КонецЕсли;
	
	РегистрационныеДанные = ПолучитьРегистрационныеДанные(Объект, ПараметрыРегистрации, Результат);
	Если РегистрационныеДанные = Неопределено
		Или РегистрационныеДанные.Количество() = 0
		Или ЗначениеЗаполнено(Результат.ТекстОшибки)
		Или ЗначениеЗаполнено(Результат.КраткоеПредставлениеОшибки) Тогда
		Возврат Результат;
	КонецЕсли;
	
	Если РегистрационныеДанные.Вид = Перечисления.ВидыДополнительныхОтчетовИОбработок.ПечатнаяФорма
		И Не ОбщегоНазначения.ПодсистемаСуществует(""СтандартныеПодсистемы.Печать"") Тогда
		Результат.ТекстОшибки = НСтр(""ru = 'Работа с печатными формами не поддерживается.'"");
		Возврат Результат;
	КонецЕсли;
	
	// Если отчет публикуется, то необходим контроль уникальности имени объекта, 
	//     под которым дополнительный отчет регистрируется в системе.
	Если Объект.Публикация = Перечисления.ВариантыПубликацииДополнительныхОтчетовИОбработок.Используется Тогда
		// Проверка имени
		ТекстЗапроса =
		""ВЫБРАТЬ
		|	ТаблицаСправочника.Ссылка,
		|	ТаблицаСправочника.Представление
		|ИЗ
		|	Справочник.ДополнительныеОтчетыИОбработки КАК ТаблицаСправочника
		|ГДЕ
		|	ТаблицаСправочника.ИмяОбъекта = &ИмяОбъекта
		|	И &УсловиеДопОтчет
		|	И ТаблицаСправочника.Публикация = ЗНАЧЕНИЕ(Перечисление.ВариантыПубликацииДополнительныхОтчетовИОбработок.Используется)
		|	И ТаблицаСправочника.ПометкаУдаления = ЛОЖЬ
		|	И ТаблицаСправочника.Ссылка <> &Ссылка"";
		
		ВидыДопОтчетов = Новый Массив;
		ВидыДопОтчетов.Добавить(ВидДополнительныйОтчет);
		ВидыДопОтчетов.Добавить(ВидОтчет);
		
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр(""ИмяОбъекта"",     Результат.ИмяОбъекта);
		Запрос.УстановитьПараметр(""ВидыДопОтчетов"", ВидыДопОтчетов);
		Запрос.УстановитьПараметр(""Ссылка"", Объект.Ссылка);
		
		Если ПараметрыРегистрации.ЭтоОтчет Тогда
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, ""&УсловиеДопОтчет"", ""ТаблицаСправочника.Вид В (&ВидыДопОтчетов)"");
		Иначе
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, ""&УсловиеДопОтчет"", ""НЕ ТаблицаСправочника.Вид В (&ВидыДопОтчетов)"");
		КонецЕсли;
		
		Запрос.Текст = ТекстЗапроса;
		
		УстановитьПривилегированныйРежим(Истина);
		Конфликтующие = Запрос.Выполнить().Выгрузить();
		УстановитьПривилегированныйРежим(Ложь);
		
		Если Конфликтующие.Количество() > 0 Тогда
			Результат.ИмяОбъектаЗанято = Истина;
			Результат.Конфликтующие = Новый СписокЗначений;
			Для Каждого СтрокаТаблицы Из Конфликтующие Цикл
				Результат.Конфликтующие.Добавить(СтрокаТаблицы.Ссылка, СтрокаТаблицы.Представление);
			КонецЦикла;
			Возврат Результат;
		КонецЕсли;
	КонецЕсли;
	
	Если РегистрационныеДанные.БезопасныйРежим
		ИЛИ Пользователи.ЭтоПолноправныйПользователь(, Истина) Тогда
		// ничего не делаем
	Иначе
		Результат.ТекстОшибки = НСтр(""ru = 'Для подключения обработки, запускаемой в небезопасном режиме, требуются административные права.'"");
		Возврат Результат;
	КонецЕсли;
	
	Если НЕ Объект.ЭтоНовый() И РегистрационныеДанные.Вид <> Объект.Вид Тогда
		Результат.ТекстОшибки = 
			СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр(""ru = 'Вид загружаемого объекта (%1) не соответствует текущему (%2).
					|Для загрузки нового объекта нажмите """"Создать"""".'""),
				Строка(РегистрационныеДанные.Вид),
				Строка(Объект.Вид));
		Возврат Результат;
	ИначеЕсли ПараметрыРегистрации.ЭтоОтчет <> (РегистрационныеДанные.Вид = ВидДополнительныйОтчет ИЛИ РегистрационныеДанные.Вид = ВидОтчет) Тогда
		Результат.ТекстОшибки = НСтр(""ru = 'Вид обработки, указанный в сведениях о внешней обработке, не соответствует ее расширению.'"");
		Возврат Результат;
	КонецЕсли;
	
	Объект.Наименование    = РегистрационныеДанные.Наименование;
	Объект.Версия          = РегистрационныеДанные.Версия;
	
	Если РегистрационныеДанные.Свойство(""ВерсияБСП"") Тогда
		Если ОбщегоНазначенияКлиентСервер.СравнитьВерсии(РегистрационныеДанные.ВерсияБСП, ""2.2.2.0"") > 0 Тогда
			Объект.РежимСовместимостиРазрешений = Перечисления.РежимыСовместимостиРазрешенийДополнительныхОтчетовИОбработок.Версия_2_2_2;
		Иначе
			Объект.РежимСовместимостиРазрешений = Перечисления.РежимыСовместимостиРазрешенийДополнительныхОтчетовИОбработок.Версия_2_1_3;
		КонецЕсли;
	Иначе
		Объект.РежимСовместимостиРазрешений = Перечисления.РежимыСовместимостиРазрешенийДополнительныхОтчетовИОбработок.Версия_2_1_3;
	КонецЕсли;
	
	Если РегистрационныеДанные.Свойство(""БезопасныйРежим"") Тогда
		Объект.БезопасныйРежим = РегистрационныеДанные.БезопасныйРежим;
	КонецЕсли;
	
	Объект.Информация      = РегистрационныеДанные.Информация;
	Объект.ИмяФайла        = ПараметрыРегистрации.ИмяФайла;
	Объект.ИмяОбъекта      = Результат.ИмяОбъекта;
	
	Объект.ИспользуетХранилищеВариантов = Ложь;
	Если (РегистрационныеДанные.Вид = ВидДополнительныйОтчет) ИЛИ (РегистрационныеДанные.Вид = ВидОтчет) Тогда
		Если РегистрационныеДанные.ХранилищеВариантов = ""ХранилищеВариантовОтчетов""
			ИЛИ (Метаданные.ХранилищеВариантовОтчетов <> Неопределено
				И Метаданные.ХранилищеВариантовОтчетов.Имя = ""ХранилищеВариантовОтчетов"") Тогда
			Объект.ИспользуетХранилищеВариантов = Истина;
		КонецЕсли;
		РегистрационныеДанные.Свойство(""ОпределитьНастройкиФормы"", Объект.ТеснаяИнтеграцияСФормойОтчета);
	КонецЕсли;
	
	// Загружена другая обработка (изменилось имя объекта или вид обработки).
	Если Объект.ЭтоНовый() ИЛИ Объект.ИмяОбъекта <> Результат.ИмяОбъекта ИЛИ Объект.Вид <> РегистрационныеДанные.Вид Тогда
		Объект.Назначение.Очистить();
		Объект.Разделы.Очистить();
		Объект.Вид = РегистрационныеДанные.Вид;
	КонецЕсли;
	
	// Если не заполнено назначение - устанавливаем назначение из обработки.
	Если Объект.Назначение.Количество() = 0
		И Объект.Вид <> ВидДополнительныйОтчет
		И Объект.Вид <> ВидДополнительнаяОбработка Тогда
		
		Если РегистрационныеДанные.Свойство(""Назначение"") Тогда
			ТаблицаОбъектовМетаданных = ПодключенныеОбъектыМетаданных(Объект.Вид);
			
			Для Каждого ПолноеИмяОбъектаМетаданных Из РегистрационныеДанные.Назначение Цикл
				ПозицияТочки = СтрНайти(ПолноеИмяОбъектаМетаданных, ""."");
				Если Сред(ПолноеИмяОбъектаМетаданных, ПозицияТочки + 1) = ""*"" Тогда // Например [Справочник.*].
					Поиск = Новый Структура(""Вид"", Лев(ПолноеИмяОбъектаМетаданных, ПозицияТочки - 1));
				Иначе
					Поиск = Новый Структура(""ПолноеИмя"", ПолноеИмяОбъектаМетаданных);
				КонецЕсли;
				
				Найденные = ТаблицаОбъектовМетаданных.НайтиСтроки(Поиск);
				Для Каждого СтрокаТаблицы Из Найденные Цикл
					СтрокаНазначение = Объект.Назначение.Добавить();
					СтрокаНазначение.ОбъектНазначения = СтрокаТаблицы.Ссылка;
				КонецЦикла;
			КонецЦикла;
		КонецЕсли;
		
		Объект.Назначение.Свернуть(""ОбъектНазначения"", """");
		
	КонецЕсли;
	
	Объект.Команды.Очистить();
	
	// Инициализация команд
	
	Для Каждого КомандаОписание Из РегистрационныеДанные.Команды Цикл
		
		Если НЕ ЗначениеЗаполнено(КомандаОписание.ВариантЗапуска) Тогда
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
				СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр(""ru = 'Для команды """"%1"""" не определен способ запуска.'""), КомандаОписание.Представление));
		КонецЕсли;
		
		Команда = Объект.Команды.Добавить();
		ЗаполнитьЗначенияСвойств(Команда, КомандаОписание);
		
	КонецЦикла;
	
	// Чтение разрешений, запрашиваемых дополнительной обработкой.
	Объект.Разрешения.Очистить();
	Разрешения = Неопределено;
	Если РегистрационныеДанные.Свойство(""Разрешения"", Разрешения) Тогда
		
		Для Каждого Разрешение Из Разрешения Цикл
			
			ТипXDTO = Разрешение.Тип();
			
			СтрокаТЧ = Объект.Разрешения.Добавить();
			СтрокаТЧ.ВидРазрешения = ТипXDTO.Имя;
			
			Параметры = Новый Структура();
			
			Для Каждого СвойствоXDTO Из ТипXDTO.Свойства Цикл
				
				Контейнер = Разрешение.ПолучитьXDTO(СвойствоXDTO.Имя);
				
				Если Контейнер <> Неопределено Тогда
					Параметры.Вставить(СвойствоXDTO.Имя, Контейнер.Значение);
				Иначе
					Параметры.Вставить(СвойствоXDTO.Имя);
				КонецЕсли;
				
			КонецЦикла;
			
			СтрокаТЧ.Параметры = Новый ХранилищеЗначения(Параметры);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Объект.Ответственный = Пользователи.ТекущийПользователь();
	
	Результат.Успех = Истина;
	
	Возврат Результат;
	
КонецФункции

// Для внутреннего использования.
Функция ПолучитьРегистрационныеДанные(Знач Объект, Знач ПараметрыРегистрации, Знач РезультатРегистрации)

	РегистрационныеДанные = Новый Структура;
	СтандартнаяОбработка = Истина;
	
	ИнтеграцияСТехнологиейСервиса.ПриПолученииРегистрационныхДанных(Объект, РегистрационныеДанные, СтандартнаяОбработка);
	Если СтандартнаяОбработка Тогда
		ПриПолученииРегистрационныхДанных(Объект, РегистрационныеДанные, ПараметрыРегистрации, РезультатРегистрации);
	КонецЕсли;
	
	Возврат РегистрационныеДанные;
КонецФункции

// Для внутреннего использования.
Процедура ПриПолученииРегистрационныхДанных(Объект, РегистрационныеДанные, ПараметрыРегистрации, РезультатРегистрации)
	
	// Подключение и получение имени, под которым объект будет подключаться.
	Менеджер = ?(ПараметрыРегистрации.ЭтоОтчет, ВнешниеОтчеты, ВнешниеОбработки);
	
	ИнформацияОбОшибке = Неопределено;
	Попытка
		#Если ТолстыйКлиентОбычноеПриложение Тогда
			РезультатРегистрации.ИмяОбъекта = ПолучитьИмяВременногоФайла();
			ДвоичныеДанные = ПолучитьИзВременногоХранилища(ПараметрыРегистрации.АдресДанныхОбработки);
			ДвоичныеДанные.Записать(РезультатРегистрации.ИмяОбъекта);
		#Иначе
			Если ОбщегоНазначения.ЕстьЗащитаОтОпасныхДействий() Тогда
				РезультатРегистрации.ИмяОбъекта =
					СокрЛП(Менеджер.Подключить(ПараметрыРегистрации.АдресДанныхОбработки, , Истина,
						ОбщегоНазначения.ОписаниеЗащитыБезПредупреждений()));
			Иначе
				РезультатРегистрации.ИмяОбъекта =
					СокрЛП(Менеджер.Подключить(ПараметрыРегистрации.АдресДанныхОбработки, , Истина));
			КонецЕсли;
		#КонецЕсли
		
		// Получение сведений о внешней обработке.
		ВнешнийОбъект = Менеджер.Создать(РезультатРегистрации.ИмяОбъекта);
		ВнешнийОбъектМетаданные = ВнешнийОбъект.Метаданные();
		
		СведенияОВнешнейОбработке = ВнешнийОбъект.СведенияОВнешнейОбработке();
		ОбщегоНазначенияКлиентСервер.ДополнитьСтруктуру(РегистрационныеДанные, СведенияОВнешнейОбработке, Истина);
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
	КонецПопытки;
	#Если ТолстыйКлиентОбычноеПриложение Тогда
		Попытка
			УдалитьФайлы(РезультатРегистрации.ИмяОбъекта);
		Исключение
			ТекстПредупреждения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр(""ru = 'Ошибка при получении регистрационных данных:
				|Ошибка при удалении временного файла """"%1"""":
				|%2'""),
				РезультатРегистрации.ИмяОбъекта,
				ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			ЗаписатьПредупреждение(Объект.Ссылка, ТекстПредупреждения);
		КонецПопытки;
	#КонецЕсли
	Если ИнформацияОбОшибке <> Неопределено Тогда
		Если ПараметрыРегистрации.ЭтоОтчет Тогда
			ТекстОшибки = НСтр(""ru='Невозможно подключить дополнительный отчет из файла.
			|Возможно, он не подходит для этой версии программы.'"");
		Иначе
			ТекстОшибки = НСтр(""ru='Невозможно подключить дополнительную обработку из файла.
			|Возможно, она не подходит для этой версии программы.'"");
		КонецЕсли;
		РезультатРегистрации.ТекстОшибки = ТекстОшибки;
		РезультатРегистрации.КраткоеПредставлениеОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке);
		ТекстОшибки = ТекстОшибки + Символы.ПС + Символы.ПС + НСтр(""ru = 'Техническая информация:'"") + Символы.ПС;
		ЗаписатьОшибку(Объект.Ссылка, ТекстОшибки + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке));
		Возврат;
	КонецЕсли;
	
	Если РегистрационныеДанные.Наименование = Неопределено ИЛИ РегистрационныеДанные.Информация = Неопределено Тогда
		Если РегистрационныеДанные.Наименование = Неопределено Тогда
			РегистрационныеДанные.Наименование = ВнешнийОбъектМетаданные.Представление();
		КонецЕсли;
		Если РегистрационныеДанные.Информация = Неопределено Тогда
			РегистрационныеДанные.Информация = ВнешнийОбъектМетаданные.Комментарий;
		КонецЕсли;
	КонецЕсли;
	
	Если ТипЗнч(РегистрационныеДанные.Вид) <> Тип(""ПеречислениеСсылка.ВидыДополнительныхОтчетовИОбработок"") Тогда
		РегистрационныеДанные.Вид = Перечисления.ВидыДополнительныхОтчетовИОбработок[РегистрационныеДанные.Вид];
	КонецЕсли;
	
	РегистрационныеДанные.Вставить(""ХранилищеВариантов"");
	Если РегистрационныеДанные.Вид = Перечисления.ВидыДополнительныхОтчетовИОбработок.ДополнительныйОтчет
		Или РегистрационныеДанные.Вид = Перечисления.ВидыДополнительныхОтчетовИОбработок.Отчет Тогда
		Если ВнешнийОбъектМетаданные.ХранилищеВариантов <> Неопределено Тогда
			РегистрационныеДанные.ХранилищеВариантов = ВнешнийОбъектМетаданные.ХранилищеВариантов.Имя;
		КонецЕсли;
	КонецЕсли;
	
	РегистрационныеДанные.Команды.Колонки.Добавить(""ВариантЗапуска"");
	
	Для Каждого КомандаОписание Из РегистрационныеДанные.Команды Цикл
		КомандаОписание.ВариантЗапуска = Перечисления.СпособыВызоваДополнительныхОбработок[КомандаОписание.Использование];
	КонецЦикла;
	
	#Если ТолстыйКлиентОбычноеПриложение Тогда
		РезультатРегистрации.ИмяОбъекта = ВнешнийОбъектМетаданные.Имя;
	#КонецЕсли
КонецПроцедуры

// Вывод команд заполнения в формах объектов.
Процедура ПриОпределенииКомандЗаполненияПодключенныхКОбъекту(Команды, ИОМы, БыстрыйПоискПоИОМам)
	Запрос = Новый Запрос;
	Запрос.Текст =
	""ВЫБРАТЬ
	|	Таблица.Ссылка,
	|	Таблица.Команды.(
	|		Идентификатор,
	|		ВариантЗапуска,
	|		Представление,
	|		ПоказыватьОповещение,
	|		Скрыть
	|	),
	|	Таблица.Назначение.(
	|		ОбъектНазначения
	|	)
	|ИЗ
	|	Справочник.ДополнительныеОтчетыИОбработки КАК Таблица
	|ГДЕ
	|	Таблица.Назначение.ОбъектНазначения В(&ИОМы)
	|	И Таблица.Вид = &Вид
	|	И Таблица.ИспользоватьДляФормыОбъекта = ИСТИНА
	|	И Таблица.Публикация = ЗНАЧЕНИЕ(Перечисление.ВариантыПубликацииДополнительныхОтчетовИОбработок.Используется)
	|	И Таблица.Публикация <> ЗНАЧЕНИЕ(Перечисление.ВариантыПубликацииДополнительныхОтчетовИОбработок.Отключена)
	|	И Таблица.ПометкаУдаления = ЛОЖЬ"";
	Запрос.УстановитьПараметр(""ИОМы"", ИОМы);
	Запрос.УстановитьПараметр(""Вид"", Перечисления.ВидыДополнительныхОтчетовИОбработок.ЗаполнениеОбъекта);
	Если ПравоДоступа(""Изменение"", Метаданные.Справочники.ДополнительныеОтчетыИОбработки) Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст, ""И Таблица.Публикация = ЗНАЧЕНИЕ(Перечисление.ВариантыПубликацииДополнительныхОтчетовИОбработок.Используется)"", """");
	Иначе
		Запрос.Текст = СтрЗаменить(Запрос.Текст, ""И Таблица.Публикация <> ЗНАЧЕНИЕ(Перечисление.ВариантыПубликацииДополнительныхОтчетовИОбработок.Отключена)"", """");
	КонецЕсли;
	
	КлючиПараметровОбработчика = ""Ссылка, Идентификатор, ВариантЗапуска, Представление, ПоказыватьОповещение, ЭтоОтчет"";
	ЗаполнениеФормы = Перечисления.СпособыВызоваДополнительныхОбработок.ЗаполнениеФормы;
	
	ИспользуетсяТеснаяИнтеграцияСПодсистемойВМоделиСервиса = ИспользуетсяТеснаяИнтеграцияСПодсистемойВМоделиСервиса();
	Если ИспользуетсяТеснаяИнтеграцияСПодсистемойВМоделиСервиса Тогда
		МодульДополнительныеОтчетыИОбработкиВМоделиСервиса = ОбщегоНазначения.ОбщийМодуль(""ДополнительныеОтчетыИОбработкиВМоделиСервиса"");
	КонецЕсли;
	
	Таблица = Запрос.Выполнить().Выгрузить();
	Для Каждого ОтчетИлиОбработка Из Таблица Цикл
		Если ИспользуетсяТеснаяИнтеграцияСПодсистемойВМоделиСервиса
			И Не МодульДополнительныеОтчетыИОбработкиВМоделиСервиса.ЭтоПоставляемаяОбработка(ОтчетИлиОбработка.Ссылка) Тогда
			Продолжить;
		КонецЕсли;
		
		ТипыЗаполнениеОбъекта = Новый Массив;
		Для Каждого СтрокаТаблицыНазначение Из ОтчетИлиОбработка.Назначение Цикл
			Источник = БыстрыйПоискПоИОМам[СтрокаТаблицыНазначение.ОбъектНазначения];
			Если Источник = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			ПодключаемыеКоманды.ДополнитьМассивТипов(ТипыЗаполнениеОбъекта, Источник.ТипСсылкиДанных);
		КонецЦикла;
		
		Для Каждого СтрокаТаблицы Из ОтчетИлиОбработка.Команды Цикл
			Если СтрокаТаблицы.Скрыть Тогда
				Продолжить;
			КонецЕсли;
			Команда = Команды.Добавить();
			Команда.Вид            = ""ЗаполнениеОбъектов"";
			Команда.Представление  = СтрокаТаблицы.Представление;
			Команда.Важность       = ""СмТакже"";
			Команда.Порядок        = 50;
			Команда.ИзменяетВыбранныеОбъекты = Истина;
			Если СтрокаТаблицы.ВариантЗапуска = ЗаполнениеФормы Тогда
				Команда.Обработчик  = ""ДополнительныеОтчетыИОбработки.ОбработчикКомандыЗаполнения"";
				Команда.РежимЗаписи = ""НеЗаписывать"";
			Иначе
				Команда.Обработчик  = ""ДополнительныеОтчетыИОбработкиКлиент.ОбработчикКомандыЗаполнения"";
				Команда.РежимЗаписи = ""Записывать"";
			КонецЕсли;
			Команда.ТипПараметра = Новый ОписаниеТипов(ТипыЗаполнениеОбъекта);
			Команда.ДополнительныеПараметры = Новый Структура(КлючиПараметровОбработчика);
			ЗаполнитьЗначенияСвойств(Команда.ДополнительныеПараметры, СтрокаТаблицы);
			Команда.ДополнительныеПараметры.Ссылка = ОтчетИлиОбработка.Ссылка;
			Команда.ДополнительныеПараметры.ЭтоОтчет = Ложь;
		КонецЦикла;
	КонецЦикла;
КонецПроцедуры

// Преобразует строковое представление версии в числовое.
//
Функция ВерсияЧислом(ВерсияСтрокой)
	Если ПустаяСтрока(ВерсияСтрокой) Или ВерсияСтрокой = ""0.0.0.0"" Тогда
		Возврат 0;
	КонецЕсли;
	
	Разряд = 0;
	
	Результат = 0;
	
	ОписаниеТипаЧисло = Новый ОписаниеТипов(""Число"");
	Остаток = ВерсияСтрокой;
	ПозицияТочки = СтрНайти(Остаток, ""."");
	Пока ПозицияТочки > 0 Цикл
		ЧислоСтрокой = Лев(Остаток, ПозицияТочки - 1);
		Число = ОписаниеТипаЧисло.ПривестиЗначение(ЧислоСтрокой);
		Результат = Результат * 1000 + Число;
		Остаток = Сред(Остаток, ПозицияТочки + 1);
		ПозицияТочки = СтрНайти(Остаток, ""."");
		Разряд = Разряд + 1;
	КонецЦикла;
	
	Число = ОписаниеТипаЧисло.ПривестиЗначение(Остаток);
	Результат = Результат * 1000 + Число;
	Разряд = Разряд + 1;
	
	// Номера версии после 4 точки возвращает после запятой.
	// Например, для версии ""1.2.3.4.5.6.7"" вернет 1002003004,005006007.
	Если Разряд > 4 Тогда
		Результат = Результат / Pow(1000, Разряд - 4);
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

#КонецОбласти
"}
},
{0,
{"ДополнительныеОтчетыИОбработки Модуль Пример",0,0,"","ПараметрыРегистрации 		= ДополнительныеОтчетыИОбработки.СведенияОВнешнейОбработке(""2.2.2.1"");
ПараметрыРегистрации.Вид 	= ДополнительныеОтчетыИОбработкиКлиентСервер.ВидОбработкиДополнительныйОтчет();
ПараметрыРегистрации.Версия = ""1.0"";

Команда 				= ПараметрыРегистрации.Команды.Добавить();
Команда.Представление 	= НСтр(""ru = 'Бюджет движения денежных средств (Нордстар)'"");
Команда.Идентификатор 	= ""норд_Отчет_БДДС"";
Команда.Использование 	= ДополнительныеОтчетыИОбработкиКлиентСервер.ТипКомандыОткрытиеФормы();
Команда.ПоказыватьОповещение = Истина;

Возврат ПараметрыРегистрации;"}
},
{0,
{"СписокМакетов",0,0,"","МассивМакетов = Новый Массив;

рфОбъектЗначение = РеквизитФормыВЗначение(""Объект"");

// Выполнение операций с Объектом ""рфОбъектЗначение""
Макеты = рфОбъектЗначение.Метаданные().Макеты;

Для каждого Макет Из Макеты Цикл
	
	МассивМакетов.Добавить(Макет.Имя);
	
КонецЦикла;

Элементы.ИмяМакета.СписокВыбора.ЗагрузитьЗначения(МассивМакетов);

Если Элементы.ИмяМакета.СписокВыбора.Количество() > 0 Тогда
	ИмяМакета = Элементы.ИмяМакета.СписокВыбора[0];
КонецЕсли;"}
},
{0,
{"Печатные формы для замены",0,0,"КПФ","Для каждого СтрокаПФ Из КоллекцияПечатныхФорм Цикл
	
	Если СтрокаПФ.ИмяМакета = ""СчетНаОплатуФаксимиле"" Тогда
		СтрокаПФ.ИмяМакета 	= ""СчетНаОплату"";
		СтрокаПФ.ИмяВРЕГ 	= Врег(СтрокаПФ.ИмяМакета);
	КонецЕсли;
	
КонецЦикла;"}
},
{0,
{"Получить версию БСП",0,0,"","ВерсияБСП = СтандартныеПодсистемыСервер.ВерсияБиблиотеки();
Сообщить(ВерсияБСП);

&НаСервереБезКонтекста
Функция ПолучитьВерсиюБСПНаСервере()
	
	ВерсияБСП = СтандартныеПодсистемыСервер.ВерсияБиблиотеки();
	Возврат ВерсияБСП;
	
КонецФункции // ПолучитьВерсиюБСПНаСервере()"}
},
{2,
{"ЗаполнениеОбъекта (заполнить ТЧ)",1,0,"",""},
{0,
{"ЗаполнениеОбъекта",0,0,"","Функция СведенияОВнешнейОбработке() Экспорт
	
	ПараметрыРегистрации = Новый Структура;
	МассивНазначений = Новый Массив;
	МассивНазначений.Добавить(""Документ.СчетФактураВыданныйАванс"");
	
	ПараметрыРегистрации.Вставить(""Вид"", ""ЗаполнениеОбъекта"");
	ПараметрыРегистрации.Вставить(""Назначение"", МассивНазначений);
	ПараметрыРегистрации.Вставить(""Наименование"", ""Заполнить документ"");
	ПараметрыРегистрации.Вставить(""Версия"", ""1.0"");
	ПараметрыРегистрации.Вставить(""БезопасныйРежим"", Истина);
	ПараметрыРегистрации.Вставить(""Информация"", ""Дополнительная обработка табличной части к документу счет-фактура выданный аванс"");
	
	ТаблицаКоманд = ПолучитьТаблицуКоманд();
	
	ДобавитьКоманду(ТаблицаКоманд,
	""Заполнить документ"",
	""Заполнить документ"",
	""ВызовКлиентскогоМетода"",
	Истина);
	
	ПараметрыРегистрации.Вставить(""Команды"", ТаблицаКоманд);
	
	Возврат ПараметрыРегистрации;
	
КонецФункции

Функция ПолучитьТаблицуКоманд()
	
	Команды = Новый ТаблицаЗначений;
	Команды.Колонки.Добавить(""Представление"", Новый ОписаниеТипов(""Строка""));
	Команды.Колонки.Добавить(""Идентификатор"", Новый ОписаниеТипов(""Строка""));
	Команды.Колонки.Добавить(""Использование"", Новый ОписаниеТипов(""Строка""));
	Команды.Колонки.Добавить(""ПоказыватьОповещение"", Новый ОписаниеТипов(""Булево""));
	Команды.Колонки.Добавить(""Модификатор"", Новый ОписаниеТипов(""Строка""));
	
	Возврат Команды;
	
КонецФункции

Процедура ДобавитьКоманду(ТаблицаКоманд, Представление, Идентификатор, Использование, ПоказыватьОповещение = Ложь, Модификатор = """")
	
	НоваяКоманда = ТаблицаКоманд.Добавить();
	НоваяКоманда.Представление = Представление;
	НоваяКоманда.Идентификатор = Идентификатор;
	НоваяКоманда.Использование = Использование;
	НоваяКоманда.ПоказыватьОповещение = ПоказыватьОповещение;
	НоваяКоманда.Модификатор = Модификатор;
	
КонецПроцедуры

//Так как мы использовали ВызовКлиентскогоМетода, то обязательную процедуру, 
//для внешней подключаемой обработки заполнения объектов, 
//ВыполнитьКоманду(ИдентификаторКоманды, ОбъектыНазначенияМассив) Экспорт, 
//необходимо выполнять &НаКлиенте в модуле формы обработки, а значит создадим 
//любую форму обработки, пользователь её всеравно не увидит, и поместим внутрь модуля формы следующий код:

&НаКлиенте
Процедура ВыполнитьКоманду(ИдентификаторКоманды, ОбъектыНазначенияМассив) Экспорт
	//Спросим у пользователя разрешение на продолжение обработки
	Режим = РежимДиалогаВопрос.ДаНет;
	Текст = ""Текущие данные документа будут заменены новыми без возможности восстановления.
	|Продолжить?"";
	Ответ = Вопрос(Текст, Режим, 0);
	
	Если Ответ = КодВозвратаДиалога.Да Тогда
		
		//Если пользователь дал разрешение на продолжение, то начнем перебирать все
		//документы, у которых мы планируем заполнить табличную часть
		Для каждого Элемент из ОбъектыНазначенияМассив Цикл
			
			//Зададим ключ поиска документа, из которого вызвана данная обработка,
			//чтобы получить ссылку на редактирумый документ в удобном виде для
			//функции ОткрытьФорму()
			КлючПоиска = Новый Структура(""Ключ"", Элемент);
			
			//Но нам не надо открывать новую форму (окно) для изменяемого документа, а
			//Нам надо все изменения показать в уже открытых у клиента окнах
			Окна = ПолучитьОкна();
			Для каждого Окно из Окна Цикл
				
				//Окно изменяемого документа будет точно не основным, а вспомогательным, поэтому
				//сразу пропускаем основное окно, а далее идем на не очень хороший способ поиска открытого окна
				//изменяемого документа. Мы просто переберем все окна, а в заголовке, которых будет встречаться
				//Наименование, номер и дата нужного документа - будем изменять
				Если НЕ Окно.Основное И Найти(Окно.Заголовок, Элемент) Тогда
					//Передадим ключ поиска (можно сказать ссылку на объект) и данные о найденном открытом окне
					//в функцию ОткрытьФорму()
					//Код находится в цикле на тот случай, если открытых окон изменяемого документа больше одного
					Форма = ОткрытьФорму(""Документ.СчетФактураВыданныйАванс.Форма.ФормаДокумента"",КлючПоиска,,,Окно);
					
					//Далее мы получаем объект только, что повторно открытой формы и помещаем её в переменную
					//В объекте содержатся все реквизиты (элементы) формы
					НовыйОбъект = Форма.Объект;
					
					//Мы помещаем объект формы в переменную,
					//так как должны передать её в процедуру на сервере,
					//где нельзя изменять объект формы, зато можно править переменную содержащую его
					ЗаполнитьОбъект(НовыйОбъект);
					
					//После выполнения процедуры на сервере мы получаем изменную переменную НовыйОбъект,
					//которую необходимо передать в уже полученную нами форму
					КопироватьДанныеФормы(НовыйОбъект, Форма.Объект);
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

&НаСервере
Функция ЗаполнитьОбъект(НовыйОбъект)
	
	Если ТипЗнч(НовыйОбъект.ДокументОснование) = Тип(""ДокументСсылка.ПоступлениеБезналичныхДенежныхСредств"") Тогда
		
		Если НовыйОбъект.ДокументОснование.РасшифровкаПлатежа.Количество() > 0 Тогда
			НовыйОбъект.Авансы.Очистить();
		КонецЕсли;
		
		Для каждого СтрокаТЧ из НовыйОбъект.ДокументОснование.РасшифровкаПлатежа Цикл
			
			НоваяСтрока = НовыйОбъект.Авансы.Добавить();
			Если ЗначениеЗаполнено(СтрокаТЧ.СчетНаОплату) Тогда
				НоваяСтрока.Содержание = ""Предварительная оплата"" + ФормированиеПечатныхФорм.СформироватьЗаголовокДокумента(СтрокаТЧ.СчетНаОплату, НСтр(""ru=' по счету на оплату'""));
			КонецЕсли;
			НоваяСтрока.Сумма 		= СтрокаТЧ.Сумма;
			НоваяСтрока.СтавкаНДС 	= Перечисления.СтавкиНДС.НДС18_118;
			ТекПроцентНДС 			= ЦенообразованиеКлиентСервер.ПолучитьСтавкуНДСЧислом(НоваяСтрока.СтавкаНДС);
			НоваяСтрока.СуммаНДС 	= ЦенообразованиеКлиентСервер.РассчитатьСуммуНДС(НоваяСтрока.Сумма, ТекПроцентНДС);
			
		КонецЦикла;
	КонецЕсли;
	
КонецФункции"}
},
{0,
{"ЗаполнениеОбъекта изменение элементов таблицы",0,0,"","&НаКлиенте
Процедура ВыполнитьКоманду(ИдентификаторКоманды, ОбъектыНазначенияМассив) Экспорт
	
	ВладелецФормыОбъект = ВладелецФормы.Объект;
	
	ЗаполнитьОбъект(ВладелецФормыОбъект);
	
КонецПроцедуры // ВыполнитьКоманду()

&НаКлиенте
Функция ЗаполнитьОбъект(ВладелецФормыОбъект)
	
	Для каждого ТекущаяСтрока из ВладелецФормыОбъект.ИмяТаблицы Цикл
		ТекущаяСтрока.Количество = 100;
	КонецЦикла;
	
КонецФункции"}
}
}
},
{13,
{"Программно",1,0,"",""},
{3,
{"Таблица значений",1,0,"",""},
{0,
{"Колонка в таблицу значений (УФ)",0,0,"","Если НЕ РезультатЗапроса.Пустой() Тогда
	РезультатЗапросаТЗ = РезультатЗапроса.Выгрузить();
	РезультатЗапросаТЗКолонки = РезультатЗапросаТЗ.Колонки;
	
	Для каждого ИмяКолонки Из РезультатЗапросаТЗКолонки Цикл
		//Таблица.Колонки.Добавить(ИмяКолонки);
		ДобавитьКолонкуНаСервере(ИмяКолонки.Имя, ИмяКолонки.ТипЗначения, ИмяКолонки.Заголовок, ""Таблица"", Элементы.Таблица); 
	КонецЦикла;
	
	Таблица.Загрузить(РезультатЗапросаТЗ);
КонецЕсли;

//Процедура программно добавит колонку в таблицу
//-------------------------------------------------------------------------
//Параметры:
//		ИмяКолонки - Строка - вида ""Тест3""
//		ОписаниеТипов - ОписаниеТипов - напр., ""Строка""
//		Заголовок - Строка - напр., ""Пример""
//		Реквизит - Строка - Путь к реквизиту, напр ""Таблица"" или ""Объект.Таблица""
//		ЭлементыРеквизит - ТаблицаФормы - Путь к элементу на форме
//-------------------------------------------------------------------------
//автор: Кучеров Р 28.05.2018 
&НаСервере
Процедура ДобавитьКолонкуНаСервере(ИмяКолонки, ОписаниеТипов, Заголовок, Реквизит, ЭлементыРеквизит, Видимость = Истина)
	
	Если Элементы.Найти(ИмяКолонки) = Неопределено Тогда
		нРеквизиты 	= Новый Массив;
		нРеквизиты.Добавить(Новый РеквизитФормы(ИмяКолонки, Новый ОписаниеТипов(ОписаниеТипов), Реквизит, Заголовок, Истина));
		ИзменитьРеквизиты(нРеквизиты);
		
		нЭлемент 		= Элементы.Добавить(ИмяКолонки, Тип(""ПолеФормы""), ЭлементыРеквизит);
		нЭлемент.Вид 	= ВидПоляФормы.ПолеВвода;
		//нЭлемент.ПутьКДанным 	= Реквизит + ""."" + ИмяКолонки; //Это разве работает!?
		нЭлемент.ПутьКДанным 	= Реквизит + ""."" + ИмяКолонки;
		нЭлемент.Подсказка 		= Заголовок;
		нЭлемент.Видимость 		= Видимость;
	КонецЕсли; 
	
КонецПроцедуры
"}
},
{0,
{"Колонка в таблицу значений (ОФ)",0,0,"","ЭлементСписок 	= ЭлементыФормы.<?""Имя таблицы"">;

ТекПозиция 		= 0;
НовКолонка 		= ЭлементСписок.Колонки.Вставить(ТекПозиция + 1);
НовКолонка.Имя 	= ""КартинкаНаличие"";
НовКолонка.Данные 		= """";
НовКолонка.ТекстШапки 	= ""А"";
НовКолонка.Ширина 		= 26;"}
},
{0,
{"ВывестиТаблицуНаФорму",0,0,"","&НаСервере
Процедура ВывестиТаблицуНаФорму(УФ,ИмяТЗНаФорме,ТЗ, ТЗОбработчиковСобытий = Неопределено) Экспорт
    
    // СОЗДАНИЕ РЕКВИЗИТОВ ФОРМЫ
    МассивДобавляемыхРеквизитов = Новый Массив; 
    
    Для Каждого Колонка Из ТЗ.Колонки Цикл
        МассивДобавляемыхРеквизитов.Добавить(Новый РеквизитФормы(Колонка.Имя, Колонка.ТипЗначения,ИмяТЗНаФорме ,Колонка.Заголовок));    
    КонецЦикла; 
    
    МассивУдаляемыхРеквизитов = УФ.ПолучитьРеквизиты(ИмяТЗНаФорме);
    МассивИменУдаляемыхРеквизитов = Новый Массив;
    
    Для каждого Элемент Из МассивУдаляемыхРеквизитов Цикл
        МассивИменУдаляемыхРеквизитов.Добавить(ИмяТЗНаФорме + ""."" + Элемент.Имя);
    КонецЦикла; 
    
    УФ.ИзменитьРеквизиты(МассивДобавляемыхРеквизитов,МассивИменУдаляемыхРеквизитов); 
    
    // СОЗДАНИЕ ЭЛЕМЕНТОВ ФОРМЫ
    Для каждого Элемент Из МассивУдаляемыхРеквизитов Цикл
        УдаляемыйЭлемент = УФ.Элементы.Найти(ИмяТЗНаФорме + Элемент.Имя);
        УФ.Элементы.Удалить(УдаляемыйЭлемент);
    КонецЦикла; 
    
    Для Каждого Колонка Из ТЗ.Колонки Цикл
        НоваяКолонка = УФ.Элементы.Добавить(ИмяТЗНаФорме + Колонка.Имя, Тип(""ПолеФормы""), УФ.Элементы[ИмяТЗНаФорме]); 
        НоваяКолонка.Заголовок = Колонка.Заголовок; 
        НоваяКолонка.ПутьКДанным = ИмяТЗНаФорме + ""."" + Колонка.Имя;
        НоваяКолонка.Вид = ВидПоляФормы.ПолеВвода; 
        НоваяКолонка.РежимРедактирования = РежимРедактированияКолонки.ВходПриВводе;    
    КонецЦикла;     
    
    УФ[ИмяТЗНаФорме].Загрузить(ТЗ);
    
    // Привязка обработчиков событий
    Если ТЗОбработчиковСобытий = Неопределено Тогда
        Возврат;
    КонецЕсли;    
    
    Для Каждого Строка Из ТЗОбработчиковСобытий Цикл
        УФ.Элементы[Строка.ИмяЭлемента].УстановитьДействие(Строка.ИмяСобытия, Строка.ИмяЭлемента + Строка.ИмяСобытия); 
    КонецЦикла;    
    
КонецПроцедуры"}
}
},
{4,
{"Обычне формы",1,0,"",""},
{0,
{"Флаг ЗаказПодтвержден",0,0,"","//++(
Флажок = ЭлементыФормы.Добавить(Тип(""Флажок""), ""ЗаказПодтвержден"",,);
Флажок.Заголовок = ""Заказ подтвержден"";
Флажок.Данные = ""ЗаказПодтвержден"";
Флажок.Лево = ЭлементыФормы.ОтражатьВБухгалтерскомУчете.Лево;
Флажок.Верх = ЭлементыФормы.Организация.Верх;
Флажок.Ширина = 120;
Флажок.УстановитьПривязку(ГраницаЭлементаУправления.Лево,ЭлементыФормы.Организация,ГраницаЭлементаУправления.Право);
Флажок.УстановитьПривязку(ГраницаЭлементаУправления.Право,Флажок,ГраницаЭлементаУправления.Лево);
Флажок.УстановитьДействие(""ПриИзменении"", новый Действие(""ЗаказПодтвержденПриИзменении""));

Надпись = ЭлементыФормы.Добавить(Тип(""Надпись""), ""НадписьДатаПодтверждения"",,);
Надпись.Заголовок = ""Дата подтверждения:"";
Надпись.Лево = Флажок.Лево+Флажок.Ширина+7;
Надпись.Верх = ЭлементыФормы.Организация.Верх;
Надпись.Ширина = 115;
Надпись.УстановитьПривязку(ГраницаЭлементаУправления.Лево,Флажок,ГраницаЭлементаУправления.Право);
Надпись.УстановитьПривязку(ГраницаЭлементаУправления.Право,Надпись ,ГраницаЭлементаУправления.Лево);

Реквизит = ЭлементыФормы.Добавить(Тип(""ПолеВвода""), ""ДатаПодтверждения"",,);
Реквизит.Данные = ""ДатаПодтверждения"";
Реквизит.Лево = Надпись.Лево+Надпись.Ширина+2;
Реквизит.Верх = ЭлементыФормы.Организация.Верх;
Реквизит.Ширина = 95;
Реквизит.УстановитьПривязку(ГраницаЭлементаУправления.Лево,Надпись,ГраницаЭлементаУправления.Право);
Реквизит.УстановитьПривязку(ГраницаЭлементаУправления.Право,ЭлементыФормы.ДоговорКонтрагента ,ГраницаЭлементаУправления.Право);

ЭлементыФормы.Склад.АвтоОтметкаНезаполненного = Истина;

ЭлементыФормы.ЗаказПодтвержден.Доступность  = НЕ ЗаказПодтвержден;
ЭлементыФормы.ДатаПодтверждения.Доступность = НЕ ЗаказПодтвержден;

Если ЭтоНовый() Тогда
	ЗаказПодтвержден = Ложь;
	ДатаПодтверждения = Дата(1,1,1,0,0,0);
КонецЕсли;	

ЭлементыФормы.ДействияФормы.Кнопки.Вставить(26, , ТипКнопкиКоманднойПанели.Разделитель, , );
ЭлементыФормы.ДействияФормы.Кнопки.Вставить(27, ""ОформитьПакетДокументов"", ТипКнопкиКоманднойПанели.Действие,""Оформить пакет документов"", новый Действие(""ОформитьПакетДокументовНажатие""));

ЭлементыФормы.ДействияФормы.Кнопки.ОформитьПакетДокументов.Доступность = (Организация.Наименование = ""ИП Вафин А.Ю."");

ПредЗаказПодтвержден = ЗаказПодтвержден;

Если НЕ ЭтоНовый() Тогда
	СТИВ_Доработки.ЗаписатьФактОткрытияОбъектаВИсторию(Ссылка);
КонецЕсли;
//++)

Процедура ЗаказПодтвержденПриИзменении(Элемент) //++
	
	Если ЗаказПодтвержден Тогда
	//___проверка на просрочку по договору_______	
		Запрос = Новый Запрос;
		Запрос.Текст = ""ВЫБРАТЬ РАЗРЕШЕННЫЕ
		               |	ВзаиморасчетыОстатки.Организация КАК Организация,
		               |	ВзаиморасчетыОстатки.Контрагент КАК Контрагент,
		               |	ВзаиморасчетыОстатки.ДоговорКонтрагента КАК ДоговорКонтрагента,
		               |	СУММА(ВзаиморасчетыОстатки.СуммаВзаиморасчетовОстаток) КАК ОбщаяСуммаДолга,
		               |	ВзаиморасчетыОстатки.ДоговорКонтрагента.ДопустимоеЧислоДнейЗадолженности КАК СрокОплаты
		               |ПОМЕСТИТЬ Остатки
		               |ИЗ
		               |	РегистрНакопления.ВзаиморасчетыСКонтрагентами.Остатки(
		               |			,
		               |			ДоговорКонтрагента = &ДоговорКонтрагента
		               |				И НЕ Контрагент В
		               |						(ВЫБРАТЬ
		               |							СобственныеКонтрагенты.Контрагент
		               |						ИЗ
		               |							РегистрСведений.СобственныеКонтрагенты КАК СобственныеКонтрагенты)) КАК ВзаиморасчетыОстатки
		               |
		               |СГРУППИРОВАТЬ ПО
		               |	ВзаиморасчетыОстатки.Организация,
		               |	ВзаиморасчетыОстатки.Контрагент,
		               |	ВзаиморасчетыОстатки.ДоговорКонтрагента.ДопустимоеЧислоДнейЗадолженности,
		               |	ВзаиморасчетыОстатки.ДоговорКонтрагента
		               |
		               |ИМЕЮЩИЕ
		               |	СУММА(ВзаиморасчетыОстатки.СуммаВзаиморасчетовОстаток) > 0
		               |;
		               |
		               |////////////////////////////////////////////////////////////////////////////////
		               |ВЫБРАТЬ РАЗРЕШЕННЫЕ
		               |	ВзаиморасчетыОбороты.Период КАК Период,
		               |	ВзаиморасчетыОбороты.Организация КАК Организация,
		               |	ВзаиморасчетыОбороты.Контрагент КАК Контрагент,
		               |	ВзаиморасчетыОбороты.ДоговорКонтрагента КАК ДоговорКонтрагента,
		               |	ВЫБОР
		               |		КОГДА ВзаиморасчетыОбороты.СуммаВзаиморасчетовПриход > 0
		               |			ТОГДА ВзаиморасчетыОбороты.СуммаВзаиморасчетовПриход
		               |		ИНАЧЕ 0
		               |	КОНЕЦ + ВЫБОР
		               |		КОГДА ВзаиморасчетыОбороты.СуммаВзаиморасчетовРасход < 0
		               |			ТОГДА -ВзаиморасчетыОбороты.СуммаВзаиморасчетовРасход
		               |		ИНАЧЕ 0
		               |	КОНЕЦ КАК СуммаУпрПриход,
		               |	Остатки.ОбщаяСуммаДолга КАК ОбщаяСуммаДолга
		               |ПОМЕСТИТЬ ОборотыПоДнямПриход
		               |ИЗ
		               |	Остатки КАК Остатки
		               |		ЛЕВОЕ СОЕДИНЕНИЕ РегистрНакопления.ВзаиморасчетыСКонтрагентами.Обороты(, , день, ДоговорКонтрагента = &ДоговорКонтрагента) КАК ВзаиморасчетыОбороты
		               |		ПО Остатки.Организация = ВзаиморасчетыОбороты.Организация
		               |			И Остатки.Контрагент = ВзаиморасчетыОбороты.Контрагент
		               |			И Остатки.ДоговорКонтрагента = ВзаиморасчетыОбороты.ДоговорКонтрагента
		               |ГДЕ
		               |	ВЫБОР
		               |			КОГДА ВзаиморасчетыОбороты.СуммаВзаиморасчетовПриход > 0
		               |				ТОГДА ВзаиморасчетыОбороты.СуммаВзаиморасчетовПриход
		               |			ИНАЧЕ 0
		               |		КОНЕЦ + ВЫБОР
		               |			КОГДА ВзаиморасчетыОбороты.СуммаВзаиморасчетовРасход < 0
		               |				ТОГДА -ВзаиморасчетыОбороты.СуммаВзаиморасчетовРасход
		               |			ИНАЧЕ 0
		               |		КОНЕЦ > 0
		               |;
		               |
		               |////////////////////////////////////////////////////////////////////////////////
		               |ВЫБРАТЬ
		               |	ОборотыПоДнямПриход.Период КАК Период,
		               |	ОборотыПоДнямПриход.Организация КАК Организация,
		               |	ОборотыПоДнямПриход.Контрагент КАК Контрагент,
		               |	ОборотыПоДнямПриход.ДоговорКонтрагента КАК ДоговорКонтрагента,
		               |	СУММА(ОборотыПоДнямПриход1.СуммаУпрПриход) КАК СуммаУпрПриход
		               |ПОМЕСТИТЬ ОборотыБольшеОстаткаПриход
		               |ИЗ
		               |	ОборотыПоДнямПриход КАК ОборотыПоДнямПриход
		               |		ЛЕВОЕ СОЕДИНЕНИЕ ОборотыПоДнямПриход КАК ОборотыПоДнямПриход1
		               |		ПО ОборотыПоДнямПриход.Период <= ОборотыПоДнямПриход1.Период
		               |			И ОборотыПоДнямПриход.Организация = ОборотыПоДнямПриход1.Организация
		               |			И ОборотыПоДнямПриход.Контрагент = ОборотыПоДнямПриход1.Контрагент
		               |			И ОборотыПоДнямПриход.ДоговорКонтрагента = ОборотыПоДнямПриход1.ДоговорКонтрагента
		               |
		               |СГРУППИРОВАТЬ ПО
		               |	ОборотыПоДнямПриход.Период,
		               |	ОборотыПоДнямПриход.Организация,
		               |	ОборотыПоДнямПриход.Контрагент,
		               |	ОборотыПоДнямПриход.ДоговорКонтрагента,
		               |	ОборотыПоДнямПриход.ОбщаяСуммаДолга
		               |
		               |ИМЕЮЩИЕ
		               |	ОборотыПоДнямПриход.ОбщаяСуммаДолга <= СУММА(ОборотыПоДнямПриход1.СуммаУпрПриход)
		               |;
		               |
		               |////////////////////////////////////////////////////////////////////////////////
		               |ВЫБРАТЬ
		               |	МАКСИМУМ(ОборотыБольшеОстаткаПриход.Период) КАК Период,
		               |	ОборотыБольшеОстаткаПриход.Организация,
		               |	ОборотыБольшеОстаткаПриход.Контрагент,
		               |	ОборотыБольшеОстаткаПриход.ДоговорКонтрагента
		               |ПОМЕСТИТЬ ДатыОбразованияДт
		               |ИЗ
		               |	ОборотыБольшеОстаткаПриход КАК ОборотыБольшеОстаткаПриход
		               |
		               |СГРУППИРОВАТЬ ПО
		               |	ОборотыБольшеОстаткаПриход.Организация,
		               |	ОборотыБольшеОстаткаПриход.Контрагент,
		               |	ОборотыБольшеОстаткаПриход.ДоговорКонтрагента
		               |;
		               |
		               |////////////////////////////////////////////////////////////////////////////////
		               |ВЫБРАТЬ
		               |	Остатки.Организация КАК Организация,
		               |	Остатки.Контрагент КАК Контрагент,
		               |	Остатки.ДоговорКонтрагента КАК ДоговорКонтрагента,
		               |	ДатыОбразованияДт.Период КАК ДатаОбразованияДолга,
		               |	РАЗНОСТЬДАТ(ДатыОбразованияДт.Период, &Период, ДЕНЬ) КАК КоличествоДнейЗадолженности,
		               |	Остатки.ОбщаяСуммаДолга КАК ОбщаяСуммаДолга,
		               |	ВЫБОР
		               |		КОГДА Остатки.СрокОплаты <> 0
		               |			ТОГДА ВЫБОР
		               |					КОГДА ДатыОбразованияДт.Период < НАЧАЛОПЕРИОДА(ДОБАВИТЬКДАТЕ(&Период, ДЕНЬ, -Остатки.СрокОплаты), ДЕНЬ)
		               |						ТОГДА ДОБАВИТЬКДАТЕ(&Период, ДЕНЬ, -Остатки.СрокОплаты)
		               |					ИНАЧЕ ДатыОбразованияДт.Период
		               |				КОНЕЦ
		               |		ИНАЧЕ &Период
		               |	КОНЕЦ КАК ДатаНачалаНеПросрочки,
		               |	ВЫБОР
		               |		КОГДА Остатки.СрокОплаты <> 0
		               |			ТОГДА ВЫБОР
		               |					КОГДА ДатыОбразованияДт.Период < НАЧАЛОПЕРИОДА(ДОБАВИТЬКДАТЕ(&Период, ДЕНЬ, -Остатки.СрокОплаты), ДЕНЬ)
		               |						ТОГДА ДОБАВИТЬКДАТЕ(&Период, ДЕНЬ, -Остатки.СрокОплаты)
		               |					ИНАЧЕ ДАТАВРЕМЯ(1, 1, 1, 0, 0, 0)
		               |				КОНЕЦ
		               |		ИНАЧЕ &Период
		               |	КОНЕЦ КАК ДатаНачалаПросрочки
		               |ПОМЕСТИТЬ ИтогоОстатки
		               |ИЗ
		               |	Остатки КАК Остатки
		               |		ЛЕВОЕ СОЕДИНЕНИЕ ДатыОбразованияДт КАК ДатыОбразованияДт
		               |		ПО Остатки.Организация = ДатыОбразованияДт.Организация
		               |			И Остатки.Контрагент = ДатыОбразованияДт.Контрагент
		               |			И Остатки.ДоговорКонтрагента = ДатыОбразованияДт.ДоговорКонтрагента
		               |
		               |СГРУППИРОВАТЬ ПО
		               |	Остатки.Организация,
		               |	Остатки.Контрагент,
		               |	Остатки.ДоговорКонтрагента,
		               |	ДатыОбразованияДт.Период,
		               |	Остатки.ОбщаяСуммаДолга,
		               |	ВЫБОР
		               |		КОГДА Остатки.СрокОплаты <> 0
		               |			ТОГДА ВЫБОР
		               |					КОГДА ДатыОбразованияДт.Период < НАЧАЛОПЕРИОДА(ДОБАВИТЬКДАТЕ(&Период, ДЕНЬ, -Остатки.СрокОплаты), ДЕНЬ)
		               |						ТОГДА ДОБАВИТЬКДАТЕ(&Период, ДЕНЬ, -Остатки.СрокОплаты)
		               |					ИНАЧЕ ДатыОбразованияДт.Период
		               |				КОНЕЦ
		               |		ИНАЧЕ &Период
		               |	КОНЕЦ,
		               |	ВЫБОР
		               |		КОГДА Остатки.СрокОплаты <> 0
		               |			ТОГДА ВЫБОР
		               |					КОГДА ДатыОбразованияДт.Период < НАЧАЛОПЕРИОДА(ДОБАВИТЬКДАТЕ(&Период, ДЕНЬ, -Остатки.СрокОплаты), ДЕНЬ)
		               |						ТОГДА ДОБАВИТЬКДАТЕ(&Период, ДЕНЬ, -Остатки.СрокОплаты)
		               |					ИНАЧЕ ДАТАВРЕМЯ(1, 1, 1, 0, 0, 0)
		               |				КОНЕЦ
		               |		ИНАЧЕ &Период
		               |	КОНЕЦ
		               |;
		               |
		               |////////////////////////////////////////////////////////////////////////////////
		               |ВЫБРАТЬ РАЗРЕШЕННЫЕ РАЗЛИЧНЫЕ
		               |	ИтогоОстатки.Организация КАК Организация,
		               |	ИтогоОстатки.Контрагент КАК Контрагент,
		               |	ИтогоОстатки.ДоговорКонтрагента КАК ДоговорКонтрагента,
		               |	ИтогоОстатки.ДатаОбразованияДолга КАК ДатаОбразованияДолга,
		               |	ИтогоОстатки.КоличествоДнейЗадолженности КАК КоличествоДнейЗадолженности,
		               |	ИтогоОстатки.ОбщаяСуммаДолга КАК ОбщаяСуммаДолга,
		               |	ВЫБОР
		               |		КОГДА ИтогоОстатки.ДатаНачалаНеПросрочки > ВзаиморасчетыОбороты.Период
		               |			ТОГДА ВЫБОР
		               |					КОГДА ИтогоОстатки.ОбщаяСуммаДолга - ЕСТЬNULL(СУММА(ВЫБОР
		               |									КОГДА ИтогоОстатки.ДатаНачалаНеПросрочки <= ВзаиморасчетыОбороты.Период
		               |										ТОГДА ВзаиморасчетыОбороты.СуммаВзаиморасчетовПриход + ВЫБОР
		               |												КОГДА ВзаиморасчетыОбороты.СуммаВзаиморасчетовРасход < 0
		               |													ТОГДА -ВзаиморасчетыОбороты.СуммаВзаиморасчетовРасход
		               |												ИНАЧЕ 0
		               |											КОНЕЦ
		               |									ИНАЧЕ 0
		               |								КОНЕЦ), 0) < 0
		               |						ТОГДА 0
		               |					ИНАЧЕ ИтогоОстатки.ОбщаяСуммаДолга - ЕСТЬNULL(СУММА(ВЫБОР
		               |									КОГДА ИтогоОстатки.ДатаНачалаНеПросрочки <= ВзаиморасчетыОбороты.Период
		               |										ТОГДА ВзаиморасчетыОбороты.СуммаВзаиморасчетовПриход + ВЫБОР
		               |												КОГДА ВзаиморасчетыОбороты.СуммаВзаиморасчетовРасход < 0
		               |													ТОГДА -ВзаиморасчетыОбороты.СуммаВзаиморасчетовРасход
		               |												ИНАЧЕ 0
		               |											КОНЕЦ
		               |									ИНАЧЕ 0
		               |								КОНЕЦ), 0)
		               |				КОНЕЦ
		               |		ИНАЧЕ 0
		               |	КОНЕЦ КАК ОбщаяСуммаПросроченногоДолга,
		               |	ВЫБОР
		               |		КОГДА ИтогоОстатки.ДатаНачалаНеПросрочки > ВзаиморасчетыОбороты.Период
		               |			ТОГДА РАЗНОСТЬДАТ(ИтогоОстатки.ДатаОбразованияДолга, ИтогоОстатки.ДатаНачалаНеПросрочки, ДЕНЬ)
		               |		ИНАЧЕ 0
		               |	КОНЕЦ КАК КоличествоПросроченныхДней
		               |ИЗ
		               |	ИтогоОстатки КАК ИтогоОстатки
		               |		ЛЕВОЕ СОЕДИНЕНИЕ РегистрНакопления.ВзаиморасчетыСКонтрагентами.Обороты(, , Регистратор, ДоговорКонтрагента = &ДоговорКонтрагента) КАК ВзаиморасчетыОбороты
		               |		ПО ИтогоОстатки.Организация = ВзаиморасчетыОбороты.Организация
		               |			И ИтогоОстатки.Контрагент = ВзаиморасчетыОбороты.Контрагент
		               |			И ИтогоОстатки.ДоговорКонтрагента = ВзаиморасчетыОбороты.ДоговорКонтрагента
		               |ГДЕ
		               |	ВзаиморасчетыОбороты.Период >= ИтогоОстатки.ДатаОбразованияДолга
		               |	И (ЕСТЬNULL(ВзаиморасчетыОбороты.СуммаУпрПриход, 0) > 0
		               |			ИЛИ ЕСТЬNULL(ВзаиморасчетыОбороты.СуммаУпрРасход, 0) < 0)
		               |
		               |СГРУППИРОВАТЬ ПО
		               |	ИтогоОстатки.Организация,
		               |	ИтогоОстатки.Контрагент,
		               |	ИтогоОстатки.ДоговорКонтрагента,
		               |	ИтогоОстатки.ДатаОбразованияДолга,
		               |	ИтогоОстатки.КоличествоДнейЗадолженности,
		               |	ИтогоОстатки.ОбщаяСуммаДолга,
		               |	ИтогоОстатки.ДатаНачалаНеПросрочки,
		               |	ВзаиморасчетыОбороты.Период"";
		
		Запрос.УстановитьПараметр(""ДоговорКонтрагента"", ДоговорКонтрагента);
		Запрос.УстановитьПараметр(""Период"", ТекущаяДата());
		
		Выборка = Запрос.Выполнить().Выбрать();
		
		ЕстьПросрочка = ложь;
		Пока Выборка.Следующий() Цикл
			Если Выборка.ОбщаяСуммаПросроченногоДолга<>0 Тогда
				Сообщить(""По договору ""+ДоговорКонтрагента+"" Сумма просроченного долга = ""+Выборка.ОбщаяСуммаПросроченногоДолга+"" ""+ДоговорКонтрагента.ВалютаВзаиморасчетов);
				Если не РольДоступна(""ПолныеПрава"") И НЕ РольДоступна(""ПодтверждениеЗаказовБезПредоплаты"") Тогда
					ЕстьПросрочка = Истина;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		Если Не ЕстьПросрочка Тогда
			ДатаПодтверждения = ТекущаяДата();	
		Иначе
			ЗаказПодтвержден = Ложь;
		КонецЕсли;
		
		//____проверка предоплаты по заказу_________
		Если ДоговорКонтрагента.ПроцентПредоплаты<>0 Тогда
		    Запрос = Новый Запрос;
			Запрос.Текст = ""ВЫБРАТЬ РАЗРЕШЕННЫЕ
			               |	ВзаиморасчетыОстатки.Сделка,
			               |	СУММА(ВзаиморасчетыОстатки.СуммаВзаиморасчетовОстаток) КАК СуммаДолга
			               |ИЗ
			               |	РегистрНакопления.ВзаиморасчетыСКонтрагентами.Остатки(, Сделка = &Сделка) КАК ВзаиморасчетыОстатки
			               |
			               |СГРУППИРОВАТЬ ПО
			               |	ВзаиморасчетыОстатки.Сделка"";
			
			Запрос.УстановитьПараметр(""Сделка"", Ссылка);
			
			Выборка = Запрос.Выполнить().Выбрать();
			
			ЕстьПредоплата = Ложь;
			СкммаПредоплаты = ДоговорКонтрагента.ПроцентПредоплаты*СуммаДокумента/100;
			
			Если Выборка.Следующий() Тогда
				СуммаДолга = Выборка.СуммаДолга;
			Иначе
				СуммаДолга = СуммаДокумента;
			КонецЕсли;
			
			Если СуммаДокумента -(СуммаДокумента + СуммаДолга) < СкммаПредоплаты Тогда
				Сообщить(""По заказу покупателя необходима предоплата в размере не менее ""+формат(СкммаПредоплаты, ""ЧДЦ=2"")+"" ""+Ссылка.ВалютаДокумента, СтатусСообщения.Важное);
				Если НЕ РольДоступна(""ПолныеПрава"") И НЕ РольДоступна(""ПодтверждениеЗаказовБезПредоплаты"") Тогда
					ЕстьПредоплата = Ложь;
				Иначе
					ЕстьПредоплата = Истина;
				КонецЕсли;
			Иначе
				 ЕстьПредоплата = Истина;
			КонецЕсли;
				
			Если ЕстьПредоплата Тогда
				ДатаПодтверждения = ТекущаяДата();	
			Иначе
				ЗаказПодтвержден = Ложь;
			КонецЕсли;
		КонецЕсли;	
	КонецЕсли;
	
	ЭлементыФормы.Контрагент.ТолькоПросмотр 		= ЗаказПодтвержден;
	ЭлементыФормы.ДоговорКонтрагента.ТолькоПросмотр = ЗаказПодтвержден;

КонецПроцедуры//++)	
"}
},
{0,
{"Как добавить колонку в табличное поле",0,0,"","Иногда возникает необходимость программно добавить новую колонку в табличное поле документа или элемента справочика. Сделать это можно следующим образом.

Префикс = ""АйТи_"";
лЭлементыФормы<?""Имя таблицы (слитно)"">Колонки = ЭлементыФормы.<?""Имя таблицы (слитно)"">.Колонки;
Если лЭлементыФормы<?""Имя таблицы (слитно)"">Колонки.Найти(Префикс + ""НалоговыйУчет"") = Неопределено Тогда
	КолонкаТабличногоПоля = ЭтаФорма.ЭлементыФормы.<?""Имя таблицы (слитно)"">.Колонки.Добавить(Префикс + ""НалоговыйУчет"", ""НУ""); // Или ЭлементыФормы.<?""Имя таблицы (слитно)"">.Колонки.Добавить(Префикс + ""НалоговыйУчет"", ""НУ"");
	КолонкаТабличногоПоля.УстановитьЭлементУправления(Тип(""ПолеВвода"")); // нужно до присвоения значения реквизиту «Данные». В противном случае добавленный на форму элемент нельзя будет редактировать
	КолонкаТабличногоПоля.Данные 			= ""НалоговыйУчет"";
	КолонкаТабличногоПоля.ПодсказкаВШапке 	= """";
	КолонкаТабличногоПоля.Видимость 		= Истина;
	
	лКолонкаТабличногоПоляЭлементУправления 						= КолонкаТабличногоПоля.ЭлементУправления;
	лКолонкаТабличногоПоляЭлементУправления.МинимальноеЗначение 	= 0;
	лКолонкаТабличногоПоляЭлементУправления.МаксимальноеЗначение 	= 100;
КонецЕсли; 


И здесь есть подводный камень: «УстановитьЭлементУправления» нужно до присвоения значения реквизиту «Данные». В противном случае добавленный на форму элемент нельзя будет редактировать.

Также, в типовой конфигурации 1С:Зарплата и управление персоналом 8.2, имеется специальная функци. При ее использовании код можно сократить до одной строки.

КолонкаТабличногоПоля = РаботаСДиалогами.ВставитьКолонкуВТабличноеПоле(Неопределено, ЭтаФорма.ЭлементыФормы.ОтражениеВУчете, ""НалоговыйУчет"", ""НУ"", ""НалоговыйУчет"", , , , Тип(""ПолеВвода""));"}
},
{0,
{"Добавить колонку пример",0,0,"","Добавить колонку пример:

Функция ДобавитьКолонкуПроцентаИзноса(пЭтаФорма, пВидимость = Истина) Экспорт
	
	лРезультат = Ложь;
	
	лЭлементыФормыМатериалыКолонки 						= пЭтаФорма.ЭлементыФормы.Материалы.Колонки;
	лЭлементыФормыМатериалыКолонкаАйТи_ПроцентИзноса 	= лЭлементыФормыМатериалыКолонки.Найти(""АйТи_ПроцентИзноса"");
	Если лЭлементыФормыМатериалыКолонкаАйТи_ПроцентИзноса = Неопределено Тогда
		НовыйЭлемент 	= лЭлементыФормыМатериалыКолонки.Добавить(""АйТи_ПроцентИзноса"", ""% износа"");
		НовыйЭлемент.УстановитьЭлементУправления(Тип(""ПолеВвода"")); // нужно до присвоения значения реквизиту «Данные». В противном случае добавленный на форму элемент нельзя будет редактировать
		НовыйЭлемент.Данные 			= ""АйТи_ПроцентИзноса"";
		НовыйЭлемент.ПодсказкаВШапке 	= ""Процент износа"";
		НовыйЭлемент.Видимость 		= пВидимость;
		НовыйЭлемент.Доступность 	= Истина;
		НовыйЭлемент.Ширина 		= 15;
		
		лНовыйЭлементЭлементУправления 						= НовыйЭлемент.ЭлементУправления;
		лНовыйЭлементЭлементУправления.МинимальноеЗначение 	= 0;
		лНовыйЭлементЭлементУправления.МаксимальноеЗначение = 100;
		
		лРезультат = Истина;
	Иначе
		лЭлементыФормыМатериалыКолонкаАйТи_ПроцентИзноса.Видимость = пВидимость;
	КонецЕсли;
	
	Возврат лРезультат;
	
КонецФункции // ДобавитьКолонкуПроцентаИзноса()"}
},
{0,
{"Кнопку в панель (КоманднаяПанельФормы)",0,0,"","//+++
НовоеДействие 	=  Новый Действие(""АйТи_ОбменДаннымиПометка"");
лКнопка 		= ЭлементыФормы.КоманднаяПанельФормы.Кнопки.Добавить(""АйТи_ОбменДанными"", ТипКнопкиКоманднойПанели.Действие, ""Обмен данными (АйТи)"", НовоеДействие);
лКнопка.Подсказка = ""Выполнять в режиме загрузки (Обмен данными = Истина)"";

Процедура АйТи_ОбменДаннымиПометка(Кнопка)
	
	лКнопка 		= ЭлементыФормы.КоманднаяПанельФормы.Кнопки.АйТи_ОбменДанными;
	лКнопка.Пометка = НЕ лКнопка.Пометка;
	
КонецПроцедуры"}
}
},
{3,
{"Фирменные",1,0,"",""},
{0,
{"Подпись и цвет доработок",0,0,"АйТиДораб[отк]","лПрефиксДоработокАйТи 	= ""АйТи_"";
лПодписьДоработокАйТи 	= "" (АйТи)"";
лЦветДоработокАйТи 		= Новый Цвет(83, 106, 194);
"}
},
{0,
{"Кнопка",0,0,"","лИмяКнопки 	= ""АйТи_Кнопка"";
ДобавитьКнопкуНаФорму(Элементы, пФорма.Команды, лИмяКнопки, ""Настройки отбора по умолчанию"" + лПодписьДоработокАйТи, лИмяКнопки, Элементы.НастройкаВыгрузкиДокументов);
Элементы[лИмяКнопки].ЦветТекста 	= лЦветДоработокАйТи;"}
},
{0,
{"Вывести телефон/комментарий контактного лица",0,0,"","АйТи_ОбщиеФункцииСервер.ВывестиТелефонКомментарийКЛ(ЭтаФорма, <?""Реквизит контактного лица"">, <?""Реквизит телефона"">, ""<?""Имя реквизита телефона (с одноимённым элементом)"">"", Элементы.пКИВладелец, Элементы.пКИВставитьПеред,, Элементы.пКЛКомментарийПрикрепить, Истина); //ПриСозданииНаСервере

//+++ АйТи <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> ## Телефон и комментарий контактного лица

&НаКлиенте
Процедура Подключаемый_<?""Реквизит контактного лица"">ПриИзменении(Элемент)
	
	лИнфоКЛ 	= АйТи_ОбщиеФункцииСервер.ПолучитьИнфоКЛ(<?""Реквизит контактного лица"">);
	Айти_ОбщиеФункцииКлиент.УстановитьЭлементКомментарийПоля(лИнфоКЛ.Комментарий, ЭтаФорма[""АбонентКомментарий""], Элементы[""Элемент_АбонентКомментарий""]);
	
КонецПроцедуры // Подключаемый_АбонентПриИзменении()

&НаКлиенте
Процедура Подключаемый_<?""Имя реквизита телефона (с одноимённым элементом)"">ПриИзменении(Элемент)
	
	Айти_ОбщиеФункцииКлиент.ТелефонКонтактногоЛицаПриИзменении(ЭтаФорма, <?""Реквизит контактного лица"">, <?""Реквизит телефона"">, <?""Реквизит телефона"">, <?""Имя реквизита телефона (с одноимённым элементом)"">);
	
КонецПроцедуры

&НаКлиенте
Процедура Подключаемый_АйТи_Позвонить(Команда)
	
	ФормаМИКО 	= ПолучитьФорму(""Обработка.МИКО_ПанельТелефонииДля1С.Форма.Форма"");
	                                                        
	врДанные 	= Новый Структура;
	врДанные.Вставить(""ОснованиеЗвонка""	, Объект.Ссылка);
	врДанные.Вставить(""Ответ""			, Объект.Описание);
	
	Оповестить(""Позвонить"", <?""Реквизит телефона"">, врДанные);
	
КонецПроцедуры

&НаКлиенте
Процедура Подключаемый_МестоОткрытие(Элемент, СтандартнаяОбработка)
	
	СтандартнаяОбработка 	= Ложь;
	
	лИмяТелефонКонтактногоЛица_КомментарийКонтакт 	= ""<?""Имя реквизита телефона (с одноимённым элементом)"">_КомментарийКонтакт"";
	лИмяТелефонКонтактногоЛица_ЗначенияПолей 		= ""<?""Имя реквизита телефона (с одноимённым элементом)"">_ЗначенияПолей"";
	
	лРезультат 		= АйТи_ОбщиеФункцииКлиент.ПодготовкаОткрытьФормуКонтактнойИнформации(Элемент, ЭтаФорма[лИмяТелефонКонтактногоЛица_КомментарийКонтакт], ЭтаФорма[лИмяТелефонКонтактногоЛица_ЗначенияПолей],, <?""Реквизит контактного лица"">, Истина);
	
	Если лРезультат <> Неопределено Тогда
		ОписаниеОповещения 	= Новый ОписаниеОповещения(""ЗначениеКИКонтактаРедактированиеВДиалогеЗавершено"", ЭтотОбъект, лРезультат.ДополнительныеПараметры);
		УправлениеКонтактнойИнформациейКлиент.ОткрытьФормуКонтактнойИнформации(лРезультат.ПараметрыФормы,, ОписаниеОповещения);
	КонецЕсли; 
	
КонецПроцедуры

&НаКлиенте
Процедура ЗначениеКИКонтактаРедактированиеВДиалогеЗавершено(РезультатЗакрытия, ДополнительныеПараметры) Экспорт
	
	Если ТипЗнч(РезультатЗакрытия) <> Тип(""Структура"") Тогда
		Возврат;
	КонецЕсли;
	
	<?""Реквизит телефона"">						= РезультатЗакрытия.Представление;
	ЭтаФорма.<?""Имя реквизита телефона (с одноимённым элементом)"">_ЗначенияПолей		= РезультатЗакрытия.КонтактнаяИнформация;
	ЭтаФорма.<?""Имя реквизита телефона (с одноимённым элементом)"">_КомментарийКонтакт	= РезультатЗакрытия.Комментарий;
	
КонецПроцедуры

//--- АйТи <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> ## Телефон и комментарий контактного лица"}
}
},
{12,
{"Элементы УФ",1,0,"",""},
{0,
{"ДобавитьЭлемент (УФ)",0,0,"","&НаСервере
Процедура ДобавитьЭлементНаСервере(ИмяКолонки, ПутьКДанным, ЭлементРодитель, пВставитьПеред = Неопределено, Заголовок = """", Видимость = Истина)
	
	Если Элементы.Найти(ИмяКолонки) = Неопределено Тогда
		Если ПустаяСтрока(Заголовок) Тогда
			Заголовок 	= ИмяКолонки;
		КонецЕсли;
		
		лТипЭлемента 	= Тип(""ПолеФормы"");
		
		Если пВставитьПеред = Неопределено Тогда
			лЭлементФормы 	= Элементы.Добавить(ИмяКолонки, лТипЭлемента, ЭлементРодитель);
		Иначе
			лЭлементФормы 	= Элементы.Вставить(ИмяКолонки, лТипЭлемента, ЭлементРодитель, пВставитьПеред);
		КонецЕсли;
		
		лЭлементФормы.Вид 			= ВидПоляФормы.ПолеВвода;
		лЭлементФормы.ПутьКДанным 	= ПутьКДанным;
		лЭлементФормы.Подсказка 	= Заголовок;
		лЭлементФормы.Видимость 	= Видимость;
	КонецЕсли; 
	
КонецПроцедуры"}
},
{0,
{"Добавить-Вставить",0,0,"ДобВст[ави]","лТипЭлемента 	= Тип(""ПолеФормы"");
Если пВставитьПеред = Неопределено Тогда
	лЭлементФормы 	= Элементы.Добавить(ИмяКолонки, лТипЭлемента, ЭлементРодитель);
Иначе
	лЭлементФормы 	= Элементы.Вставить(ИмяКолонки, лТипЭлемента, ЭлементРодитель, пВставитьПеред);
КонецЕсли;"}
},
{0,
{"Процедура добавления элементов (ДобавитьЭлементыНаФорму)",0,0,"","&НаСервере
Процедура ДобавитьЭлементыНаФормуДокумента<?""Имя документа (слитно)"">(пФорма) Экспорт
	
	лПрефиксИмя 		= ""АйТи_""; // Через ""пФорма.Элементы."" обращаться с учётом префикса или через возвращенный элемент при добавлении
	
КонецПроцедуры"}
},
{0,
{"Закладки и страница",0,0,"ФЭДС[траниц]","лСтраницы			=	Форма.Элементы.Добавить(лПрефиксИмя + ""Страницы"", Тип(""ГруппаФормы""), пФорма);
лСтраницы.Вид		=	ВидГруппыФормы.Страницы;
лСтраницы.Заголовок	=	""Страницы"";

СтраницаОсновное			=	Форма.Элементы.Добавить(лПрефиксИмя + ""СтраницаОсновное"", Тип(""ГруппаФормы""), лСтраницы);
СтраницаОсновное.Вид		=	ВидГруппыФормы.Страница;
СтраницаОсновное.Заголовок	=	""Основное"";"}
},
{0,
{"Группы добавить",0,0,"ФЭДГ[рупп]","лГруппа<?""Название группы (слитно)"">			=	пФорма.Элементы.Добавить(лПрефиксИмя + ""Группа<?""Название группы (слитно)"">"", Тип(""ГруппаФормы""), пФорма); // (<Имя>, <ТипЭлемента>, <Родитель>, <Элемент>)
лГруппа<?""Название группы (слитно)"">.Вид		=	ВидГруппыФормы.ОбычнаяГруппа;
лГруппа<?""Название группы (слитно)"">.Заголовок	=	""<?""Название группы (слитно)"">"";
лГруппа<?""Название группы (слитно)"">.ОтображатьЗаголовок = Ложь;"}
},
{0,
{"Группы вставить",0,0,"ФЭВГ[рупп]","лГруппа<?""Название группы (слитно)"">			=	пФорма.Элементы.Вставить(лПрефиксИмя + ""Группа<?""Название группы (слитно)"">"", Тип(""ГруппаФормы""), пФорма, ПередКемВставить); // (<Имя>, <ТипЭлемента>, <Родитель>, <Элемент>)
лГруппа<?""Название группы (слитно)"">.Вид		=	ВидГруппыФормы.ОбычнаяГруппа;
лГруппа<?""Название группы (слитно)"">.Заголовок	=	""<?""Название группы (слитно)"">"";
лГруппа<?""Название группы (слитно)"">.ОтображатьЗаголовок = Ложь;"}
},
{0,
{"Новый элемент",0,0,"ФЭДЭ[лемент]","лЭлемент<?""Имя элемента (слитно)"">				=	пФорма.Элементы.Добавить(лПрефиксИмя + ""<?""Имя элемента (слитно)"">"", Тип(""ПолеФормы""), пФорма);
лЭлемент<?""Имя элемента (слитно)"">.Вид			=	ВидПоляФормы.ПолеВвода;
лЭлемент<?""Имя элемента (слитно)"">.ПутьКДанным	=	""Объект.ИмяРеквизита"";
лЭлемент<?""Имя элемента (слитно)"">.Заголовок		=	""<?""Имя элемента (слитно)"">"";"}
},
{0,
{"Переместить",0,0,"ФЭП","пФорма.Элементы.Переместить(Форма.Элементы.Шапка, пФорма, ПередКемВставить); // (<Элемент>, <Родитель>, <МестоРасположения>)"}
},
{0,
{"УстановитьДействие",0,0,"ЭУД[ействи]","лЭлемент.УстановитьДействие(""ПриИзменении"", ""ИмяМетодаДляВыполнения"");"}
},
{0,
{"ДобавитьКнопкуНаФорму",0,0,"","// Параметры:
//  Элементы               - ВсеЭлементыФормы
//  Команды               - КомандыФормы
//  ИмяКнопки               - Строка
//  Синоним               - Строка
//  ИмяДействия           - Строка
//  ГруппаРодитель           - ГруппаФормы (По умолчанию = Неопределено)
//  ТолькоВоВсехДействиях - Булево (По умолчанию = Ложь)
//  Картинка               - Картинка (По умолчанию = Неопределено)
//  Пометка               - Булево (По умолчанию = Ложь) 
//
Процедура ПрограммноДобавитьКнопку(Элементы, Команды, ИмяКнопки, Синоним, ИмяДействия
	, ГруппаРодитель = Неопределено, ТолькоВоВсехДействиях = Ложь, Картинка = Неопределено, Пометка = Ложь, ПрефиксИмяКоманды = ""Команда_"") Экспорт
	
	ИмяКоманды = ПрефиксИмяКоманды + ИмяКнопки;
	
	//Добавляем новую команду
	Если Команды.Найти(ИмяКоманды) = Неопределено Тогда
		Команда 			= Команды.Добавить(ИмяКоманды);
		Команда.Действие 	= ИмяДействия;
		Если Картинка <> Неопределено Тогда
			Команда.Картинка = Картинка;
		КонецЕсли;	
	КонецЕсли; 
	
	//Добавляем элемент кнопки
	Если Элементы.Найти(ИмяКнопки) = Неопределено Тогда
		Если ГруппаРодитель = Неопределено Тогда
			НоваяКнопка 	= Элементы.Добавить(ИмяКнопки, Тип(""КнопкаФормы""));
		Иначе    
			НоваяКнопка 	= Элементы.Добавить(ИмяКнопки, Тип(""КнопкаФормы""), ГруппаРодитель);
		КонецЕсли;
		
		НоваяКнопка.Вид 					= ВидКнопкиФормы.ОбычнаяКнопка;
		НоваяКнопка.ИмяКоманды 				= ИмяКоманды;
		НоваяКнопка.Заголовок 				= Синоним;
		НоваяКнопка.ТолькоВоВсехДействиях 	= ТолькоВоВсехДействиях;
		НоваяКнопка.Пометка 				= Пометка;
	КонецЕсли; 
	
КонецПроцедуры // ПрограммноДобавитьКнопку()"}
},
{0,
{"Добавить флаг",0,0,"","Процедура ПрограммноДобавитьФлаг(пФорма, пИмяРеквизита, пЗаголовок = """", пРодитель = Неопределено, пВставитьПеред = Неопределено, пПрефиксЭлемента = ""Элемент_"", пЦветТекстаЗаголовка = Неопределено)
	
	лИмяРеквизита 					= пИмяРеквизита;
	лДобавленныйРеквизит 			= Новый РеквизитФормы(лИмяРеквизита, Новый ОписаниеТипов(""Булево""), , пЗаголовок, Ложь);
	
	МассивДобавляемыхРеквизитов 	= Новый Массив;
	МассивДобавляемыхРеквизитов.Добавить(лДобавленныйРеквизит);
	пФорма.ИзменитьРеквизиты(МассивДобавляемыхРеквизитов);
	
	Если пВставитьПеред <> Неопределено Тогда
		лЭлементФормы 		= пФорма.Элементы.Вставить(пПрефиксЭлемента + лИмяРеквизита, Тип(""ПолеФормы""), пРодитель, пВставитьПеред);
	Иначе	
		лЭлементФормы 		= пФорма.Элементы.Добавить(пПрефиксЭлемента + лИмяРеквизита, Тип(""ПолеФормы""), пРодитель);
	КонецЕсли; 
	
	лЭлементФормы.Вид 			= ВидПоляФормы.ПолеФлажка;
	лЭлементФормы.ПутьКДанным 	= лИмяРеквизита;
	лЭлементФормы.ПоложениеЗаголовка 	= ПоложениеЗаголовкаЭлементаФормы.Право;
	
	Если пЦветТекстаЗаголовка <> Неопределено Тогда
		лЭлементФормы.ЦветТекстаЗаголовка 	= пЦветТекстаЗаголовка;
	КонецЕсли;

КонецПроцедуры // ПрограммноДобавитьФлаг()"}
},
{0,
{"ПрограммноПрикрепитьЭлемент",0,0,"","//Функция программно создаст новый элемент и прикрепит его относительно указанного элемента
//-------------------------------------------------------------------------
//Параметры:
//		пФорма 	- УправляемаяФорма 	- Форма, полученная как ЭтаФорма
//		пТипЭлемента 	- УправляемаяФорма 	- Вида, Тип(""ПолеФормы"") или Тип(""ДекорацияФормы""). Для декорации не будет создан реквизит формы 
//		пЭлементОснование 	- ПолеФормы 	- Элемент относительно которого добавить поле
//		пЭлементИмя 	- Строка 	- Имя для создаваемого элемента. Если пустое, будет добавлено к имени основания ""_Доп_Право"" или ""_Доп_Лево""
//		пЭлементПредставление 	- Строка 	- Представление создаваемого элемента
//		пПоложениеЗаголовкаЭлементаФормы 	- ПоложениеЗаголовкаЭлементаФормы 	- Если ничего, то без заголовка, иначе значение параметра
//		пСправа 	- Булево 	- Расположить создаваемое поле слева или справа от пЭлементОснование
//		пПоместитьВГруппу 	- Булево 	- Помещать основание и создаваемый элементы в группу (чтобы получились ""слеплены"" и выравнены)
//		пГруппаГоризонтальная 	- ГруппировкаПодчиненныхЭлементовФормы 	- Если ничего, то ГоризонтальнаяЕслиВозможно, иначе если Истина, Горизонтальная
//		пПрефиксЭлемента 	- Строка 	- Префикс создаваемого элемента, будет добавлен в начале имени
//		пУстановитьДействие 	- Структура 	- Список действий вида, Новый Структура(""ПриИзменении"") или Новый Структура(""ПриИзменении"", ""СвоеДействие"")
//Возвращаемое значение:
//		Строка 	- ИмяРеквизита, который создан. Его элемент будет иметь префикс пПрефиксЭлемента
//-------------------------------------------------------------------------
//автор: КучеровРМ 31.05.2019
Функция ПрограммноПрикрепитьЭлемент(пФорма, пТипЭлемента, пЭлементОснование, пЭлементИмя = """", пЭлементПредставление = """", пПоложениеЗаголовкаЭлементаФормы = Неопределено, пСправа = Истина, пПоместитьВГруппу = Ложь, пГруппаГоризонтальная = Неопределено, пПрефиксЭлемента = ""Элемент_"", пУстановитьДействие = Неопределено) Экспорт
	
	пИмяСоздатьПоле = """";
	
	лЭлементы				= пФорма.Элементы;
	
	лЭлементОснованиеИмя 	= пЭлементОснование.Имя;
	
	Если ПустаяСтрока(пЭлементИмя) Тогда			   
		Если пСправа Тогда
			пИмяСоздатьПоле = пЭлементОснование.Имя + ""_Доп_Право"";
		Иначе
			пИмяСоздатьПоле = пЭлементОснование.Имя + ""_Доп_Лево"";
		КонецЕсли;
	Иначе
		пИмяСоздатьПоле 	= пЭлементИмя;
	КонецЕсли; 
	
	Родитель = пЭлементОснование.Родитель;
	
	Если пПоместитьВГруппу Тогда
		ДобавленнаяГруппа 		= лЭлементы.Вставить(""Группа_"" + лЭлементОснованиеИмя, Тип(""ГруппаФормы""), Родитель, пЭлементОснование);
		ДобавленнаяГруппа.Вид 	= ВидГруппыФормы.ОбычнаяГруппа;
		ДобавленнаяГруппа.ОтображатьЗаголовок 	= Ложь;
		ДобавленнаяГруппа.Объединенная 	= Истина;
		ДобавленнаяГруппа.Отображение 	= ОтображениеОбычнойГруппы.Нет; //С этим свойством будет как бы в красивой сетке, иначе будет смещаться. Но при Объединенная = Истина всё норм
		
		Если пГруппаГоризонтальная = Неопределено Тогда
			ДобавленнаяГруппа.Группировка 			= ГруппировкаПодчиненныхЭлементовФормы.ГоризонтальнаяЕслиВозможно;
		ИначеЕсли пГруппаГоризонтальная = Истина Тогда
			ДобавленнаяГруппа.Группировка 			= ГруппировкаПодчиненныхЭлементовФормы.Горизонтальная;
		Иначе
			ДобавленнаяГруппа.Группировка 			= ГруппировкаПодчиненныхЭлементовФормы.Вертикальная;
		КонецЕсли; 
		
		лЭлементы.Переместить(пЭлементОснование, ДобавленнаяГруппа);
		
		Родитель 	= ДобавленнаяГруппа;
	КонецЕсли; 
	
	Если пСправа Тогда
		ЭлементФормы 		= лЭлементы.Добавить(пПрефиксЭлемента + пИмяСоздатьПоле, пТипЭлемента, Родитель);
	Иначе
		ЭлементФормы 		= лЭлементы.Вставить(пПрефиксЭлемента + пИмяСоздатьПоле, пТипЭлемента, Родитель, пЭлементОснование);
	КонецЕсли;
	
	Если пТипЭлемента = Тип(""ПолеФормы"") Тогда
		лДобавленныйРеквизитФормы 		= Новый РеквизитФормы(пИмяСоздатьПоле, Новый ОписаниеТипов(""Строка""), , пЭлементПредставление, Ложь);
		
		МассивДобавляемыхРеквизитов 	= Новый Массив;
		МассивДобавляемыхРеквизитов.Добавить(лДобавленныйРеквизитФормы);
		пФорма.ИзменитьРеквизиты(МассивДобавляемыхРеквизитов);
		
		ЭлементФормы.Вид 					= ВидПоляФормы.ПолеВвода;
		ЭлементФормы.ПутьКДанным 			= пИмяСоздатьПоле;
		Если ЗначениеЗаполнено(пПоложениеЗаголовкаЭлементаФормы) Тогда
			ЭлементФормы.ПоложениеЗаголовка = пПоложениеЗаголовкаЭлементаФормы;
		Иначе
			ЭлементФормы.ПоложениеЗаголовка = ПоложениеЗаголовкаЭлементаФормы.Нет;
		КонецЕсли;	
	ИначеЕсли пТипЭлемента = Тип(""ДекорацияФормы"") Тогда
		ЭлементФормы.Заголовок 	= пЭлементПредставление;
	КонецЕсли;  
	
	Если ТипЗнч(пУстановитьДействие) = Тип(""Структура"") Тогда
		Для каждого лДействие Из пУстановитьДействие Цикл
			
			лДействиеКлюч 		= лДействие.Ключ; 
			лДействиеЗначение 	= лДействие.Значение; 
			Если ЗначениеЗаполнено(лДействиеЗначение) Тогда
				ЭлементФормы.УстановитьДействие(лДействиеКлюч	, лДействиеЗначение);
			Иначе
				ЭлементФормы.УстановитьДействие(лДействиеКлюч	, ""Подключаемый_"" + пИмяСоздатьПоле + лДействиеКлюч);
			КонецЕсли; 
			
		КонецЦикла; 	
	КонецЕсли; 
	
	Возврат пИмяСоздатьПоле;
	
КонецФункции // ПрограммноПрикрепитьЭлемент()"}
}
},
{0,
{"Кнопка",0,0,"","
ИмяКоманды 				= ""ОткрытьНастройкаПередачиТоваровДетально"";
КомандаФормы 			= ЭтаФорма.Команды.Добавить(ИмяКоманды);
КомандаФормы.Действие 	= ""ОткрытьНастройкаПередачиТоваровДетально""; //&НаКлиенте
КомандаФормы.Заголовок 	= ""Настройка передачи товаров между организациями (детально)"";
КомандаФормы.Отображение 	= ОтображениеКнопки.КартинкаИТекст;
КомандаФормы.ИзменяетСохраняемыеДанные = Ложь;

НовыйЭлемент 			= ЭтаФорма.Элементы.Добавить(""ОткрытьНастройкаПередачиТоваровДетально"", Тип(""КнопкаФормы""), Элементы.ГруппаРегламентированныйУчет);
НовыйЭлемент.Вид 		= ВидКнопкиФормы.Гиперссылка;
НовыйЭлемент.ИмяКоманды = ИмяКоманды;

//В модуль формы добавить процедуру для реагирования на событие:
&НаКлиенте
Процедура ОткрытьНастройкаПередачиТоваровДетально(Команда)
	
	ОткрытьФорму(""РегистрСведений._НастройкаПередачиТоваровМеждуОрганизациямиДетальные.Форма"", , ЭтаФорма);
	
КонецПроцедуры"}
},
{0,
{"ДобавитьЭлементНаСервере (быстро)",0,0,"","&НаСервере
Процедура ДобавитьЭлементНаСервере(ЭтаФорма, ИмяКолонки, ПутьКДанным, ЭлементРодитель, пВставитьПеред = Неопределено, Заголовок = """", Видимость = Истина) Экспорт
	
	Элементы  	= ЭтаФорма.Элементы;
	
	Если Элементы.Найти(ИмяКолонки) = Неопределено Тогда
		Если ПустаяСтрока(Заголовок) Тогда
			Заголовок 	= ИмяКолонки;
		КонецЕсли;
		
		лТипЭлемента 	= Тип(""ПолеФормы"");
		
		Если пВставитьПеред = Неопределено Тогда
			лЭлементФормы 	= Элементы.Добавить(ИмяКолонки, лТипЭлемента, ЭлементРодитель);
		Иначе
			лЭлементФормы 	= Элементы.Вставить(ИмяКолонки, лТипЭлемента, ЭлементРодитель, пВставитьПеред);
		КонецЕсли;
		
		лЭлементФормы.Вид 			= ВидПоляФормы.ПолеВвода;
		лЭлементФормы.ПутьКДанным 	= ПутьКДанным;
		лЭлементФормы.Заголовок 	= Заголовок;
		лЭлементФормы.Подсказка 	= Заголовок;
		лЭлементФормы.Видимость 	= Видимость;
	КонецЕсли; 
	
КонецПроцедуры"}
},
{0,
{"Кнопка (Команда Подключаемый_)",0,0,"ПроцПодк[люч]","&НаКлиенте
Процедура Подключаемый_<?""Имя элемента (слитно)"">ПриИзменении(Элемент)
	
	Подключаемый_<?""Имя элемента (слитно)"">ИзмененииНаСервере();
	
КонецПроцедуры

&НаСервере
Процедура Подключаемый_<?""Имя элемента (слитно)"">ИзмененииНаСервере()
	
	
	
КонецПроцедуры"}
},
{0,
{"Пример (ДополнитьФормуПрограммно)",0,0,"","&НаСервере
Процедура КЛ_ДополнитьФормуПрограммно()
	
	МассивРеквизитовФормы = Новый Массив;
	
	//Новый реквизит Товары.КЛ_ЭтоСборка
	НовыйРеквизитФормы 	= Новый РеквизитФормы(""КЛ_ЭтоСборка"", Новый ОписаниеТипов(""Булево""), ""Объект.Товары"", ""Это сборка"");
	МассивРеквизитовФормы.Добавить(НовыйРеквизитФормы);
	
	//Новый реквизит КЛ_СтатусОбработки
	НовыйРеквизитФормы 	= Новый РеквизитФормы(""КЛ_СтатусОбработки"", 
	Новый ОписаниеТипов(""ПеречислениеСсылка.СтатусыДокументовРеализации""),,""Статус обработки"");
	
	МассивРеквизитовФормы.Добавить(НовыйРеквизитФормы);
	ИзменитьРеквизиты(МассивРеквизитовФормы);
	
	НовыйЭлемент 		= Элементы.Добавить(""КЛ_СтатусОбработки"", Тип(""ПолеФормы""), Элементы.ГруппаШапкаЛевая);
	НовыйЭлемент.Вид 	= ВидПоляФормы.ПолеВвода;
	НовыйЭлемент.КнопкаОчистки = Истина;
	НовыйЭлемент.УстановитьДействие(""ПриИзменении"",""КЛ_ПриИзмененииСтатусаОбработки"");
	
	НовыйЭлемент 		= Элементы.Вставить(""КЛ_ЭтоСборка"", Тип(""ПолеФормы""),Элементы.Товары,Элементы.ТоварыКоличество);
	НовыйЭлемент.Вид 	= ВидПоляФормы.ПолеФлажка;
	
КонецПроцедуры"}
},
{0,
{"ДобавитьДанныеВСписок (Динамический)",0,0,"","Процедура ДобавитьДанныеВСписок(пЭтаФорма, пИмяСписка, пИмяРеквизита, пЭлементСписок, пЗаголовок = """", пПрефикс = ""АйТи_"") Экспорт
	
	Если ПустаяСтрока(пЗаголовок) Тогда
		пЗаголовок 	= пИмяРеквизита;
	КонецЕсли;
	
	АйТи_ОбщиеФункцииСервер.ДобавитьЭлементНаСервере(пЭтаФорма, пПрефикс + пИмяСписка + пИмяРеквизита, пИмяСписка + ""."" + пИмяРеквизита, пЭлементСписок,, пЗаголовок);
	
КонецПроцедуры // ДобавитьДанныеВСписок()

"}
},
{0,
{"Программно несколько примеров",0,0,"","Добавить поле формы
8.3(управляемая форма):
ПолеФормы = Элементы.Добавить(""ТипКонтрагента"", Тип(""ПолеФормы""), Элементы.ГруппаКонтрагента);
ПолеФормы.Вид = ВидПоляФормы.ПолеВвода; 
ПолеФормы.Заголовок = ""Тип контрагента"";
ПолеФормы.ПутьКДанным = ""Объект.ТипКонтрагента"";
ПолеФормы.Подсказка = ""Тип контрагента"";
ПолеФормы.Доступность= Истина;
ПолеФормы.АвтоВыборНезаполненного= Истина;
ПолеФормы.АвтоОтметкаНезаполненного= Истина;
ПолеФормы.ВыбиратьТип= Ложь;
ПолеФормы.ПропускатьПриВводе = Ложь;
ПолеФормы.РасширенноеРедактирование = Ложь;
ПолеФормы.РедактированиеТекста= Истина;
ПолеФормы.РежимВыбораИзСписка= Ложь;
ПолеФормы.РежимПароля= Ложь;
ПолеФормы.ТолькоПросмотр= Ложь;
 //Кнопки
ПолеФормы.КнопкаВыбора= Истина;
ПолеФормы.КнопкаОткрытия= Истина;
ПолеФормы.КнопкаОчистки= Истина;
 //События добавляемого элемента
ПолеФормы.УстановитьДеяствие(""ПриИзменении"", ""МП_ТипКонтрагентаПриИзменении"");
Добавить колонку таблицы
8.2 (не управляемая форма):
Колонка = ЭлементыФормы.ТоварыИУслуги.Колонки.Вставить(2, ""Содержание""); 
Колонка.Имя = ""айтиСумма""; 
Колонка.Данные = ""айтиСумма""; 
Колонка.УстановитьЭлементУправления(Тип(""ПолеВвода""));
8.3(управляемая форма):
Колонка = Элементы.Добавить(""Сумма"", Тип(""ПолеФормы""), Элементы.ТабличноеПолеДокументы);
Колонка.Вид = ВидПоляФормы.ПолеВвода; 
Колонка.Заголовок = ""Сумма докeмента"";
ПолеФормы.ПутьКДанным = ""Объект.Документы.ИтогПоДокументу"";
Добавить флажок
Флажок= Элементы.Добавить(""флНУ"", Тип(""ПолеФормы""), Элементы.Шапка);
Флажок.Вид = ВидПоляФормы.ПолеФлажка; 
Флажок.Заголовок = ""НУ"";
Флажок.Подсказка = ""Налоговый учет""
Флажок.ПоложениеЗаголовка = ПоложениеЗаголовкаЭлементаФормы.Право;
Флажок.ПутьКДанным = ""Объект.НУ"";
Добавить группу

Группа  = Элементы.Добавить(""Основная"", Тип(""ГруппаФормы""), Элементы.Шапка);
Группа.Вид = ВидГруппыФормы.ОбычнаяГруппа;  
Группа.ОтображатьЗаголовок = Ложь;
Группа.Отображение = ОтображениеОбычнойГруппы.Нет;
Группа .Группировка = ГруппировкаПодчиненныхЭлементов.Горизонтальная;
Добавить подменю

Подменю = Элементы.Добавить(""ГрДействия"", Тип(""ГруппаФормы""), Элементы.КомандыСписка);
Подменю.Вид = ВидГруппыФормы.Подменю;  
Подменю.Заголовок = ""Действия"";
Добавить Команду
КомандаПодменю = Форма.Команды.Добавить(""РаспределитьПоСумме"");
КомандаПодменю.Действие = ""Сб_РаспределитьПоСумме"";
КомандаПодменю.Заголовок = ""Распределить по сумме"";
КомандаПодменю.Подсказка = ""Распределить по сумме"";
КомандаПодменю.ИзменяетСохраняемыеДанные = Истина;
КомандаПодменю.Картинка= БиблиотекаКартинок.ОтборИСортировка;
КомандаПодменю.Отображение= ОтображениеКнопки.Картинка;
Добавить Кнопку
8.2 (не управляемая форма):
Вариант 1:

     НовоеДействие =  Новый Действие(""ДействияФормыЗаполнитьИсточникиФинансирования"");
     ТипКнопки = ТипКнопкиКоманднойПанели.Действие; 
     НоваяКнопка = ЭлементыФормы.ДействияФормы.Кнопки.Добавить(""ЗаполнитьИсточникиФинансирования"",
                                 ТипКнопки,""Заполнить источники финансирования"",НовоеДействие);
     //НоваяКнопка.Имя = ""НоваяКнопка"";
     //НоваяКнопка.Имя = ""ЗаполнитьИсточникиФинансирования"";
     //НоваяКнопка.Текст = ""Заполнить источники финансирования"";
     НоваяКнопка.Отображение = ОтображениеКнопкиКоманднойПанели.Надпись;
     НоваяКнопка.Подсказка = ""Заполнить источники финансирования"";
     НоваяКнопка.Пояснение = ""Открывает табличную часть Источники финансирования"";
     НоваяКнопка.Картинка = БиблиотекаКартинок.Лупа;
     НоваяКнопка.Подсказка = ""Вызов """"Добавочное действие"""""";
     НоваяКнопка.Пояснение = ""Кнопка, добавленная средствами языка"";>
     // Сочетание клавиш Alt+Ctrl+F3
     СочетаниеКлавиш =  Новый СочетаниеКлавиш(Клавиша.F3, Истина, Истина);
     НоваяКнопка.СочетаниеКлавиш = СочетаниеКлавиш;
Вариант 2:

     КнопкаВверх  = ЭлементКоманднаяПанель.Кнопки.Добавить(""КнопкаВверх"", 
                                                           ТипКнопкиКоманднойПанели.Действие, ,
                                                           ФормаОтчета.ДействияЭлементовФормы.ПриНажатииНаКнопкуВверх);
     КнопкаВверх.Картинка = БиблиотекаКартинок.ПереместитьВверх16;
     КнопкаВверх.Отображение = ОтображениеКнопкиКоманднойПанели.Картинка;

8.3 (управляемая форма):
КнопкаПодменю = Элементы.Добавить(""РаспределитьПоСумме"", Тип(""КнопкаФормы""), Подменю);
КнопкаПодменю.Заголовок = ""Распределить по сумме"";
КнопкаПодменю.ИмяКоманды = ""РаспределитьПоСумме"";
КнопкаПодменю.Подсказка = ""Распределить по сумме"";
Добавить страницу в элементы формы
8.2 (не управляемая форма):
     ЭлементыФормы.ПанельШагов.Страницы.Добавить(Страница);

8.3 (управляемая форма):
      //Панель = Элементы.Добавить(""ПанельФормы"",Тип(""ГруппаФормы""), );
       //Панель.Вид=ВидГруппыФормы.Страницы;
   НовавяСтраницаФормы = Элементы.Добавить(ЭлементСтруктуры.Ключ,Тип(""ГруппаФормы""),Панель);
   НовавяСтраницаФормы.Заголовок = ЭлементСтруктуры.Значение;
   НовавяСтраницаФормы.Вид = ВидГруппыФормы.Страница;"}
},
{0,
{"Функция программного изменения формы",0,0,"","//Добавить в нужную форму в конец события ПриСозданииНаСервере:
//АйТи_Б24_ОбщиеФункцииСервер.ПрограммноеИзменениеФормы(ЭтаФорма);
Процедура ПрограммноеИзменениеФормы(пФорма) Экспорт
	
	Элементы 	= пФорма.Элементы;
	лИмяФормы 	= пФорма.ИмяФормы;
	
	лПодписьДоработокАйТи 	= "" (АйТи)"";
	лЦветДоработокАйТи 		= Новый Цвет(83, 106, 194);
	
	Если лИмяФормы = ""ОбщаяФорма.Б24_Синхр_ПроверитьНаОбновления"" Тогда
		Элементы.ТекущаяВерсияИнфо.Заголовок 	= Элементы.ТекущаяВерсияИнфо.Заголовок + лПодписьДоработокАйТи;
		Элементы.ТекущаяВерсияИнфо.ЦветТекста 	= лЦветДоработокАйТи;	
	ИначеЕсли лИмяФормы = ""Справочник.Б24_Синхр_НастройкиСинхронизацииСБитрикс24.Форма.ФормаЭлемента"" Тогда
		НовыеРеквизиты 	= Новый Массив;
		
		НовыйРеквизит 	= Новый РеквизитФормы(""м2"", Новый ОписаниеТипов(""Число""),""Объект.Запасы"", ""м2"");
		НовыйРеквизит2 	= Новый РеквизитФормы(""м3"", Новый ОписаниеТипов(""Число""),""Объект.Запасы"", ""м3"");
		
		НовыеРеквизиты.Добавить(НовыйРеквизит);
		НовыеРеквизиты.Добавить(НовыйРеквизит2);
		пФорма.ИзменитьРеквизиты(НовыеРеквизиты);
	ИначеЕсли лИмяФормы = ""Справочник.Б24_Синхр_НастройкиСинхронизацииСБитрикс24.Форма.НастройкаСинхронизацииСделок"" Тогда
		//Элементы.ЗагружатьСделки.Видимость 			= Ложь;
		//Элементы.НастройкиЗагрузкиЗаказов.Видимость = Ложь; 
		//Элементы.ВыгружатьСделки.Видимость 			= Ложь; 
		//Элементы.НастройкаВыгрузкиЗаказов.Видимость = Ложь; 
		
		Элементы.ЗагружатьСделки.ЦветТекстаЗаголовка 	= лЦветДоработокАйТи; 
		Элементы.ЗагружатьСделки.Заголовок 				= ""Загружать статус сделки"" + лПодписьДоработокАйТи;
		
		Элементы.ВыгружатьСделки.ЦветТекстаЗаголовка 	= лЦветДоработокАйТи; 
		Элементы.ВыгружатьСделки.Заголовок 				= ""Выгружать статус сделки"" + лПодписьДоработокАйТи;
		
		лИмяКнопки 	= ""АйТи_НастройкиКомпановкиПоУмолчанию"";
		ДобавитьКнопкуНаФорму(Элементы, пФорма.Команды, лИмяКнопки, ""Настройки отбора по умолчанию"" + лПодписьДоработокАйТи, лИмяКнопки, Элементы.НастройкаВыгрузкиЗаказов);
		Элементы[лИмяКнопки].ЦветТекста 	= лЦветДоработокАйТи;
	ИначеЕсли лИмяФормы = ""Справочник.Б24_Синхр_НастройкиСинхронизацииСБитрикс24.Форма.НастройкаСинхронизацииЗаказов"" Тогда 	
		лИмяКнопки 	= ""АйТи_НастройкиКомпановкиПоУмолчанию"";
		ДобавитьКнопкуНаФорму(Элементы, пФорма.Команды, лИмяКнопки, ""Настройки отбора по умолчанию"" + лПодписьДоработокАйТи, лИмяКнопки, Элементы.НастройкаВыгрузкиДокументов);
		Элементы[лИмяКнопки].ЦветТекста 	= лЦветДоработокАйТи;
	КонецЕсли;
	
КонецПроцедуры // ПрограммноеИзменениеФормы()
"}
},
{0,
{"Программно вывести КИ",0,0,"","//Функция программно выводит поля под контактную информацию (КИ), или прикрепляет их к существующему
//-------------------------------------------------------------------------
//Параметры:
//		пФорма 	- УправляемаяФорма 	- Форма, полученная как ЭтаФорма
//		пРеквизитКИ 	- Строка 	- Имя реквизита на форме, к которому добавить информацию в поле с КИ (его элемент называться должен так же!). Если пустой, то будет создан с именен пИмяСоздатьКИ
//		пИмяСоздатьКИ 	- Строка 	- Имя создаваемого реквизита. Учитывается при пустом пРеквизитКИ. И будет создана группа, куда поместит этот реквизит под КИ. И создаст события
//		пПредставление 	- Строка 	- Представление создаваемого реквизита, созданного по имени пИмяСоздатьКИ 
//		пВладелец 	- ЭлементФормы 	- Владелец группы, в которую будут помещены элементы
//		пВставитьПеред 	- ЭлементФормы 	- Перед каким элементом добавить созданный - если указан пИмяСоздатьКИ. Хотя он же в группе будет.. Наверно можно его пропустить
//		пСоздатьПримечание 	- Булево 	- Выведет правее поля КИ поле с примечанием (обычно для телефона), реквизит примечания будет с именем лИмяРеквизита + ""_КомментарийКонтакт""
//Возвращаемое значение:
//		Строка 	- Имя переданного или созданного реквизита, который в итоге на форме
//-------------------------------------------------------------------------
//автор: КучеровРМ 06.06.2019 
Функция ПрограммноВывестиКИ(пФорма, пРеквизитКИ = """", пИмяСоздатьКИ = """", пПредставление = """", пВладелец = Неопределено, пВставитьПеред = Неопределено, пСоздатьПримечание = Истина) Экспорт
	
	лИмяРеквизита 	= """";
	Родитель 		= пВладелец;
	лЭлементы		= пФорма.Элементы;
	
	Если ЗначениеЗаполнено(пРеквизитКИ) Тогда //Реквизит для вывода телефона уже есть, обращаемся к нему
		лИмяРеквизита 					= пРеквизитКИ;
		ЭлементФормы 					= лЭлементы[лИмяРеквизита];
		ЭлементФормы.КнопкаОткрытия 	= Истина;
		
		//ЭлементФормы.УстановитьДействие(""ПриИзменении""	, ""Подключаемый_"" + пРеквизитКИ + ""ПриИзменении"");
		//ЭлементФормы.УстановитьДействие(""Открытие""		, ""Подключаемый_"" + пРеквизитКИ + ""Открытие"");
	ИначеЕсли ЗначениеЗаполнено(пИмяСоздатьКИ) Тогда
		ДобавленнаяГруппа 		= лЭлементы.Добавить(""Группа_"" + пИмяСоздатьКИ, Тип(""ГруппаФормы""), пВладелец);
		ДобавленнаяГруппа.Вид 	= ВидГруппыФормы.ОбычнаяГруппа;
		ДобавленнаяГруппа.Группировка 			= ГруппировкаПодчиненныхЭлементовФормы.Горизонтальная;
		ДобавленнаяГруппа.ОтображатьЗаголовок 	= Ложь;

		Родитель 	= ДобавленнаяГруппа;
		
		лИмяРеквизита 					= пИмяСоздатьКИ;
		лДобавленныйРеквизитФормы 		= Новый РеквизитФормы(пИмяСоздатьКИ, Новый ОписаниеТипов(""Строка""), , пПредставление, Ложь);
		
		МассивДобавляемыхРеквизитов 	= Новый Массив;
		МассивДобавляемыхРеквизитов.Добавить(лДобавленныйРеквизитФормы);
		пФорма.ИзменитьРеквизиты(МассивДобавляемыхРеквизитов);
		
		//Перед каким элементом добавить созданный - если указан пИмяСоздатьКИ. Хотя он же в группе будет.. Наверно можно его пропустить
		Если пВставитьПеред <> Неопределено Тогда
			ЭлементФормы 		= лЭлементы.Вставить(""Элемент_"" + пИмяСоздатьКИ, Тип(""ПолеФормы""), Родитель, пВставитьПеред);
		Иначе
			ЭлементФормы 		= лЭлементы.Добавить(""Элемент_"" + пИмяСоздатьКИ, Тип(""ПолеФормы""), Родитель);
		КонецЕсли;
		
		ЭлементФормы.Вид 			= ВидПоляФормы.ПолеВвода;
		ЭлементФормы.ПутьКДанным 	= пИмяСоздатьКИ;
		
		ЭлементФормы.КнопкаОткрытия 	= Истина;
		ЭлементФормы.УстановитьДействие(""ПриИзменении""	, ""Подключаемый_"" + лИмяРеквизита + ""ПриИзменении"");
		ЭлементФормы.УстановитьДействие(""Открытие""		, ""Подключаемый_"" + лИмяРеквизита + ""Открытие"");
	КонецЕсли;
	
	Если пСоздатьПримечание Тогда
		лПутьКДанным 					= лИмяРеквизита + ""_КомментарийКонтакт"";
		
		ПрограммноПрикрепитьЭлемент(пФорма, Тип(""ПолеФормы""), ЭлементФормы, лПутьКДанным, ""Комментарий контактного лица"",,, Истина, Истина,, Новый Структура(""ПриИзменении""));
		
		ПолеКомментарий = лЭлементы[""Элемент_"" + лПутьКДанным];
		
		ПолеКомментарий.ПропускатьПриВводе 	= Истина;
		ПолеКомментарий.ПодсказкаВвода 		= НСтр(""ru='Прим.'"");
		ПолеКомментарий.Ширина 				= 10;
		ПолеКомментарий.РастягиватьПоГоризонтали 	= Ложь;
	КонецЕсли; 
	
	лДобавленныйРеквизитФормы 		= Новый РеквизитФормы(лИмяРеквизита + ""_ЗначенияПолей"", Новый ОписаниеТипов(""Строка""), , пПредставление, Ложь);
	
	МассивДобавляемыхРеквизитов 	= Новый Массив;
	МассивДобавляемыхРеквизитов.Добавить(лДобавленныйРеквизитФормы);
	пФорма.ИзменитьРеквизиты(МассивДобавляемыхРеквизитов);
	
	Возврат лИмяРеквизита;
	
КонецФункции // ПрограммноВывестиКИ()"}
},
{0,
{"Программная работа с реквизитами и элементами формы.",0,0,"","Программная работа с реквизитами и элементами формы.
https://flumi.ru/articles/show/programmnaia_rabota_s_rekvizitami_i_elementami_formy

//-----------------------------------------------

// Заменит основное действие формы указанным                
ЭтаФорма.УстановитьДействие(""ОбработкаВыбора"", ""Добавленный_ОбработкаВыбора"");

// Заменит основное действие элемента формы указанным
Элементы.СуществующийРеквизитОбъекта.УстановитьДействие(""ПриИзменении"", ""Добавленный_ПриИзменииСуществующегоРеквизитаОбъекта"");

//-----------------------------------------------

// Добавляет команду на форму              
ДобавленнаяКомандаФормы 			= Команды.Добавить(""ДобавленнаяКомандаФормы"");      
ДобавленнаяКомандаФормы.Действие 	= ""ДействиеДобавленнойКомандыФормы"";
ДобавленнаяКомандаФормы.Картинка 	= БиблиотекаКартинок.БизнесПроцессОбъект;
ДобавленнаяКомандаФормы.Отображение = ОтображениеКнопки.КартинкаИТекст;

// Добавляет кнопку на форму, связывает ее с добавленной командной и помещает на командную панель формы
ДобавленнаяКнопкаФормы 	= Элементы.Вставить(""ДобавленнаяКнопкаФормы"", Тип(""КнопкаФормы""),
ДобавленнаяКнопкаФормы.Заголовок 	= НСтр(""ru='Нажмите на добавленную кнопку формы'"");
ДобавленнаяКнопкаФормы.ИмяКоманды 	= ""ДобавленнаяКомандаФормы""; // Имя ранее добавленной команды

//-----------------------------------------------

// Добавляет подменю на командную панель формы
ГруппаПодменюКоманднойПанели 		= Элементы.Добавить(""ДобавленноеПодменюКоманднойПанелиФормы"", Тип(""ГруппаФормы""), Элементы.ФормаКоманднаяПанель);
ГруппаПодменюКоманднойПанели.Вид 	= ВидГруппыФормы.Подменю;
ГруппаПодменюКоманднойПанели.Заголовок 	= НСтр(""ru='Добавленное подменю командной панели формы'"");
ГруппаПодменюКоманднойПанели.Картинка 	= БиблиотекаКартинок.БыстрыеНастройкиОтчета;
ГруппаПодменюКоманднойПанели.Отображение 	= ОтображениеКнопки.КартинкаИТекст;

//-----------------------------------------------

// Перемещает существующую кнопку в созданное подменю
// (При обращении к элементам можно использовать как обращение через ""Эелменты"", так и переменные, которыми они описаны в процессе создания)
Элементы.Переместить(ДобавленнаяКнопкаФормы, ГруппаПодменюКоманднойПанели);

// Поместим существующий элемент перед уже размещенным в созданной группе:
Элементы.Переместить(Элементы.ФормаСуществующаяКомандаКоманднойПанелиФормы, Элементы.ДобавленноеПодменюКоманднойПанелиФормы, ДобавленнаяКнопкаФормы);

//-----------------------------------------------

// Добавляет свертываемую группу формы с горизонтальной группировкой
ДобавленнаяГруппаШапкаФормы 		= Элементы.Добавить(""ДобавленнаяГруппаШапкаФормы"", Тип(""ГруппаФормы""), ЭтаФорма);
ДобавленнаяГруппаШапкаФормы.Вид 	= ВидГруппыФормы.ОбычнаяГруппа;
ДобавленнаяГруппаШапкаФормы.Группировка = ГруппировкаПодчиненныхЭлементовФормы.Горизонтальная;
ДобавленнаяГруппаШапкаФормы.Заголовок 	= НСтр(""ru='Добавленная сворачиваемая группа формы'"");
ДобавленнаяГруппаШапкаФормы.ЗаголовокСвернутогоОтображения = НСтр(""ru='Развернуть свернутую группу'"");
ДобавленнаяГруппаШапкаФормы.Поведение 	= ПоведениеОбычнойГруппы.Свертываемая;

// !Важно! Не прокатит:
//ДобавленнаяГруппаШапкаФормы.Свернута = Истина;

// Добавляет левую группу свертываемой группы формы с вертикальной гркппировкой
ДобавленнаяГруппаШапкиФормы_Лево 		= Элементы.Добавить(""ДобавленнаяГруппаШапкиФормы_Лево"", Тип(""ГруппаФормы""), ДобавленнаяГруппаШапкаФормы);
ДобавленнаяГруппаШапкиФормы_Лево.Вид 	= ВидГруппыФормы.ОбычнаяГруппа;
ДобавленнаяГруппаШапкиФормы_Лево.ОтображатьЗаголовок 	= Ложь;
ДобавленнаяГруппаШапкиФормы_Лево.Отображение 	= ОтображениеОбычнойГруппы.Нет;
ДобавленнаяГруппаШапкиФормы_Лево.Группировка 	= ГруппировкаПодчиненныхЭлементовФормы.Вертикальная;

// Добалвляет правую группу свертываемой группы формы с вертикальной группировкой
ДобавленнаяГруппаШапкиФормы_Право 		= Элементы.Добавить(""ДобавленнаяГруппаШапкиФормы_Право"", Тип(""ГруппаФормы""), ДобавленнаяГруппаШапкаФормы);
ДобавленнаяГруппаШапкиФормы_Право.Вид 	= ВидГруппыФормы.ОбычнаяГруппа;
ДобавленнаяГруппаШапкиФормы_Право.ОтображатьЗаголовок 	= Ложь;
ДобавленнаяГруппаШапкиФормы_Право.Отображение 			= ОтображениеОбычнойГруппы.Нет;
ДобавленнаяГруппаШапкиФормы_Право.Группировк 			= ГруппировкаПодчиненныхЭлементовФормы.Вертикальная;
 
//-----------------------------------------------

// Добавляет надпись на левую группу формы
НадписьФормы 			= Элементы.Добавить(""ДобавленнаяНадписьФормы"", Тип(""ДекорацияФормы""), ДобавленнаяГруппаШапкиФормы_Лево);              
НадписьФормы.Заголовок = НСтр(""ru='Добавленная надпись формы'"");

// Добавляет картинку на правую группу формы
КартинкаФормы 			= Элементы.Добавить(""ДобавленнаяКартинкаФормы"", Тип(""ДекорацияФормы""), ДобавленнаяГруппаШапкиФормы_Право);           
КартинкаФормы.Заголовок = НСтр(""Добавленная картинка формы"");
КартинкаФормы.Вид 		= ВидДекорацииФормы.Картинка;
КартинкаФормы.Картинка 	= БиблиотекаКартинок.АктивныеПользователи;

//-----------------------------------------------

// Добалвяет группу страниц формы
ГруппаСтраницФормы 		= Элементы.Добавить(""ДобавленнаяГруппаСтраницФормы"", Тип(""ГруппаФормы""), ЭтаФорма);
ГруппаСтраницФормы.Вид 	= ВидГруппыФормы.Страницы;
ГруппаСтраницФормы.ОтображениеСтраниц 	= ОтображениеСтраницФормы.ЗакладкиСлеваГоризонтально;

// Добалвяет страницу на форму в гуруппе страниц
ГруппаСтраница1Формы 		= Элементы.Добавить(""ДобавленнаяСтраница1Формы"", Тип(""ГруппаФормы""), ГруппаСтраницФормы);
ГруппаСтраница1Формы.Вид 	= ВидГруппыФормы.Страница;
ГруппаСтраница1Формы.Заголовок = НСтр(""ru='Добавленная страница 1 формы'"");

//-----------------------------------------------

// Добавляет реквизит формы и выводит его на форму
лДобавленныйРеквизитФормы 		= Новый РеквизитФормы(""ДобавленныйРеквизитФормыБулево"", Новый ОписаниеТипов(""Булево""), , НСтр(""ru='Добавленный реквизит формы Булево'""), Ложь);

МассивДобавляемыхРеквизитов 	= Новый Массив;
МассивДобавляемыхРеквизитов.Добавить(лДобавленныйРеквизитФормы);
ИзменитьРеквизиты(МассивДобавляемыхРеквизитов);                       

ЭлементФормы 		= Элементы.Добавить(""ЭлементДобавленныйРеквизитФормыБулево"", Тип(""ПолеФормы""), ГруппаСтраница1Формы);
ЭлементФормы.Вид 	= ВидПоляФормы.ПолеФлажка;
ЭлементФормы.ПутьКДанным 	= ""ДобавленныйРеквизитФормыБулево"";

// Выводит на форму добавленный в объекте реквизит
ЭлементФормы 		= Элементы.Добавить(""СуществующийНоНеОтображаемыйРеквизитОбъектаСтрока"", Тип(""ПолеФормы""), ГруппаСтраница1Формы);
ЭлементФормы.Вид 	= ВидПоляФормы.ПолеВвода;
ЭлементФормы.ПутьКДанным 	= ""Объект.СуществующийНоНеОтображаемыйРеквизитОбъекта"";

//-----------------------------------------------

// Добавяет реквизиты табличной части на форму
ДобавленныйРеквизитТЧОбъектаСтрока = Новый РеквизитФормы(""ДобавленныйРеквизитТЧОбъектаСтрока"", Новый ОписаниеТипов(""Строка""), ""Объект.СуществующаяТЧОбъекта"", НСтр(""ru='Добавленный строковый реквизит существующей ТЧ Объекта'""), Ложь);

МассивДобавляемыхРеквизитов = Новый Массив;
МассивДобавляемыхРеквизитов.Добавить(ДобавленныйРеквизитТЧОбъектаСтрока);
ИзменитьРеквизиты(МассивДобавляемыхРеквизитов);                       

// Выводит добавленный реквизиты на форму                      
ЭлементФормы 		= Элементы.Добавить(""ТЧ_ДобавленныйРеквизитТЧОбъектаСтрока"", Тип(""ПолеФормы""), Элементы.СуществующаяТЧОбъекта);
ЭлементФормы.Вид 	= ВидПоляФормы.ПолеВвода;
ЭлементФормы.ПутьКДанным 	= ""Объект.СуществующаяТЧОбъекта.ДобавленныйРеквизитТЧОбъектаСтрока"";

// Выводит на форму добавленный в объекте реквизит
ЭлементФормы 		= Элементы.Добавить(""ТЧ_СуществующийНоНеОтображаемыйРеквизитТЧОбъектаСтрока"", Тип(""ПолеФормы""), Элементы.СуществующаяТЧОбъекта);
ЭлементФормы.Вид 	= ВидПоляФормы.ПолеВвода;
ЭлементФормы.ПутьКДанным 	= ""Объект.СуществующаяТЧОбъекта.СуществующийНоНеОтображаемыйРеквизитТЧОбъекта"";

//-----------------------------------------------

// Добавит таблицу значений на форму
МассивТипов 	= Новый Массив;
МассивТипов.Добавить(Тип(""ТаблицаЗначений""));
ОписаниеТипаТЗ 	= Новый ОписаниеТипов(МассивТипов);

РеквизитФормыТаблицаЗначений = Новый РеквизитФормы(""ДобавленнаяТаблицаЗначенийФормы"", ОписаниеТипаТЗ, , НСтр(""ru='Добавленная ТЧ на форму'""),  Ложь);

// Добавит на форму реквизит таблицы значений               
РеквизитФормыРеквизитТаблицыЗначений = Новый РеквизитФормы(""ДобавленныйРеквизитДобавленнойТаблицыЗначений"", Новый ОписаниеТипов(""Строка""), ""ДобавленнаяТаблицаЗначенийФормы"", НСтр(""ru='Добавленный реквизит добавленной таблицы значений'""), Ложь);      

МассивДобавляемыхРеквизитов 	= Новый Массив;
МассивДобавляемыхРеквизитов.Добавить(РеквизитФормыТаблицаЗначений);
МассивДобавляемыхРеквизитов.Добавить(РеквизитФормыРеквизитТаблицыЗначений);
ИзменитьРеквизиты(МассивДобавляемыхРеквизитов);

// Выведет на форму добавленную таблицу значений
ДобавляемаяНаФормуДобавленнаяТаблица 				= Элементы.Добавить(""ДобавляемаяНаФормуДобавленнаяТаблица"",
ДобавляемаяНаФормуДобавленнаяТаблица.ПутьКДанным 	= ""ДобавленнаяТаблицаЗначенийФормы"";

// Выведет на форму добавленный реквизит добавленной таблицы значений
ДобавляемыйНаФормуРеквизитДобавленнойТаблицы 				= Элементы.Добавить(""ДобавляемыйНаФормуРеквизитДобавленнойТаблицы"",
ДобавляемыйНаФормуРеквизитДобавленнойТаблицы.ПутьКДанным 	= ""ДобавленнаяТаблицаЗначенийФормы.ДобавленныйРеквизитДобавленнойТаблицыЗначений"";

//-----------------------------------------------

// Создаст реквизит динамического списка на форме
ДобавляемыйРеквизитДинамическогоСписка = Новый РеквизитФормы(""ДобавляемыйРеквизитДинамическогоСписка"", Новый ОписаниеТипов(""ДинамическийСписок""), , НСтр(""ru='Добавленный динамический список'""), Ложь);

МассивДобавляемыхРеквизитов 	= Новый Массив;
МассивДобавляемыхРеквизитов.Добавить(ДобавляемыйРеквизитДинамическогоСписка);
ИзменитьРеквизиты(МассивДобавляемыхРеквизитов);

// Опишем параметры динамического списка    
ЭтаФорма.ДобавляемыйРеквизитДинамическогоСписка.ПроизвольныйЗапрос 	= Истина;
ЭтаФорма.ДобавляемыйРеквизитДинамическогоСписка.ТекстЗапроса 		= ""Выбрать * Из Справочник.Валюты"";                      
ЭтаФорма.ДобавляемыйРеквизитДинамическогоСписка.ОсновнаяТаблица 	= ""Справочник.Валюты"";
ЭтаФорма.ДобавляемыйРеквизитДинамическогоСписка.УстановитьОбязательноеИспользование(""Ссылка"", Истина);

//Создание элементов формы
ДобавленныйЭлементТаблицаДинамическогоСписка 				= Элементы.Добавить(""ДобавленныйЭлементТаблицаДинамическогоСписка"", Тип(""ТаблицаФормы""), ГруппаСтраница4Формы);
ДобавленныйЭлементТаблицаДинамическогоСписка.ПутьКДанным 	= ""ДобавляемыйРеквизитДинамическогоСписка"";
ДобавленныйЭлементТаблицаДинамическогоСписка.Отображение 	= ОтображениеТаблицы.Список;

НоваяКолонка 				= Элементы.Добавить(""ДобавленнаяКолонкаДинамическогоСписка_Ссылка"", Тип(""ПолеФормы""), ДобавленныйЭлементТаблицаДинамическогоСписка);
НоваяКолонка.ПутьКДанным 	= ""ДобавляемыйРеквизитДинамическогоСписка.Ссылка"";

НоваяКолонка 				= Элементы.Добавить(""ДобавленнаяКолонкаДинамическогоСписка_ПометкаУдаления"", Тип(""ПолеФормы""), ДобавленныйЭлементТаблицаДинамическогоСписка);
НоваяКолонка.ПутьКДанным 	= ""ДобавляемыйРеквизитДинамическогоСписка.ПометкаУдаления"";

НоваяКолонка 				= Элементы.Добавить(""ДобавленнаяКолонкаДинамическогоСписка_Код"", Тип(""ПолеФормы""), ДобавленныйЭлементТаблицаДинамическогоСписка);
НоваяКолонка.ПутьКДанным 	= ""ДобавляемыйРеквизитДинамическогоСписка.Код"";

НоваяКолонка 				= Элементы.Добавить(""ДобавленнаяКолонкаДинамическогоСписка_Наименование"", Тип(""ПолеФормы""), ДобавленныйЭлементТаблицаДинамическогоСписка);
НоваяКолонка.ПутьКДанным 	= ""ДобавляемыйРеквизитДинамическогоСписка.Наименование"";
НоваяКолонка.РастягиватьПоГоризонтали 	= Ложь;

//-----------------------------------------------"}
}
},
{4,
{"Элементы",1,0,"",""},
{0,
{"Видимость",0,0,"Видим[ос]","Элементы.<?""Имя элемента формы"">.Видимость 	= <?"""", ВыборВарианта, ""Истина"", ""Истина"", ""Ложь"", ""Ложь"">;"}
},
{0,
{"Доступность",0,0,"Дост[упнос]","Элементы.<?""Имя элемента формы"">.Доступность 	= <?"""", ВыборВарианта, ""Истина"", ""Истина"", ""Ложь"", ""Ложь"">;"}
},
{0,
{"Заголовок (не весь в автозамене, чтобы можно было дописывать иные загловки, не вызывая это)",0,0,"Заго[лов]","Элементы.<?""Имя элемента формы"">.Заголовок 	= Элементы.<?""Имя элемента формы"">.Заголовок;"}
},
{4,
{"Фирменные",1,0,"",""},
{0,
{"Элемент доработан АйТи",0,0,"ЭлемАйТи","Элементы.<?""Имя элемента формы"">.ЦветТекстаЗаголовка 	= Новый Цвет(83, 106, 194); 
Элементы.<?""Имя элемента формы"">.Заголовок 				= Элементы.<?""Имя элемента формы"">.Заголовок + "" (АйТи)"";"}
},
{0,
{"Цвет текста (фирменный, синеватый, Цвет(83, 106, 194))",0,0,"ЦветАй[Ти]","Элементы.<?""Имя элемента формы"">.ЦветТекста 	= Новый Цвет(83, 106, 194);"}
},
{0,
{"Цвет текста заголовка (фирменный, синеватый, Цвет(83, 106, 194))",0,0,"ЦветЗагАй[Ти]","Элементы.<?""Имя элемента формы"">.ЦветТекстаЗаголовка 	= Новый Цвет(83, 106, 194);"}
},
{0,
{"Заголовок (фирменный, АйТи)",0,0,"ЗаголовкАй[Ти]","Элементы.<?""Имя элемента формы"">.Заголовок 	= Элементы.<?""Имя элемента формы"">.Заголовок + "" (АйТи)"";"}
}
}
},
{21,
{"Строка",1,0,"",""},
{4,
{"Повторяющиеся символы",1,0,"",""},
{0,
{"УдалитьПовторяющиесяСимволы",0,0,"","Функция УдалитьПовторяющиесяСимволы(Знач Строка, Знач Символ, Знач Режим = ""Слева"") Экспорт
    
    Если ВРег(Режим) = ""СЛЕВА"" Тогда
        
        Пока Лев(Строка, 1)= Символ Цикл
            
            Строка = Сред(Строка, 2);
            
        КонецЦикла;
        
    ИначеЕсли ВРег(Режим) = ""СПРАВА"" Тогда
        
        Пока Прав(Строка, 1)= Символ Цикл
            
            Строка = Лев(Строка, СтрДлина(Строка) - 1);
            
        КонецЦикла;
        
    КонецЕсли;
    
    Возврат Строка;
КонецФункции"}
},
{0,
{"УбратьЛидирующиеНули",0,0,"","Функция УбратьЛидирующиеНули(Строка) Экспорт
    
    Для сч = 0 по СтрДлина(Строка) Цикл
        
        Если НЕ Сред(Строка,Сч, 1) = ""0"" Тогда //Как только всретили не ноль, возвращаем хвостик
            Возврат Сред(Строка , Сч);
        КонецЕсли;
        
    КонецЦикла;
    
    Возврат """";
	
КонецФункции"}
},
{0,
{"НомерБезНулей3",0,0,"","Функция НомерБезНулей3(знач Номер)
    
    //убираем префикс и нули
    Пока Найти(""123456789"", Лев(Номер, 1)) = 0 Цикл
        Номер = Сред(Номер, 2);    
	КонецЦикла;
	
    Возврат Номер;
    
КонецФункции // НомерБезНулей3()"}
},
{0,
{"НомерНаПечать (Типовое)",0,0,"","ПрефиксацияОбъектовКлиентСервер.НомерНаПечать(Номер, УдалитьПрефиксИнформационнойБазы, УдалитьПользовательскийПрефикс)
ИЛИ
ОбщегоНазначения.ПолучитьНомерНаПечать()"}
}
},
{4,
{"Сходство наименований",1,0,"",""},
{0,
{"Статья: Степень сходства двух наименований справочника",0,0,"","https://infostart.ru/public/332257/

Статья посвящена исследованию следующего вопроса: необходимо сравнить 2 наименования справочников с целью вычисления их степени сходства. По задумке, степень сходства должна выражаться в процентах.
Задача возникла при попытках поиска элементов справочника номенклатуры для обновления значений реквизитов. Суть проблемы заключалась в неуникальности реквизитов для поиска (артикул, например) в пределах всего справочника, что приводило к ложной подстановке обновляемых реквизитов. 

В итоге, в качестве решения проблемы разработана модель сравнения наименования найденного элемента справочника с наименованием элемента, необходимого для обновления реквизитов. Таким образом, мы отсеиваем полностью несовпадающие по наименованию элементы справочника при неуникальных остальных реквизитах, по которым мы пытаемся спозиционироваться на элемент.

Существуют масса алгоритмов определения степени сходства 2-х текстов, после изучения которых, был выработан следующий алгоритм:

Вычисляем длины наименований
Принимаем за эталон наибольшую длину (для организации цикла)
Принимаем наименование с наибольшей длиной за эталонную строку
Попарно вычисляем число вхождений в обоих наименованиях каждого символа из эталонной строки
Удаляем из наименований символы, для которых произведён поиск
Складываем общее количество вхождений для каждого наименования
После цикла вычисляем степень сходства по формуле (результат в процентах):
(Вхождение1/Вхождение2)*100
Здесь, ""Вхождение1"" - общее число вхождений каждого символа эталонной строки в первое наименование, ""Вхождение2"" - общее число вхождений каждого символа эталонной строки во второе наименование. 

Перед вычислением по формуле, в условном операторе, необходимо определить какое из наименований имеет наибольшее число вхождений.

Ниже представлен полученный код для платформы 1С Предприятие 7.7. Принимаются предложения по оптимизации.

//возвращает процент сходства 2-х наименований
Функция СходствоНаименований(Знач Наим1="""",Знач Наим2="""") 
    Наим1 = СокрЛП(Наим1);
    Наим2 = СокрЛП(Наим2);
    Наим1 = СтрЗаменить(Наим1,""  "",""""); //Удаляем двойные пробелы
    Наим1 = СтрЗаменить(Наим1,"" "","""");  //Удаляет одинарные пробелы
    Наим2 = СтрЗаменить(Наим2,""  "","""");
    Наим2 = СтрЗаменить(Наим2,"" "","""");
    //проверяем значения на схожесть  
    Длина1  = СтрДлина(Наим1);
    Длина2  = СтрДлина(Наим2);
    Если Длина1 > Длина2 Тогда
        Длина = Длина1;
    Стр   = Наим1;
    Иначе
    Длина = Длина2;
    Стр   = Наим2;
    КонецЕсли;
    Сч = 0; Вхождение1 = 0; Вхождение2 = 0;
    Пока (Стр<>"""") Цикл
        Символ = Лев(Стр,1);
        Вхождение1 = Вхождение1+СтрЧислоВхождений(Наим1,Символ);
        Вхождение2 = Вхождение2+СтрЧислоВхождений(Наим2,Символ);
        Наим1 = СтрЗаменить(Наим1,Символ,"""");
        Наим2 = СтрЗаменить(Наим2,Символ,"""");
        Стр = Прав(Стр,СтрДлина(Стр)-1);
    КонецЦикла;
    Возврат  ?(Вхождение1>Вхождение2,Окр((Вхождение2/Вхождение1)*100,3,1),Окр((Вхождение1/Вхождение2)*100,3,1));
КонецФункции //СходствоНаименований()

Выявленные преимущества алгоритма:

Время исполнения кода на очень хорошем уровне (меньше 0.0001 сек.)
Переносимось алгоритма (не нужно подключать внешние компоненты)
Выходной показатель (процент степени сходства) соответствует различию входных данных

Выявленные недостатки:
Чувствительность алгоритма к сильному различию в количестве символов 2-х наименований (показатель степени сходства быстро снижается) 
При простой перестановке символов в разных наименованиях результат будет 100% сходства, что неверно.
Результаты экспериментов
Эксперимент 1:

Наименование1 = ""A0900001N Угольник 1""х1""
Наименование2 = ""CJ 65 V3 Лобзик""
Результат = 13.636%
Эксперимент 2:

Наименование1 = ""Cъемник рулевых тяг и шаровых опор TOYA""
Наименование2 = ""Cъемник рулевых тяг и шаровых опор  2-х позиционный, зев 20 мм""
Результат = 56.863%
Эксперимент 3:

Наименование1 = ""MF 800 VE миксер Felisatti""
Наименование2 = ""MF1200/VE2 миксер Felisatti""
Результат = 84.000%
Возможное решение описанных выше недостатков

Метод написан на базе платформы 1С:8 пользователем DrBlack

Функция ПолучитьПроцентСходстваНаименований_2(Знач НаимСравн="""", МассивСлов, ОбщДлинаСлов)
    СуммаСовпадений = 0;
    Для Каждого ТекСлово Из МассивСлов Цикл     
        Если СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке(ТекСлово) Тогда
            СчНачало = СтрДлина(ТекСлово);
        Иначе
            СчНачало = Макс(3, СтрДлина(ТекСлово)-4);
        КонецЕсли;
        МаксСовпадений = 0;
        Для Сч = СчНачало По СтрДлина(ТекСлово) Цикл          
            ТекОтрезокЛево = Лев(ТекСлово,  Сч);
            ТекОтрезокПрав = Прав(ТекСлово, Сч);          
            МаксСовпадений = Макс(МаксСовпадений, ?(СтрЧислоВхождений(НаимСравн, ТекОтрезокЛево)>0, Сч, 0), ?(СтрЧислоВхождений(НаимСравн, ТекОтрезокПрав)>0, Сч, 0));     
        КонецЦикла;   
        СуммаСовпадений = СуммаСовпадений + МаксСовпадений;       
    КонецЦикла;   
    ПроцентСовпадения = Окр(Мин(ОбщДлинаСлов, СуммаСовпадений) / ОбщДлинаСлов * 100, 3, 1);   
    Возврат ПроцентСовпадения;
КонецФункции
Входные параметры:
НаимСравн - строка, с которой надо сравнить
МассивСлов - эталонная строка, заранее разбитая на составляющие
ОбщДлинаСлов - общая длинна слов в МассивСлов для вычисления коэф. схожести

Суть данного метода - устранить недостатки метода из топика.

Описание колонок на скрине:
Процент1 - сравнение методом из топика
Процент2 - сравнение методом пользователя  DrBlack по вхождению слов (не короче 4х символов)
Процент3 - усредненный коэф (Процент1 + Процент2 х 2) / 3"}
},
{0,
{"ПолучитьПроцентСходстваНаименованийУчетСлов",0,0,"","//НаимСравн - строка, с которой надо сравнить
//МассивСлов - эталонная строка, заранее разбитая на составляющие. Или строка, которую СтрРазделить 
//ОбщДлинаСлов - общая длинна слов в МассивСлов для вычисления коэф. схожести
Функция ПолучитьПроцентСходстваНаименованийУчетСлов(Знач НаимСравн = """", МассивСлов, ОбщДлинаСлов = Неопределено)

	Если ТипЗнч(МассивСлов) = Тип(""Строка"") Тогда
		МассивСлов 	= СтрРазделить(МассивСлов, "" "");
	КонецЕсли; 
	
	Если НЕ ЗначениеЗаполнено(ОбщДлинаСлов) Тогда
		ОбщДлинаСлов 	= 0;
		Для каждого лСлово из МассивСлов Цикл
			ОбщДлинаСлов 	= ОбщДлинаСлов + СтрДлина(лСлово);
		КонецЦикла;	
	КонецЕсли; 

    СуммаСовпадений 	= 0;
    
    Для Каждого ТекСлово Из МассивСлов Цикл
        
        Если СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке(ТекСлово) Тогда
            СчНачало 	= СтрДлина(ТекСлово);
        Иначе
            СчНачало 	= Макс(3, СтрДлина(ТекСлово) - 4);
        КонецЕсли;
        МаксСовпадений 	= 0;
        
        Для Сч = СчНачало По СтрДлина(ТекСлово) Цикл
            
            ТекОтрезокЛево 	= Лев(ТекСлово,  Сч);
            ТекОтрезокПрав 	= Прав(ТекСлово, Сч);
            
            МаксСовпадений 	= Макс(МаксСовпадений, ?(СтрЧислоВхождений(НаимСравн, ТекОтрезокЛево) > 0, Сч, 0), ?(СтрЧислоВхождений(НаимСравн, ТекОтрезокПрав) > 0, Сч, 0));
            
        КонецЦикла;
        
        СуммаСовпадений 	= СуммаСовпадений + МаксСовпадений;
        
    КонецЦикла;
    
    ПроцентСовпадения 	= Окр(Мин(ОбщДлинаСлов, СуммаСовпадений) / ОбщДлинаСлов * 100, 3, 1);
    
    Возврат ПроцентСовпадения;
	
КонецФункции"}
},
{0,
{"СходствоНаименований",0,0,"","Функция СходствоНаименований(Знач Наим1="""", Знач Наим2="""") 
    Наим1 = СокрЛП(Наим1);
    Наим2 = СокрЛП(Наим2);
    Наим1 = СтрЗаменить(Наим1,""  "",""""); //Удаляем двойные пробелы
    Наим1 = СтрЗаменить(Наим1,"" "","""");  //Удаляет одинарные пробелы
    Наим2 = СтрЗаменить(Наим2,""  "","""");
    Наим2 = СтрЗаменить(Наим2,"" "","""");
    //проверяем значения на схожесть  
    Длина1  = СтрДлина(Наим1);
    Длина2  = СтрДлина(Наим2);
    Если Длина1 > Длина2 Тогда
        Длина = Длина1;
    Стр   = Наим1;
    Иначе
    Длина = Длина2;
    Стр   = Наим2;
    КонецЕсли;
    Сч = 0; Вхождение1 = 0; Вхождение2 = 0;
    Пока (Стр<>"""") Цикл
        Символ = Лев(Стр,1);
        Вхождение1 = Вхождение1+СтрЧислоВхождений(Наим1,Символ);
        Вхождение2 = Вхождение2+СтрЧислоВхождений(Наим2,Символ);
        Наим1 = СтрЗаменить(Наим1,Символ,"""");
        Наим2 = СтрЗаменить(Наим2,Символ,"""");
        Стр = Прав(Стр,СтрДлина(Стр)-1);
    КонецЦикла;
    Возврат  ?(Вхождение1>Вхождение2,Окр((Вхождение2/Вхождение1)*100,3,1),Окр((Вхождение1/Вхождение2)*100,3,1));
КонецФункции //СходствоНаименований()"}
},
{0,
{"Релевантность",0,0,"","Функция Релевантность(выр1,выр2)
	
    Длина1 = СтрДлина(Выр1);
    Длина2 = СтрДлина(Выр2);
    
    СовпавшихСимволов = 0;
    Сч = 1;
    Для Сч = 1 По Длина1 Цикл
        Символ = Сред(Выр1,Сч,1);
        НомерПозиции = Найти(Выр2,Символ);
        Если НомерПозиции = 0 Тогда
            Продолжить;
        Иначе
            СовпавшихСимволов = СовпавшихСимволов + 1;
            Выр2 = Лев(Выр2,НомерПозиции-1)+Сред(Выр2,НомерПозиции+1);
        КонецЕсли;
	КонецЦикла;
	
    рел="""";
	
    Если (Длина1<>0) и (Длина2<>0) тогда рел=цел((СовпавшихСимволов/Длина1 + СовпавшихСимволов/Длина2)/2*100);КонецЕсли;
	
	возврат рел;
	
КонецФункции"}
}
},
{0,
{"Символы",0,0,"","//Знаки (!, "" и т.д.)
33, 47
58, 64
91, 96
123, 126

//Букв англ заглавные
65, 90

//Букв англ прописные
97, 122

//Цифры, знаки, англ буквы
33, 126

Символ(33)

лГСЧ 				= Новый ГенераторСлучайныхЧисел(); 
лСлучайнаяСтрока 	= Символ(лГСЧ.СлучайноеЧисло(33, 126)); // цифры, знаки, англ буквы
"}
},
{0,
{"ПустаяСтрока с условием",0,0,"ПустаяСт[рока]","<?""Переменная со строкой"">Знач = СокрЛП(<?""Переменная со строкой"">);
Если НЕ ПустаяСтрока(<?""Переменная со строкой"">Знач) Тогда
	<?>
КонецЕсли;"}
},
{0,
{"ПустаяСтрока",0,0,"ПуСтр","ПустаяСтрока(<?""Переменная со строкой"">)"}
},
{0,
{"Строка для отладки",0,0,"СтрО[тладк]","АйТи_ДляОтладки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(""Для отладки надо поставить точку останова в модуле 'СтроковыеФункцииКлиентСервер' в строке 'ПодставитьПараметрыВСтроку'""); // АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy"">"}
},
{0,
{"ПодставитьПараметрыВСтроку",0,0,"","// Подставляет параметры в строку. Максимально возможное число параметров - 9.
// Параметры в строке задаются как %<номер параметра>. Нумерация параметров начинается с единицы.
//
// Параметры:
//  СтрокаПодстановки  - Строка - шаблон строки с параметрами (вхождениями вида ""%ИмяПараметра"");
//  Параметр<n>        - Строка - подставляемый параметр.
//
// Возвращаемое значение:
//  Строка   - текстовая строка с подставленными параметрами.
//
// Пример:
//  ПодставитьПараметрыВСтроку(НСтр(""ru='%1 пошел в %2'""), ""Вася"", ""Зоопарк"") = ""Вася пошел в Зоопарк"".
//
// Примечание:
//  В случаях, когда число используемых параметров в строке совпадает с числом переданных для подстановки параметров,
//  рекомендуется использовать функцию платформы СтрШаблон.
// В УНФ СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку
Функция ПодставитьПараметрыВСтроку(Знач СтрокаПодстановки,
	Знач Параметр1, Знач Параметр2 = Неопределено, Знач Параметр3 = Неопределено,
	Знач Параметр4 = Неопределено, Знач Параметр5 = Неопределено, Знач Параметр6 = Неопределено,
	Знач Параметр7 = Неопределено, Знач Параметр8 = Неопределено, Знач Параметр9 = Неопределено) Экспорт
	
	ИспользоватьАльтернативныйАлгоритм = 
		СтрНайти(Параметр1, ""%"")
		Или СтрНайти(Параметр2, ""%"")
		Или СтрНайти(Параметр3, ""%"")
		Или СтрНайти(Параметр4, ""%"")
		Или СтрНайти(Параметр5, ""%"")
		Или СтрНайти(Параметр6, ""%"")
		Или СтрНайти(Параметр7, ""%"")
		Или СтрНайти(Параметр8, ""%"")
		Или СтрНайти(Параметр9, ""%"");
		
	Если ИспользоватьАльтернативныйАлгоритм Тогда
		СтрокаПодстановки = ПодставитьПараметрыВСтрокуАльтернативныйАлгоритм(СтрокаПодстановки, Параметр1,
			Параметр2, Параметр3, Параметр4, Параметр5, Параметр6, Параметр7, Параметр8, Параметр9);
	Иначе
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, ""%1"", Параметр1);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, ""%2"", Параметр2);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, ""%3"", Параметр3);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, ""%4"", Параметр4);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, ""%5"", Параметр5);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, ""%6"", Параметр6);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, ""%7"", Параметр7);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, ""%8"", Параметр8);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, ""%9"", Параметр9);
	КонецЕсли;
	
	Возврат СтрокаПодстановки;
КонецФункции
"}
},
{0,
{"СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку",0,0,"ППВС","СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(""%1"", Параметр);"}
},
{0,
{"Типовые",0,0,"","// Общий модуль: СтроковыеФункцииКлиентСервер

// Разбивает строку на несколько строк по разделителю. Разделитель может иметь любую длину.
//
// Параметры:
//  Строка                 - Строка - текст с разделителями;
//  Разделитель            - Строка - разделитель строк текста, минимум 1 символ;
//  ПропускатьПустыеСтроки - Булево - признак необходимости включения в результат пустых строк.
//    Если параметр не задан, то функция работает в режиме совместимости со своей предыдущей версией:
//     - для разделителя-пробела пустые строки не включаются в результат, для остальных разделителей пустые строки
//       включаются в результат.
//     - если параметр Строка не содержит значащих символов или не содержит ни одного символа (пустая строка), то в
//       случае разделителя-пробела результатом функции будет массив, содержащий одно значение """" (пустая строка), а
//       при других разделителях результатом функции будет пустой массив.
//
//
// Возвращаемое значение:
//  Массив - массив строк.
//
// Примеры:
//  РазложитьСтрокуВМассивПодстрок("",один,,два,"", "","") - возвратит массив из 5 элементов, три из которых  - пустые строки;
//  РазложитьСтрокуВМассивПодстрок("",один,,два,"", "","", Истина) - возвратит массив из двух элементов;
//  РазложитьСтрокуВМассивПодстрок("" один   два  "", "" "") - возвратит массив из двух элементов;
//  РазложитьСтрокуВМассивПодстрок("""") - возвратит пустой массив;
//  РазложитьСтрокуВМассивПодстрок("""",,Ложь) - возвратит массив с одним элементом """" (пустой строкой);
//  РазложитьСтрокуВМассивПодстрок("""", "" "") - возвратит массив с одним элементом """" (пустой строкой);
// СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок
Функция РазложитьСтрокуВМассивПодстрок(Знач Строка, Знач Разделитель = "","", Знач ПропускатьПустыеСтроки = Неопределено) Экспорт
	
	Результат = Новый Массив;
	
	// для обеспечения обратной совместимости
	Если ПропускатьПустыеСтроки = Неопределено Тогда
		ПропускатьПустыеСтроки = ?(Разделитель = "" "", Истина, Ложь);
		Если ПустаяСтрока(Строка) Тогда 
			Если Разделитель = "" "" Тогда
				Результат.Добавить("""");
			КонецЕсли;
			Возврат Результат;
		КонецЕсли;
	КонецЕсли;
	//
	
	Позиция = Найти(Строка, Разделитель);
	Пока Позиция > 0 Цикл
		Подстрока = Лев(Строка, Позиция - 1);
		Если Не ПропускатьПустыеСтроки Или Не ПустаяСтрока(Подстрока) Тогда
			Результат.Добавить(Подстрока);
		КонецЕсли;
		Строка = Сред(Строка, Позиция + СтрДлина(Разделитель));
		Позиция = Найти(Строка, Разделитель);
	КонецЦикла;
	
	Если Не ПропускатьПустыеСтроки Или Не ПустаяСтрока(Строка) Тогда
		Результат.Добавить(Строка);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Возвращает строку, полученную из массива элементов, разделенных символом разделителя
//
// Параметры:
//  Массив - Массив - массив элементов из которых необходимо получить строку
//  Разделитель - Строка - любой набор символов, который будет использован как разделитель между элементами в строке
//
// Возвращаемое значение:
//  Результат - Строка - строка, полученная из массива элементов, разделенных символом разделителя
// СтроковыеФункцииКлиентСервер.ПолучитьСтрокуИзМассиваПодстрок
Функция ПолучитьСтрокуИзМассиваПодстрок(Массив, Разделитель = "","") Экспорт
	
	// возвращаемое значение функции
	Результат = """";
	
	Для Каждого Элемент ИЗ Массив Цикл
		
		Подстрока = ?(ТипЗнч(Элемент) = Тип(""Строка""), Элемент, Строка(Элемент));
		
		РазделительПодстрок = ?(ПустаяСтрока(Результат), """", Разделитель);
		
		Результат = Результат + РазделительПодстрок + Подстрока;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции
"}
},
{0,
{"ЧислоПрописью (рубль)",0,0,"ЧПР[убль]","ЧислоПрописью(<?""Переменная"">,, ""Рубль, рублей, рубля, м, копейка, копейки, копеек, ж, 2"")"}
},
{0,
{"ЧислоПрописью (штука)",0,0,"ЧПШт[ук]","ЧислоПрописью(<?""Переменная"">,,""штука, штуки, штук, ж,,,,,0"")"}
},
{0,
{"Величина прописью",0,0,"","&НаКлиенте
Функция ПолучитьЦелоеЧислоПрописью(Число, ФормСтрока = ""ДП=Ложь; НД=Ложь"", ПарПредмета = ""месяц,месяца,месяцев,м,,,,,0"", Скобки = Истина)
	
	ЧислоПрописью 				= СокрЛП(ЧислоПрописью(Число, ФормСтрока, "",,,,,,,,0""));
	ЧислоПрописьюВеличина 		= ЧислоПрописью(Число, ФормСтрока, ПарПредмета);
	
	Если Скобки Тогда
		ЧислоПрописьюВеличина 	= СтрЗаменить(ЧислоПрописьюВеличина, ЧислоПрописью, ""("" + ЧислоПрописью + "")"");
	КонецЕсли;
	
	ЧислоПрописьюПолностью 		= Строка(Число) + "" "" + ЧислоПрописьюВеличина;
	
	Возврат ЧислоПрописьюПолностью;
	
КонецФункции // ПолучитьЦелоеЧислоПрописью()"}
},
{0,
{"СтрокаСЧислом Годов, лет и т.д. (ГодМесяцПрописью)",0,0,"","Функция ГодМесяцПрописью(пГод = """", пМесяц = """")
	
	лГодМесяцПрописью = """";
	
	лГодМесяцПрописью = ?(пГод = ""0"", """", "" "" + СтрокаСЧислом("";%1 год; ;%1 года;%1 лет;%1 года"", пГод, ВидЧисловогоЗначения.Количественное, ""L=ru"")) 
	+ ?(пМесяц = ""0"", """", "" "" + СтрокаСЧислом("";%1 месяц; ;%1 месяца;%1 месяцев;%1 месяца"", пМесяц, ВидЧисловогоЗначения.Количественное, ""L=ru""));
	
	Возврат лГодМесяцПрописью;
	
КонецФункции // ГодМесяцПрописью()

Функция ГодМесяцДеньПрописью(пГод = """", пМесяц = """", пДень = """")
	
	лГодМесяцДеньПрописью = """";
	
	ГодМесяцДеньПрописью = ?(пГод = """" ИЛИ пГод = ""0"", """", "" "" + СтрокаСЧислом("";%1 год; ;%1 года;%1 лет;%1 года"", пГод, ВидЧисловогоЗначения.Количественное, ""L=ru"")) 
	+ ?(пМесяц = """" ИЛИ пМесяц = ""0"", """", "" "" + СтрокаСЧислом("";%1 месяц; ;%1 месяца;%1 месяцев;%1 месяца"", пМесяц, ВидЧисловогоЗначения.Количественное, ""L=ru""))
	+ ?(пДень = """" ИЛИ пДень = ""0"", """", "" "" + СтрокаСЧислом("";%1 день; ;%1 дня;%1 дней;%1 дня"", пДень, ВидЧисловогоЗначения.Количественное, ""L=ru""));
	
	Возврат лГодМесяцДеньПрописью;
	
КонецФункции // ГодМесяцДеньПрописью()"}
},
{0,
{"СтрокаСЧислом Типовое",0,0,"","// Пример вывода строки, содержащей количество дней до нового года

Строка = СтрокаСЧислом("";остался %1 день;;осталось %1 дня;осталось %1 дней;осталось %1 дня"",
    ДнейДоНовогоГода,
    ВидЧисловогоЗначения.Количественное,
    ""L=ru"");
Строка = ""До Нового Года "" + Строка;

// Результаты вычисления:

// ""До Нового Года остался 1 день""

// ""До Нового Года осталось 2 дня""

// ""До Нового Года осталось 5 дней"""}
},
{0,
{"УчетПустойСтроки",0,0,"","//Функция УчетПустойСтроки
//-------------------------------------------------------------------------
//Параметры:
//		ЭлементУчета - Любой - Будет обработан переводом в строку
//		КоличествоСимволовЗамены - Число - Сколько символов отведено под эту запись
//		СимволЗамены - Строка - Какие символы отведены под эту запись
//Возвращаемое значение:
//		Строка - Вида: ""   "", ""_____"", ""#####"" и т.д.
//-------------------------------------------------------------------------
//автор: Кучеров Р 06.06.2018
&НаСервере
Функция УчетПустойСтроки(ЭлементУчета, КоличествоСимволовЗамены = 1, СимволЗамены = """")
	
	ЭлементУчетаСтрока = ?(ТипЗнч(ЭлементУчета) = Тип(""Строка""), ЭлементУчета, Строка(ЭлементУчета));
	
	Если ПустаяСтрока(ЭлементУчетаСтрока) Тогда
		Если НЕ ПустаяСтрока(СимволЗамены) ИЛИ СимволЗамены = "" "" Тогда
			РезультатЭлементУчетаСтрока = """";
			
			Для ии = 1 По КоличествоСимволовЗамены Цикл
				
				РезультатЭлементУчетаСтрока = РезультатЭлементУчетаСтрока + СимволЗамены;
				
			КонецЦикла;
		Иначе
			РезультатЭлементУчетаСтрока = """";
		КонецЕсли;
	Иначе 
		Возврат ЭлементУчетаСтрока;
	КонецЕсли; 
	
	Возврат РезультатЭлементУчетаСтрока;
	
КонецФункции // УчетПустойСтроки()"}
},
{0,
{"РазложитьСтрокуВМассивПодстрок (аналог СтрРазделить)",0,0,"","Функция РазложитьСтрокуВМассивПодстрок(Знач Строка, Знач Разделитель = "","",
	Знач ПропускатьПустыеСтроки = Неопределено)
	
	Результат = Новый Массив;
	
	// для обеспечения обратной совместимости
	Если ПропускатьПустыеСтроки = Неопределено Тогда
		ПропускатьПустыеСтроки = ?(Разделитель = "" "", Истина, Ложь);
		Если ПустаяСтрока(Строка) Тогда 
			Если Разделитель = "" "" Тогда
				Результат.Добавить("""");
			КонецЕсли;
			Возврат Результат;
		КонецЕсли;
	КонецЕсли;
	//
	
	Позиция = Найти(Строка, Разделитель);
	Пока Позиция > 0 Цикл
		Подстрока = Лев(Строка, Позиция - 1);
		Если Не ПропускатьПустыеСтроки Или Не ПустаяСтрока(Подстрока) Тогда
			Результат.Добавить(Подстрока);
		КонецЕсли;
		Строка = Сред(Строка, Позиция + СтрДлина(Разделитель));
		Позиция = Найти(Строка, Разделитель);
	КонецЦикла;
	
	Если Не ПропускатьПустыеСтроки Или Не ПустаяСтрока(Строка) Тогда
		Результат.Добавить(Строка);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции  "}
},
{0,
{"Элементы через разделитель",0,0,"","лРезделительЭлементов 	= "", "";
лСтрока 				= """";
Для каждого <?""Имя коллекции для обхода (слитно)"">Элем Из <?""Имя коллекции для обхода (слитно)""> Цикл
	лСтрока 	= лСтрока + СокрЛП(<?""Имя коллекции для обхода (слитно)"">Элем.Текст) + лРезделительЭлементов;
КонецЦикла;

лСтрока = Сред(лСтрока, 1, СтрДлина(лСтрока) - СтрДлина(лРезделительЭлементов)); // Убираем последний разделитель

	
"}
},
{0,
{"Элементы через разделитель: в массив через СтрРазделить с заменой внутри СтрЗаменить",0,0,"СтрРазСтрЗам","л<?""Строка (слитно)"">Массив 	= СтрРазделить(СтрЗаменить(<?""Строка (слитно)"">, "" "", """"), "","", Ложь);
Для каждого л<?""Строка (слитно)"">Элем Из л<?""Строка (слитно)"">Массив Цикл
	
	л<?""Строка (слитно)"">Элем
	
КонецЦикла; "}
},
{0,
{"ЕстьКириллица",0,0,"","&НаКлиенте
Функция ЕстьКириллица(ИсходнаяСтрока)
	
	ЕстьКириллица = Ложь; 
	ИсходнаяСтрока = СокрЛП(ИсходнаяСтрока); 
	Если СтрДлина(ИсходнаяСтрока) > 0 Тогда 
		Для Сч = 1 по СтрДлина(ИсходнаяСтрока) Цикл 
			Символ = НРег(Сред(ИсходнаяСтрока, Сч, 1)); 
			Если Найти(""абвгдеёжзийклмнопрстуфхцчшщъыьэюя"", Символ) Тогда 
				Возврат Истина; 
			КонецЕсли; 
		КонецЦикла; 
	КонецЕсли; 
	
	Возврат Ложь; 
	
КонецФункции"}
},
{1,
{"Веб",1,0,"",""},
{0,
{"Проверка значения на возможность выгрузки в веб (замена символов)",0,0,"","функция в(СЗСообщения,стр) //Проверка значения на возможность выгрузки в веб
	йй = СокрЛП(стр);
	йй = СтрЗаменить(йй,	""&"",	""&amp;"");
	//йй = СтрЗаменить(йй,	"""""""",	""&quot;"");
	йй = СтрЗаменить(йй,	""'"",	""&apos;"");
	йй = СтрЗаменить(йй,	""<"",	""&lt;"");
	йй = СтрЗаменить(йй,	"">"",	""&gt;"");
	йй = СтрЗаменить(йй,	""§"",	""&sect;"");
	йй = СтрЗаменить(йй,	""^"",	""&circ;"");
	йй = СтрЗаменить(йй,	""~"",	""˜&tilde;"");
	//йй = СтрЗаменить(йй,	"""",	"""");
	//йй = СтрЗаменить(йй,	"""",	"""");
	//йй = СтрЗаменить(йй,	"""",	"""");
	//йй = СтрЗаменить(йй,	"""",	"""");
	//йй = СтрЗаменить(йй,	"""",	"""");
	//Если Найти(йй,"">"")<>0 Тогда мСообщить(СЗСообщения,""Ошибка значения ""+СокрЛП(йй)); йй=стрЗаменить(йй,"">"",""""); КонецЕсли;
	//Если Найти(йй,""<"")<>0 Тогда мСообщить(СЗСообщения,""Ошибка значения ""+СокрЛП(йй)); йй=стрЗаменить(йй,""<"",""""); КонецЕсли;
	//Если Найти(йй,Символы.ПС)<>0 Тогда мСообщить(СЗСообщения,""Ошибка значения ""+СокрЛП(йй)); йй=стрЗаменить(йй,Символы.ПС,""""); КонецЕсли;
	//Если Найти(йй,Символы.ВК)<>0 Тогда мСообщить(СЗСообщения,""Ошибка значения ""+СокрЛП(йй)); йй=стрЗаменить(йй,Символы.ВК,""""); КонецЕсли;
	Возврат йй;
КонецФункции
"}
}
},
{1,
{"Для совместимости",1,0,"",""},
{0,
{"Строковые функции для совместимости с платформой 8.3.5 и ниже",0,0,"","////////////////////////////////////////////////////////////////////////////////
// Строковые функции для совместимости с платформой 8.3.5 и ниже
//
////////////////////////////////////////////////////////////////////////////////

Функция _СтрНачинаетсяС(Строка, СтрокаПоиска) Экспорт // СтрНачинаетсяС()
	Возврат Найти(Строка, СтрокаПоиска) = 1;
КонецФункции

Функция _СтрЗаканчиваетсяНа(Строка, СтрокаПоиска) Экспорт // СтрЗаканчиваетсяНа()
	Возврат Прав(Строка, СтрДлина(СтрокаПоиска)) = СтрокаПоиска;
КонецФункции

Функция _СтрРазделить(знач Строка, Разделитель, ВключатьПустые = Истина) Экспорт // СтрРазделить()
	Результат = Новый Массив;
	
	Если Строка = """" Тогда 
		Если ВключатьПустые Тогда
			Результат.Добавить(Строка);
		КонецЕсли;
		Возврат Результат;
	КонецЕсли;
	
	Позиция = Найти(Строка, Разделитель);
	Пока Позиция > 0 Цикл
		Подстрока = Лев(Строка, Позиция - 1);
		Если ВключатьПустые ИЛИ НЕ Подстрока = """" Тогда
			Результат.Добавить(Подстрока);
		КонецЕсли;
		Строка = Сред(Строка, Позиция + СтрДлина(Разделитель));
		Позиция = Найти(Строка, Разделитель);
	КонецЦикла;
	
	Если ВключатьПустые ИЛИ НЕ Строка = """" Тогда
		Результат.Добавить(Строка);
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

Функция _СтрСоединить(Строки, знач Разделитель = Неопределено) Экспорт // СтрСоединить()
	Результат = """";
	
	Если Разделитель = Неопределено Тогда
		Разделитель = """";
	КонецЕсли;
	
	Если Строки.Количество() Тогда
		Результат = Строки[0];
	КонецЕсли;
	
	Для сч = 1 По Строки.ВГраница() Цикл
		Результат = Результат + Разделитель + Строки[сч];
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

Функция _СтрНайти(Строка, ПодстрокаПоиска, НаправлениеПоиска = Неопределено, НачальнаяПозиция = Неопределено, НомерВхождения = 1) Экспорт // СтрНайти()
	// НаправлениеПоиска: СКонца,СНачала. По умолчанию: СНачала
	
	Если Строка = """" и ПодстрокаПоиска = """" Тогда
		// чтобы отрабатывало как в платформе
		Если НаправлениеПоиска = ""СКонца"" Тогда
			Если НомерВхождения = 1 Тогда
				Возврат 1;
			Иначе
				Возврат 0;
			КонецЕсли;
		Иначе
			Возврат мин(НомерВхождения, ?(НачальнаяПозиция=Неопределено, 1, НачальнаяПозиция));
		КонецЕсли;
	КонецЕсли;
	
	Если НачальнаяПозиция = Неопределено Тогда
		Если НаправлениеПоиска = ""СКонца"" Тогда
			лНачальнаяПозиция = СтрДлина(Строка);
		Иначе
			лНачальнаяПозиция = 1;
		КонецЕсли;
	Иначе
		лНачальнаяПозиция = НачальнаяПозиция;
	КонецЕсли;
	
	Если НаправлениеПоиска = ""СКонца"" Тогда
		лСтрока = """";
		Для сч = 1 По СтрДлина(Строка) Цикл
			лСтрока = Сред(Строка, сч, 1) + лСтрока;
		КонецЦикла;
		лПодстрокаПоиска = """";
		Для сч = 1 По СтрДлина(ПодстрокаПоиска) Цикл
			лПодстрокаПоиска = Сред(ПодстрокаПоиска, сч, 1) + лПодстрокаПоиска;
		КонецЦикла;
		лНачальнаяПозиция = макс(1, СтрДлина(Строка)-лНачальнаяПозиция-СтрДлина(ПодстрокаПоиска)+2);
	Иначе
		лСтрока = Строка;
		лПодстрокаПоиска = ПодстрокаПоиска;
		лНачальнаяПозиция = лНачальнаяПозиция;
	КонецЕсли;
	
	лНомерВхождения = 0;
	Результат = Найти(Сред(лСтрока, лНачальнаяПозиция), лПодстрокаПоиска);
	Пока Результат Цикл
		лНачальнаяПозиция = Результат + лНачальнаяПозиция + СтрДлина(ПодстрокаПоиска)-1;
		лНомерВхождения = лНомерВхождения + 1;
		Если лНомерВхождения = НомерВхождения Тогда
			Прервать;
		КонецЕсли;
		Результат = Найти(Сред(лСтрока, лНачальнаяПозиция), лПодстрокаПоиска);
	КонецЦикла;
	
	Если лНомерВхождения = НомерВхождения Тогда
		Результат = лНачальнаяПозиция - СтрДлина(ПодстрокаПоиска);
	Иначе
		Результат = 0;
	КонецЕсли;
	
	Если НаправлениеПоиска = ""СКонца"" И Результат<>0 Тогда
		Результат = СтрДлина(Строка) - Результат - СтрДлина(ПодстрокаПоиска) + 2;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция _СтрШаблон(Шаблон, Параметр1=Неопределено, Параметр2=Неопределено, Параметр3=Неопределено,Параметр4=Неопределено,Параметр5=Неопределено,Параметр6=Неопределено,Параметр7=Неопределено,Параметр8=Неопределено,Параметр9=Неопределено,Параметр10=Неопределено) Экспорт // СтрШаблон()
	Результат = Шаблон;
	
	Для сч = -10 По -1 Цикл
		Параметр = Вычислить(""Параметр"" + (-сч));
		Если Параметр = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		Если Найти(Результат, ""%(""+(-сч)+"")"") = 0 И Найти(Результат, ""%""+(-сч))=0 Тогда
			ВызватьИсключение ""Слишком много фактических параметров"";
		КонецЕсли;
		Результат = СтрЗаменить(Результат, ""%(""+ (-сч) + "")"", Параметр);
		Результат = СтрЗаменить(Результат, ""%""+ (-сч), Параметр);
	КонецЦикла;
	
	Возврат Результат;
КонецФункции"}
}
}
},
{7,
{"Под 1С",1,0,"",""},
{0,
{"Сформированить синоним переменной",0,0,"","// Формирует синоним переменной.
// Пример: на входе ""ИмяПеременнойАБВГ"", на выходе ""Имя переменной АБВГ""
//
// Параметры
// ИмяРеквизита - Строка. Имя переменной, имя колонки таблицы
//
// Возвращаемое значение:
// Строка - Представление переменной
//
Функция СформироватьСиноним(ИмяРеквизита)
	
	Перем Синоним, ъ, Символ, ПредСимвол, СледСимвол, Прописная, ПредПрописная, СледПрописная, ДлинаСтроки;
	
	Синоним = ВРег(Сред(ИмяРеквизита, 1, 1));
	ДлинаСтроки = СтрДлина(ИмяРеквизита);
	Для ъ=2 По ДлинаСтроки Цикл
		Символ = Сред(ИмяРеквизита, ъ, 1);
		ПредСимвол = Сред(ИмяРеквизита, ъ-1, 1);
		СледСимвол = Сред(ИмяРеквизита, ъ+1, 1);
		Прописная = Символ = ВРег(Символ);
		ПредПрописная = ПредСимвол = ВРег(ПредСимвол);
		СледПрописная = СледСимвол = ВРег(СледСимвол);
		
		// Варианты:
		Если НЕ ПредПрописная И Прописная Тогда
			Синоним = Синоним + "" "" + Символ;
		ИначеЕсли Прописная И НЕ СледПрописная Тогда
			Синоним = Синоним + "" "" + Символ;
		Иначе
			Синоним = Синоним + Символ;
		Конецесли;
	КонецЦикла;
	
	Возврат Синоним;
	
КонецФункции // СформироватьСиноним()"}
},
{0,
{"Сформировать переменную из синонима",0,0,"","// Преобразовывает имя переменной к более читабельному виду, аналогично внутренним алгоритмам 1С
// Например ""ОбменСБазой"" -> ""Обмен с базой""
Функция ПредставлениеПерменной(знач ИмяПеременной) Экспорт
	Перем МаленькиеБуквы, Буква, Ответ, сч, ПредыдущаяБуква, СледующаяБуква;
	ИмяПеременной = СокрЛП(ИмяПеременной);
	МаленькиеБуквы = ""абвгдеёжзийклмнопрстуфхцчшщъыьэюя_"";
	Буква = Лев(ИмяПеременной, 1);
	Ответ = """"+Буква;
	Для сч=2 По СтрДлина(ИмяПеременной) Цикл
		ПредыдущаяБуква = Буква;
		Буква = Сред(ИмяПеременной, сч, 1);
		Если (Найти(МаленькиеБуквы, Буква)=0) и (Найти(МаленькиеБуквы, ПредыдущаяБуква)>0) Тогда
			СледующаяБуква = Сред(ИмяПеременной, сч+1, 1);
			Если (СледующаяБуква<>"""") и (Найти(МаленькиеБуквы, СледующаяБуква)>0) Тогда
				Буква = НРег(Буква);
			КонецЕсли;
			Буква = "" ""+Буква;
		КонецЕсли;
		Ответ = Ответ + Буква;
	КонецЦикла;
	Возврат СтрЗаменить(Ответ, ""_"", "" "");
КонецФункции"}
},
{0,
{"Синонимайзер",0,0,"","//Значения параметров обозначают начальные значения переменных цикла. Делая их параметрами, мы, кроме сокращения количества строк в записи функции, добиваемся некоторого расширения ее возможностей. Например, присвоив параметру Ответ значение ""Синоним:"" мы получим результат, начинающийся со строки ""Синоним:"". Присвоив параметру Стэйт значение 7 * 2 * 2 * 2 * 2 * 2 (7 умножить на два в некоторой степени), мы ""защитим от преобразования"" соответствующее количество символов в имени. Присвоив параметру б некоторое значение, мы получим результат, начинающийся с этого значения, записанного в верхнем регистре.
Функция Синонимайзер(Имя, Ответ = """", Стэйт = 7, б = """") Экспорт
	
	Для ё = 1 По СтрДлина(Имя) Цикл
		
		а = Сред(Имя, ё, 1);
		Стэйт = (НРег(а) <> а) * 4 + Цел(Стэйт / 2);
		Ответ = Ответ + ?(Стэйт = 2, НРег(б), ?(ё = 2, ВРег(б), б)) + ?(Стэйт = 4 ИЛИ Стэйт = 5, "" "", """");
		б = а;
		
	КонецЦикла;
	
	Возврат Ответ + б;
	
КонецФункции"}
},
{0,
{"Cклонения по падежам",0,0,"","// Функция для склонения одного слова!!!
// z1 - само слово
// z2 - номер падежа
// z3 - пол
// z4 - 1-склонять как фамилию, 2-имя, 3-отчество
Функция ПадежС(z1,Знач z2=2,Знач z3=""*"",z4=0) Экспорт
	z5=Найти(z1,""-"");
	z6=?(z5=0,"""",""-""+ПадежС(Сред(z1,z5+1,СтрДлина(z1)-z5+1),z2,z3,z4));
	z1=НРег(?(z5=0,z1,Лев(z1,z5-1)));
	z7=Прав(z1,3);z8=Прав(z7,2);z9=Прав(z8,1);
	z5=СтрДлина(z1);
	za=Найти(""ая ия ел ок яц ий па да ца ша ба та га ка"",z8);
	zb=Найти(""аеёийоуэюяжнгхкчшщ"",Лев(z7,1));
	zc=Макс(z2,-z2);
	zd=?(za=4,5,Найти(""айяь"",z9));
	zd=?((zc=1)или(z9=""."")или((z4=2)и(Найти(""оиеу""+?(z3=""ч"","""",""бвгджзклмнпрстфхцчшщъ""),z9)>0))или((z4=1)и(Найти(""мия мяэ лия кия жая лея"",z7)>0)),9,?((zd=4)и(z3=""ч""),2,?(z4=1,?(Найти(""оеиую"",z9)+Найти(""их ых аа еа ёа иа оа уа ыа эа юа яа"",z8)>0,9,?(z3<>""ч"",?(za=1,7,?(z9=""а"",?(za>18,1,6),9)),?(((Найти(""ой ый"",z8)>0)и(z5>4)и(Прав(z1,4)<>""опой""))или((zb>10)и(za=16)),8,zd))),zd)));
	ze=Найти(""лец вей бей дец пец мец нец рец вец аец иец ыец бер"",z7);
	zf=?((zd=8)и(zc<>5),?((zb>15)или(Найти(""жий ний"",z7)>0),""е"",""о""),?(z1=""лев"",""ьв"",?((Найти(""аеёийоуэюя"",Сред(z1,z5-3 ,1))=0)и((zb>11)или(zb=0))и(ze<>45),"""",?(za=7,""л"",?(za=10,""к"",?(za=13,""йц"",?(ze=0,"""",?(ze<12,""ь""+?(ze=1,""ц"",""""),?(ze<37,""ц"",?(ze<49,""йц"",""р""))))))))));
	zf=?((zd=9)или((z4=3)и(z3=""ы"")),z1,Лев(z1,z5-?((zd>6)или(zf<>""""),2,?(zd>0,1,0)))+zf+СокрП(Сред(""а у а ""+Сред(""оыые"",Найти(""внч"",z9)+1,1)+""ме ""+?(Найти(""гжкхш"",Лев(z8,1))>0,""и"",""ы"")+"" е у ойе я ю я ем""+?(za=16,""и"",""е"")+"" и е ю ейе и и ь ьюи и и ю ейи ойойу ойойойойуюойойгомуго""+?((zf=""е"")или(za=16)или((zb>12)и(zb<16)),""и"",""ы"")+""мм"",10*zd+2*zc-3,2)));
	Возврат ?(""""=z1,"""",?(z4>0,ВРег(Лев(zf,1))+?((z2<0)и(z4>1),""."",Сред(zf,2)),zf)+z6);
КонецФункции
//_____________________________________________________________________________
// z1 - фамилия имя отчество например Железняков Юрий Юрьевич
// z2 - Падеж ( по  умолчанию = 2 - родительный)
// 2 - родительный  ( нет кого?    ) Железнякова Юрия Юрьевича     
// 3 - дательный    ( кому?        ) Железнякову Юрию Юрьевичу 
// 4 - винительный  ( вижу кого?   ) Железнякова Юрия Юрьевича  
// 5 - творительный ( кем?         ) Железняковым Юрием Юрьевичем    
// 6 - предложный   ( о ком?       ) Железнякове Юрии Юрьевиче 
// Если задать Z2 меньше 0, то на выходе получим от -1=Железняков Ю. Ю. до -6=Железнякове Ю. Ю.
// z3 - параметр Пол может не указываться, но при наличии фамилий с 
// инициалами точное определение пола невозможно, поэтому предлагается задавать пол этим
// параметром  1 - мужской 2 - женский  
// ДЛЯ СКЛОНЕНИЯ ПРОФЕССИЙ ИСПОЛЬЗУЙТЕ ФУНКЦИЮ ПАДЕЖП И БУДЕТ ВАМ СЧАСТЬЕ!
// ---------------------------------------------------------------------------------------
// Бибик Галушка Цой Николайчик Наталия Петровна Герценберг Кривошей Капица-Метелица
// Если Падеж(Фио ,1 ,3),       то на выходе получим Фамилия Имя Отчество и т.д.
// Если Падеж(Фио ,1 ,3,""1"" ),  то                   Фамилия 
// Если Падеж(Фио ,1 ,3,""2"" ),  то                   Имя 
// Если Падеж(Фио ,1 ,3,""3"" ),  то                   Отчество 
// Если Падеж(Фио, 1 ,3,""12"" ), то                   Фамилия Имя 
// Если Падеж(Фио, 1 ,3,""23"" ), то                   Имя Отчество 
// Если Падеж(Фио,-1 ,3,""231"" ),то                   И. О. Фамилия 
// Если Падеж(Фио,-1 ,3,""23"" ), то                   И. О.  
// 10-11-2003 3-20

Функция Падежик(z1,z2=2,z3=3,Знач z4=""123"",z5=1) Экспорт
	Возврат?(z5<4,Падежик(СокрЛП(СтрЗаменить(Сред(z1,Найти(z1+"" "","" "")+1),""."","". "")),z2,z3,СтрЗаменить(z4,z5,ПадежС(Лев(z1,Найти(z1+"" "","" "")-1),z2,Сред(""ча""+НРег(Прав(СокрП(z1),1)),z3,1),z5)+"" ""),z5+1),z4);
КонецФункции//Падежик

Функция Падеж(z1,z2=2,z3=3,Знач z4=""123"") Экспорт
	z1=СокрП(z1);
	z5=Прав(z1,4);
	z6=Найти(""оглы кызы"",z5);
	Возврат Падежик(?(z6>0,Лев(z1,СтрДлина(z1)-5),z1),z2,z3,z4)+?(z6>0,z5,"""");
КонецФункции//Падеж

Функция ПадежП(Знач z1,Знач z2,z3=0) Экспорт
	z1=СокрЛП(z1);z4=Найти(z1+"" "","" "")+1;z5=Лев(z1,z4-2);z6=Прав(z5,2);
	z7=?((Найти(""ая ий ый"",z6)>0)и(Найти(""ющий нный"",Сред(z1,z4-5,4))=0)и(z3=0),""1"",""*"");
	Возврат НРег(?((z6=""ая"")или(Прав(z6,1)=""а""),ПадежС(z5,z2,z7,1)+"" ""+ПадежС(Сред(z1,z4),z2),ПадежС(z5,z2,""ч"",1)+?((z6=""ий"")и(Найти(z1,"" "")=0),"""","" ""+?(z7=""1"",ПадежП(Сред(z1,z4),z2,Число(z7)),Сред(z1,z4)))));
	// Прим: ДолжнРук=ПадежП(Выборка.ДолжностьРуководителя,2);
КонецФункции//ПадежП

// Пример использования
ПодписантРодитПад=Падеж(Константа.Руководитель.Получить(ДатаДок),-2); 
// (c) Jurer Production End ( Finish )"}
},
{0,
{"Cклонения по падежам из УНФ чья-то",0,0,"","//Функция возвращает фамилию, имя и отчество в нужном падеже
//-------------------------------------------------------------------------
// ФИО - строка формата Фамилия Имя Отчество (через пробел), можно опускать Имя и/или Отчество
// Падеж - название падежа (хоть первая буква) или его № 1-6
// ТолькоИнициалы - если истина, то будут только первые буквы вида Фамилия И.О.
//-------------------------------------------------------------------------
//автор: (Софья Коган?)
Функция ПадежФИО(Знач ФИО,Падеж=1,ТолькоИнициалы=Ложь) Экспорт
	
	Если ТипЗнч(ФИО)<>Тип(""Строка"") Тогда
		Сообщить(""Неверная строка передана """"падежу ФИО!"""""");
		Возврат ФИО;
	КонецЕсли;
	
	// уберем множественные пробелы
	Пока Истина Цикл
		ФИО=СокрЛП(СтрЗаменить(ФИО,""  "","" ""));
		Если Найти(ФИО,""  "")=0 Тогда 
			Прервать 
		КонецЕсли;
	КонецЦикла;
	
	Если ТипЗнч(Падеж)=Тип(""Строка"") Тогда
		пад=СокрЛП(НРег(Лев(Падеж,1))); 
		Если Найти(""рдвтп"",пад)=0 Тогда
			Сообщить(""Неверный падеж передан """"падежу ФИО""""!""); 
			Возврат ФИО;
		КонецЕсли;
	ИначеЕсли ТипЗнч(Падеж)=Тип(""Число"") Тогда
		Если (Падеж<1) или (Падеж>6) Тогда
			Сообщить(""Неверный падеж передан """"падежу ФИО""""!""); 
			Возврат ФИО;
		КонецЕсли;			
		пад=Падеж-1;
	КонецЕсли;
	
	ФИО=СокрЛП(НРег(ФИО)); // так удобнее
	
	// свой анализатор состава
	Фамилия="""";
	Для й=1 По СтрДлина(ФИО) Цикл
		символс=Сред(ФИО,й,1);
		Если символс="" "" Тогда 
			Прервать
		КонецЕсли;
		Фамилия=Фамилия+символс;
	КонецЦикла;
	ы=й+1; // перешли пробел
	Имя="""";
	Для й=ы По СтрДлина(ФИО) Цикл
		символс=Сред(ФИО,й,1);
		Если символс="" "" Тогда 
			Прервать 
		КонецЕсли;
		Имя=Имя+символс;
	КонецЦикла;
	ы=й+1; // перешли второй пробел
	Отчество="""";
	Для й=ы По СтрДлина(ФИО) Цикл
		символс=Сред(ФИО,й,1);
		Если символс="" "" Тогда
			Прервать 
		КонецЕсли;
		Отчество=Отчество+символс;
	КонецЦикла;
	
	// вернем, если сам именительный
	Если (Лев(Падеж,1)=""И"") или (Падеж=1) Тогда
		Если ТолькоИнициалы Тогда
			Имя=Лев(Имя,1); Отчество=Лев(Отчество,1);
		КонецЕсли;
		Фамилия=ВРег(Лев(Фамилия,1))+Сред(Фамилия,2);
		Имя=ВРег(Лев(Имя,1))+Сред(Имя,2);
		Отчество=ВРег(Лев(Отчество,1))+Сред(Отчество,2);
		Возврат Фамилия + "" "" + Имя + "". "" + Отчество + ""."";
	КонецЕсли;
	
	// теперь имеем раздельно Фамилию, Имя и Отчество.	
	// начинается собственно блок анализа содержания и падежей
	
	// проанализируем пол М/Ж
	Если Прав(Отчество,1)=""а"" Тогда Пол=""Ж"" Иначе Пол=""М"" КонецЕсли;
	
	// создадим структуру таблицы, хранящей окончания слов
	ток=Новый ТаблицаЗначений;
	ТипСтроки=Новый ОписаниеТипов(""Строка"",Новый КвалификаторыСтроки(2));
	ТипЧисла=Новый ОписаниеТипов(""Число"",Новый КвалификаторыЧисла(1,0));
	ток.Колонки.Добавить(""СтарОк"",ТипСтроки); // старое окончание 2 символа
	// колонки, хранящие новые окончания слов
	ток.Колонки.Добавить(""р""); // родительный
	ток.Колонки.Добавить(""д""); // дательный
	ток.Колонки.Добавить(""в""); // винительный
	ток.Колонки.Добавить(""т""); // творительный
	ток.Колонки.Добавить(""п""); // предложный
	// для указания, сколько букв с конца слова отсечь,
	ток.Колонки.Добавить(""КолвоСрез"",ТипЧисла); // кол-во срезаемых букв
	
	Гласные=""аеэоуиыяюьъ""; // список гласных букв в виде строки
	
	// ======== обработаем фамилию ==========
	// заполним таблицу данными для фамилии
	
	Если пол=""М"" Тогда
		строток=ток.Добавить(); // иванов
		строток.СтарОк=""*s"";
		строток.р=""а""; строток.д=""у""; строток.в=""а""; строток.т=""ым""; строток.п=""е"";
		строток.КолвоСрез=0;
		
		строток=ток.Добавить(); // красинский
		строток.СтарОк=""*й""; 
		строток.р=""ого""; строток.д=""ому""; строток.в=""ого""; строток.т=""им""; строток.п=""ом"";
		строток.КолвоСрез=2;		
		
		строток=ток.Добавить(); // белый
		строток.СтарОк=""ый"";
		строток.р=""ого""; строток.д=""ому""; строток.в=""ого""; строток.т=""ым""; строток.п=""ом"";
		строток.КолвоСрез=2;
		
		строток=ток.Добавить(); // палей
		строток.СтарОк=""*й"";
		строток.р=""я""; строток.д=""ю""; строток.в=""я""; строток.т=""ем""; строток.п=""е"";
		строток.КолвоСрез=1;
		
		строток=ток.Добавить(); // рабинович
		строток.СтарОк=""*ч"";
		строток.р=""а""; строток.д=""у""; строток.в=""а""; строток.т=""ем""; строток.п=""е"";
		строток.КолвоСрез=0;
		
		строток=ток.Добавить(); // починок, зализняк
		строток.СтарОк=""*к"";
		строток.р=""ка""; строток.д=""ку""; строток.в=""ка""; строток.т=""ком""; строток.п=""ке"";
		строток.КолвоСрез=2;
		
		строток=ток.Добавить(); // шинкарь
		строток.СтарОк=""*ь"";
		строток.р=""я""; строток.д=""ю""; строток.в=""я""; строток.т=""ем""; строток.п=""е"";
		строток.КолвоСрез=1;
		
		строток=ток.Добавить(); // перельман, оганесян
		строток.СтарОк=""*н"";
		строток.р=""а""; строток.д=""у""; строток.в=""а""; строток.т=""ом""; строток.п=""е"";
		строток.КолвоСрез=0;
		
		строток=ток.Добавить(); // баранкин
		строток.СтарОк=""ин"";
		строток.р=""а""; строток.д=""у""; строток.в=""а""; строток.т=""ым""; строток.п=""е"";
		строток.КолвоСрез=0;
		
	ИначеЕсли Пол=""Ж"" Тогда		
		строток=ток.Добавить(); // склодовская
		строток.СтарОк=""ая"";
		строток.р=""ой""; строток.д=""ой""; строток.в=""ую""; строток.т=""ой""; строток.п=""ой"";
		строток.КолвоСрез=2;
		
		строток=ток.Добавить(); // иванова
		строток.СтарОк=""*а""; 
		строток.р=""ой""; строток.д=""ой""; строток.в=""у""; строток.т=""ой""; строток.п=""ой"";
		строток.КолвоСрез=1;
	КонецЕсли;
	
	// таблица заполнена. считаем 2 последних буквы и поищем их
	Если не ПустаяСтрока(Фамилия) Тогда
		пб=Прав(Фамилия,2); кол=""СтарОк""; // ищем по ней
		новФамилия=Фамилия; // если ничего не изменится, так и будет
		стро=ток.Найти(пб,кол);
		Если стро<>Неопределено Тогда // нашли строгое сразу
			Основа=Лев(Фамилия,СтрДлина(Фамилия)-стро.КолвоСрез);
			новФамилия=Основа+СокрЛП(стро[пад]);
		Иначе // строго не нашли, ищем только по последней
			пб=""*""+Прав(пб,1); 
			стро=ток.Найти(пб,кол);
			Если стро<>Неопределено Тогда // нашли по последней
				Основа=Лев(Фамилия,СтрДлина(Фамилия)-стро.КолвоСрез);
				новФамилия=Основа+СокрЛП(стро[пад]);
			Иначе // по последней не нашли, ищем по виду буквы
				пб=""*""+?(Найти(Гласные,Прав(пб,1))=0,""s"",""g"");
				стро=ток.Найти(пб,кол);
				Если стро<>Неопределено Тогда // нашли по виду
					Если НЕ Прав(Фамилия,1) = ""."" Тогда
						Основа=Лев(Фамилия,СтрДлина(Фамилия)-стро.КолвоСрез);
						новФамилия=Основа+СокрЛП(стро[пад]);
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	Иначе
		новФамилия="""";
	КонецЕсли;
	
	// ======== обработаем имя ==========
	// заполним таблицу данными для имени
	ток.Очистить();
	
	Если Пол=""М"" Тогда
		// обработаем исключения
		Если Имя=""лев"" Тогда Имя=""льв"" КонецЕсли;
		Если Имя=""павел"" Тогда Имя=""павл"" КонецЕсли;
		
		строток=ток.Добавить(); // сергей
		строток.старок=""*й"";
		строток.р=""я""; строток.д=""ю""; строток.в=""я""; строток.т=""ем""; строток.п=""е"";
		строток.колвосрез=1;
		
		строток=ток.Добавить(); // иван + лев + павел
		строток.старок=""*s"";
		строток.р=""а""; строток.д=""у""; строток.в=""а""; строток.т=""ом""; строток.п=""е"";
		строток.колвосрез=0;
		
		строток=ток.Добавить(); // никита
		строток.старок=""*а"";
		строток.р=""ы""; строток.д=""е""; строток.в=""у""; строток.т=""ой""; строток.п=""е"";
		строток.колвосрез=1;
		
		строток=ток.Добавить(); // лука
		строток.старок=""*а"";
		строток.р=""и""; строток.д=""е""; строток.в=""у""; строток.т=""ой""; строток.п=""е"";
		строток.колвосрез=1;
		
		строток=ток.Добавить(); // иеремия
		строток.старок=""ия"";
		строток.р=""и""; строток.д=""и""; строток.в=""ю""; строток.т=""ей""; строток.п=""и"";
		строток.колвосрез=1;
		
		строток=ток.Добавить(); // илья
		строток.старок=""*я"";
		строток.р=""и""; строток.д=""е""; строток.в=""ю""; строток.т=""ей""; строток.п=""е"";
		строток.колвосрез=1;
		
		строток=ток.Добавить(); // игорь
		строток.старок=""*ь"";
		строток.р=""я""; строток.д=""ю""; строток.в=""я""; строток.т=""ем""; строток.п=""е"";
		строток.колвосрез=1;
		
	ИначеЕсли Пол=""Ж"" Тогда
		
		строток=ток.Добавить(); // ирина
		строток.старок=""*а"";
		строток.р=""ы""; строток.д=""е""; строток.в=""у""; строток.т=""ой""; строток.п=""е"";
		строток.колвосрез=1;
		
		строток=ток.Добавить(); // эсфирь
		строток.старок=""*ь"";
		строток.р=""и""; строток.д=""и""; строток.в=""ь""; строток.т=""ью""; строток.п=""и"";
		строток.колвосрез=1;
		
		строток=ток.Добавить(); // мария
		строток.старок=""ия"";
		строток.р=""и""; строток.д=""и""; строток.в=""ю""; строток.т=""ей""; строток.п=""и"";
		строток.колвосрез=1;
		
		строток=ток.Добавить(); // софья
		строток.старок=""*я"";
		строток.р=""и""; строток.д=""е""; строток.в=""ю""; строток.т=""ей""; строток.п=""е"";
		строток.колвосрез=1;
	КонецЕсли;
	
	// таблица заполнена. считаем 2 последних буквы и поищем их
	Если не ПустаяСтрока(Имя) Тогда
		пб=Прав(Имя,2); кол=""СтарОк""; // ищем по ней
		новИмя=Имя; // если ничего не изменится, так и будет
		стро=ток.Найти(пб,кол);
		Если стро<>Неопределено Тогда // нашли строгое сразу
			Основа=Лев(Имя,СтрДлина(Имя)-стро.КолвоСрез);
			новИмя=Основа+СокрЛП(стро[пад]);
		Иначе // строго не нашли, ищем только по последней
			пб=""*""+Прав(пб,1); 
			стро=ток.Найти(пб,кол);
			Если стро<>Неопределено Тогда // нашли по последней
				Основа=Лев(Имя,СтрДлина(Имя)-стро.КолвоСрез);
				новИмя=Основа+СокрЛП(стро[пад]);
			Иначе // по последней не нашли, ищем по виду буквы
				пб=""*""+?(Найти(Гласные,Прав(пб,1))=0,""s"",""g"");
				стро=ток.Найти(пб,кол);
				Если стро<>Неопределено=1 Тогда // нашли по виду
					Основа=Лев(Имя,СтрДлина(Имя)-стро.КолвоСрез);
					новИмя=Основа+СокрЛП(стро[пад]);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	Иначе
		новИмя="""";
	КонецЕсли;
	
	// ======== обработаем отчество, тут проще ==========
	ток.Очистить();
	
	Если Пол=""М"" Тогда
		строток=ток.Добавить();
		строток.р=""а""; строток.д=""у""; строток.в=""а""; строток.т=""ем""; строток.п=""е"";
		строток.колвосрез=0;
	ИначеЕсли Пол=""Ж"" Тогда
		строток=ток.Добавить();
		строток.р=""ы""; строток.д=""е""; строток.в=""у""; строток.т=""ой""; строток.п=""е"";
		строток.колвосрез=1;
	КонецЕсли;
	Если не ПустаяСтрока(Отчество) Тогда
		Основа=Лев(Отчество,СтрДлина(Отчество)-ток[0].КолвоСрез);	
		новОтчество=Основа+СокрЛП(ток[0][пад]);
	Иначе
		новОтчество="""";
	КонецЕсли;	
	
	Если ТолькоИнициалы Тогда
		новИмя=Лев(новИмя,1)+"".""; 
		новОтчество=Лев(новОтчество,1)+""."";
	КонецЕсли;
	
	// установим первые буквы верхним регистром
	новФамилия=ВРег(Лев(новФамилия,1))+Сред(новФамилия,2);
	новИмя=ВРег(Лев(новИмя,1))+Сред(новИмя,2);
	новОтчество=ВРег(Лев(новОтчество,1))+Сред(новОтчество,2);
	
	// и теперь всё вместе	
	новФИО=новФамилия+"" ""+новИмя+"" ""+новОтчество;
	Возврат новФИО;
КонецФункции
"}
},
{0,
{"ПросклонятьФразуПоСловам",0,0,"","Функция ПросклонятьФразуПоСловам(Знач ИсходнаяСтрока, Падеж) Экспорт

    Результат = """";

    ИсходнаяСтрока = СокрЛП(ИсходнаяСтрока);
    Если СтрДлина(ИсходнаяСтрока) = 0 Тогда
        Возврат Результат;
    КонецЕсли;

    Поз = Найти(ИсходнаяСтрока, "" "");
    Пока Поз > 0 Цикл

        СловоВПадеже = """";

        Слово = Лев(ИсходнаяСтрока, Поз-1);
        УниверсальныеМеханизмы.Просклонять(глЗначениеПеременной(""глКомпонентаСклоненияФИО""), Слово, Падеж, , СловоВПадеже);

        Результат = СокрЛП(Результат + "" "" + НРег(СловоВПадеже));
        ИсходнаяСтрока = СокрЛП(Сред(ИсходнаяСтрока, Поз));

        Если ПустаяСтрока(ИсходнаяСтрока) Тогда
            Прервать;// Это перестраховка. Цикл и так должен прерваться
 
        КонецЕсли;

        Поз = Найти(ИсходнаяСтрока, "" "");
    КонецЦикла;

    Если НЕ ПустаяСтрока(ИсходнаяСтрока) Тогда// добавляем заключительное слово
 
        СловоВПадеже = """";
        УниверсальныеМеханизмы.Просклонять(глЗначениеПеременной(""глКомпонентаСклоненияФИО""), ИсходнаяСтрока, Падеж, , СловоВПадеже);
        Результат = СокрЛП(Результат + "" "" + НРег(СловоВПадеже));

    КонецЕсли;
    
    Возврат Результат;

КонецФункции// ПросклонятьФразуПоСловам()"}
},
{0,
{"Просклонять через ФИО и ФизическиеЛицаЗарплатаКадры.Просклонять",0,0,"","&НаСервереБезКонтекста
Функция ДолжностьПросклонятьПредставление(Должность)

	ДолжностьМассив = СтрРазделить(Должность, "" "", Ложь);
	
	ДолжностьРезультат = """";
	
	Для каждого ЭлМасс Из ДолжностьМассив Цикл
		Результат = """";
		ФизическиеЛицаЗарплатаКадры.Просклонять(ЭлМасс, 2, Результат);
		
		ДолжностьРезультат = ДолжностьРезультат + Результат + "" "";
		
	КонецЦикла; 
	
	Возврат НРег(СокрЛП(ДолжностьРезультат));

КонецФункции // ДолжностьПросклонятьПредставление()"}
}
},
{1,
{"Формат",1,0,"",""},
{0,
{"Как убрать пробелы из числа 1С",0,0,"Формат","<?""Введите переменную для приминения формата"">Строка = Формат(<?""Введите переменную для приминения формата"">, ""ЧГ="");"}
}
},
{3,
{"Регламентные и фоновые задания",1,0,"",""},
{2,
{"Фоновые задания",1,0,"",""},
{0,
{"СейчасВыполняетсяЗадание",0,0,"","Функция СейчасВыполняетсяЗадание(НазваниеЗадания) Экспорт
	
	мФоновыеЗадания = ФоновыеЗадания.ПолучитьФоновыеЗадания(Новый структура(""Наименование"", НазваниеЗадания));
	
	Для каждого ТекЭлемент из мФоновыеЗадания Цикл
		
		Если ТекЭлемент.Конец = Неопределено тогда
			Возврат Истина		
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции"}
},
{0,
{"ПолучитьПоследнееВыполнениеЗадания",0,0,"","Функция ПолучитьПоследнееВыполнениеЗадания(НазваниеЗадания) Экспорт
	
	Результат = Неопределено;
	
	мФоновыеЗадания = ФоновыеЗадания.ПолучитьФоновыеЗадания(Новый структура(""Наименование"", НазваниеЗадания));
	
	Для каждого ТекЭлемент из мФоновыеЗадания Цикл
		
		Если ТекЭлемент.Конец <> Неопределено тогда
			Результат =  ТекЭлемент.Конец;		
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции"}
}
},
{0,
{"Фоновое задание",0,0,"","// В общем модуле
Перем V<?""Версия платформы (например \""82\"", \""83\"", без кавычек)"">Com Экспорт;

Процедура ПередНачаломРаботыСистемы(Отказ)
	Если ИмяПользователя() = ""<?""Регламентный пользователь"">"" тогда
		ПодключитьОбработчикОжидания(""ОбработчикОжидания"",5);
	КонецЕсли;
КонецПроцедуры

Процедура ОбработчикОжидания() Экспорт
	ВыполнитьОбработкуЗаданий();
	Тест = ИмяПользователя() + "" ОбработчикОжидания.ВыполнитьОбработкуЗаданий "" + Строка(ТекущаяДата());
	Сообщить(Тест);
КонецПроцедуры

Процедура ПриНачалеРаботыСистемы()
	Сообщение = Новый СообщениеПользователю;
	Сообщение.Текст = ИмяПользователя() + "" ПриНачалеРаботыСистемы "" + Строка(ТекущаяДата());
	Сообщение.Сообщить();
	
	Если ИмяПользователя() <> ""<?""Регламентный пользователь"">"" Тогда // Иначе начнуться бесконечные рекурсивные открывания 1С
		V<?""Версия платформы (например \""82\"", \""83\"", без кавычек)"">Com = Новый COMОбъект(""V83.Application"");
		Попытка
			Открытие = V<?""Версия платформы (например \""82\"", \""83\"", без кавычек)"">Com.Connect(СтрокаСоединенияИнформационнойБазы()+ ""Usr=""""<?""Регламентный пользователь"">"""";Pwd="""""""";"");
		Исключение
			ТекстОшибки = ИнформацияОбОшибке();
			Сообщение = Новый СообщениеПользователю;
			Сообщение.Текст = ""При попытке открытия дополнительного приложения возникла ошибка: "" + ТекстОшибки.Описание;
			Сообщение.Сообщить();
			//Отказ = Истина;
			//Возврат;
		КонецПопытки;
	ИначеЕсли ИмяПользователя() = ""<?""Регламентный пользователь"">"" Тогда
		ОбщийМодуль1.НачатьРегЗадание();
	КонецЕсли;
	
КонецПроцедуры

// В общем модуле
Процедура НачатьРегЗаданиеНаСервере() Экспорт
	Фоновое = ФоновыеЗадания.Выполнить(""ОбщийМодуль.РегламентноеЗадание1"");
	Тест = ИмяПользователя() + "" ОбщийМодуль.НачатьРегЗаданиеНаСервере "" + Строка(ТекущаяДата()) + "" Начало фонового "" + Строка(Фоновое.Начало);
	Сообщить(Тест);
КонецПроцедуры"}
},
{0,
{"Отключение регламентных заданий в копии базы (через константу ИмяРабочейБазы)",0,0,"","////////////////////////////////////////////////////////////////////////////////
// Отключение регламентных заданий в копии базы


//Данный код позволит вам автоматически отключать регламентные задачи в копиях баз данных.
//У нас есть регламентные задачи которые надо выполнять только на рабочей базе (забирает данные с другой базы). При создание копии базы данные «уходили» в нерабочую базу. Что бы это искоренить был придуман следующий алгоритм дейсвий:
//В константе «ИмяРабочейБазы» прописывается имя рабочей базы (Например: ”UT82_Live”)
//Если создается копия базы то она называется по другому (Например: ”UT82_Test”)
//Если имя базы не совпадает с константой «ИмяРабочейБазы», то идет отключение регламенты задач.
//Для этого была создана процедура «ПроверкаНаКопию()». Процедура находиться в общем привилигированнм модуле.
//Вызваться процедура при инициализации сеанса пользователя («Модуль сеанса» - Процедура «УстановкаПараметровСеанса()»).
//Сама процедура:

// Проверяет не являеться ли текущая база копией
// Определяеться по константе ИмяРабочейБазы - которая не должна отличаться от текущей базы
// Если база копия то отрубаем регламентное задание
// Истина - это не копия
// Ложь - это копия базы
Функция ПроверкаНаКопию()  Экспорт
    // ---- Проверка на копию ----
    ИмяРабочейБазы = СокрЛП(НРег(Константы.ИмяРабочейБазы.Получить()));
    СтрокаСоединения = НРег(СтрокаСоединенияИнформационнойБазы());

    ИскомаяБаза = """""""" + ИмяРабочейБазы + """""""";
    БазаНайдена = Найти(СтрокаСоединения,ИскомаяБаза) > 0;

    Если БазаНайдена и Не ПустаяСтрока(ИмяРабочейБазы) тогда
        Возврат Истина;
    Иначе
        #Если НаКлиенте тогда
        Сообщить(""Текущая базе не являеться рабочей! (см. константу """"ИмяРабочейБазы"""") "" + Константы.ИмяРабочейБазы.Получить());
        #КонецЕсли
    КонецЕсли;

    // ---- Инцилизиурем константы ----

    ИмяСервера = ""server1C"";        // адрес 1С сервер
    АдминКластера = """";
    ПарольАдминаКластера = """";
    Админ1С = ""COMConnect"";     // пользователь с полными правами
    ПарольАдмина1С = """";        // пароль админа 1С

    // ---- Отписываемся от регламентых заданий ----
    Соединение = Новый COMОбъект(""V82.COMConnector"");               // Соединились с 1С
    Попытка
        СоединениеАгент = Соединение.ConnectAgent(ИмяСервера);      // Соединились с 1С Агентом
        Кластеры = СоединениеАгент.GetClusters();                   // Получитли массив кластеров (COMSafeArray)
    Исключение
        #Если НаКлиенте тогда
        Сообщить(""Ошибка соединения с COM сервером: "" + ОписаниеОшибки());
        #КонецЕсли
        Возврат Ложь;
    КонецПопытки;

    КоличествоКластеров = Кластеры.GetLength(0);
    Если КоличествоКластеров < 1 тогда
        #Если НаКлиенте тогда
        Сообщить(""Не найден кластер на сервере "" + ИмяСервера);
        #КонецЕсли
        Возврат Ложь;
    КонецЕсли;

    РабочийКластер = Кластеры.GetValue(0);
    Попытка
        // Авторизируемся на кластере (Кластер,Имя,Пароль)
        СоединениеАгент.Authenticate(РабочийКластер, АдминКластера, ПарольАдминаКластера);
    Исключение
        #Если НаКлиенте тогда
        Сообщить(""Ошибка авторизации: "" + ОписаниеОшибки());
        #КонецЕсли
        Возврат Ложь;
    КонецПопытки;

    // Подключаемся к рабочему процессу
    РабочийПроцесс = СоединениеАгент.GetWorkingProcesses(РабочийКластер).GetValue(0);
    Порт = СтрЗаменить(Строка(РабочийПроцесс.MainPort),Символы.НПП,"""");  // убиваем непереносимые пробелы
    СтрокаПодлючения = РабочийПроцесс.HostName + "":"" + Порт;
    СоединениеСРабочимПроцессом = Соединение.ConnectWorkingProcess(СтрокаПодлючения);
    СоединениеСРабочимПроцессом.AddAuthentication(Админ1С,ПарольАдмина1С);

    // Ищем текущую базу данных
    МассивБаз = СоединениеСРабочимПроцессом.GetInfoBases();
    БазаНайдена = Ложь;
    Для каждого РабочаяБаза из МассивБаз цикл
        ИскомаяБаза = НРег("""""""" + РабочаяБаза.Name + """""""");
        БазаНайдена = Найти(СтрокаСоединения,ИскомаяБаза) > 0;
        Если БазаНайдена тогда
            Прервать;
        КонецЕсли;
    КонецЦикла;

    Если Не БазаНайдена тогда
        #Если НаКлиенте тогда
        Сообщить(""База ("" + СтрокаСоединения + "") не найдена на сервере "" + ИмяСервера);
        #КонецЕсли
        Возврат Ложь;
    КонецЕсли;

    Если НЕ РабочаяБаза.ScheduledJobsDenied тогда
        #Если НаКлиенте тогда
        Сообщить(""Отключаем регламентное задание"");
        #КонецЕсли
        РабочаяБаза.ScheduledJobsDenied = Истина;   // Блокируем выполнения регламентных заданий
        СоединениеСРабочимПроцессом.UpdateInfoBase(РабочаяБаза);
        ВызватьИсключение ""Выключенно регламентное задание. Перезапуститесь."" ; // Что бы прервать сеанс регламентного
    КонецЕсли;

    Возврат Ложь;
КонецФункции

И не забываем вставить вызов этой процедуры из модуля сеанса...

Процедура УстановкаПараметровСеанса()
    ПолныеПрава.ПроверкаНаКопию();
    ...
КонецПроцедуры"}
}
},
{2,
{"Форма",1,0,"",""},
{0,
{"Объект формы",0,0,"ОбъектФормы","<?""Имя документа"">Форма 		= ПолучитьФорму(""Документ.<?""Имя документа"">.ФормаОбъекта"");
<?""Имя документа"">ДанныеФормы 	= Форма.Объект; // Получаем объект формы в переменную
//Форма.ПриОткрытии(Неопределено); // Выполнение процедур формы"}
},
{0,
{"Открыть форму",0,0,"ПоказатьДок[умент]","<?""Имя документа"">.ПолучитьФорму().Открыть();"}
}
},
{12,
{"Командная строка",1,0,"",""},
{0,
{"Запуск обработки",0,0,"","// Запуск обработки из командной строки Windows (для запуска через службы Windows)

""C:\Program Files\1cv8\bin\1cv8.exe"" ENTERPRISE /F ""Путь_к_ИБ_D:\Конфигурации\Типовые\УпрТорг"" /N ""ИмяПользователя"" /P ""Пароль"" /Execute ""Путь_к_обработке.epf""

""C:\Program Files\1cv8\bin\1cv8.exe"" ENTERPRISE /S bases\ut_sql /N ""ИмяПользователя"" /P ""Пароль"" /Execute ""Путь_к_обработке.epf""
 
""C:\Program Files\1cv8\bin\1cv8.exe"" ENTERPRISE /IBName ""запуск информационной базы по имени базы в списке информационнх баз"" /N ""ИмяПользователя"" /P ""Пароль"" /Execute ""Путь_к_обработке.epf""


// После выполнения обработки 1С, если её надо закрыть:  
// ЗавершитьРаботуСистемы()
"}
},
{0,
{"Запуск 1С с параметрами",0,0,"","/N ""ИмяПользователя"" /P ""Пароль"""}
},
{0,
{"Запуск кода в конфигурации из командной строки",0,0,"","Запуск кода в конфигурации из командной строки
Иногда возникает необходимость запуска кода в базе 1С из командной строки. Например, надо выполнять те или иные процедуры по расписанию, но при этом нет желания каждый раз менять конфигурацию, а хочется прописать всё в батнике и запускать через шедулер (at).
Вижу следующие варианты:
1. изменить один раз конфигурацию, чтобы потом можно было передавать через параметр исполняемый код.
2. прописать выполняемый код во внешней обработке и запускать 1С с параметром /execute
3. написать на vba процедуру выполнения заданных операций через COM.

1. Изменить один раз конфигурацию, чтобы потом можно было передавать через параметр исполняемый код.
В таком варианте необходимо прописать следующий код в модуле приложения процедуре ПриНачалеРаботыСистемы():
Код 1C v 8.х
 Ключ = ""Выполнить=""; 
ДлКлюча = СтрДлина(Ключ);
 Если Лев(ПараметрЗапуска, ДлКлюча) = Ключ Тогда
  Попытка ДлПараметра = СтрДлина(ПараметрЗапуска);
   СтрокаКода = Прав(ПараметрЗапуска, ДлПараметра-ДлКлюча);
   Выполнить(СтрокаКода); 
 Исключение СтрСообщения=""Не удалось выполнить код:""+Символы.ПС+СтрокаКода;
   Предупреждение(СтрСообщения,3); 
   ЗаписьЖурналаРегистрации(""Запуск кода из командной строки."", УровеньЖурналаРегистрации.Ошибка, , , СтрСообщения);
  КонецПопытки;
КонецЕсли;   

После этого для выполнения кода из командной строки достаточно будет запустить 1С с параметром /cВыполнить=[ИсполняемыйКод]. Например:
Код DOS Batch File
 1cv8.exe enterprise /f""C:\Базы\InfoBase"" /nПользователь /pПароль /c Выполнить=Сообщить(""Тест!"");   


2. Прописать выполняемый код во внешней обработке и запускать 1С с параметром /execute
1С имеет параметр запуска ""/Execute"", с помощью которого можно запустить внешнюю обработку после старта системы. Чтобы воспользоваться этой возможностью, необходимо создать внешнюю обработку с исполняемым кодом в модуле формы:
Код 1C v 8.х
 Процедура ПриОткрытии()
 // тут распологается исполняемы код 
Сообщить(""!"");
 // закрываем обработку после выполнения кода 
Закрыть(); 
КонецПроцедуры   

После этого можно запускать данную обработку из командной строки например так:
Код DOS Batch File
 1cv8.exe enterprise /f""C:\Базы\InfoBase"" /nПользователь /pПароль /executec:\Обработки\ВнешняяОбработка.epf   


3. Написать на vba процедуру выполнения заданных операций через COM.
Можно все действия прописать в файле VBS и уже его запускать. Пример содержимого файла VBS:
Код VBS
 Set v81 = CreateObject(""V81.Application"") v81.Connect (""File=""""C:\Базы\InfoBase"""";Usr=""""пользователь"""";Pwd=пароль"") v81.WriteLogEvent(""Был выполнен запуск из VBA"")   "}
},
{0,
{"Как из скрипта VBS запустить 1C, чтобы окно программы не видно было",0,0,"","Как из скрипта VBS запустить 1C, чтобы окно программы не видно было?
Код 1C v 8.х
 WshShell = Новый COMОбъект(""WScript.Shell"");
WshShell.Run(СтрокаЗапуска, 0, Истина)   


Код VBS
 Set WshShell=CreateObject(""WScript.Shell"")
WshShell.Run """"""C:\Program Files\1cv81\bin\1cv8.exe"""" ENTERPRISE /Sserver\base"",0,0    


Код VBS
 On Error Resume Next 
Set objClass = GetObject(""winmgmts:{impersonationLevel=impersonate}!\\.\root\CIMV2:Win32_Process"")
'WScript.Echo ""Запускаем""
Res = objClass.Create(""C:\Program Files\1CV8PDA\1Cv8pSRV.exe """"Параметры"""""", Null, Null, PID)
If Res <> 0 Then
  WScript.Echo ""Код ошибки: "" & Res
  WScript.Quit
End If   "}
},
{0,
{"Запустить скрипт CMD",0,0,"","ObjShell 			= Новый COMОбъект(""WScript.Shell"") ;
ПутьКФайлу 			= ПолучитьИмяВременногоФайла(""txt"");
ПутьКФайлуВКавычках = """""""" + ПутьКФайлу + """""""";
Script 				= ""/c typeperf """"\Процессор(_Total)\% загруженности процессора"""" -sc 1 >> "" + ПутьКФайлуВКавычках + "" & typeperf """"\Память\% использования выделенной памяти"""" -sc 1 >> "" + ПутьКФайлуВКавычках + "" & typeperf """"\Физический диск(_Total)\% активности диска"""" -sc 1 >> "" + ПутьКФайлуВКавычках + "" & exit 1"";
ObjScriptExec 		= ObjShell.Run(""cmd.exe "" + Script, 0, True); //Exec открывает окно консоли, только Run с доп параметрами его не открывает, но тогда результат только через файл

ТекстовыйФайл.Прочитать(ПутьКФайлу, КодировкаТекста.OEM);
лРезультатПроизводительностьСтроки 	= ТекстовыйФайл.ПолучитьТекст();

//Удалим файл
Файл 		= Новый Файл(ПутьКФайлу);
Если Файл.Существует() Тогда
	УдалитьФайлы(ПутьКФайлу);
КонецЕсли;"}
},
{0,
{"Запустить скрипт PowerShell",0,0,"","ObjShell 			= Новый COMОбъект(""WScript.Shell"") ;
ПутьКФайлу 			= ПолучитьИмяВременногоФайла(""txt"");
Script 				= ПолучитьСкриптPowerShell(ПутьКФайлу);
ObjScriptRun 		= ObjShell.Run(""Powershell.exe -windowstyle hidden -Executionpolicy Bypass -nologo -noninteractive -comand "" + Script, 0, True);
//ObjScriptExec 	= ObjShell.Exec(""powershell.exe -windowstyle hidden -Executionpolicy Bypass -nologo -noninteractive -comand "" + Script); //Exec открывает окно консоли, только Run с доп параметрами его не открывает, но тогда результат только через файл
//StrPingResults 	= НРег(ObjScriptExec.StdOut.ReadAll());

ТекстовыйФайл.Прочитать(ПутьКФайлу);
лРезультатПроцессы 	= ТекстовыйФайл.ПолучитьТекст();

//Удалим файл
Файл 		= Новый Файл(ПутьКФайлу);
Если Файл.Существует() Тогда
	УдалитьФайлы(ПутьКФайлу);
КонецЕсли;

&НаКлиенте
Функция ПолучитьСкриптPowerShell(ПутьКФайлу)

	Script = ""
	|$File = '"" + ПутьКФайлу + ""'
	|$DateTime = (Get-Date -Format """"dd.MM.yyyy HH:mm:ss"""")
	|$DateTime >> $File
	|exit 1"";

	Возврат Script;
	
КонецФункции // ПолучитьСкриптPowerShell()
"}
},
{0,
{"Пример скрипта PowerShell",0,0,"","&НаКлиенте
Функция ПолучитьСкриптPowerShell(ПутьКФайлу, пЧислоВыводимыхПроцессов = 5)

	Script = ""
	|$File = '"" + ПутьКФайлу + ""'
	|$DateTime = (Get-Date -Format """"dd.MM.yyyy HH:mm:ss"""")
	|#$DateTime >> $CpuLogFile
	|$usedDiskSpaceDrives = ''
	|$driveLetters = Get-WmiObject Win32_Volume | select DriveLetter
	|foreach ($driveLetter in $driveLetters)
	|{
	|$drive = Get-WmiObject Win32_Volume | where {$_.DriveLetter -eq $driveLetter.DriveLetter}
	|
	|if (-Not $drive.Capacity -eq 0)
	|{
	|$driveCapacity = $drive.Capacity
	|$usedDiskSpace = $driveCapacity - $drive.FreeSpace
	|$usedDiskSpacePct = [math]::Round(($usedDiskSpace / $drive.Capacity) * 100,1)
	|$usedDiskSpaceValues = '^driveCapacity=' + $driveCapacity +'^usedDiskSpace=' + $usedDiskSpace + '^usedDiskSpacePct=' + $usedDiskSpacePct
	|#$usedDiskSpacePct = """"{0:N2}"""" -f $usedDiskSpacePct
	|
	|
	|$usedDiskSpaceDrives = $usedDiskSpaceDrives + '^driveCaption=' + $drive.Caption + '=' + $usedDiskSpaceValues + '#'
	|}
	|}
	
	|# Lets throw them into an object for outputting
	|$objHostInfo = New-Object System.Object
	|$objHostInfo | Add-Member -MemberType NoteProperty -Name Name -Value $computer
	|$objHostInfo | Add-Member -MemberType NoteProperty -Name CPULoadPercent -Value $ComputerCpu
	|$objHostInfo | Add-Member -MemberType NoteProperty -Name CpuLoadAverage -Value $CpuLoadAverage
	|$objHostInfo | Add-Member -MemberType NoteProperty -Name MemoryUsedPercent -Value $PercentMemoryUsed
	|$objHostInfo | Add-Member -MemberType NoteProperty -Name usedDiskSpaceDrives -Value $usedDiskSpaceDrives
	
	|$objHostInfoStr = 'ComputerCpu=' + $ComputerCpu + ';CpuLoadAverage=' + $CpuLoadAverage + ';PercentMemoryUsed=' + $PercentMemoryUsed + ';usedDiskSpaceDrives={' + $usedDiskSpaceDrives + '}'
	|$objHostInfoStr >> $CpuLogFile
	|#$objHostInfoStr
	|# Lets dump our info into an array
	|#$objHostInfo >> $CpuLogFile
	
	|#'CPU LoadPercentage Average|' + $CpuLoad >> $CpuLogFile
	|$Process = Get-Process | Sort-Object CPU -desc | Select-Object -first "" + пЧислоВыводимыхПроцессов + ""
	|$Process >> $CpuLogFile
	|#$Process
	|exit 1"";

	Возврат Script;
	
КонецФункции // ПолучитьСкриптPowerShell_Процессы()
"}
},
{0,
{"CMD RAR (архивы установщиком SFX по 50 мб) (можно перетащить файл на файл *.cmd)",0,0,"","@: SFX установки с частями по 50 мб

@: Установка русской кодировки
chcp 1251

For %%i In (%*) Do (
	set FileName = %%~ni_p50m
	""C:\Program Files\WinRAR\WinRAR.exe"" a %%~ni_p50m %%i -v50m -sfx
)"}
},
{0,
{"RAR Архив Справка",0,0,"","Синтаксис командной строки

WinRAR допускает управление из командной строки. Общий синтаксис командной строки таков:

Bash
WinRAR <команда> -<ключ1> -<ключN> <архив> <файлы…> <@файл-список…> <путь для извлечения\>


команда	Комбинация символов, определяющая действие, которое будет выполнять WinRAR. См. ""Список команд WinRAR"".
ключ	Ключи используются для определения специфических действий, степени сжатия, типа архива и пр. См. ""список ключей WinRAR"".
архив	Имя обрабатываемого архива.
файлы	Имена обрабатываемых файлов.
файл-список	Файлы-списки - это обычные текстовые файлы, содержащие имена файлов для обработки. Каждое имя файла должно быть указано на отдельной строке и начинаться с первой позиции строки. В файл-список допускается помещать комментарии, признак начала комментария - символы //. Например, для архивирования файлов *.txt из папки c:\work\doc, файлов *.bmp из папки c:\work\image и всех файлов из папки c:\work\misc можно создать backup.lst, содержащий следующие строки:
.	c:\work\doc\*.txt //резервная копия текстов
.	c:\work\image\*.bmp //резервная копия рисунков
.	c:\work\misc
.	После этого для архивирования достаточно будет выполнить команду:
.	
Bash
winrar a backup @backup.lst
.
путь для извлечения	Используется только с командами e и x и указывает папку, в которую нужно извлекать файлы. Если эта папка не существует, то она будет создана.

Примечания

а) Если не указаны ни файлы, ни файл-список, то подразумевается шаблон *.*, т.е. WinRAR обработает все файлы.

б) Если при создании архива не указано его расширение, то WinRAR будет использовать формат архива по умолчанию, выбранный в профиле архивации по умолчанию, но если вы хотите указать тип архива явно, то это можно сделать добавлением расширения .rar или .zip к имени архива.

Если при распаковке архива не указано его расширение, то WinRAR считает, что это архив .rar, т.е. маска '*' (без кавычек) означает все архивы с расширением .rar. Если требуется обработать все архивы, не имеющие в имени расширения, то нужно использовать маску '*.' (без кавычек). Маска *.* выбирает все файлы. Символы подстановки (шаблоны) можно использовать в большинстве операций, таких как извлечение, тестирование и многих других, однако при архивировании и удалении шаблоны запрещены.

в) Ключи, введённые в командной строке, имеют более высокий приоритет, чем соответствующие установки в диалоговом окне конфигурации, т.е. используются параметры, заданные ключами.

г) Для команд C, E, S, T, RR, K и X в имени архива допускается использовать шаблоны, поэтому одной командой можно обработать сразу нескольких архивов. Более того, если вместе с этими командами указать ключ -r, то поиск архивов будет вестись и во всех вложенных папках.

д) Некоторые команды и ключи применимы только к архивам RAR, некоторые — к архивам RAR и ZIP, а некоторые — к архивам всех поддерживаемых форматов. Это зависит от возможностей, заложенных в формат архива.

е) Команды и ключи не зависят от регистра символов, поэтому вы можете набирать их как строчными, так и прописными буквами.

ж) Если какой-либо компонент командной строки содержит пробелы, он должен быть заключён в двойные кавычки.

Примеры
Добавить папку ""c:\latest data"" в архив Info.rar 
Bash
WinRAR a Info.rar ""c:\latest data""
Распаковать архив Info.rar в папку d:\data 
Bash
WinRAR x Info.rar d:\data\
Список команд

A	Добавить файлы в архив
C	Добавить архивный комментарий
CH	Изменить параметры архива
CV	Преобразовать архивы
CW	Записать в файл комментарий архива
D	Удалить файлы из архива
E	Извлечь файлы из архива, игнорируя пути
F	Освежить имеющиеся файлы в архиве
I	Найти строку в архивах
K	Заблокировать архив
M	Переместить файлы и папки в архив
R	Восстановить повреждённый архив
RC	Воссоздать недостающие тома
RN	Переименовать файлы в архиве
RR[N]	Добавить информацию для восстановления
RV[N]	Создать тома для восстановления
S[имя]	Преобразовать архив в самораспаковывающийся
S-	Удалить SFX-модуль
T	Протестировать файлы в архиве
U	Обновить файлы в архиве
X	Извлечь файлы из архива с полными путями

Список ключей

--	Прервать дальнейший поиск ключей в командной строке
-@[+]	Запретить [разрешить] списки файлов
-ac	Снять атрибут ""Архивный"" после архивации или извлечения
-ad	Добавить к пути назначения имя архива
-af<тип>	Указать формат архива
-ag[формат]	Добавить к имени архива текущую дату и время
-ai	Игнорировать файловые атрибуты
-ao	Добавить файлы с установленным атрибутом ""Архивный""
-ap<путь>	Установить путь внутри архива
-as	Синхронизировать содержимое архива
-av	Добавить электронную подпись
-av-	Запретить добавление/проверку электронной подписи
-cfg-	Игнорировать профиль по умолчанию и переменную окружения
-cl	Преобразовать имена файлов в нижний регистр
-cp<имя>	Выбрать профиль упаковки
-cu	Преобразовать имена файлов в верхний регистр
-df	Удалить файлы после архивации
-dh	Открывать совместно используемые файлы
-dr	Удалить файлы в Корзину
-ds	Не сортировать файлы при архивации
-dw	Уничтожить (затереть) файлы после архивации
-ed	Не добавлять пустые папки
-en	Не добавлять блок ""Конец архива""
-ep	Исключить пути из имён
-ep1	Исключить из пути базовую папку
-ep2	Сохранять полные пути файлов
-ep3	Сохранять полные пути, включая букву диска
-e[+]<атр>	Задать исключение или включение файлов из/в обработку по маске атрибутов
-f	Освежить имеющиеся файлы
-hp[пароль]	Шифровать и данные, и заголовки файлов
-iadm	Запрашивать административный доступ для SFX-архива
-ibck	Запустить WinRAR как фоновый процесс в системном лотке
-ieml[.][адрес]	Отправить архив по электронной почте
-iicon<имя>	Указать значок для SFX-модуля
-iimg<имя>	Указать логотип для SFX-модуля
-ilog[имя]	Записывать протокол ошибок в файл
-inul	Не выводить сообщения об ошибках
-ioff	Выключить компьютер
-k	Заблокировать архив
-kb	Сохранять на диске файлы, извлечённые с ошибками
-log[формат][=имя]	Записывать имена в файл-протокол
-m<n>	Установить метод сжатия
-mc<параметры>	Указать дополнительные параметры сжатия
-md<n>	Установить размер словаря
-ms[список]	Указать типы файлов для архивирования без сжатия
-mt<потоки>	Установить число потоков
-n<файл>	Включить в обработку только указанный файл
-n@<файл-список>	Включить в обработку только файлы, указанные в файле-списке
-oc	Установить NTFS-атрибут ""Сжатый""
-or	Переименовывать файлы автоматически
-os	Сохранить потоки NTFS
-ow	Обработать информацию о правах доступа к файлам
-o[+,-]	Установить режим перезаписи
-p[пароль]	Установить пароль
-r	Обрабатывать вложенные папки
-r-	Запретить рекурсию (обработку вложенных папок)
-r0	Обрабатывать вложенные папки только по шаблону
-ri	Установить приоритет и время простоя
-rr[N]	Добавить информацию для восстановления
-rv[N]	Создать тома для восстановления
-s	Создать непрерывный архив
-s<N>	Создать непрерывные группы, используя счётчик файлов
-sc<набор символов>[объекты]	Указать набор символов (и объекты)
-se	Создать непрерывные группы, используя расширения файлов
-sfx[имя]	Создать самораспаковывающийся архив
-sl<размер>	Обрабатывать файлы размером меньше указанного
-sm<размер>	Обрабатывать файлы размером больше указанного
-sv	Создать независимые непрерывные тома
-sv-	Создать зависимые непрерывные тома
-s-	Запретить создание непрерывных архивов
-t	Протестировать файлы после архивирования
-ta<дата>	Обрабатывать файлы, изменённые после указанной даты
-tb<дата>	Обрабатывать файлы, изменённые до указанной даты
-tk	Сохранять исходное время архива
-tl	Установить время архива по самому новому файлу
-tn<время>	Обрабатывать файлы не старее, чем указанный период времени
-to<время>	Обрабатывать файлы более старые, чем указанный период времени
-ts<m,c,a>	Сохранить/восстановить время файлов (модификации, создания, последнего доступа)
-u	Обновить файлы
-v<n>[k,b,f,m,M,g,G]	Создать многотомный архив
-vd	Очищать сменный диск перед архивацией на него
-ver[n]	Управление версиями файлов
-vn	Использовать старую схему именования томов
-vp	Делать паузу перед каждым томом
-w<путь>	Задать папку для временных файлов
-x<файл>	Не обрабатывать указанный файл
-x@<файл-список>	Не обрабатывать файлы, указанные в файле-списке
-y	Подразумевать ответ ""Да"" на все запросы
-z<файл>	Прочитать комментарий архива из файла

Коды возврата WinRAR

В случае успешного окончания операции WinRAR завершает работу с нулевым (0) кодом возврата. Если код возврата отличается от нулевого, это говорит о том, что произошла какая-то ошибка.

Код возврата
Описание
0	Операция успешно завершена.
1	Предупреждение. Произошли некритические ошибки.
2	Произошла критическая ошибка.
3	Неверная контрольная сумма CRC32. Данные повреждены.
4	Предпринята попытка изменить заблокированный архив.
5	Произошла ошибка записи на диск.
6	Произошла ошибка открытия файла.
7	Ошибка при указании параметра в командной строке.
8	Недостаточно памяти для выполнения операции.
9	Ошибка при создании файла.
10	Нет файлов, удовлетворяющих указанной маске, и параметров.
255	Операция была прервана пользователем.

ОФИЦИАЛЬНАЯ

Console RAR manual

User’s Manual
~~~~~~~~~~~~~
RAR 3.93 console version
~~~~~~~~~~~~~~~~~~~~~~~~

=-=-=-=-=-=-=-=-=-=-=-=-=-=-
Welcome to the RAR Archiver!
-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Introduction
~~~~~~~~~~~~

RAR is a powerful tool allowing you to manage and control archive
files. Console RAR supports archives only in RAR format, the names
of which usually have a “.rar” extension. ZIP and other formats
are not supported. Windows users may install GUI RAR version – WinRAR,
which is able to process many more archive types.

RAR features include:

*  Highly sophisticated, original compression algorithm
*  Special compression algorithms optimized for text, audio,
graphics data, 32 and 64-bit Intel executables
*  Better compression than similar tools, using ‘solid’ archiving
*  Authenticity verification (registered version only)
*  Self-extracting archives and volumes (SFX)
*  Ability to recover physically damaged archives
*  Locking, password, file order list, file security & more …

Configuration file
~~~~~~~~~~~~~~~~~~

RAR for Unix reads configuration information from the file .rarrc
in the user’s home directory (stored in HOME environment variable)
or in /etc directory.

RAR for Windows reads configuration information from the file rar.ini,
placed in the same directory as the rar.exe file.

This file may contain the following string:

switches=any RAR switches, separated by spaces

For example:

switches=-m5 -s

Environment variable
~~~~~~~~~~~~~~~~~~~~

Default parameters may be added to the RAR command line by establishing
an environment variable “RAR”.

For instance, in UNIX following lines may be added to your profile:

RAR=’-s -md1024′
export RAR

RAR will use this string as default parameters in the command line and
will create “solid” archives with 1024 KB sliding dictionary size.

RAR handles options with priority as following:

command line switches                   highest priority
switches in the RAR variable            lower priority
switches saved in configuration file    lowest priority

Log file
~~~~~~~~

If the switch -ilog is specified in the command line or configuration
file, RAR will write informational messages, concerning errors
encountered while processing archives, into a log file. Read switch
-ilog description for more details.

The file order list for solid archiving – rarfiles.lst
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

rarfiles.lst contains a user-defined file list, which tells RAR
the order in which to add files to a solid archive. It may contain
file names, wildcards and special entry – $default. The default
entry defines the place in order list for files not matched
with other entries in this file. The comment character is ‘;’.

In Windows this file should be placed in the same directory as RAR
or in %APPDATA%\WinRAR directory, in Unix – to the user’s home directory
or in /etc.

Tips to provide improved compression and speed of operation:

– similar files should be grouped together in the archive;
– frequently accessed files should be placed at the beginning.

Normally masks placed nearer to the top of list have a higher priority,
but there is an exception from this rule. If rarfiles.lst contains such
two masks that all files matched by one mask are also matched by another,
that mask which matches a smaller subset of file names will have higher
priority regardless of its position in the list. For example, if you have
*.cpp and f*.cpp masks, f*.cpp has a higher priority, so the position of
‘filename.cpp’ will be chosen according to ‘f*.cpp’, not ‘*.cpp’.

RAR command line syntax
~~~~~~~~~~~~~~~~~~~~~~~

Syntax

RAR <command>  [ -<switches> ]  <archive>  [ <@listfiles…> ]
[ <files…> ]  [ <path_to_extract\> ]

Description

Command line options (commands and switches) provide control of
creating and managing archives with RAR. The command is a string (or a
single letter) which commands RAR to perform a corresponding action.
Switches are designed to modify the way RAR performs the action. Other
parameters are archive name and files to be archived into or extracted
from the archive.

Listfiles are plain text files that contain names of files to process.
File names should start at the first column. It is possible to
put comments to the listfile after // characters. For example,
you may create backup.lst containing the following strings:

c:\work\doc\*.txt         //backup text documents
c:\work\image\*.bmp       //backup pictures
c:\work\misc

and then run:

rar a backup @backup.lst

If you wish to read file names from stdin (standard input),
specify the empty listfile name (just @).

Win32 console RAR uses OEM (DOS) encoding in list files.

You may specify both usual file names and list files in the same
command line. If neither files nor listfiles are specified,
then *.* is implied and RAR will process all files

In a UNIX environment you need to quote wildcards to avoid them
being expanded by shell. For example, this command will extract
*.asm files from RAR archives in current path:

rar e ‘*.rar’ ‘*.asm’

Command could be any of the following:

a       Add files to archive.

Examples:

1) add all *.hlp files from the current directory to 
the archive help.rar:

rar a help *.hlp

2) archive all files from the current directory and subdirectories
to 362000 bytes size solid, self-extracting volumes 
and add the recovery record to each volume:

rar a -r -v362 -s -sfx -rr save

Because no file names are specified, all files (*) are assumed.

3) as a special exception, if directory name is specified as 
an argument and if directory name does not include file masks 
and trailing backslashes, the entire contents of the directory
and all subdirectories will be added to the archive even 
if switch -r is not specified.

The following command will add all files from the directory
Bitmaps and its subdirectories to the RAR archive Pictures.rar:

rar a Pictures.rar Bitmaps

4) if directory name includes file masks or trailing backslashes,
normal rules apply and you need to specify switch -r to process 
its subdirectories.

The following command will add all files from directory Bitmaps,
but not from its subdirectories, because switch -r is not
specified:

rar a Pictures.rar Bitmaps\*

c       Add archive comment. Comments are displayed while the archive is
being processed. Comment length is limited to 62000 bytes

Examples:

rar c distrib.rar

Also comments may be added from a file using -z[file] switch.
The following command adds a comment from info.txt file:

rar c -zinfo.txt dummy

cf      Add files comment. File comments are displayed when the ‘v’
command is given. File comment length is limited to 32767 bytes.

Example:

rar cf bigarch *.txt

ch      Change archive parameters.

This command can be used with most of archive modification
switches to modify archive parameters. It is especially
convenient for switches like -av, -cl, -cu, -tl, which do not
have a dedicated command.

It is not able to recompress, encrypt or decrypt archive data
and it cannot merge or create volumes. If used without any
switches, ‘ch’ command just copies the archive data without
modification.

Example:

Set archive time to latest file:

rar ch -tl files.rar

cw      Write archive comment to specified file.

Format of output file depends on -sc switch.

If output file name is not specified, comment data will be
sent to stdout.

Examples:

1) rar cw arc comment.txt

2) rar cw -scuc arc unicode.txt

3) rar cw arc

d       Delete files from archive. Please note if the processing of this
command results in removing all the files from the archive,
the empty archive would removed.

e       Extract files to current directory.

f       Freshen files in archive. Updates those files changed since they
were packed to the archive. This command will not add new files
to the archive.

i[i|c|h|t]=<string>
Find string in archives.

Supports following optional parameters:

i – case insensitive search (default);

c – case sensitive search;

h – hexadecimal search;

t – use ANSI, Unicode and OEM character tables (Win32 only);

If no parameters are specified, it is possible to use
the simplified command syntax i<string> instead of i=<string>

It is allowed to specify ‘t’ modifier with other parameters,
for example, ict=string performs case sensitive search
using all mentioned above character tables.

Examples:

1) rar “ic=first level” -r c:\*.rar *.txt

Perform case sensitive search of “first level” string
in *.txt files in *.rar archives on the disk c:

2) rar ih=f0e0aeaeab2d83e3a9 -r e:\texts

Search for hex string f0 e0 ae ae ab 2d 83 e3 a9
in rar archives in e:\texts directory.

k       Lock archive. Any command which intends to change the archive
will be ignored.

Example:

rar k final.rar

l[t,b]  List contents of archive [technical]. Files are listed as with
the ‘v’ command with the exception of the file path. i.e. only
the file name is displayed. Optional technical information
(host OS, solid flag and old version flag) is displayed
when ‘t’ modifier is used. Modifier ‘b’ forces RAR to output
only bare file names without any additional information.

m[f]    Move to archive [files only]. Moving files and directories
results in the files and directories being erased upon
successful completion of the packing operation. Directories will
not be removed if ‘f’ modifier is used and/or ‘-ed’ switch is
applied.

p       Print file to stdout.

You may use this command together with -inul switch to disable
all RAR messages and print only file data. It may be important
when you need to send a file to stdout for use in pipes.

r       Repair archive. Archive repairing is performed in two stages.
First, the damaged archive is searched for a recovery record
(see ‘rr’ command). If the archive contains a recovery record
and if the portion of the damaged data is continuous and less
than N*512 bytes, where N is number of recovery sectors placed
into the archive, the chance of successful archive
reconstruction is very high. When this stage has been completed,
a new archive will be created, called fixed.arcname.rar,
where ‘arcname’ is the original (damaged) archive name.

If a broken archive does not contain a recovery record or if
the archive is not completely recovered due to major damage, a
second stage is performed. During this stage only the archive
structure is reconstructed and it is impossible to recover
files which fail the CRC validation, it is still possible,
however, to recover undamaged files, which were inaccessible
due to the broken archive structure. Mostly this is useful
for non-solid archives.

When the second stage is completed, the reconstructed archive
will be saved as rebuilt.arcname.rar, where ‘arcname’ is
the original archive name.

RAR/DOS32 version uses _recover.rar and _reconst.rar instead
of names mentioned aboves.

While the recovery is in progress, RAR may prompt the user for
assistance when a suspicious file is detected.

Suspicious entry

Name:  <possibly filename>
Size:  <size>    Packed: <compressed size>

Add it: Yes/No/All

Answer ‘y’ to add this entry to the file rebuilt.arcname.rar.

Example:

rar r buggy.rar

rc      Reconstruct missing and damaged volumes using recovery volumes
(.rev files). You need to specify any existing volume
as the archive name, for example, ‘rar rc backup.part03.rar’

Read ‘rv’ command description for information about
recovery volumes.

rn      Rename archived files.

The command syntax is:

rar rn <arcname> <srcname1> <destname1> … <srcnameN> <destnameN>

For example, the following command:

rar rn data.rar readme.txt readme.bak info.txt info.bak

will rename readme.txt to readme.bak and info.txt to info.bak
in the archive data.rar.

It is allowed to use wildcards in the source and destination
names for simple name transformations like changing file
extensions. For example:

rar rn data.rar *.txt *.bak

will rename all *.txt files to *.bak.

RAR does not check if the destination file name is already
present in the archive, so you need to be careful to avoid
duplicated names. It is especially important when using
wildcards. Such a command is potentially dangerous, because
a wrong wildcard may corrupt all archived names.

rr[N]   Add data recovery record. Optionally, redundant information
(recovery record) may be added to an archive. This will cause
a small increase of the archive size and helps to recover
archived files in case of floppy disk failure or data losses of
any other kind. A recovery record contains up to 524288 recovery
sectors. The number of sectors may be specified directly in the
‘rr’ command (N = 1, 2 .. 524288) or, if it is not specified by
the user, it will be selected automatically according to the
archive size: a size of the recovery information will be about
1% of the total archive size, usually allowing the recovery of
up to 0.6% of the total archive size of continuously damaged data.

It is also possible to specify the recovery record size in
percent to the archive size. Just append the percent character
to the command parameter. For example:

rar rr3% arcname

Note that if you run this command from .bat or .cmd file,
you need to use rr3%% instead of rr3%, because the command
processor treats the single ‘%’ character as the start of
a batch file parameter. You may also use ‘p’ instead of ‘%’,
so ‘rr3p’ will work too.

If data is damaged continuously, then each rr-sector helps to
recover 512 bytes of damaged information. This value may be
lower in cases of multiple damage.

The size of the recovery record may be approximately determined
by the formula <archive size>/256 + <number of recovery
sectors>*512 bytes.

rv[N]   Create recovery volumes (.rev files), which can be later
used to reconstruct missing and damaged files in a volume
set. This command makes sense only for multivolume archives
and you need to specify the name of the first volume
in the set as the archive name. For example:

rar rv3 data.part01.rar

This feature may be useful for backups or, for example,
when you posted a multivolume archive to a newsgroup
and a part of subscribers did not receive some of the files.
Reposting recovery volumes instead of usual volumes
may reduce the total number of files to repost.

Each recovery volume is able to reconstruct one missing
or damaged RAR volume. For example, if you have 30 volumes
and 3 recovery volumes, you are able to reconstruct any
3 missing volumes. If the number of .rev files is less than
the number of missing volumes, reconstructing is impossible.
The total number of usual and recovery volumes must not
exceed 255.

Original RAR volumes must not be modified after creating
recovery volumes. Recovery algorithm uses data stored both
in REV files and in RAR volumes to rebuild missing RAR volumes.
So if you modify RAR volumes, for example, lock them, after
creating REV files, recovery process will fail.

The optional <N> parameter specifies a number of recovery
volumes to create and must be less than the total number
of RAR volumes in the set. You may also append a percent
character to this parameter, in such case the number of
creating .rev files will be equal to this percent taken
from the total number of RAR volumes. For example:

rar rv15% data.part01.rar

RAR reconstructs missing and damaged volumes either when
using ‘rc’ command or automatically, if it cannot locate
the next volume and finds the required number of .rev files
when unpacking.

Original copies of damaged volumes are renamed to *.bad
before reconstruction. For example, volname.part03.rar
will be renamed to volname.part03.rar.bad.

s[name] Convert archive to SFX. The archive is merged with a SFX module
(using a module in file default.sfx or specified in the switch).
In the Windows version default.sfx should be placed in the
same directory as the rar.exe, in Unix – in the user’s
home directory, in /usr/lib or /usr/local/lib.

s-      Remove SFX module from the already existing SFX archive.
RAR creates a new archive without SFX module, the original
SFX archive is not deleted.

t       Test archive files. This command performs a dummy file
extraction, writing nothing to the output stream, in order to
validate the specified file(s).

Examples:

Test archives in current directory:

rar t *

or for Unix:

rar t ‘*’

User may test archives in all sub-directories, starting
with the current path:

rar t -r *

or for Unix:

rar t -r ‘*’

u       Update files in archive. Adds files not yet in the archive
and updates files that have been changed since they were packed
into the archive.

v[t,b]  Verbosely list the contents of archive [technical].
Files are listed using the format: full pathname, file comment,
original and compressed size, compression ratio, last update
date and time, attributes, CRC, compression method and minimum
RAR version required to extract. Optional technical information
(host OS, solid flag and old file version flag) is displayed
when ‘t’ modifier is used. Modifier ‘b’ forces RAR to output
only bare file names without any additional information.

To list the contents of all archive volumes, use an asterisk
(‘*’) in place of the archive file extension or use the ‘-v’
switch.

Example:

1) list contents of system.rar archive (technical mode)
and redirect output to file techlist.lst

rar vt system >techlist.lst

2) list contents of tutorial.rar archive (bare file names mode)

rar vb tutorial

x       Extract files with full path.

Example:

rar x -av- -c- dime 10cents.txt

extract specified file to current path. AV check and comment
show are disabled.

Switches (used in conjunction with a command):

-?      Display help on commands and switches. The same as when none
or an illegal command line option is entered.

—      Stop switches scanning

This switch tells to RAR that there are no more switches
in the command line. It could be useful, if either archive
or file name starts from ‘-‘ character. Without ‘–‘ switch
such a name would be treated as a switch.

Example:

add all files from the current directory to the solid archive
‘-StrangeName’

RAR a -s — -StrangeName

-ac     Clear Archive attribute after compression or extraction
(Windows version only).

-ad     Append archive name to destination path.

This option may be useful when unpacking a group of archives.
By default RAR places files from all archives in the same
directory, but this switch creates a separate directory
for files unpacked from each archive.

Example:

rar x -ad *.rar data\

RAR will create subdirectories below ‘data’ for every unpacking
archive.

-ag[format]
Generate archive name using the current date and time.

Appends the current date string to an archive name when
creating an archive. Useful for daily backups.

Format of the appending string is defined by the optional
“format” parameter or by “YYYYMMDDHHMMSS” if this parameter
is absent. The format string may include the following
characters:

Y   – year
M   – month
MMM – month name as text string (Jan, Feb, etc.)
W   – a week number (a week starts with Monday)
A   – day of week number (Monday is 1, Sunday – 7)
D   – day of month
E   – day of year
H   – hours
M   – minutes (treated as minutes if encountered after hours)
S   – seconds
N   – archive number. RAR searches for already existing archive
with generated name and if found, increments the archive
number until generating a unique name. ‘N’ format character
is not supported when creating volumes.

Each of format string characters listed above represents only
one character added to archive name. For example, use WW for
two digit week number or YYYY to define four digit year.

If the first character in the format string is ‘+’, positions
of the date string and base archive name are exchanged,
so a date will precede an archive name.

The format string may contain optional text enclosed in ‘{‘
and ‘}’ characters. This text is inserted into archive name.

All other characters are added to an archive name without
changes.

If you need to update an already existing archive, be careful
with -ag switch. Depending on the format string and time passed
since previous -ag use, generated and existing archive names
may mismatch. In this case RAR will create a new archive
instead of updating the already existing.

Examples:

1) use the default YYYYMMDDHHMMSS format

rar a -ag backup

2) use DD-MMM-YY format

rar a -agDD-MMM-YY backup

3) use YYYYMMDDHHMM format, place date before ‘backup’

rar a -ag+YYYYMMDDHHMM backup

4) use YYYY-WW-A format, include fields description

rar a -agYYYY{year}-WW{week}-A{wday} backup

5) use YYYYMMDD and the archive number. It allows to generate
unique names even when YYYYMMDD format mask used more than
once in the same day

rar a -agYYYYMMDD-NN backup

-ai     Ignore file attributes.

If this switch is used when extracting, RAR does not set
general file attributes stored in archive to extracted files.
This switch preserves attributes assigned by operating system
to a newly created file.

In Windows it affects archive, system, hidden and read-only
attributes. in Unix – user, group, and others file permissions.

-ao     Add files with Archive attribute set
(Windows version only).

Example:

add all disk C: files with Archive attribute set
to the ‘f:backup’ and clear files Archive attribute

rar a -r -ac -ao f:backup c:\*.*

-ap     Set path inside archive. This path is merged to file
names when adding files to an archive and removed
from file names when extracting.

For example, if you wish to add the file ‘readme.txt’
to the directory ‘DOCS\ENG’ of archive ‘release’,
you may run:

rar a -apDOCS\ENG release readme.txt

or to extract ‘ENG’ to the current directory:

rar x -apDOCS release DOCS\ENG\*.*

-as     Synchronize archive contents

If this switch is used when archiving, those archived files
which are not present in the list of the currently added
files, will be deleted from the archive. It is convenient to
use this switch in combination with -u (update) to synchronize
contents of an archive and an archiving directory.

For example, after the command:

rar a -u -as backup sources\*.cpp

the archive ‘backup.rar’ will contain only *.cpp files
from directory ‘sources’, all other files will be deleted
from the archive. It looks similar to creating a new archive,
but with one important exception: if no files are modified
since the last backup, the operation is performed much faster
than the creation of a new archive.

-av     Put authenticity verification (registered versions only).
RAR will put, in every new and updated archive, information
concerning the creator, last update time and archive name.

If an archive, containing authenticity verification, is being
modified and this switch is not specified, the authenticity
verification information will be removed.

When extracting, testing, listing or updating an archive with
the ‘-av’ switch, RAR will perform integrity validation and
display the message:

Verifying authenticity information …

In the case of successful authenticity verification, 
message ‘Ok’, creator name and last update information will be
displayed. In the case of authenticity verification failure,
message ‘FAILED’ will be displayed.

RAR authenticity verification can be forged and does not
provide the same level of security as modern digital signature
schemes based on public key infrastructure. We recommend 
to use this RAR feature as informational only, like a special
archive comment. Avoid it in situations, when accurate
information about archive creator is important.

In order to enable the authenticity verification feature,
the program must be registered. Please contact your local
distribution site or the world-wide distribution center.

-av-    Disable authenticity verification checking or adding.

-cfg-   Ignore configuration file and RAR environment variable.

-cl     Convert file names to lower case.

-cu     Convert file names to upper case.

-c-     Disable comments show.

-df     Delete files after archiving

Move files to archive. This switch in combination with
the command “A” performs the same action as the command “M”.

-dh     Open shared files

Allows to process files opened by other applications
for writing.

This switch helps if an application allowed read access
to file, but if all types of file access are prohibited,
the file open operation will still fail.

This option could be dangerous, because it allows
to archive a file, which at the same time is modified
by another application, so use it carefully.

-dr     Delete files to Recycle Bin

Delete files after archiving and place them to Recycle Bin.
Available in Windows version only.

-ds     Do not sort files while adding to a solid archive.

-dw     Wipe files after archiving

Delete files after archiving. Before deleting file data
are overwritten by zero bytes to prevent recovery of
deleted files.

-ed     Do not add empty directories

This switch indicates that directory records are not to be
stored in the created archive. When extracting such archives,
RAR creates non-empty directories basing on paths of files
contained in them. Information about empty directories is
lost. All attributes of non-empty directories except a name
(access rights, streams, etc.) will be lost as well, so use
this switch only if you do not need to preserve such information.

If -ed is used with ‘m’ command or -df switch, RAR will not
remove empty directories.

-ee     Do not process extended attributes

Disables saving and restoring extended file attributes.
Only for OS/2 versions.

-en     Do not add “end of archive” block

By default, RAR adds an “end of archive” block to the end of
a new or updated archive. It allows to skip external data like
digital signatures safely, but in some special cases it may be
useful to disable this feature. For example, if an archive
is transferred between two systems via an unreliable link and
at the same time a sender adds new files to it, it may be
important to be sure that the already received file part will
not be modified on the other end between transfer sessions.

This switch cannot be used with volumes, because the end
of archive block contains information important for correct
volume processing.

-ep     Exclude paths from names. This switch enables files to be added
to an archive without including the path information. This
could, of course, result in multiple files existing in the
archive with the same name.

-ep1    Exclude base dir from names. Do not store the path entered in
the command line.

Example:

all files and directories from the directory tmp will be added
to the archive ‘test’, but the path in archived names will not
include ‘tmp\’

rar a -ep1 -r test tmp\*

This is equivalent to the commands:

cd tmp
rar a -r ..\test
cd ..

-ep2    Expand paths to full. Store full file paths (except a drive
letter and leading path separator) when archiving.

-ep3    Expand paths to full including the drive letter.
Win32 version only.

This switch stores full file paths including the drive
letter if used when archiving. Drive separators (colons)
are replaced by underscore characters.

If you use -ep3 when extracting, it will change
underscores back to colons and create unpacked files
in their original directories and disks. If the user
also specified a destination path, it will be ignored.

This switch can help to backup several disks to the same
archive. For example, you may run:

rar a -ep3 -r backup.rar c:\ d:\ e:\

to create backup and:

rar x -ep3 backup.rar

to restore it.

But be cautious and use -ep3 only if you are sure that
extracting archive does not contain any malicious files.
In other words, use it if you have created an archive yourself
or completely trust its author. This switch allows to overwrite
any file in any location on your computer including important
system files and should normally be used only for the purpose
of backup and restore.

-e[+]<attr>
Specifies file exclude or include attributes mask.

<attr> is a number in the decimal, octal (with leading ‘0’)
or hex (with leading ‘0x’) format.

By default, without ‘+’ sign before <attr>, this switch
defines the exclude mask. So if result of bitwise AND between
<attr> and file attributes is nonzero, file would not be
processed.

If ‘+’ sign is present, it specifies the include mask.
Only those files which have at least one attribute specified
in the mask will be processed.

In Windows version is also possible to use symbols D, S, H,
A and R instead of a digital mask to denote directories
and files with system, hidden, archive and read-only attributes.
The order in which the attributes are given is not significant.
Unix version supports D and V symbols to define directory
and device attributes.

It is allowed to specify both -e<attr> and -e+<attr>
in the same command line.

Examples:

1) archive only directory names without their contents

rar a -r -e+d dirs

2) do not compress system and hidden files:

rar a -esh files

3) do not extract read-only files:

rar x -er files

-f      Freshen files. May be used with archive extraction or creation.
The command string “a -f” is equivalent to the command ‘f’, you
could also use the switch ‘-f’ with the commands ‘m’ or ‘mf’. If
the switch ‘-f’ is used with the commands ‘x’ or ‘e’, then only
old files would be replaced with new versions extracted from the
archive.

-hp[p]  Encrypt both file data and headers.

This switch is similar to -p[p], but switch -p encrypts
only file data and leaves other information like file names
visible. This switch encrypts all sensitive archive areas
including file data, file names, sizes, attributes, comments
and other blocks, so it provides a higher security level.
Without a password it is impossible to view even the list of
files in archive encrypted with -hp.

Example:

rar a -hpfGzq5yKw secret report.txt

will add the file report.txt to the encrypted archive
secret.rar using the password ‘fGzq5yKw’

-id[c,d,p,q]
Disable messages.

Switch -idc disables the copyright string.

Switch -idd disables “Done” string at the end of operation.

Switch -idp disables the percentage indicator.

Switch -idq turns on the quiet mode, so only error messages
and questions are displayed.

It is allowed to use several modifiers at once,
so switch -idcdp is correct.

-ieml[.][addr]
Send archive by email. Win32 version only.

Attach an archive created or updated by the add command
to email message. You need to have a MAPI compliant email
client to use this switch (most modern email programs
support MAPI interface).

You may enter a destination email address directly
in the switch or leave it blank. In the latter case you
will be asked for it by your email program. It is possible
to specify several addresses separated by commas or semicolons.

If you append a dot character to -ieml, an archive will be
deleted after it was successfully attached to an email.
If the switch is used when creating a multivolume archive,
every volume is attached to a separate email message.

-ierr   Send all messages to stderr.

-ilog[name]
Log errors to file (registered version only).

Write error messages to rar.log file. If optional ‘name’
parameter is not specified, the log file is created
using the following defaults:

Unix:    .rarlog file in the user’s home directory;
Windows: rar.log file in %APPDATA%\WinRAR directory;
DOS:     rar.log file in the same directory as the rar32.exe.

If ‘name’ parameter includes a file name without path,
RAR will create the log file in default directory from
the list above using the specified name. Include both path
and name to ‘name’ parameter if you wish to change
the location of log file.

Example:

rar a -ilogc:\log\backup.log backup d:\docs

will create c:\log\backup.log log file in case of errors.

-inul   Disable all messages.

-ioff   Turn PC off after completing an operation. The hardware must
support the power off feature. Win32 version only.

-isnd   Enable sound.

-k      Lock archive. Any command which intends to change the archive
will be ignored.

-kb     Keep broken extracted files.

RAR, by default, deletes files with CRC errors after
extraction. The switch -kb specifies that files with
CRC errors should not be deleted.

-m<n>   Set compression method:

-m0   store     do not compress file when adding to archive
-m1   fastest   use fastest method (less compressive)
-m2   fast      use fast compression method
-m3   normal    use normal (default) compression method
-m4   good      use good compression method (more
compressive, but slower)
-m5   best      use best compression method (slightly more
compressive, but slowest)

If this switch is not specified, RAR uses -m3 method
(normal compression).

By default, RAR uses only the general compression
algorithm in -m1 and -m2 methods, advanced algorithms
like audio and true color processing are enabled
only in -m3..-m5 modes, the advanced text compression
is activated only in -m4..-m5. This default can be
overridden using -mc switch.

-mc<par>
Set advanced compression parameters.

This switch is intended mainly for benchmarking and
experiments. In the real environment it is usually better
to allow RAR to select optimal parameters automatically.
Please note that improper use of this switch may lead
to very serious performance and compression loss, so use
it only if you clearly understand what you do.

It has the following syntax:

-mc[param1][:param2][module][+ or -]

where <module> is the one character field denoting a part
of the compression algorithm, which has to be configured.

It may have the following values:

A       – audio compression;
C       – true color (RGB) data compression;
D       – delta compression;
E       – 32-bit x86 executables compression;
I       – 64-bit Intel Itanium executables compression;
T       – text compression.

‘+’ sign at the end of switch applies the selected algorithm
module to all processed data, ‘-‘ disables the module at all.
If no sign is specified, RAR will choose modules automatically,
based on data and the current compression method.

Switch -mc- disables all optional modules and allows only
the general compression algorithm.

<Param1> and <Param2> are module dependent parameters
described below.

Audio compression, delta compression:

<Param1> is a number of byte channels (can be 1 – 31).
RAR splits multibyte channels to bytes, for example,
two 16-bit audio channels are considered by RAR as four
channels one byte each.

<Param2> is ignored.

32-bit x86 Intel executables compression,
64-bit Intel Itanium executables compression,
true color (RGB) data compression:

<Param1> and <Param2> are ignored.

Text compression:

<Param1> is the order of PPM algorithm (can be 2 – 63).
Usually a higher value slightly increases the compression ratio
of redundant data, but only if enough memory is available
to PPM. In case of lack of memory the result may be negative.
Higher order values decrease both compression and decompression
speed.

<Param2> is memory in megabytes allocated for PPM (1-128).
Higher values may increase the compression ratio, but note
that PPM uses the equal memory size both to compress and
decompress, so if you allocate too much memory when creating
an archive, other people may have problems when decompressing
it on a computer with less memory installed. Decompression
will be still possible using virtual memory, but it may
become very slow.

Examples:

1) switch -mc1a+ forces use of 8-bit mono audio compression
for all data.

2) switch -mc10:40t+ forces use of text compression
algorithm for all data, sets the compression order to 10
and allocates 40 MB memory.

3) switch -mc12t sets the text compression order to 12,
when the text compression is used, but leaves to RAR to
decide when to use it.

4) switches -mct- -mcd- disable text and delta compression.

-md<n>  Select dictionary size <n> in KB. Must be 64, 128, 256, 512,
1024, 2048 or 4096 or a letter ‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’, ‘g’
respectively.

The sliding dictionary is a special memory area used by the
compression algorithm. If the size of the file being compressed
(or the total files size in the case of a solid archive) is
greater than the dictionary size, then increasing the dictionary
size will generally increase compression ratio, decrease packing
speed and increase memory requirements.

RAR can reduce the dictionary size if it is significantly
larger than the size of the source data. It helps to reduce
memory requirements without decreasing compression.

Default sliding dictionary size is 4096 KB.

Example:

RAR a -s -mdd sources *.asm
or
RAR a -s -md512 sources *.asm

Will create a solid archive using a 512 KB dictionary.

-ms[list]
Specify file types to store.

Specify file types, which will be stored without compression.
This switch may be used to store already compressed files,
which helps to increase archiving speed without noticeable
loss in the compression ratio.

Optional <list> parameter defines the list of file extensions
separated by semicolons. For example, -msrar;zip;jpg will
force RAR to store without compression all RAR and ZIP
archives and JPG images. It is also allowed to specify wildcard
file masks in the list, so -ms*.rar;*.zip;*.jpg will work too.

If <list> is not specified, -ms switch will use the default
set of extensions, which includes the following file types:

7z, ace, arj, bz2, cab, gz, jpeg, jpg, lha, lzh, mp3,
rar, taz, tgz, z, zip

-mt<threads>
Set the number of threads. Available in Windows version only.

<threads> parameter can take values from 0 to 16.
It defines the recommended number of active threads
for compression algorithm. If it is greater than 0,
RAR will use the multithreaded version of compression
algorithm providing higher speed on multiprocessor
architectures. Real number of active threads can differ
from the specified.

If <threads> is zero, RAR will use the single threaded
compression algorithm.

Change of <threads> parameter slightly affects the compression
ratio, so archives created with different -mt switches
will not be exactly the same even if all other compression
settings are equal.

If -mt switch is not specified, RAR will try to detect
the number of available processors and select the optimal
number of threads automatically.

-n<f>   Include only the specified file <f>. Wildcards may be used
both in the name and file parts of file mask. You may specify
the switch ‘-n’ several times.

This switch does not replace usual file masks, which still
need to be entered in the command line. It is an additional
filter limiting processed files only to those matching
the include mask specified in -n switch. It can help to
reduce the command line length sometimes.

For example, if you need to compress all *.txt and *.lst
files in directories Project and Info, you can enter:

rar a -r text Project\*.txt Project\*.lst Info\*.txt Info\*.lst

or using the switch -n:

rar a -r -n*.txt -n*.lst text Project Info

-n@<lf> Include files listed in the specified list file.

Similar to -n<f> switch, but reads include masks from
the list file. If you use -n@ without the list file name
parameter, it will read file names from stdin.

Example:

rar a -r -n@inclist.txt text Project Info

-oc     Set NTFS Compressed attribute. Win32 version only.

This switch allows to restore NTFS Compressed attribute
when extracting files. RAR saves Compressed file attributes
when creating an archive, but does not restore them unless
-oc switch is specified.

-ol     Save symbolic links as the link instead of the file.
Unix version only.

-or     Rename extracted files automatically if file with the same name
already exists. Renamed file will get the name like
‘filename(N).txt’, where ‘filename.txt’ is the original file
name and ‘N’ is a number starting from 1 and incrementing
if file exists.

-os     Save NTFS streams. Win32 version only.

This switch has meaning only for NTFS file system and allows
to save alternative data streams associated with a file.
It is especially important in Windows 2000, XP and newer,
which use streams to keep some file dependent information
like file descriptions. If you use RAR to backup your
NTFS disks, it is recommended to specify this switch.

-ow     Use this switch when archiving to save file security
information and when extracting to restore it.

Unix RAR version saves file owner and group when using
this switch.

Win32 version stores owner, group, file permissions and
audit information, but only if you have necessary privileges
to read them. Note that only NTFS file system supports
file based security under Windows.

-o[+|-] Set the overwrite mode. Can be used both when extracting
and updating archived files. Following modes are available:

-o           Ask before overwrite
(default for extracting files);

-o+          Overwrite all
(default for updating archived files);

-o-          Skip existing files.

-p[p]   Encrypt files with the string <p> as password while archiving.
The password is case-sensitive. If you omit the password on the
command line, you will be prompted with message “Enter password”.

Example:

rar a -pmyhoney secret1 *.txt

add files *.txt and encrypt them with password “myhoney”.

-p-     Do not query password

-r      Recurse subdirectories. May be used with commands:
a, u, f, m, x, e, t, p, v, l, c, cf and s.

When used with the commands ‘a’, ‘u’, ‘f’, ‘m’ will process
files in all sub-directories as well as the current working
directory.

When used with the commands x, e, t, p, v, l, c, cf or s will
process all archives in sub-directories as well as the current
working directory.

-r-     Disable recursion.

Even without -r switch RAR can enable the recursion
automatically in some situations. Switch -r- prohibits it.

If you specify a directory name when archiving and if such 
name does not include wildcards, by default RAR adds
the directory contents even if switch -r is not specified.
Also RAR automatically enables the recursion if disk root
without wildcards is specified as a file mask. Switch -r- 
disables such behavior.

For example:

rar a -r- arc dirname

command will add only the empty ‘dirname’ directory and ignore 
its contents. Following command:

rar a -r- arc c:\

will compress contents of root c: directory only and 
will not recurse into subdirectories.

-r0     Similar to -r, but when used with the commands ‘a’, ‘u’, ‘f’,
‘m’ will recurse subdirectories only for those names, which
include wildcard characters ‘*’ and ‘?’

-ri<p>[:<s>]
Set priority and sleep time. Available only in RAR for Windows.
This switch regulates system load by RAR in multitasking
environment. Possible task priority <p> values are 0 – 15.

If <p> is 0, RAR uses the default task priority.
<p> equal to 1 sets the lowest possible priority,
15 – the highest possible.

Sleep time <s> is a value from 0 to 1000 (milliseconds).
This is a period of time that RAR gives back to the system
after every read or write operation while compressing
or extracting. Non-zero <s> may be useful if you need to reduce
system load even more than can be achieved with <p> parameter.

Example:

execute RAR with default priority and 10 ms sleep time:

rar a -ri0:10 backup *.*

-rr[N]  Add a data recovery record. This switch is used when creating
or modifying an archive to add a data recovery record to
the archive. See the ‘rr[N]’ command description for details.

-rv[N]  Create recovery volumes. This switch is used when creating
a multivolume archive to generate recovery volumes.
See the ‘rv[N]’ command description for details.

-s      Create solid archive. Solid is a special archive type. Please
refer to the appendix “Glossary” for further information.

Example:

create solid archive sources.rar with 512 KB dictionary,
recursing all directories, starting with the current directory.
Add only .asm files:

rar a -s -md512 sources.rar *.asm -r

-s<N>   Create solid groups using file count

Similar to -s, but reset solid statistics after compressing
<N> files. Usually decreases compression, but also
decreases losses in case of solid archive damages.

-sc<charset>[objects]
Specify the character set for list files and archive
comment files.

‘Charset’ parameter is mandatory and can have one
of the following values:

U – Unicode;
A – ANSI (Windows) encoding. Windows version only;
O – OEM (DOS) encoding. Windows version only.

Files in Unicode format must have FFFE or FEFF Unicode
character in the beginning, otherwise RAR will ignore
this switch and process the file as ASCII text.

‘Objects’ parameter is optional and can have one of
the following values:

L – list files;
C – comment files.

It is allowed to specify more than one object, for example,
-scolc. If ‘objects’ parameter is missing, ‘charset’ is applied
to all objects.

This switch allows to specify the character set for files
in -z[file] switch, list files and comment files written by
“cw” command.

Examples:

1) rar a -scol data @list

Read names contained in ‘list’ using OEM encoding.

2) rar c -scuc -zcomment.txt data

Read comment.txt as Unicode file.

3) rar cw -scuc data comment.txt

Write comment.txt as Unicode file.

-se     Create solid groups using extension

Similar to -s, but reset solid statistics if file extension
is changed. Usually decreases compression, but also
decreases losses from solid archive damages.

-sfx[name]
Create SFX archives. If this switch is used when creating a new
archive, a Self-Extracting archive (using a module in file
default.sfx or specified in the switch) would be created.
In the Windows version default.sfx should be placed in the
same directory as the rar.exe, in Unix – in the user’s
home directory, in /usr/lib or /usr/local/lib.

Example:

rar a -sfxwincon.sfx myinst

create SelF-eXtracting (SFX) archive using wincon.sfx
SFX-module.

-si[name]
Read data from stdin (standard input), when creating
an archive. Optional ‘name’ parameter allows to specify
a file name of compressed stdin data in the created
archive. If this parameter is missing, the name will be
set to ‘stdin’. This switch cannot be used with -v.

Example:

type Tree.Far | rar a -siTree.Far tree.rar

will compress ‘type Tree.Far’ output as ‘Tree.Far’ file.

-sl<size>
Process only those files, which size is less than
specified in <size> parameter of this switch.
Parameter <size> must be specified in bytes.

-sm<size>
Process only those files, which size is more than
specified in <size> parameter of this switch.
Parameter <size> must be specified in bytes.

-sv     Create independent solid volumes

By default RAR tries to reset solid statistics as soon
as possible when starting a new volume, but only 
if enough data was packed after a previous reset
(at least a few megabytes).

This switch forces RAR to ignore packed data size and attempt
to reset statistics for volumes of any size. It decreases
compression, but increases chances to extract a part of data 
if one of several solid volumes in a volume set was lost
or damaged.

Note that sometimes RAR cannot reset statistics even
using this switch. For example, it cannot be done when 
compressing one large file split between several volumes.
RAR is able to reset solid statistics only between separate 
files, but not inside of single file.

Ignored if used when creating a non-volume archive.

-sv-    Create dependent solid volumes

Disables to reset solid statistics between volumes.

It slightly increases compression, but significantly reduces 
chances to extract a part of data if one of several solid
volumes in a volume set was lost or damaged.

Ignored if used when creating a non-volume archive.

-s-     Disable solid archiving

-t      Test files after archiving. This switch is especially
useful in combination with the move command, so files will be
deleted only if the archive had been successfully tested.

-ta<date>
Process only files modified after the specified date.

Format of the date string is YYYYMMDDHHMMSS.
It is allowed to insert separators like ‘-‘ or ‘:’ to
the date string and omit trailing fields. For example,
the following switch is correct: -ta2001-11-20
Internally it will be expanded to -ta20011120000000
and treated as “files modified after 0 hour 0 minutes
0 seconds of 20 November 2001″.

-tb<date>
Process only files modified before the specified date.
Format of the switch is the same as -ta<date>.

-tk     Keep original archive date. Prevents RAR from modifying the
archive date when changing an archive.

-tl     Set archive time to newest file. Forces RAR to set the date of a
changed archive to the date of the newest file in the archive.

-tn<time>
Process files newer than the specified time period. Format
of the time string is:

[<ndays>d][<nhours>h][<nminutes>m][<nseconds>s]

For example, use switch -tn15d to process files newer
than 15 days and -tn2h30m to process files newer than
2 hours 30 minutes.

-to<time>
Process files older than the specified time period. Format
of the switch is the same as -tn<time>.

-ts<m,c,a>[N]
Save or restore file time (modification, creation, access).

Switch -tsm instructs RAR to save file modification time,
-tsc – creation time and tsa – last access time. Optional
parameter after the switch is the number between 0 and 4
controlling the file time precision. Value ‘1’ enables
1 second precision, 2 – 0.0065536 sec, 3 – 0.0000256 sec and
4 or ‘+’ enables the maximum NTFS time precision, which is
equal to 0.0000001 sec. Value ‘0’ or ‘-‘ means that creation
and access time are not saved and low (two seconds) precision
is used for modification time. Higher precision modes add
more data to archive, up to 19 additional bytes per file
in case of -tsm4 -tsa4 -tsc4 combination. If no precision
is specified, RAR uses ‘4’ (high) value.

Default RAR mode is -tsm4 -tsc0 -tsa0, so modification time
is stored with the high precision and other times are ignored.

It is necessary to specify -tsc and -tsa switches to set
creation and access time when unpacking files (precision
is irrelevant, but must not be 0). By default RAR sets
only the modification time, even if archive contains
creation and last access time. Setting the modification
time to unpacked files may be also disabled with -tsm-.

It is possible to omit the time type letter if you need
to apply the switch to all three times. For example,
-tsm4 -tsa4 -tsc4 can be replaced by -ts4, -ts+ or -ts.
Use -ts- to save only the low precision modification time
or to ignore all three file times on unpacking.

When creating an archive, RAR automatically reduces
the precision if high mode is not supported by the file
system. It is not more than 2 seconds on FAT and 1 second
in Unix. NTFS time precision is 0.0000001 second.

Operating systems limit which time can be set on unpacking.
Windows allows to set all three times, Unix – modification
and last access, but not creation, DOS supports only
the modification time.

Examples:

1) rar a -ts backup

Store all file times with the highest possible precision.

2) rar x -tsa backup

Restore modification and last access time. Switch -tsm
is not required, because RAR uses it by default.

3) rar a -tsm1 -tsc1 backup

Store low precision modification and creation time.
Without -tsm1 RAR would save the high precision modification
time.

-u      Update files. May be used with archive extraction or creation.
The command string “a -u” is equivalent to the command ‘u’, you
could also use the switch ‘-u’ with the commands ‘m’ or ‘mf’. If
the switch ‘-u’ is used with the commands ‘x’ or ‘e’, then files
not present on the disk and files newer than their copies on the
disk would extracted from the archive.

-v      Create volumes with size autodetection or list all volumes

This switch may be used when creating or listing volumes.

In the first case it enables volume size autodetection,
so new volumes will use all available space on the destination
media. It is convenient when creating volumes on removable
disks. You may read more about volumes in -v<size> description.

In the second case, when this switch is used together with
‘V’ or ‘L’ command, it forces RAR to list contents of all
volumes starting from that specified in the command line.
Without this switch RAR displays contents of only one single
specified volume.

-v<size>[k|b|f|m|M|g|G]
Create volumes with size=<size>*1000 [*1024 | *1].
By default this switch uses <size> as thousands (1000) of bytes
(not 1024 x bytes). You may also enter the size in kilobytes
using the symbol ‘k’, in bytes using the symbol ‘b’,
megabytes – ‘m’, millions of bytes – ‘M’, gigabytes – ‘g’,
billions (milliards) of bytes – ‘G’ or select one of several
predefined values using the symbol ‘f’ following the numerical
value. Predefined values can be 360, 720, 1200, 1440 or 2880
and replaced with corresponding floppy disk size.

If the size is omitted, autodetection will be used.

You may specify several -v switches to set different sizes
for different volumes. For example:

rar a -v100k -v200k -v300k arcname

sets 100 KB size for first volume, 200 KB for second
and 300 KB for all following volumes.

If volumes are created on removable media, then after
the creation of the first volume, the user will be prompted
with:

Create next volume: Yes/No/All

At this moment in time, you should change the disks. Answering
‘A’ will cause all volumes to be created without a pause.

By default RAR volumes have names like ‘volname.partNNN.rar’,
where NNN is the volume number. Using -vn switch it is 
possible to switch to another, extension based naming scheme,
where the first volume file in a multi-volume set has
the extension .rar, following volumes are numbered from .r00
to .r99.

When extracting or testing a multi-volume archive you must use
only the first volume name. If there is no next volume
on the drive and the disk is removable, the user will be
prompted with:

Insert disk with <next volume name>

Insert the disk with the correct volume and press any key.

If while extracting, the next volume is not found and volumes
are placed on the non-removable disk, RAR will abort with
the error message:

Cannot find <volume name>

Archive volumes may not be modified. The commands ‘d’, ‘f’, ‘u’,
‘s’ cannot be used with Multi-volume sets. The command ‘a’ may
be used only for the creation of a new multi-volume sequence.

It is possible, although unlikely, that the file size, of a file
in a multi-volume set, could be greater than its uncompressed
size. This is due to the fact that ‘storing’ (no compression if
size increases) cannot be enabled for multi-volume sets.

Archive volumes may be Self-Extracting (SFX). Such an archive
should be created using both the ‘-v’ and ‘-sfx’ switches.

Example:

create archive in volumes of fixed size:

rar a -s -v1440 floparch.rar *.*

will create solid volumes of size 1440000 bytes.

-vd     Erase disk contents before creating volume

All files and directories on the target disk will be erased
when ‘-vd’ is used.  The switch applies only to removable
media, the hard disk cannot be erased using this switch.

-ver[n] File version control

Forces RAR to keep previous file versions when updating
files in the already existing archive. Old versions are
renamed to ‘filename;n’, where ‘n’ is the version number.

By default, when unpacking an archive without the switch
-ver, RAR extracts only the last added file version, the name
of which does not include a numeric suffix. But if you specify
a file name exactly, including a version, it will be also
unpacked. For example, ‘rar x arcname’ will unpack only
last versions, when ‘rar x arcname file.txt;5’ will unpack
‘file.txt;5’, if it is present in the archive.

If you specify -ver switch without a parameter when unpacking,
RAR will extract all versions of all files that match
the entered file mask. In this case a version number is
not removed from unpacked file names. You may also extract
a concrete file version specifying its number as -ver parameter.
It will tell RAR to unpack only this version and remove
a version number from file names. For example,
‘rar x -ver5 arcname’ will unpack only 5th file versions.

If you specify ‘n’ parameter when archiving, it will limit
the maximum number of file versions stored in the archive.
Old file versions exceeding this threshold will be removed.

-vn     Use the old style volume naming scheme

By default RAR volumes have names like ‘volname.partNNN.rar’,
where NNN is the volume number. Using -vn switch it is 
possible to switch to another, extension based naming scheme,
where the first volume file in a multi-volume set has
the extension .rar, following volumes are numbered from .r00
to .r99. It may have sense, if you are going to unpack
an archive under the plain MS DOS, which does not allow
more than one dot in a file name.

-vp     Pause before each volume

By default RAR asks for confirmation before creating or 
unpacking next volume only for removable drives.
This switch forces RAR to ask such confirmation always.
It can be useful if disk space is limited and you wish
to copy each volume to another media immediately after
creation.

-w<p>   Assign work directory as <p>. This switch may be used to assign
the directory for temporary files.

-x<f>   Exclude specified file <f>, wildcards may be used both
in the name and file parts of file mask. You may specify
the switch ‘-x’ several times.

If mask contains wildcards, it applies to current directory
and its subdirectories. It is not recursive without wildcards,
so if you wish to exclude some “filename” in all directories,
you need to specify two masks: “filename” for current directory
and “*\filename” for subdirectories. If you know an exact path
to file, you can use “path\filename” syntax to exclude only
this copy of “filename”. If you use -xpath\filename syntax
when unpacking an archive, “path” must be a path inside of
archive, not a file path on the disk after unpacking.

Examples:

1) rar a -r -x*.bak -x*.rar rawfiles

*.bak and *.rar files will not be added to rawfiles

2) rar a -r -x*\temp -x*\temp\* savec c:\*

compress all files on the disk c: except temp directories
and files inside of temp directories

3) rar x -x*.txt docs

extract all files except *.txt from docs.rar

-x@<lf> Exclude files listed in the specified list file. If you use -x@
without the list file name parameter, it will read file names
from stdin.

Example:

rar a -x@exlist.txt arch *.exe

-y      Assume Yes on all queries.

-z[f]   Read archive comment from file <f>. Use with -sc switch
if you need to specify the character set for comment text file.
If <f> is not specified, comment is read from stdin.

Limitations
~~~~~~~~~~~

Pathname is limited to 259 symbols.

Maximum archive comment length is 62000 bytes.

Command limitations:

The commands ‘d’,’u’,’f’,’c’,’cf’ will not operate with archive
volumes.

The command ‘a’ cannot be used to update an archive volume, only to
create a new one.

Exit values
~~~~~~~~~~~

RAR exits with a zero code (0) in case of successful operation. The exit
code of non-zero means the operation was cancelled due to an error:

255   USER BREAK       User stopped the process

9   CREATE ERROR     Create file error

8   MEMORY ERROR     Not enough memory for operation

7   USER ERROR       Command line option error

6   OPEN ERROR       Open file error

5   WRITE ERROR      Write to disk error

4   LOCKED ARCHIVE   Attempt to modify an archive previously locked
by the ‘k’ command

3   CRC ERROR        A CRC error occurred when unpacking

2   FATAL ERROR      A fatal error occurred

1   WARNING          Non fatal error(s) occurred

0   SUCCESS          Successful operation

Glossary
~~~~~~~~

Archive      Special file containing one or more files optionally
compressed and/or encrypted.

Compression  A method of encoding data to reduce it’s size.

CRC          Cyclic Redundancy Check. Mathematical method calculating
special checking information for data validity.

SFX          Archive module used to extract files from when executed.
(SelF-eXtracting module), usually in the form of a .EXE
file.

Solid        An archive packed using a special compression method which
sees all files as one continuous data stream. Particularly
advantageous when packing a large number of small files.

Volume       Part of a split archive. Splitting an archive to volumes
allows storing them on diskettes. Solid volumes must be
extracted starting from first in sequence.

Copyrights

(c) 1993-2010 Alexander Roshal"}
},
{0,
{"CMD параметры (так же перетаскиванием файла)",0,0,"","@: Установка русской кодировки
chcp 1251

For %%i In (%*) Do (
	rem здесь, вместо Echo, вставить Ваше ""конвертирование""
	@Echo %%i
	@Echo %%~ni
)
Pause"}
},
{0,
{"Добавить собственный ярлык на программу в меню ""Отправить""",0,0,"","Чтобы добавить собственный ярлык на программу в меню ""Отправить"",

в Пуск – Поиск введите shell:sendto. Откроется папка SendTo, содержащая ярлыки меню ""Отправить"".
создайте здесь ярлык к программе, в которой вы хотите открывать файлы.

В Файле параметры для указания файла:
For %%i In (%*) Do (
	rem здесь, вместо Echo, вставить Ваше ""конвертирование""
	@Echo %%i
	@Echo %%~ni
)"}
},
{0,
{"CMD кодировать/декодировать файл в base64 (через certutil)",0,0,"","Кодировать:
certutil -encode raw.txt encoded.txt
или
certutil -f -encode raw.txt encoded.txt

Декодировать:
certutil -decode encoded.txt raw.txt"}
}
},
{2,
{"Текстовый документ",1,0,"",""},
{0,
{"Текстовый документ",0,0,"","Процедура ТестСообщение(ПутьКПапке = ""D:\"", ИмяФайла = ""1C_Test"", Инфо = """", ДописатьВФайл = """")
	
	ТекДата 		= ТекущаяДата();
	ТекДатаСтрока 	= Формат(ТекДата, ""ДФ='yyyy-MM-dd HH-mm-ss'"");
	Пользователь 	= ИмяПользователя();
	
	ТекстТест 		= ТекДатаСтрока + Пользователь + "" "" + ?(НЕ ПустаяСтрока(Инфо), Инфо + "" "", """") + ДописатьВФайл;
	ТекстДок = Новый ТекстовыйДокумент;
	ТекстДок.ДобавитьСтроку(ТекстТест);
	
	//СетевоеИмяКомпьютера = ИмяКомпьютера();
	//Путь  = ""\\"" + СетевоеИмяКомпьютера + ""\шаблоны\word.doc"";
	ПутьКФайлу = ПутьКПапке + ИмяФайла + ""_"" + ТекДатаСтрока + "".txt""; // Путь сохранения файла
	ТекстДок.Записать(ПутьКФайлу);
	ТекстДок = Неопределено;
	
КонецПроцедуры"}
},
{0,
{"Прочитать построчно файл",0,0,"","Путь =  ИмяФайла;
Текст = Новый ЧтениеТекста(Путь);
Стр = Текст.ПрочитатьСтроку();
Пока Стр <> Неопределено Цикл
	Стр = Текст.ПрочитатьСтроку();
	Если НайтиЗ(Стр,""Продан"") Тогда
		Сообщить(Стр);
	КонецЕсли;    
КонецЦикла;"}
}
},
{8,
{"Дата",1,0,"",""},
{0,
{"ТекущаяДата",0,0,"ТекД=","ТекДата = ТекущаяДата();"}
},
{0,
{"ТекущаяДата()",0,0,"ТекД[ата]","ТекущаяДата()"}
},
{0,
{"ТекущаяДата  yyyy-MM-dd HH-mm-ss",0,0,"текДатаФ[ормат]","ТекДата = Формат(ТекущаяДата(), ""ДФ='yyyy-MM-dd HH-mm-ss'"");"}
},
{0,
{"Месяц прописью",0,0,"","Функция ПолучитьМесяцПрописью(КоличествоМесяцев)
	
	Если КоличествоМесяцев <= 0 Тогда
		Возврат ""месяца"";
	ИначеЕсли Окр(КоличествоМесяцев) <> КоличествоМесяцев Тогда
		Возврат ""месяца"";
	ИначеЕсли КоличествоМесяцев > 4 
		И КоличествоМесяцев < 21 Тогда 
		Возврат ""месяцев"";
	ИначеЕсли КоличествоМесяцев % 10 = 1 Тогда 
		Возврат ""месяц"";
	ИначеЕсли КоличествоМесяцев % 10 = 2
		ИЛИ КоличествоМесяцев % 10 = 3
		ИЛИ КоличествоМесяцев % 10 = 4 Тогда
		Возврат ""месяца"";
	ИначеЕсли КоличествоМесяцев % 10 = 5
		ИЛИ КоличествоМесяцев % 10 = 6
		ИЛИ КоличествоМесяцев % 10 = 7
		ИЛИ КоличествоМесяцев % 10 = 8
		ИЛИ КоличествоМесяцев % 10 = 9
		ИЛИ КоличествоМесяцев % 10 = 0 Тогда
		Возврат ""месяцев"";
	Иначе
		Возврат ""месяц"";
	КонецЕсли;	
	
КонецФункции
"}
},
{0,
{"РазобратьРазностьДат",0,0,"","//Типовая из ОМ -\ ОбщегоНазначения

// Процедура вычисляет количество лет, месяцев и дней между двумя датами
// Параметры
//  Дата1    – дата, первая дата (более поздняя, часто текущая, стаж определяется по состоянию на эту дату)
//  Дата2    – дата, вторая дата (ранняя дата, с нее начинается ""течение"" стажа)
//  Лет        – Число, в этот параметр будет записано кол-во лет между двумя датами (Дата1-Дата2)
//  Месяцев    – Число, в этот параметр будет записано кол-во месяцев между двумя датами (Дата1-Дата2)
//  Дней    – Число, в этот параметр будет записано кол-во дней между двумя датами (Дата1-Дата2)
Процедура РазобратьРазностьДат(Дата1, Дата2, Лет = 0, Месяцев = 0, Дней = 0) Экспорт
	
	Лет        	= 0;
	Месяцев    	= 0;
	Дней    	= 0;
	
	Если Дата1 > Дата2 Тогда
		ВременнаяДата = Дата1;
		
		Если День(ВременнаяДата) < День(Дата2) Тогда
			Дней = (ВременнаяДата - ДобавитьМесяц(ВременнаяДата, -1)) / 86400;
			ВременнаяДата = ДобавитьМесяц(ВременнаяДата, -1);
		КонецЕсли;
		
		Если Месяц(ВременнаяДата) < Месяц(Дата2) Тогда
			ВременнаяДата = ДобавитьМесяц(ВременнаяДата, -12);
			Месяцев = 12;
		КонецЕсли;
		
		Лет        = Макс(             Год(ВременнаяДата)        - Год(Дата2),    0);
		Месяцев    = Макс(Месяцев    + Месяц(ВременнаяДата)    - Месяц(Дата2),    0);
		Дней    = Макс(Дней        + День(ВременнаяДата)    - День(Дата2),    0);
		
		// скорректируем отображаемое значение, если ""вмешалось"" разное количество дней в месяцах
		
		Если Дата2 <> (ДобавитьМесяц(Дата1, -Лет * 12 - Месяцев) - Дней * 86400) Тогда
			Дней = Дней + (День(КонецМесяца(Дата2)) - День(НачалоМесяца(Дата2))) - (День(КонецМесяца(ДобавитьМесяц(Дата1, -1))) - День(НачалоМесяца(ДобавитьМесяц(Дата1, -1))));
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры    // РазобратьРазностьДат"}
},
{0,
{"РазобратьРазностьДат в красивый результат",0,0,""," Процедура ТЕСТ_ВыполнитьНажатие(Кнопка)
	 
	ДатаНач = Дата(2009, 12, 31);
	ДатаКон = Дата(2005, 1, 10); 
	Лет		= 0; Мес=0; Дн=0;	
	РазобратьРазностьДат(ДатаНач, ДатаКон, Лет, Мес, Дн);
	
	ЛетС 	= ФормаМножественногоЧисла(""год""	,""года""		,""лет""		,Лет);	
	МесС 	= ФормаМножественногоЧисла(""месяц""	,""месяца""	,""месяцев""	,Мес);
	ДнС 	= ФормаМножественногоЧисла(""день""	,""дня""		,""дней""		,Дн);
	
	Результат = ?(Лет>0,Строка(Лет)+"" ""+ЛетС,"""")+"" ""+?(Мес>0,Строка(Мес)+"" ""+МесС,"""")+"" ""+Строка(дн)+"" ""+ДнС;
	
	Сообщить(Результат);
	// Результат будет : 4 года 11 месяцев 21 день

КонецПроцедуры

// Сформировать множественное число
Функция ФормаМножественногоЧисла(Слово1, Слово2, Слово3, Знач ЦелоеЧисло) 
	
	// Изменим знак целого числа, иначе отрицательные числа будут неправильно преобразовываться
	Если ЦелоеЧисло < 0 Тогда
		ЦелоеЧисло = -1 * ЦелоеЧисло;
	КонецЕсли;
	
	Если ЦелоеЧисло <> Цел(ЦелоеЧисло) Тогда 
		// для нецелых чисел - всегда вторая форма
		Возврат Слово2;
	КонецЕсли;
	
	// остаток
	Остаток = ЦелоеЧисло % 10;
	Если (ЦелоеЧисло > 10) И (ЦелоеЧисло < 20) Тогда
		// для второго десятка - всегда третья форма
		Возврат Слово3;
	ИначеЕсли Остаток = 1 Тогда
		Возврат Слово1;
	ИначеЕсли (Остаток > 1) И (Остаток < 5) Тогда
		Возврат Слово2;
	Иначе
		Возврат Слово3;
	КонецЕсли;

КонецФункции    "}
},
{0,
{"РазницаВДнях",0,0,"","РазницаВДнях = (НачалоДня(ДатаОкончания) - НачалоДня(ДатаНачала)) / (60 * 60 * 24);"}
},
{0,
{"Дата начальная (нулевая)",0,0,"ДатаН","Дата(1, 1, 1)"}
}
},
{3,
{"Почта",1,0,"",""},
{0,
{"Почта полностью",0,0,"","&НаСервере 
Процедура УстановитьСоединение()    
    Профиль = Новый ИнтернетПочтовыйПрофиль;
    Профиль.АдресСервераSMTP = ""smtp.mail.ru"";
    Профиль.АдресСервераPOP3 = ""pop.mail.ru"";
    Профиль.ПортPOP3 = 110;
    Профиль.ПортSMTP = 587;
    Профиль.Пользователь = ""probasprinter@mail.ru"";
    Профиль.Пароль = ""gfhjkm"";
    Профиль.ПользовательSMTP = ""probasprinter@mail.ru"";
    Профиль.ПарольSMTP = ""gfhjkm"";
    Профиль.АутентификацияSMTP = СпособSMTPАутентификации.ПоУмолчанию; // СпособSMTPАутентификации.Login;
    Почта = Новый ИнтернетПочта;
    
   // Создадим почтовое сообщение
 
    Письмо = Новый ИнтернетПочтовоеСообщение;
    Текст = Письмо.Тексты.Добавить(""Привет"");
    Текст.ТипТекста = ТипТекстаПочтовогоСообщения.ПростойТекст;
    Письмо.Тема = ""Пробное письмо""; 
    Письмо.Отправитель = ""probasprinter@mail.ru""; // Вида йцу@mail.ru
    Письмо.ИмяОтправителя = ""ИмяОтправителя"";
    Письмо.Получатели.Добавить(""qwer@rambler.ru""); // Вида йцу@rambler.ru
    
    Попытка
        Почта.Подключиться(Профиль);
        Сообщить(""Подключенено"");
        Почта.Послать(Письмо);
        Сообщить(""Письма отправлены"");
    Исключение
        Сообщить(""Не удалось подключиться к серверу"");
        Сообщить(ОписаниеОшибки());
    КонецПопытки;
    
    Почта.Отключиться();
    Сообщить(""Соединение завершено"");
КонецПроцедуры"}
},
{0,
{"Почта частью типовой",0,0,"","Функция ОтправитьПисьмо(АдресаПолучателей)
	
	//Профиль 	= Справочники.УчетныеЗаписиЭлектроннойПочты.НайтиПоНаименованию(""Наименование""); // Вида йцу@mail.ru
	Профиль 	= Справочники.УчетныеЗаписиЭлектроннойПочты.СистемнаяУчетнаяЗаписьЭлектроннойПочты;
	Почта 		= Новый ИнтернетПочта;
	
	Письмо 		= Новый ИнтернетПочтовоеСообщение;
	Текст 		= Письмо.Тексты.Добавить(""Тест текста письма программно"");
	Текст.ТипТекста = ТипТекстаПочтовогоСообщения.ПростойТекст;
	Письмо.Тема 	= ""Пробное письмо""; 
	Письмо.Отправитель 		= ""Отправитель""; // Вида йцу@mail.ru
	Письмо.ИмяОтправителя 	= ""ИмяОтправителя"";
	Письмо.Получатели.Добавить(АдресаПолучателей); // Вида йцу@mail.ru
	
	Попытка
		Почта.Подключиться(Профиль);
		Сообщить(""Подключенено"");
		Почта.Послать(Письмо);
		Сообщить(""Письма отправлены"");
	Исключение
		Сообщить(""Не удалось подключиться к серверу"");
		Сообщить(ОписаниеОшибки());
	КонецПопытки;
	
	Почта.Отключиться();
	Сообщить(""Соединение завершено"");
	
КонецФункции // ОтправитьПисьмо()
"}
},
{0,
{"Почта типовой Бух",0,0,"","Функция ОтправитьПисьмо(АдресаПолучателей)
	
	Если ПустаяСтрока(АдресаПолучателей) Тогда
		Возврат Неопределено;
	КонецЕсли; 
	//Профиль = Справочники.УчетныеЗаписиЭлектроннойПочты.НайтиПоНаименованию(""@mail.ru"");
	Профиль = Справочники.УчетныеЗаписиЭлектроннойПочты.СистемнаяУчетнаяЗаписьЭлектроннойПочты;
	
//  ПараметрыОтправки - Структура - содержит всю необходимую информацию о письме:
//
//   * Кому - Массив, Строка - интернет адреса получателей письма.
//          - Массив - коллекция структур адресов:
//              * Адрес         - Строка - почтовый адрес (должно быть обязательно заполнено).
//              * Представление - Строка - имя адресата.
//          - Строка - интернет адреса получателей письма, разделитель - "";"".
//
//   * ПолучателиСообщения - Массив - массив структур, описывающий получателей:
//      ** Адрес - Строка - Почтовый адрес получателя сообщения.
//      ** Представление - Строка - представление адресата.
//
//   * Копии        - Массив, Строка - адреса получателей копий письма. См. описание поля Кому.
//
//   * СкрытыеКопии - Массив, Строка - адреса получателей скрытых копий письма. См. описание поля Кому.
//
//   * Тема       - Строка - (обязательный) тема почтового сообщения.
//   * Тело       - Строка - (обязательный) текст почтового сообщения (простой текст в кодировке win-1251).

	ПараметрыОтправки = Новый Структура();
	ПараметрыОтправки.Вставить(""Кому"", АдресаПолучателей); // вида, ""йцу@mail.ru"" или несколько через "";"" 
	ПараметрыОтправки.Вставить(""Тема"", ""Синхронизация с Битрикс"");
	ПараметрыОтправки.Вставить(""Тело"", ""Синхронизация с Битрикс в активном состоянии."");
	
	Попытка
		РаботаСПочтовымиСообщениями.ОтправитьПочтовоеСообщение(Профиль, ПараметрыОтправки);
		
		//ЗаписьЖурналаРегистрации(""Фоновое задание.Отправка письма"", 
		//УровеньЖурналаРегистрации.Информация, Метаданные.ОбщиеМодули.АйТи_Б24_ОбменСПорталомСервер, , ""(АйТи, Б24) Отправка письма о запущенной синхронизации"");
	Исключение
		Сообщить(""Синхронизация с Битрикс. Не удалось подключиться к серверу"");
		Сообщить(ОписаниеОшибки());
	КонецПопытки;
	
КонецФункции // ОтправитьПисьмо()"}
}
},
{6,
{"Математические",1,0,"",""},
{0,
{"Инкремент",0,0,"+=","<?""Переменная""> 	= <?""Переменная""> + 1;"}
},
{0,
{"Декремент",0,0,"-=","<?""Переменная""> 	= <?""Переменная""> - 1;"}
},
{0,
{"Умножить",0,0,"*=","<?""Переменная""> 	= <?""Переменная""> * <?""Умножить на"">;"}
},
{0,
{"Разделить",0,0,"/=","<?""Переменная""> 	= <?""Переменная""> / 1;"}
},
{0,
{"ОстатокОтДеления",0,0,"","ОстатокОтДеления 	= <?""Делимое""> - Цел(<?""Делимое""> / <?""Делитель"">) * <?""Делитель"">;
ОстатокОтДеления 	= <?""Делимое""> % <?""Делитель"">;"}
},
{0,
{"Математические",0,0,"","//Функция считает детерминант матрицы 3 на 3 
//-------------------------------------------------------------------------
//Матрица3На3 - двумерный массив (3на3),
//Возврат - число;
//-------------------------------------------------------------------------
//автор: Макаров А.
Функция Детерминат(Матрица3На3)
	
	Дет = 	Число(Матрица3На3[0][0]) * (Число(Матрица3На3[1][1]) * Число(Матрица3На3[2][2]) - Число(Матрица3На3[1][2]) * Число(Матрица3На3[2][1]))
			-	Число(Матрица3На3[0][1]) * (Число(Матрица3На3[1][0]) * Число(Матрица3На3[2][2]) - Число(Матрица3На3[1][2]) * Число(Матрица3На3[2][0])) 
			+ Число(Матрица3На3[0][2]) * (Число(Матрица3На3[1][0]) * Число(Матрица3На3[2][1]) - Число(Матрица3На3[1][1]) * Число(Матрица3На3[2][0]));
	
	Возврат Дет;
	
КонецФункции

//Функция производит ""вырезание""  матрицы 3 на 3 из исходной 4 на 4
//-------------------------------------------------------------------------
//Матрица4На4 - двумерный массив (4на4),
//i - число, ""вырезаемый столбец"",
//j - число, ""вырезаемая строка"",  
//Возврат - число;
//-------------------------------------------------------------------------
//автор: Макаров А.
Функция ВырезаниеМатрицы(Матрица4На4, i, j)
	
	МассивВСтроке = """";
	
	Для строка=0 По Матрица4На4.ВГраница() Цикл
		Для столбец=0 По Матрица4На4[строка].Вграница() Цикл
			Если  НЕ (строка = i  ИЛИ столбец = j) Тогда
				МассивВСтроке = МассивВСтроке + Матрица4На4[строка][столбец]
			КонецЕсли;	
		КонецЦикла;
	КонецЦикла;
	
	Матрица3На3 = Новый Массив(3, 3);
	
	С = 1;  л = """";
	
	Для строка=0 По Матрица3На3.ВГраница() Цикл
		Для столбец=0 По Матрица3На3[строка].Вграница() Цикл
			Матрица3На3[строка][столбец] = (Сред(МассивВСтроке, с,1));
			С= С +1;
			л = л +"" "" +Матрица3На3[строка][столбец];
		КонецЦикла;
		л = """";
	КонецЦикла;
	
	Возврат  Матрица3На3;
	
КонецФункции

//Функция возводит число в степень
//-------------------------------------------------------------------------
//Основание - число,
//Степень - число,
//Возврат - число;
//-------------------------------------------------------------------------
//автор: Макаров А.
Функция ЧислоВСтепени(Основание,Степень)
	
	к = 1;
	Результат = Основание;
	
	Пока к <=Степень Цикл
		
		Результат = Результат * Основание;
		к = к +1; 	
		
	КонецЦикла; 
	
	Возврат Результат;
	
КонецФункции
"}
}
},
{3,
{"Время",1,0,"",""},
{2,
{"Пауза",1,0,"",""},
{0,
{"Пауза",0,0,"","Процедура СделатьПаузу(ЗадержкаСекунд = 3, Вариант = ""Ping"")
	
    Если ЗадержкаСекунд = 0 Тогда
        Возврат
    КонецЕсли;
	
	Если ТранзакцияАктивна() Тогда
		ЗафиксироватьТранзакцию();
	КонецЕсли;
	
	Сообщить(""начало: ""+ТекущаяДата());
	
	Если Вариант = ""Ping"" Тогда
		
		СтрокаЗапроса = ""ping -n 1 -w ""+Формат(1000 * ЗадержкаСекунд, ""ЧДЦ=0; ЧГ="") + "" 127.255.255.255""; 
		WshShell = Новый COMОбъект(""WScript.Shell""); 
		WshShell.Run(СтрокаЗапроса, 0, -1); 
		
	ИначеЕсли Вариант = ""smaharbA"" Тогда
		
		Для к = 1 По ЗадержкаСекунд Цикл
			ПолучитьCOMОбъект(""winmgmts:"").ExecNotificationQuery(""Select * from __instancemodificationevent where TargetInstance isa 'Win32_UTCTime'"").NextEvent();
		КонецЦикла;
		
	ИначеЕсли Вариант = ""Пустой цикл"" Тогда
		
		// грузит процессор
		ДатаВыхода = ТекущаяДата() + ЗадержкаСекунд;
		Пока ТекущаяДата() < ДатаВыхода Цикл
			ОбработкаПрерыванияПользователя();
		КонецЦикла;
		
	ИначеЕсли Вариант = ""Sleep"" Тогда
		
		// не работает
		
		scr = Новый ComОбъект(""WScript.Shell""); 
		scr.Run(""sleep ""+Формат(ЗадержкаСекунд, ""ЧДЦ=0; ЧГ=""), 0, 1);
		
	ИначеЕсли Вариант = ""SleepJs"" Тогда
		
		// работает
		
		Скрипт = Новый ТекстовыйДокумент(); 
		Скрипт.УстановитьТекст 
		( 
		""if (WScript.Arguments.Count()==0) 
		| WScript.Quit(); 
		|else 
		| if (isNaN(parseInt(WScript.Arguments(0)))) 
		| WScript.Quit(); 
		|WScript.Sleep(WScript.Arguments(0));"" 
		); 
		Скрипт.Записать(КаталогВременныхФайлов()+""sleep.js"", КодировкаТекста.ANSI); 
		WshShell = Новый COMОбъект(""wscript.shell""); 
		WshShell.Run(""wscript.exe """"""+КаталогВременныхФайлов()+""sleep.js"""" ""+Формат(ЗадержкаСекунд*1000,""ЧГ=0""), 0, -1); 
		УдалитьФайлы(КаталогВременныхФайлов()+""sleep.js""); 
		
	ИначеЕсли Вариант = ""SleepVbs"" Тогда
		
		// работает
		
		Сигнатура = Формат(ТекущаяДата(), ""ДФ=yyyyMMddhhmmss"");
		ПутьСкрипта = КаталогВременныхФайлов()+""SleepScript""+Сигнатура+"".vbs"";
		СкриптФайл = Новый ТекстовыйДокумент;
		СкриптФайл.ДобавитьСтроку(""WScript.Sleep(""+Формат(ЗадержкаСекунд*1000, ""ЧГ=0"")+"")"");
		СкриптФайл.Записать(ПутьСкрипта, КодировкаТекста.OEM);
		WSHShell = Новый COMОбъект(""WScript.Shell"");
		WSHShell.Run(""wscript.exe """"""+ПутьСкрипта+"""""""", 0, 1);
		УдалитьФайлы(ПутьСкрипта);
		
	ИначеЕсли Вариант = ""TimeoutWS"" Тогда
		
		// работает
		
		КомандаWindows = ""Timeout /T "" + Формат(ЗадержкаСекунд, ""ЧГ=0"") + "" /NoBreak"";
		
		WshShell = Новый COMОбъект(""WScript.Shell""); 
		WshShell.Run(КомандаWindows, 0, -1);
		
	ИначеЕсли Вариант = ""Timeout"" Тогда
		
		// работает, показывает черное окно
		
		КомандаWindows = ""Timeout /T "" + Формат(ЗадержкаСекунд, ""ЧГ=0"") + "" /NoBreak"";
		ЗапуститьПриложение(КомандаWindows,,Истина);
		
	ИначеЕсли Вариант = ""DynamicWrapper"" Тогда
		
		// нужна библиотека
		
		Wrapper = Новый ComОбъект(""DynamicWrapper""); 
		Wrapper.Register(""KERNEL32.DLL"", ""Sleep"", ""i=l"", ""f=s""); 
		
		Wrapper.Sleep(ЗадержкаСекунд);
		
	КонецЕсли;
	
	Сообщить(""^^^^^^: ""+ТекущаяДата());
		
КонецПроцедуры"}
},
{0,
{"Пауза мини",0,0,"","Процедура Пауза(Длительность) Экспорт
	ДатаНачалаОперации = ТекущаяДата();
	Пока ТекущаяДата() - ДатаНачалаОперации < Длительность Цикл
	КонецЦикла;
КонецПроцедуры"}
}
},
{0,
{"MSScriptControl.ScriptControl",0,0,"","Scr = Новый COMОбъект(""MSScriptControl.ScriptControl""); 
Scr.Language = ""javascript""; 

ВремяНачалаВыполнения = Scr.Eval(""new Date().getTime()"");

//выполнить код

ВремяКонцаВыполнения = Scr.Eval(""new Date().getTime()"");
ВремяВыполнения = ВремяКонцаВыполнения - ВремяНачалаВыполнения; //время в милисекундах"}
},
{0,
{"Позже",0,0,"","Функция ПозжеЧаса(Час)
	
	Если Час<=Час(ТекущаяДата()) Тогда
		Возврат Истина;
	КонецЕсли;
	Возврат Ложь;
	
КонецФункции"}
}
},
{4,
{"Сортировка",1,0,"",""},
{0,
{"СортировкаПузырьком",0,0,"","Функция СортировкаПузырьком(МассивЭлементов) Экспорт
	
    // Количество просмотров массива - по количеству числа его элементов
    Для просмотр = 0 По МассивЭлементов.Количество()-1 Цикл
        // Собственно, просмотр массива
        Для индекс = 0 По МассивЭлементов.Количество()-1 Цикл
            // Если достигли конца массива то прервём цикл,
                        // чтобы не выполнять условие ниже
            Если индекс = МассивЭлементов.Количество()-1 Тогда
                Прервать;
            КонецЕсли;
            // Сравнение элементов и их перестановка (если требуется)
            Если МассивЭлементов[индекс] > МассивЭлементов[индекс+1] Тогда
                СтаршийЭлемент = МассивЭлементов[индекс];
                МладшийЭлемент = МассивЭлементов[индекс+1];
                МассивЭлементов[индекс] = МладшийЭлемент;
                МассивЭлементов[индекс+1] = СтаршийЭлемент;
            КонецЕсли;
        КонецЦикла;
	КонецЦикла;
	
    Возврат МассивЭлементов;
	
КонецФункции"}
},
{0,
{"ЕстьИзменения",0,0,"","ЕстьИзменения = Ложь;

Если НЕ ЕстьИзменения Тогда
	ЕстьИзменения = Истина;
КонецЕсли; 

Если ЕстьИзменения Тогда
	ДокументОбъект.Записать();
КонецЕсли;"}
},
{0,
{"БыстраяСортировка",0,0,""," //Алгоритм ""Быстрая сортировка"" { 
 Процедура б_Сортировка(Массив,НижнийПредел,ВерхнийПредел)
	 
	 i    = НижнийПредел;
	 j    = ВерхнийПредел;
	 m    = Массив[Цел((i+j)/2)];
	 
	 Пока Истина Цикл        
		 Пока Массив[i] < m Цикл            
			 i    = i + 1;                   
		 КонецЦикла;
		 
		 Пока Массив[j] > m Цикл            
			 j    = j - 1;                   
		 КонецЦикла; 
		 
		 Если i > j Тогда                       
			 Прервать;                        
		 КонецЕсли;
		 
	 КонецЦикла;
	 
	 Если НижнийПредел < j Тогда         
		 б_Сортировка(Массив,НижнийПредел,j);        
	 КонецЕсли; 
	 
	 Если i < ВерхнийПредел Тогда                      
		 б_Сортировка(Массив,i,ВерхнийПредел);        
	 КонецЕсли;
	 
 КонецПроцедуры
 
 Функция БыстраяСортировка(Массив)
	 
	 НижняяГраница = 0;
	 ВерхняяГраница = Массив.ВГраница();    
	 б_Сортировка(Массив,НижняяГраница,ВерхняяГраница);
	 
	 Возврат Массив;
	 
 КонецФункции"}
},
{0,
{"СортировкаСпискомЗначений",0,0,"","//Сортировка списком значений {---
Функция СортировкаСпискомЗначений(Знач Массив)
	
	мСписокЗнч = Новый СписокЗначений;
	мСписокЗнч.ЗагрузитьЗначения(Массив);
	мСписокЗнч.СортироватьПоЗначению(НаправлениеСортировки.Возр);
	
	Возврат мСписокЗнч.ВыгрузитьЗначения();
	
КонецФункции"}
}
},
{5,
{"Битрикс",1,0,"",""},
{0,
{"Запрос для свойств",0,0,"","Запрос = новый Запрос;
Запрос.МенеджерВременныхТаблиц = [МенеджерВременныхТаблиц];
Запрос.Текст = ""ВЫБРАТЬ
|	ВремЗначенияСвойствТоваровДляВыгрузкиРеквизитовПоПользовательсокмуАлгоритму.Значение
|ИЗ
|	ВремЗначенияСвойствТоваровДляВыгрузкиРеквизитовПоПользовательсокмуАлгоритму
|ГДЕ
|	ВремЗначенияСвойствТоваровДляВыгрузкиРеквизитовПоПользовательсокмуАлгоритму.Номенклатура = &Номенклатура
|	И ВремЗначенияСвойствТоваровДляВыгрузкиРеквизитовПоПользовательсокмуАлгоритму.Свойство.Наименование ПОДОБНО &Свойство + """"%"""""";

Запрос.УстановитьПараметр(""Номенклатура"", [Номенклатура]);
Запрос.УстановитьПараметр(""Свойство"", ""Белки"");  

ВыполненныйЗапрос = Запрос.Выполнить();

Если ВыполненныйЗапрос.Пустой() тогда
	[Результат] = 0;
Иначе
	Выборка = ВыполненныйЗапрос.Выбрать();
	Пока Выборка.Следующий() Цикл
		[Результат] = Строка(Выборка.Значение);
		Прервать;
	КонецЦикла;
КонецЕсли;"}
},
{0,
{"БУС АдресЭлектроннойПочтыКонтрагентаДляОбменаДокументами",0,0,"","// Если нету предопределённого АдресЭлектроннойПочтыКонтрагентаДляОбменаДокументами, то его заполним
АдресЭлектроннойПочтыКонтрагентаДляОбменаДокументами = Справочники.ВидыКонтактнойИнформации.АдресЭлектроннойПочтыКонтрагентаДляОбменаДокументами;
ЗаполненТип = ЗначениеЗаполнено(АдресЭлектроннойПочтыКонтрагентаДляОбменаДокументами.Тип);
ЗаполненВидОбъектаКонтактнойИнформации = ЗначениеЗаполнено(АдресЭлектроннойПочтыКонтрагентаДляОбменаДокументами.ВидОбъектаКонтактнойИнформации);
ОбработатьОбъект = НЕ ЗаполненТип ИЛИ НЕ ЗаполненВидОбъектаКонтактнойИнформации;

Если ОбработатьОбъект Тогда
	АдресЭлектроннойПочтыКонтрагентаДляОбменаДокументами = АдресЭлектроннойПочтыКонтрагентаДляОбменаДокументами.ПолучитьОбъект();
КонецЕсли; 
Если НЕ ЗаполненТип Тогда
	АдресЭлектроннойПочтыКонтрагентаДляОбменаДокументами.Тип 	= Перечисления.ТипыКонтактнойИнформации.АдресЭлектроннойПочты;
КонецЕсли;
Если НЕ ЗаполненВидОбъектаКонтактнойИнформации Тогда
	АдресЭлектроннойПочтыКонтрагентаДляОбменаДокументами.ВидОбъектаКонтактнойИнформации = Перечисления.ВидыОбъектовКонтактнойИнформации.Контрагенты;
КонецЕсли;
Если ОбработатьОбъект Тогда
	АдресЭлектроннойПочтыКонтрагентаДляОбменаДокументами.Записать();
КонецЕсли;"}
},
{0,
{"ПроверитьДанныеКонтрагента, , если они не указаны в настройках",0,0,"","Процедура ЗагрузитьДокументы(ПараметрыОбмена, ТзнДокументов, ДокументXDTO)
	
	// Типовое
	
	//+++ АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> ТЗ № <?""№""> >> Загрузка данных контрагента из ЗначенияРеквизитов, если они не указаны в настройках
	НовСтрЗначенияРеквизитов = НовСтр.ЗначенияРеквизитов;
	
	Если НовСтр.Контрагент <> Неопределено Тогда
		ПроверитьДанныеКонтрагента(НовСтрЗначенияРеквизитов, НовСтр.Контрагент.ИНН, ""ИНН"");	
		ПроверитьДанныеКонтрагента(НовСтрЗначенияРеквизитов, НовСтр.Контрагент.Наименование, ""Название компании"");
		ПроверитьДанныеКонтрагента(НовСтрЗначенияРеквизитов, НовСтр.Контрагент.НаименованиеПолное, ""Название компании"");	
	КонецЕсли; 
	//--- АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> ТЗ № <?""№""> № ИС00-004705
	
КонецПроцедуры

//+++ АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> ТЗ № <?""№"">
Процедура ПроверитьДанныеКонтрагента(НовСтрЗначенияРеквизитов, Параметр, ЕгоИмяВДопРеквизите)
	
	Если НЕ ЗначениеЗаполнено(Параметр) Тогда
		
		НайденнаяСтрока = НовСтрЗначенияРеквизитов.Найти(ЕгоИмяВДопРеквизите, ""Наименование"");
		Если НайденнаяСтрока <> Неопределено Тогда
			Параметр = НайденнаяСтрока.Значение;
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры
//АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy""> ТЗ № <?""№"">"}
},
{4,
{"БУС",1,0,"",""},
{5,
{"КА",1,0,"",""},
{0,
{"ЗадатьСтатусЗаказа",0,0,"","// Недостающие методы в папке Запрос -\ ЗначенияСвойствОбъектов

Процедура АйТи_ПриПроведенииЗаказПокупателяОбработкаПроведения(Источник, Отказ, РежимПроведения) Экспорт
	
	ИсточникСсылка 		= Источник.Ссылка;
	ИсточникЗаказПодтвержден 	= Источник.ЗаказПодтвержден;
	ИсточникДатаПодтверждения 	= Источник.ДатаПодтверждения;
	
	Если ИсточникЗаказПодтвержден И ЗначениеЗаполнено(ИсточникДатаПодтверждения) Тогда
		КодСвойстваЗаказа 		= ""00000000048""; // Свойство заказов
		КодСвойстваДатаОплаты 	= ""00000000057""; // Свойство дата оплаты
		
		НазначениеСвойств 		= ПланыВидовХарактеристик.НазначенияСвойствКатегорийОбъектов.Документ_ЗаказПокупателя;
		ЗначениеСвойстваЗаказа 	= ПолучитьЗначениеСвойстваОбъекта(ИсточникСсылка, КодСвойстваЗаказа, НазначениеСвойств);
		
		КодЗначенияСвойстваНовый 	= ""000000232""; // Новый
		КодЗначенияСвойстваОплачен 	= ""000000233""; // Оплачен
		КодЗначенияСвойстваПодтвержден 	= ""000000236""; // Подтвержден
		КодЗначенияСвойстваОплаченКОтгрузке = ""000000237""; // Оплачен, в стадии отгрузки
		
		//ЗначениеСвойстваНовый 	= ПолучитьЗначениеСвойства(КодСвойстваЗаказа, КодЗначенияСвойстваНовый);
		//ЗначениеСвойстваПодтвержден 	= ПолучитьЗначениеСвойства(КодСвойстваЗаказа, КодЗначенияСвойстваПодтвержден);
		//
		//СвойствоЗаказаУспех 	= ЗаписатьЗначениеСвойства(ИсточникСсылка, КодСвойстваЗаказа, ЗначениеСвойстваПодтвержден); 
		//СвойствоДатаОплатыУспех 	= ЗаписатьЗначениеСвойства(ИсточникСсылка, КодСвойстваДатаОплаты, Справочники.ЗначенияСвойствОбъектов.ПустаяСсылка()); 
		
		ЗадатьСтатусЗаказа(ИсточникСсылка, КодСвойстваЗаказа, КодЗначенияСвойстваОплаченКОтгрузке);
		
		//Сообщить(""Изменён стутус для синхронизации с Битрикс на 'Подтвержден'"");
	Иначе
		
	КонецЕсли;
	
КонецПроцедуры

//Функция ЗадатьСтатусЗаказа
//-------------------------------------------------------------------------
//Параметры:
//		Объект - Ссылка - Ссылка на объект, свойство которого надо получить
//		КодСвойстваЗаказа - Строка - Код свойства, значения которого меняем
//		КодЗначенияСвойства - Строка - Код свойства, значения которого пристваиваем
//		СтиратьДатуОплаты - Булево - Стирать дату, т.к. в случает даты заказ будет в статусе ""оплачен""
//Возвращаемое значение:
//		Булево - Истина, если изменение успешно
//-------------------------------------------------------------------------
//автор: КучеровРМ 07.09.2018
Функция ЗадатьСтатусЗаказа(Объект, КодСвойстваЗаказа, КодЗначенияСвойства, СтиратьДатуОплаты = Истина)

	ЗначениеСвойства 	= ПолучитьЗначениеСвойства(КодСвойстваЗаказа, КодЗначенияСвойства);
	ИзменениеУспех 		= ЗаписатьЗначениеСвойства(Объект, КодСвойстваЗаказа, ЗначениеСвойства); 
	
	Если СтиратьДатуОплаты Тогда
	
		КодСвойстваДатаОплаты 	= ""00000000057""; // Свойство дата оплаты
		СвойствоДатаОплатыУспех = ЗаписатьЗначениеСвойства(Объект, КодСвойстваДатаОплаты, Справочники.ЗначенияСвойствОбъектов.ПустаяСсылка());
	
	КонецЕсли; 
	
	Возврат ИзменениеУспех;
	
КонецФункции // ЗадатьСтатусЗаказа()"}
},
{0,
{"Задать статус заказа при оплате",0,0,"","
Функция ЕстьОплатаЗаказа(ЗаказПокупателяСсылка)
	
	ЕстьОплатаЗаказа = Ложь;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	""ВЫБРАТЬ ПЕРВЫЕ 1
	|	ПлатежноеПоручениеВходящее.Ссылка,
	|	ПлатежноеПоручениеВходящее.ДокументОснование,
	|	ПлатежноеПоручениеВходящее.ДатаОплаты
	|ИЗ
	|	Документ.ПлатежноеПоручениеВходящее КАК ПлатежноеПоручениеВходящее
	|ГДЕ
	|	ПлатежноеПоручениеВходящее.ДокументОснование = &ДокументОснование
	|	И ПлатежноеПоручениеВходящее.Оплачено"";
	
	Запрос.УстановитьПараметр(""ДокументОснование"", ЗаказПокупателяСсылка);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		ЕстьОплатаЗаказа = Истина;
	КонецЕсли; 
	
	Возврат ЕстьОплатаЗаказа
	
КонецФункции // ЕстьОплатаЗаказа()

Процедура АйТи_ПриПроведенииПлатежноеПоручениеОбработкаПроведения(Источник, Отказ, РежимПроведения) Экспорт
	
	ИсточникСсылка 		= Источник.Ссылка;
	ИсточникОплачено 	= Источник.Оплачено;
	ИсточникДатаОплаты 	= Источник.ДатаОплаты;
	ИсточникЗаказПодтвержден 	= Источник.ЗаказПодтвержден;
	
	ИсточникРасшифровкаПлатежа = Источник.РасшифровкаПлатежа;
	
	Сделка = Неопределено;
	Если ИсточникРасшифровкаПлатежа.Количество() > 0 Тогда
		Сделка = ИсточникРасшифровкаПлатежа[0].Сделка;
	КонецЕсли;
	
	КодСвойстваДатаОплаты 	= ""00000000057""; // Свойство дата оплаты
	
	
	Если ЗначениеЗаполнено(Сделка) Тогда
		СделкаЗаказПодтвержден 	= Сделка.ЗаказПодтвержден;
		
		КодСвойстваЗаказа 		= ""00000000048""; // Свойство заказов
		КодСвойстваДатаОплаты 	= ""00000000057""; // Свойство дата оплаты
		
		КодЗначенияСвойстваНовый 	= ""000000232""; // Новый
		КодЗначенияСвойстваОплачен 	= ""000000233""; // Оплачен
		КодЗначенияСвойстваПодтвержден 	= ""000000236""; // Подтвержден
		КодЗначенияСвойстваОплаченКОтгрузке = ""000000237""; // Оплачен, в стадии отгрузки
		
		Если НЕ СделкаЗаказПодтвержден Тогда
			Если ИсточникОплачено ИЛИ ЕстьОплатаЗаказа(Сделка) Тогда
				ЗадатьСтатусЗаказа(Сделка, КодСвойстваЗаказа, КодЗначенияСвойстваОплаченКОтгрузке);
				//Если ЗначениеЗаполнено(ИсточникДатаОплаты) Тогда
				//	НоваяДатаЗаказа 		= Формат(ИсточникДатаОплаты, ""ДФ=yyyy-MM-ddTHH:mm:ss"");
				//	СвойствоДатаОплатыУспех = ЗаписатьЗначениеСвойства(Сделка, КодСвойстваДатаОплаты, НоваяДатаЗаказа);
				//КонецЕсли;
			Иначе
				ЗадатьСтатусЗаказа(Сделка, КодСвойстваЗаказа, КодЗначенияСвойстваНовый);
			КонецЕсли;
		Иначе
			ЗадатьСтатусЗаказа(Сделка, КодСвойстваЗаказа, КодЗначенияСвойстваПодтвержден);	
		КонецЕсли; 
	КонецЕсли;
	
КонецПроцедуры

Процедура АйТи_ПриПроведенииРеализацияТоваровУслугОбработкаПроведения(Источник, Отказ, РежимПроведения) Экспорт
	
	ИсточникСсылка 		= Источник.Ссылка;
	ИсточникПроведен 	= Источник.Проведен;
	ИсточникСделка 		= Источник.Сделка;
	
	Если НЕ ЗначениеЗаполнено(ИсточникСделка) Тогда
		Возврат;	
	КонецЕсли;
	
	КодСвойстваДатаОплаты 	= ""00000000057""; // Свойство дата оплаты
	
	ИсточникСделкаЗаказПодтвержден = ИсточникСделка.ЗаказПодтвержден;
	
	Если ИсточникПроведен Тогда
		КодСвойстваЗаказа 		= ""00000000048""; // Свойство заказов
		КодСвойстваДатаОплаты 	= ""00000000057""; // Свойство дата оплаты
		
		КодЗначенияСвойстваНовый 	= ""000000232""; // Новый
		КодЗначенияСвойстваОплачен 	= ""000000234""; // Оплачен
		КодЗначенияСвойстваПодтвержден 	= ""000000236""; // Подтвержден
		КодЗначенияСвойстваОтправленКлиенту = ""000000233""; // Отправлен клиенту
		
		КодЗначенияСвойстваОплаченКОтгрузке = ""000000237""; // Оплачен, в стадии отгрузки
		
		Если ИсточникСделкаЗаказПодтвержден Тогда
			ЗадатьСтатусЗаказа(ИсточникСделка, КодСвойстваЗаказа, КодЗначенияСвойстваОтправленКлиенту);
		ИначеЕсли ЕстьОплатаЗаказа(ИсточникСделка) Тогда
			ЗадатьСтатусЗаказа(ИсточникСделка, КодСвойстваЗаказа, КодЗначенияСвойстваОплачен);
		//	Если ЗначениеЗаполнено(ИсточникДатаОплаты) Тогда
		//		НоваяДатаЗаказа 		= Формат(ИсточникДатаОплаты, ""ДФ=yyyy-MM-ddTHH:mm:ss"");
		//		СвойствоДатаОплатыУспех = ЗаписатьЗначениеСвойства(ИсточникСделка, КодСвойстваДатаОплаты, НоваяДатаЗаказа);
		//	КонецЕсли;
		//Иначе
		//	ЗадатьСтатусЗаказа(ИсточникСделка, КодСвойстваЗаказа, КодЗначенияСвойстваНовый);
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры
"}
},
{0,
{"Модуль Статусы (загружая инфо о счетах)",0,0,"","
////////////////////////////////////////////////////////////////////////////////
// Влюбленная в свое дело команда ООО «АйТи-Консалтинг»,
// г. Ярославль, ул. Советская, д.69, к.2, этаж 1,
// тел. (4852) 59-33-33, info@allzon.ru,
// https://itcons99.ru/, http://itcons76.ru/
////////////////////////////////////////////////////////////////////////////////

#Область БитриксСтатусы
	
//+++ ====== Битрикс. Статусы [ АйТи КучеровРМ 20.09.2018 ТЗ № ИС00-004698 ] ================================================

////////////////////////////////////////////////////////////////////////////////
// Свойства 

Функция ЗадатьСтатусЗаказа(Объект, КодСвойстваЗаказа, КодЗначенияСвойства, СтиратьДату = Истина)

	ЗначениеСвойства 	= ПолучитьЗначениеСвойства(КодСвойстваЗаказа, КодЗначенияСвойства);
	ИзменениеУспех 		= ЗаписатьЗначениеСвойства(Объект, КодСвойстваЗаказа, ЗначениеСвойства); 
	
	Если СтиратьДату Тогда
		КодСвойстваДатаОплаты 	= ""00000000057""; // Свойство дата оплаты
		СвойствоДатаОплатыУспех = ЗаписатьЗначениеСвойства(Объект, КодСвойстваДатаОплаты, """");
	КонецЕсли; 
	
	Возврат ИзменениеУспех;
	
КонецФункции // ОбновитьСтатусЗаказа()
 
Функция ЗаписатьЗначениеСвойства(ОбъектСсылка, КодСвойстваОбъекта, Значение) 
	
	НаборЗаписейЗначенияСвойств = РегистрыСведений.ЗначенияСвойствОбъектов.СоздатьНаборЗаписей();
	
	Если Значение <> Неопределено Тогда
		Запись 			= НаборЗаписейЗначенияСвойств.Добавить();
		Запись.Объект   = ОбъектСсылка;
		Свойство 		= ПланыВидовХарактеристик.СвойстваОбъектов.НайтиПоКоду(КодСвойстваОбъекта);
		Запись.Свойство = Свойство.Ссылка;
		Запись.Значение = Значение;
		
		НаборЗаписейЗначенияСвойств.Отбор.Объект.Установить(ОбъектСсылка);
		НаборЗаписейЗначенияСвойств.Отбор.Свойство.Установить(Свойство); //.Ссылка
		
		Попытка
			НаборЗаписейЗначенияСвойств.Записать();
			Возврат Истина;
		Исключение
			//Сообщить(""Не удалось записать значения свойств:"" + Символы.ПС + ОписаниеОшибки());
			Возврат Ложь;
		КонецПопытки;
	КонецЕсли;
	
	Возврат Ложь; 
	
КонецФункции

Функция ЗаписатьЗначенияСвойстваСтруктура(ОбъектСсылка, СтруктураСвойства) 
	
	НаборЗаписейЗначенияСвойств = РегистрыСведений.ЗначенияСвойствОбъектов.СоздатьНаборЗаписей();
	
	Если ЗначениеЗаполнено(СтруктураСвойства.Значение) Тогда
		Запись 			= НаборЗаписейЗначенияСвойств.Добавить();
		Запись.Объект   = ОбъектСсылка;
		Свойство 		= ПланыВидовХарактеристик.СвойстваОбъектов.НайтиПоКоду(СтруктураСвойства.КодСвойстваОбъекта);
		Запись.Свойство = Свойство.Ссылка;
		Запись.Значение = СтруктураСвойства.Значение;
	КонецЕсли;
	
	НаборЗаписейЗначенияСвойств.Отбор.Объект.Установить(ОбъектСсылка);
	НаборЗаписейЗначенияСвойств.Отбор.Свойство.Установить(Свойство); //.Ссылка
	
	Попытка
		НаборЗаписейЗначенияСвойств.Записать();
	Исключение
		Сообщить(""Не удалось записать значения свойств:"" + Символы.ПС + ОписаниеОшибки());
		Возврат Ложь;
	КонецПопытки;
	
	Возврат Истина; 
	
КонецФункции

//Функция ПолучитьЗначениеСвойстваОбъекта
//-------------------------------------------------------------------------
//Параметры:
//		Объект - Ссылка - Ссылка на объект, свойство которого надо получить
//		КодСвойстваОбъекта - Строка - Код свойства, значения которого получаем
//		НазначениеСвойств - ПланВидовХарактеристикСсылка.НазначенияСвойствКатегорийОбъектов - Напр., ПланыВидовХарактеристик.НазначенияСвойствКатегорийОбъектов.Справочник_Контрагенты
//		Параметр - Тип - описание
//Возвращаемое значение:
//		СправочникСсылка.ЗначенияСвойствОбъектов - Значение свойства
//-------------------------------------------------------------------------
//автор: КучеровРМ 07.09.2018 
Функция ПолучитьЗначениеСвойстваОбъекта(Объект, КодСвойстваОбъекта, НазначениеСвойств) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	""ВЫБРАТЬ ПЕРВЫЕ 1
	|	СвойстваОбъектов.Наименование КАК СвойстваОбъектовНаименование,
	|	СвойстваОбъектов.ПометкаУдаления КАК ПометкаУдаления,
	|	СвойстваОбъектов.Ссылка КАК Свойство,
	|	ЗначенияСвойствОбъектов.Значение КАК Значение
	|ИЗ
	|	(ВЫБРАТЬ
	|		СвойстваОбъектов.Ссылка КАК Ссылка,
	|		СвойстваОбъектов.Наименование КАК Наименование,
	|		СвойстваОбъектов.ПометкаУдаления КАК ПометкаУдаления
	|	ИЗ
	|		ПланВидовХарактеристик.СвойстваОбъектов КАК СвойстваОбъектов
	|	ГДЕ
	|		СвойстваОбъектов.НазначениеСвойства В(&НазначениеСвойств)) КАК СвойстваОбъектов
	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ЗначенияСвойствОбъектов КАК ЗначенияСвойствОбъектов
	|		ПО (ЗначенияСвойствОбъектов.Свойство = СвойстваОбъектов.Ссылка)
	|			И (ЗначенияСвойствОбъектов.Объект = &ОбъектОтбораЗначений)
	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.НазначенияСвойствОбъектов КАК НазначенияСвойствОбъектов
	|		ПО (НазначенияСвойствОбъектов.Свойство = СвойстваОбъектов.Ссылка)
	|			И (ЗначенияСвойствОбъектов.Значение ЕСТЬ NULL )
	|ГДЕ
	|	(НазначенияСвойствОбъектов.Объект ЕСТЬ NULL 
	|			ИЛИ НазначенияСвойствОбъектов.Объект В (&СписокНазначенийСвойств))
	|	И СвойстваОбъектов.Ссылка.Код = &КодСвойстваОбъекта
	|
	|УПОРЯДОЧИТЬ ПО
	|	СвойстваОбъектовНаименование"";
	
	//КодСвойстваОбъекта 		= ""00000000048"";
	//НазначениеСвойств 		= ПланыВидовХарактеристик.НазначенияСвойствКатегорийОбъектов.Справочник_Контрагенты;
	ОбъектОтбораЗначений 	= Объект;
	СписокНазначенийСвойств = Объект;
	
	Запрос.УстановитьПараметр(""КодСвойстваОбъекта""	, КодСвойстваОбъекта);
	Запрос.УстановитьПараметр(""НазначениеСвойств""	, НазначениеСвойств);
	Запрос.УстановитьПараметр(""ОбъектОтбораЗначений"", ОбъектОтбораЗначений);
	Запрос.УстановитьПараметр(""СписокНазначенийСвойств"", СписокНазначенийСвойств);

	РезультатЗапроса = Запрос.Выполнить();
	
	ЗначениеСвойства = Неопределено;
	Если НЕ РезультатЗапроса.Пустой() Тогда
		ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
		Если ВыборкаДетальныеЗаписи.Следующий() Тогда
			ВыборкаДетальныеЗаписиЗначение = ВыборкаДетальныеЗаписи.Значение;
			Если ВыборкаДетальныеЗаписиЗначение <> NULL Тогда
				ЗначениеСвойства = ВыборкаДетальныеЗаписиЗначение;
			Иначе
				ЗначениеСвойства = Неопределено;
			КонецЕсли
		КонецЕсли;
	КонецЕсли;

	Возврат ЗначениеСвойства;
	
КонецФункции // ПолучитьЗначениеСвойстваОбъекта()

//Функция ПолучитьЗначениеСвойства
//-------------------------------------------------------------------------
//Параметры:
//		КодСвойства - Строка - КодСвойства
//		КодЗначенияСвойства - Строка - КодЗначенияСвойства
//Возвращаемое значение:
//		Массив - Массив Значений заданного свойства, с типом СправочникСсылка.ЗначенияСвойствОбъектов
//		СправочникСсылка.ЗначенияСвойствОбъектов - Значение свойства, если получаем 1 элемент по коду
//		Неопределено - Если элементов 0
//-------------------------------------------------------------------------
//автор: КучеровРМ 07.09.2018 
Функция ПолучитьЗначениеСвойства(КодСвойства, КодЗначенияСвойства = """") Экспорт

	КодЗначенияСвойстваЗаполнен = НЕ ПустаяСтрока(КодЗначенияСвойства);
	Если КодЗначенияСвойстваЗаполнен Тогда
		ЗапросВЫБРАТЬ = ""ПЕРВЫЕ 1"";
		ЗапросКодЗначенияСвойства = ""
		|	И ЗначенияСвойствОбъектов.Код = &КодЗначенияСвойства"";
	Иначе
		ЗапросВЫБРАТЬ = """";
		ЗапросКодЗначенияСвойства = """";
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	""ВЫБРАТЬ "" + ЗапросВЫБРАТЬ + ""
	|	ЗначенияСвойствОбъектов.Ссылка,
	|	ЗначенияСвойствОбъектов.ВерсияДанных,
	|	ЗначенияСвойствОбъектов.ПометкаУдаления,
	|	ЗначенияСвойствОбъектов.Предопределенный,
	|	ЗначенияСвойствОбъектов.Владелец,
	|	ЗначенияСвойствОбъектов.Родитель,
	|	ЗначенияСвойствОбъектов.ЭтоГруппа,
	|	ЗначенияСвойствОбъектов.Код,
	|	ЗначенияСвойствОбъектов.Наименование
	|ИЗ
	|	Справочник.ЗначенияСвойствОбъектов КАК ЗначенияСвойствОбъектов
	|ГДЕ
	|	ЗначенияСвойствОбъектов.Владелец.Код = &КодСвойства"";
	
	Если КодЗначенияСвойстваЗаполнен Тогда // Значит выводим одно значение соогласно переданому коду
		Запрос.Текст = Запрос.Текст + ЗапросКодЗначенияСвойства;
		Запрос.УстановитьПараметр(""КодЗначенияСвойства"", КодЗначенияСвойства);
	КонецЕсли;
	
	Запрос.УстановитьПараметр(""КодСвойства"", КодСвойства);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	ЗначениеСвойства = Новый Массив;
	Если НЕ РезультатЗапроса.Пустой() Тогда
		ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
		Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
			ВыборкаДетальныеЗаписиСсылка = ВыборкаДетальныеЗаписи.Ссылка;
			ЗначениеСвойства.Добавить(ВыборкаДетальныеЗаписиСсылка);
			
			Если КодЗначенияСвойстваЗаполнен Тогда // Значит ожидаем одно значение согласно коду
				Прервать; 	
			КонецЕсли; 
		КонецЦикла;
	КонецЕсли;

	ЗначениеСвойстваКоличество = ЗначениеСвойства.Количество();
	Если ЗначениеСвойстваКоличество > 0 Тогда
		Если ЗначениеСвойстваКоличество > 1 Тогда
			Возврат ЗначениеСвойства;
		Иначе
			Возврат ЗначениеСвойства[0];
		КонецЕсли;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат ЗначениеСвойства; // На всякий случай
	
КонецФункции // ПолучитьЗначениеЗначениеСвойства()

////////////////////////////////////////////////////////////////////////////////
// Битрикс 

Функция ПлатежноеПоручениеУстановитьСвойства(Источник)

	Успех = Ложь;
	
	ИсточникСсылка 		= Источник.Ссылка;
	ИсточникОплачено 	= Источник.Оплачено;
	ИсточникДатаОплаты 	= Источник.ДатаОплаты;
	
	ИсточникРасшифровкаПлатежа = Источник.РасшифровкаПлатежа;
	
	Сделка = Неопределено;
	Если ИсточникРасшифровкаПлатежа.Количество() > 0 Тогда
		Сделка = ИсточникРасшифровкаПлатежа[0].Сделка;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(Сделка) Тогда
		Возврат Успех;	
	КонецЕсли;
	
	КодСвойстваДатаОплаты 	= ""00000000057""; // Свойство дата оплаты
	
	Если ЗначениеЗаполнено(Сделка) Тогда
		СделкаЗаказПодтвержден 	= Сделка.ЗаказПодтвержден;
		
		КодСвойстваЗаказа 		= ""00000000048""; // Свойство заказов
		КодСвойстваДатаОплаты 	= ""00000000057""; // Свойство дата оплаты
		
		КодЗначенияСвойстваНовый 	= ""000000232""; // Новый
		КодЗначенияСвойстваОплачен 	= ""000000233""; // Оплачен
		КодЗначенияСвойстваПодтвержден 	= ""000000236""; // Подтвержден
		КодЗначенияСвойстваОплаченКОтгрузке = ""000000237""; // Оплачен, в стадии отгрузки
		
		ПлатежноеПоручениеДатаОплаты = ""00000000049"";
		
		Если НЕ СделкаЗаказПодтвержден Тогда
			Если ИсточникОплачено ИЛИ ЕстьОплатаЗаказа(Сделка) Тогда
				ЗадатьСтатусЗаказа(Сделка, КодСвойстваЗаказа, КодЗначенияСвойстваОплаченКОтгрузке);
				//Если ЗначениеЗаполнено(ИсточникДатаОплаты) Тогда
				//	НоваяДатаЗаказа 		= Формат(ИсточникДатаОплаты, ""ДФ=yyyy-MM-ddTHH:mm:ss"");
				//	СвойствоДатаОплатыУспех = ЗаписатьЗначениеСвойства(Сделка, КодСвойстваДатаОплаты, НоваяДатаЗаказа);
				//КонецЕсли;
			Иначе
				ЗадатьСтатусЗаказа(Сделка, КодСвойстваЗаказа, КодЗначенияСвойстваНовый);
			КонецЕсли;
			//ЗначениеСвойства 	= ПолучитьЗначениеСвойства(КодСвойстваЗаказа, КодЗначенияСвойства);
			ИзменениеУспех 		= ЗаписатьЗначениеСвойства(ИсточникСсылка, ПлатежноеПоручениеДатаОплаты, """"); // Т.к. на сайте дата оплаты сразу переводит сделку в завершённую
			//ЗадатьСтатусЗаказа(ИсточникСсылка, ПлатежноеПоручениеДатаОплаты, """"); // Т.к. на сайте дата оплаты сразу переводит сделку в завершённую 
		Иначе
			ЗадатьСтатусЗаказа(Сделка, КодСвойстваЗаказа, КодЗначенияСвойстваПодтвержден);	
		КонецЕсли;
		
		Успех = Истина;
		
	КонецЕсли;

	Возврат Успех;
	
КонецФункции // ПлатежноеПоручениеУстановитьСвойства()
 
Функция РеализацияТоваровУслугУстановитьСвойства(Источник)
	
	Успех = Ложь;
	
	ИсточникСсылка 		= Источник.Ссылка;
	ИсточникПроведен 	= Источник.Проведен;
	ИсточникСделка 		= Источник.Сделка;
	
	Если НЕ ЗначениеЗаполнено(ИсточникСделка) Тогда
		Возврат Успех;	
	КонецЕсли;
	
	КодСвойстваДатаОплаты 	= ""00000000057""; // Свойство дата оплаты
	
	ИсточникСделкаЗаказПодтвержден = ИсточникСделка.ЗаказПодтвержден;
	
	Если Истина Тогда // ИсточникПроведен Тогда
		КодСвойстваЗаказа 		= ""00000000048""; // Свойство заказов
		КодСвойстваДатаОплаты 	= ""00000000057""; // Свойство дата оплаты
		
		КодЗначенияСвойстваНовый 	= ""000000232""; // Новый
		КодЗначенияСвойстваОплачен 	= ""000000234""; // Оплачен
		КодЗначенияСвойстваПодтвержден 	= ""000000236""; // Подтвержден
		КодЗначенияСвойстваОтправленКлиенту = ""000000233""; // Отправлен клиенту
		
		КодЗначенияСвойстваОплаченКОтгрузке = ""000000237""; // Оплачен, в стадии отгрузки
		
		Если ИсточникСделкаЗаказПодтвержден Тогда
			ЗадатьСтатусЗаказа(ИсточникСделка, КодСвойстваЗаказа, КодЗначенияСвойстваОтправленКлиенту);
		ИначеЕсли ЕстьОплатаЗаказа(ИсточникСделка) Тогда
			ЗадатьСтатусЗаказа(ИсточникСделка, КодСвойстваЗаказа, КодЗначенияСвойстваОплачен);
			//	Если ЗначениеЗаполнено(ИсточникДатаОплаты) Тогда
			//		НоваяДатаЗаказа 		= Формат(ИсточникДатаОплаты, ""ДФ=yyyy-MM-ddTHH:mm:ss"");
			//		СвойствоДатаОплатыУспех = ЗаписатьЗначениеСвойства(ИсточникСделка, КодСвойстваДатаОплаты, НоваяДатаЗаказа);
			//	КонецЕсли;
			//Иначе
			//	ЗадатьСтатусЗаказа(ИсточникСделка, КодСвойстваЗаказа, КодЗначенияСвойстваНовый);
		КонецЕсли;
		
		Успех = Истина;
		
	КонецЕсли;

	Возврат Успех;	
	
КонецФункции // РеализацияТоваровУслугУстановитьСвойства()

Функция ЕстьОплатаЗаказа(ЗаказПокупателяСсылка) Экспорт
	
	Найден = Ложь;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	""ВЫБРАТЬ ПЕРВЫЕ 1
	|	ПлатежноеПоручениеВходящее.Ссылка,
	|	ПлатежноеПоручениеВходящее.ДокументОснование,
	|	ПлатежноеПоручениеВходящее.ДатаОплаты
	|ИЗ
	|	Документ.ПлатежноеПоручениеВходящее КАК ПлатежноеПоручениеВходящее
	|ГДЕ
	|	ПлатежноеПоручениеВходящее.ДокументОснование = &ДокументОснование
	|	И ПлатежноеПоручениеВходящее.Оплачено
	|	И НЕ ПлатежноеПоручениеВходящее.ПометкаУдаления"";
	
	Запрос.УстановитьПараметр(""ДокументОснование"", ЗаказПокупателяСсылка);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		Найден = Истина;
	КонецЕсли; 
	
	Возврат Найден;
	
КонецФункции // ЕстьОплатаЗаказа()

Функция ЕстьРеализацияЗаказа(ЗаказПокупателяСсылка) Экспорт
	
	Найден = Ложь;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	""ВЫБРАТЬ ПЕРВЫЕ 1
	|	РеализацияТоваровУслуг.Ссылка,
	|	РеализацияТоваровУслуг.Сделка
	|ИЗ
	|	Документ.РеализацияТоваровУслуг КАК РеализацияТоваровУслуг
	|ГДЕ
	|	РеализацияТоваровУслуг.Сделка = &Сделка
	|	И РеализацияТоваровУслуг.Проведен
	|	И НЕ РеализацияТоваровУслуг.ПометкаУдаления"";
	
	Запрос.УстановитьПараметр(""Сделка"", ЗаказПокупателяСсылка);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		Найден = Истина;
	КонецЕсли; 
	
	Возврат Найден;
	
КонецФункции // ЕстьОплатаЗаказа()

Функция СменаСтатуса(Документ) Экспорт 
	
	ДокументОплачен 			= Документ.Оплачен;
	
	ДокументЗаказПодтвержден 	= Документ.Заказ.ЗаказПодтвержден;
	ДокументЗаказ 				= Документ.Заказ;
	
	ЕстьРеализацияЗаказа = ЕстьРеализацияЗаказа(ДокументЗаказ);
	
	// Коды свойств и их значений
	КодСвойстваЗаказа = ""00000000048""; // Свойство заказов
	
	КодЗначенияСвойстваНовый 		= ""000000232""; // Новый
	КодЗначенияСвойстваПодтвержден 	= ""000000236""; // Подтвержден
	КодЗначенияСвойстваОплачен 		= ""000000234""; // Оплачен
	КодЗначенияСвойстваОплаченКОтгрузке = ""000000237""; // Оплачен, в стадии отгрузки
	КодЗначенияСвойстваОтправленКлиенту = ""000000233""; // Отправлен клиенту
	КодЗначенияСвойстваОтправленЖдемОплату = ""000000238""; // Отгружен, ждем оплату
	
	НачальноеСостояниеСтатуса 	= КодЗначенияСвойстваОтправленКлиенту;
	КонечноеСостояниеСтатуса 	= КодЗначенияСвойстваОплачен;
	
	КодЗначениеСвойстваСтатусЗаказа = НачальноеСостояниеСтатуса; //КодЗначенияСвойстваНовый
	
	// Приминение статуса
	Если ДокументЗаказПодтвержден Тогда
		Если ЕстьРеализацияЗаказа И ДокументОплачен Тогда
			КодЗначениеСвойстваСтатусЗаказа = КонечноеСостояниеСтатуса; //КодЗначенияСвойстваОплачен
		ИначеЕсли ЕстьРеализацияЗаказа И НЕ ДокументОплачен Тогда
			КодЗначениеСвойстваСтатусЗаказа = КодЗначенияСвойстваОтправленЖдемОплату; // КодЗначенияСвойстваОтправленКлиенту
		ИначеЕсли НЕ ЕстьРеализацияЗаказа И НЕ ДокументОплачен Тогда
			КодЗначениеСвойстваСтатусЗаказа = КодЗначенияСвойстваПодтвержден;
		ИначеЕсли ДокументОплачен Тогда
			КодЗначениеСвойстваСтатусЗаказа = КодЗначенияСвойстваОплаченКОтгрузке;
		КонецЕсли; 
	Иначе
		Если ДокументОплачен Тогда
			Если ЕстьРеализацияЗаказа Тогда
				КодЗначениеСвойстваСтатусЗаказа = КонечноеСостояниеСтатуса; //КодЗначенияСвойстваОплачен
			Иначе
				КодЗначениеСвойстваСтатусЗаказа = КодЗначенияСвойстваОплаченКОтгрузке;
			КонецЕсли; 
		КонецЕсли;
	КонецЕсли; 
	//ЗадатьСтатусЗаказа(ДокументЗаказ, КодСвойстваЗаказа, КодЗначенияСвойстваОплаченКОтгрузке);	
	
	Если ТипЗнч(Документ.Объект) = Тип(""ДокументСсылка.ЗаказПокупателя"") Тогда
		ЗначениеСвойстваСтатусЗаказа 	= ПолучитьЗначениеСвойства(КодСвойстваЗаказа, КодЗначениеСвойстваСтатусЗаказа);
		Документ.СвойствоСтатусЗаказа 	= ЗначениеСвойстваСтатусЗаказа;
		
		ЗадатьСтатусЗаказа(ДокументЗаказ, КодСвойстваЗаказа, КодЗначениеСвойстваСтатусЗаказа, Ложь); // Это частичная магия, при этом встанет конечное состояние статуса сделки
	КонецЕсли; 
	
	КонечныйСтатус = КодЗначениеСвойстваСтатусЗаказа = КодЗначенияСвойстваОплачен; // Совсем конечный статус (типа ""Выполнен"")
	
	Возврат КонечныйСтатус;
	
КонецФункции // СменаСтатуса()
 
// Дописать в ОМ -\ Б_ПроцедурыИФункцииВыгрузкиДанныхНаСайт 
//-\ ВыгрузитьЗаказXDTO
// После строки: XDTOЗначенияРеквизитов 		= ПараметрыОбмена.МояФабрикаXDTO.Создать(XDTOЗначенияРеквизитовТип); 
////+++ АйТи КучеровРМ 20.09.2018 ТЗ № ИС00-004698
//	Если НЕ Документ.Оплачен Тогда // Это магия, только при этом условии встанет конечное состояние статуса сделки
//		МожноВыводитьИнфоПоОплате 	= АйТи_Доработки.СменаСтатуса(Документ);
//		Документ.Оплачен 			= МожноВыводитьИнфоПоОплате;
//	КонецЕсли;
//	//--- АйТи КучеровРМ 20.09.2018 ТЗ № ИС00-004698
//-\ ВыгрузитьОплатуXDTO
////+++ АйТи КучеровРМ 20.09.2018 ТЗ № ИС00-004698
//	Если НЕ Документ.Проведен Тогда // Это магия, только при этом условии встанет конечное состояние статуса сделки
//		МожноВыводитьИнфоПоОплате 	= АйТи_Доработки.СменаСтатуса(Документ);
//		Документ.Оплачен 			= МожноВыводитьИнфоПоОплате;
//	КонецЕсли; 
//	//--- АйТи КучеровРМ 20.09.2018 ТЗ № ИС00-004698

//--- ====== Битрикс. Статусы [ АйТи КучеровРМ 20.09.2018 ТЗ № ИС00-004698 ] ================================================ 

#КонецОбласти
"}
},
{0,
{"Модуль Статусы (загружая инфо о счетах) (без модификаций)",0,0,"","
////////////////////////////////////////////////////////////////////////////////
// Влюбленная в свое дело команда ООО «АйТи-Консалтинг»,
// г. Ярославль, ул. Советская, д.69, к.2, этаж 1,
// тел. (4852) 59-33-33, info@allzon.ru,
// https://itcons99.ru/, http://itcons76.ru/
////////////////////////////////////////////////////////////////////////////////

#Область БитриксСтатусы
	
//+++ ====== Битрикс. Статусы [ АйТи КучеровРМ 20.09.2018 ТЗ № ИС00-004698 ] ================================================

////////////////////////////////////////////////////////////////////////////////
// Свойства 

Функция ЗадатьСтатусЗаказа(Объект, КодСвойстваЗаказа, КодЗначенияСвойства, СтиратьДату = Истина)

	ЗначениеСвойства 	= ПолучитьЗначениеСвойства(КодСвойстваЗаказа, КодЗначенияСвойства);
	ИзменениеУспех 		= ЗаписатьЗначениеСвойства(Объект, КодСвойстваЗаказа, ЗначениеСвойства); 
	
	Если СтиратьДату Тогда
		КодСвойстваДатаОплаты 	= ""00000000057""; // Свойство дата оплаты
		СвойствоДатаОплатыУспех = ЗаписатьЗначениеСвойства(Объект, КодСвойстваДатаОплаты, """");
	КонецЕсли; 
	
	Возврат ИзменениеУспех;
	
КонецФункции // ОбновитьСтатусЗаказа()
 
Функция ЗаписатьЗначениеСвойства(ОбъектСсылка, КодСвойстваОбъекта, Значение) 
	
	НаборЗаписейЗначенияСвойств = РегистрыСведений.ЗначенияСвойствОбъектов.СоздатьНаборЗаписей();
	
	Если Значение <> Неопределено Тогда
		Запись 			= НаборЗаписейЗначенияСвойств.Добавить();
		Запись.Объект   = ОбъектСсылка;
		Свойство 		= ПланыВидовХарактеристик.СвойстваОбъектов.НайтиПоКоду(КодСвойстваОбъекта);
		Запись.Свойство = Свойство.Ссылка;
		Запись.Значение = Значение;
		
		НаборЗаписейЗначенияСвойств.Отбор.Объект.Установить(ОбъектСсылка);
		НаборЗаписейЗначенияСвойств.Отбор.Свойство.Установить(Свойство); //.Ссылка
		
		Попытка
			НаборЗаписейЗначенияСвойств.Записать();
			Возврат Истина;
		Исключение
			Предупреждение(""Не удалось записать значения свойств:"" + Символы.ПС + ОписаниеОшибки());
			Возврат Ложь;
		КонецПопытки;
	КонецЕсли;
	
	Возврат Ложь; 
	
КонецФункции

Функция ЗаписатьЗначенияСвойстваСтруктура(ОбъектСсылка, СтруктураСвойства) 
	
	НаборЗаписейЗначенияСвойств = РегистрыСведений.ЗначенияСвойствОбъектов.СоздатьНаборЗаписей();
	
	Если ЗначениеЗаполнено(СтруктураСвойства.Значение) Тогда
		Запись 			= НаборЗаписейЗначенияСвойств.Добавить();
		Запись.Объект   = ОбъектСсылка;
		Свойство 		= ПланыВидовХарактеристик.СвойстваОбъектов.НайтиПоКоду(СтруктураСвойства.КодСвойстваОбъекта);
		Запись.Свойство = Свойство.Ссылка;
		Запись.Значение = СтруктураСвойства.Значение;
	КонецЕсли;
	
	НаборЗаписейЗначенияСвойств.Отбор.Объект.Установить(ОбъектСсылка);
	НаборЗаписейЗначенияСвойств.Отбор.Свойство.Установить(Свойство); //.Ссылка
	
	Попытка
		НаборЗаписейЗначенияСвойств.Записать();
	Исключение
		Сообщить(""Не удалось записать значения свойств:"" + Символы.ПС + ОписаниеОшибки());
		Возврат Ложь;
	КонецПопытки;
	
	Возврат Истина; 
	
КонецФункции

//Функция ПолучитьЗначениеСвойстваОбъекта
//-------------------------------------------------------------------------
//Параметры:
//		Объект - Ссылка - Ссылка на объект, свойство которого надо получить
//		КодСвойстваОбъекта - Строка - Код свойства, значения которого получаем
//		НазначениеСвойств - ПланВидовХарактеристикСсылка.НазначенияСвойствКатегорийОбъектов - Напр., ПланыВидовХарактеристик.НазначенияСвойствКатегорийОбъектов.Справочник_Контрагенты
//		Параметр - Тип - описание
//Возвращаемое значение:
//		СправочникСсылка.ЗначенияСвойствОбъектов - Значение свойства
//-------------------------------------------------------------------------
//автор: КучеровРМ 07.09.2018 
Функция ПолучитьЗначениеСвойстваОбъекта(Объект, КодСвойстваОбъекта, НазначениеСвойств) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	""ВЫБРАТЬ ПЕРВЫЕ 1
	|	СвойстваОбъектов.Наименование КАК СвойстваОбъектовНаименование,
	|	СвойстваОбъектов.ПометкаУдаления КАК ПометкаУдаления,
	|	СвойстваОбъектов.Ссылка КАК Свойство,
	|	ЗначенияСвойствОбъектов.Значение КАК Значение
	|ИЗ
	|	(ВЫБРАТЬ
	|		СвойстваОбъектов.Ссылка КАК Ссылка,
	|		СвойстваОбъектов.Наименование КАК Наименование,
	|		СвойстваОбъектов.ПометкаУдаления КАК ПометкаУдаления
	|	ИЗ
	|		ПланВидовХарактеристик.СвойстваОбъектов КАК СвойстваОбъектов
	|	ГДЕ
	|		СвойстваОбъектов.НазначениеСвойства В(&НазначениеСвойств)) КАК СвойстваОбъектов
	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ЗначенияСвойствОбъектов КАК ЗначенияСвойствОбъектов
	|		ПО (ЗначенияСвойствОбъектов.Свойство = СвойстваОбъектов.Ссылка)
	|			И (ЗначенияСвойствОбъектов.Объект = &ОбъектОтбораЗначений)
	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.НазначенияСвойствОбъектов КАК НазначенияСвойствОбъектов
	|		ПО (НазначенияСвойствОбъектов.Свойство = СвойстваОбъектов.Ссылка)
	|			И (ЗначенияСвойствОбъектов.Значение ЕСТЬ NULL )
	|ГДЕ
	|	(НазначенияСвойствОбъектов.Объект ЕСТЬ NULL 
	|			ИЛИ НазначенияСвойствОбъектов.Объект В (&СписокНазначенийСвойств))
	|	И СвойстваОбъектов.Ссылка.Код = &КодСвойстваОбъекта
	|
	|УПОРЯДОЧИТЬ ПО
	|	СвойстваОбъектовНаименование"";
	
	//КодСвойстваОбъекта 		= ""00000000048"";
	//НазначениеСвойств 		= ПланыВидовХарактеристик.НазначенияСвойствКатегорийОбъектов.Справочник_Контрагенты;
	ОбъектОтбораЗначений 	= Объект;
	СписокНазначенийСвойств = Объект;
	
	Запрос.УстановитьПараметр(""КодСвойстваОбъекта""	, КодСвойстваОбъекта);
	Запрос.УстановитьПараметр(""НазначениеСвойств""	, НазначениеСвойств);
	Запрос.УстановитьПараметр(""ОбъектОтбораЗначений"", ОбъектОтбораЗначений);
	Запрос.УстановитьПараметр(""СписокНазначенийСвойств"", СписокНазначенийСвойств);

	РезультатЗапроса = Запрос.Выполнить();
	
	ЗначениеСвойства = Неопределено;
	Если НЕ РезультатЗапроса.Пустой() Тогда
		ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
		Если ВыборкаДетальныеЗаписи.Следующий() Тогда
			ВыборкаДетальныеЗаписиЗначение = ВыборкаДетальныеЗаписи.Значение;
			Если ВыборкаДетальныеЗаписиЗначение <> NULL Тогда
				ЗначениеСвойства = ВыборкаДетальныеЗаписиЗначение;
			Иначе
				ЗначениеСвойства = Неопределено;
			КонецЕсли
		КонецЕсли;
	КонецЕсли;

	Возврат ЗначениеСвойства;
	
КонецФункции // ПолучитьЗначениеСвойстваОбъекта()

//Функция ПолучитьЗначениеСвойства
//-------------------------------------------------------------------------
//Параметры:
//		КодСвойства - Строка - КодСвойства
//		КодЗначенияСвойства - Строка - КодЗначенияСвойства
//Возвращаемое значение:
//		Массив - Массив Значений заданного свойства, с типом СправочникСсылка.ЗначенияСвойствОбъектов
//		СправочникСсылка.ЗначенияСвойствОбъектов - Значение свойства, если получаем 1 элемент по коду
//		Неопределено - Если элементов 0
//-------------------------------------------------------------------------
//автор: КучеровРМ 07.09.2018 
Функция ПолучитьЗначениеСвойства(КодСвойства, КодЗначенияСвойства = """") Экспорт

	КодЗначенияСвойстваЗаполнен = НЕ ПустаяСтрока(КодЗначенияСвойства);
	Если КодЗначенияСвойстваЗаполнен Тогда
		ЗапросВЫБРАТЬ = ""ПЕРВЫЕ 1"";
		ЗапросКодЗначенияСвойства = ""
		|	И ЗначенияСвойствОбъектов.Код = &КодЗначенияСвойства"";
	Иначе
		ЗапросВЫБРАТЬ = """";
		ЗапросКодЗначенияСвойства = """";
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	""ВЫБРАТЬ "" + ЗапросВЫБРАТЬ + ""
	|	ЗначенияСвойствОбъектов.Ссылка,
	|	ЗначенияСвойствОбъектов.ВерсияДанных,
	|	ЗначенияСвойствОбъектов.ПометкаУдаления,
	|	ЗначенияСвойствОбъектов.Предопределенный,
	|	ЗначенияСвойствОбъектов.Владелец,
	|	ЗначенияСвойствОбъектов.Родитель,
	|	ЗначенияСвойствОбъектов.ЭтоГруппа,
	|	ЗначенияСвойствОбъектов.Код,
	|	ЗначенияСвойствОбъектов.Наименование
	|ИЗ
	|	Справочник.ЗначенияСвойствОбъектов КАК ЗначенияСвойствОбъектов
	|ГДЕ
	|	ЗначенияСвойствОбъектов.Владелец.Код = &КодСвойства"";
	
	Если КодЗначенияСвойстваЗаполнен Тогда // Значит выводим одно значение соогласно переданому коду
		Запрос.Текст = Запрос.Текст + ЗапросКодЗначенияСвойства;
		Запрос.УстановитьПараметр(""КодЗначенияСвойства"", КодЗначенияСвойства);
	КонецЕсли;
	
	Запрос.УстановитьПараметр(""КодСвойства"", КодСвойства);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	ЗначениеСвойства = Новый Массив;
	Если НЕ РезультатЗапроса.Пустой() Тогда
		ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
		Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
			ВыборкаДетальныеЗаписиСсылка = ВыборкаДетальныеЗаписи.Ссылка;
			ЗначениеСвойства.Добавить(ВыборкаДетальныеЗаписиСсылка);
			
			Если КодЗначенияСвойстваЗаполнен Тогда // Значит ожидаем одно значение согласно коду
				Прервать; 	
			КонецЕсли; 
		КонецЦикла;
	КонецЕсли;

	ЗначениеСвойстваКоличество = ЗначениеСвойства.Количество();
	Если ЗначениеСвойстваКоличество > 0 Тогда
		Если ЗначениеСвойстваКоличество > 1 Тогда
			Возврат ЗначениеСвойства;
		Иначе
			Возврат ЗначениеСвойства[0];
		КонецЕсли;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат ЗначениеСвойства; // На всякий случай
	
КонецФункции // ПолучитьЗначениеЗначениеСвойства()

////////////////////////////////////////////////////////////////////////////////
// Битрикс 

Функция ПлатежноеПоручениеУстановитьСвойства(Источник)

	Успех = Ложь;
	
	ИсточникСсылка 		= Источник.Ссылка;
	ИсточникОплачено 	= Источник.Оплачено;
	ИсточникДатаОплаты 	= Источник.ДатаОплаты;
	
	ИсточникРасшифровкаПлатежа = Источник.РасшифровкаПлатежа;
	
	Сделка = Неопределено;
	Если ИсточникРасшифровкаПлатежа.Количество() > 0 Тогда
		Сделка = ИсточникРасшифровкаПлатежа[0].Сделка;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(Сделка) Тогда
		Возврат Успех;	
	КонецЕсли;
	
	КодСвойстваДатаОплаты 	= ""00000000057""; // Свойство дата оплаты
	
	Если ЗначениеЗаполнено(Сделка) Тогда
		СделкаЗаказПодтвержден 	= Сделка.ЗаказПодтвержден;
		
		КодСвойстваЗаказа 		= ""00000000048""; // Свойство заказов
		КодСвойстваДатаОплаты 	= ""00000000057""; // Свойство дата оплаты
		
		КодЗначенияСвойстваНовый 	= ""000000232""; // Новый
		КодЗначенияСвойстваОплачен 	= ""000000233""; // Оплачен
		КодЗначенияСвойстваПодтвержден 	= ""000000236""; // Подтвержден
		КодЗначенияСвойстваОплаченКОтгрузке = ""000000237""; // Оплачен, в стадии отгрузки
		
		ПлатежноеПоручениеДатаОплаты = ""00000000049"";
		
		Если НЕ СделкаЗаказПодтвержден Тогда
			Если ИсточникОплачено ИЛИ ЕстьОплатаЗаказа(Сделка) Тогда
				ЗадатьСтатусЗаказа(Сделка, КодСвойстваЗаказа, КодЗначенияСвойстваОплаченКОтгрузке);
				//Если ЗначениеЗаполнено(ИсточникДатаОплаты) Тогда
				//	НоваяДатаЗаказа 		= Формат(ИсточникДатаОплаты, ""ДФ=yyyy-MM-ddTHH:mm:ss"");
				//	СвойствоДатаОплатыУспех = ЗаписатьЗначениеСвойства(Сделка, КодСвойстваДатаОплаты, НоваяДатаЗаказа);
				//КонецЕсли;
			Иначе
				ЗадатьСтатусЗаказа(Сделка, КодСвойстваЗаказа, КодЗначенияСвойстваНовый);
			КонецЕсли;
			//ЗначениеСвойства 	= ПолучитьЗначениеСвойства(КодСвойстваЗаказа, КодЗначенияСвойства);
			ИзменениеУспех 		= ЗаписатьЗначениеСвойства(ИсточникСсылка, ПлатежноеПоручениеДатаОплаты, """"); // Т.к. на сайте дата оплаты сразу переводит сделку в завершённую
			//ЗадатьСтатусЗаказа(ИсточникСсылка, ПлатежноеПоручениеДатаОплаты, """"); // Т.к. на сайте дата оплаты сразу переводит сделку в завершённую 
		Иначе
			ЗадатьСтатусЗаказа(Сделка, КодСвойстваЗаказа, КодЗначенияСвойстваПодтвержден);	
		КонецЕсли;
		
		Успех = Истина;
		
	КонецЕсли;

	Возврат Успех;
	
КонецФункции // ПлатежноеПоручениеУстановитьСвойства()
 
Функция РеализацияТоваровУслугУстановитьСвойства(Источник)
	
	Успех = Ложь;
	
	ИсточникСсылка 		= Источник.Ссылка;
	ИсточникПроведен 	= Источник.Проведен;
	ИсточникСделка 		= Источник.Сделка;
	
	Если НЕ ЗначениеЗаполнено(ИсточникСделка) Тогда
		Возврат Успех;	
	КонецЕсли;
	
	КодСвойстваДатаОплаты 	= ""00000000057""; // Свойство дата оплаты
	
	ИсточникСделкаЗаказПодтвержден = ИсточникСделка.ЗаказПодтвержден;
	
	Если Истина Тогда // ИсточникПроведен Тогда
		КодСвойстваЗаказа 		= ""00000000048""; // Свойство заказов
		КодСвойстваДатаОплаты 	= ""00000000057""; // Свойство дата оплаты
		
		КодЗначенияСвойстваНовый 	= ""000000232""; // Новый
		КодЗначенияСвойстваОплачен 	= ""000000234""; // Оплачен
		КодЗначенияСвойстваПодтвержден 	= ""000000236""; // Подтвержден
		КодЗначенияСвойстваОтправленКлиенту = ""000000233""; // Отправлен клиенту
		
		КодЗначенияСвойстваОплаченКОтгрузке = ""000000237""; // Оплачен, в стадии отгрузки
		
		Если ИсточникСделкаЗаказПодтвержден Тогда
			ЗадатьСтатусЗаказа(ИсточникСделка, КодСвойстваЗаказа, КодЗначенияСвойстваОтправленКлиенту);
		ИначеЕсли ЕстьОплатаЗаказа(ИсточникСделка) Тогда
			ЗадатьСтатусЗаказа(ИсточникСделка, КодСвойстваЗаказа, КодЗначенияСвойстваОплачен);
			//	Если ЗначениеЗаполнено(ИсточникДатаОплаты) Тогда
			//		НоваяДатаЗаказа 		= Формат(ИсточникДатаОплаты, ""ДФ=yyyy-MM-ddTHH:mm:ss"");
			//		СвойствоДатаОплатыУспех = ЗаписатьЗначениеСвойства(ИсточникСделка, КодСвойстваДатаОплаты, НоваяДатаЗаказа);
			//	КонецЕсли;
			//Иначе
			//	ЗадатьСтатусЗаказа(ИсточникСделка, КодСвойстваЗаказа, КодЗначенияСвойстваНовый);
		КонецЕсли;
		
		Успех = Истина;
		
	КонецЕсли;

	Возврат Успех;	
	
КонецФункции // РеализацияТоваровУслугУстановитьСвойства()

Функция ЕстьОплатаЗаказа(ЗаказПокупателяСсылка) Экспорт
	
	Найден = Ложь;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	""ВЫБРАТЬ ПЕРВЫЕ 1
	|	ПлатежноеПоручениеВходящее.Ссылка,
	|	ПлатежноеПоручениеВходящее.ДокументОснование,
	|	ПлатежноеПоручениеВходящее.ДатаОплаты
	|ИЗ
	|	Документ.ПлатежноеПоручениеВходящее КАК ПлатежноеПоручениеВходящее
	|ГДЕ
	|	ПлатежноеПоручениеВходящее.ДокументОснование = &ДокументОснование
	|	И ПлатежноеПоручениеВходящее.Оплачено
	|	И НЕ ПлатежноеПоручениеВходящее.ПометкаУдаления"";
	
	Запрос.УстановитьПараметр(""ДокументОснование"", ЗаказПокупателяСсылка);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		Найден = Истина;
	КонецЕсли; 
	
	Возврат Найден;
	
КонецФункции // ЕстьОплатаЗаказа()

Функция ЕстьРеализацияЗаказа(ЗаказПокупателяСсылка) Экспорт
	
	Найден = Ложь;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	""ВЫБРАТЬ ПЕРВЫЕ 1
	|	РеализацияТоваровУслуг.Ссылка,
	|	РеализацияТоваровУслуг.Сделка
	|ИЗ
	|	Документ.РеализацияТоваровУслуг КАК РеализацияТоваровУслуг
	|ГДЕ
	|	РеализацияТоваровУслуг.Сделка = &Сделка
	|	И РеализацияТоваровУслуг.Проведен
	|	И НЕ РеализацияТоваровУслуг.ПометкаУдаления"";
	
	Запрос.УстановитьПараметр(""Сделка"", ЗаказПокупателяСсылка);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		Найден = Истина;
	КонецЕсли; 
	
	Возврат Найден;
	
КонецФункции // ЕстьОплатаЗаказа()

Функция СменаСтатуса(Документ) Экспорт 
	
	ДокументОплачен 			= Документ.Оплачен;
	
	ДокументЗаказПодтвержден 	= Документ.Заказ.ЗаказПодтвержден;
	ДокументЗаказ 				= Документ.Заказ;
	
	ЕстьРеализацияЗаказа = ЕстьРеализацияЗаказа(ДокументЗаказ);
	
//000000237	Выполнен и оплачен
//000000238	Не оплачен
//000000232	Новый
//000000235	Оплачен, в стадии отгрузки
//000000236	Отгружен, ждем оплату
//000000233	Отправлен клиенту
//000000234	Подтвержден

	// Коды свойств и их значений
	КодСвойстваЗаказа = ""00000000048""; // Свойство заказов
	
	КодЗначенияСвойстваНовый 		= ""000000232""; // Новый
	КодЗначенияСвойстваПодтвержден 	= ""000000234""; // Подтвержден
	КодЗначенияСвойстваОплачен 		= ""000000237""; // Оплачен
	КодЗначенияСвойстваОплаченКОтгрузке = ""000000235""; // Оплачен, в стадии отгрузки
	КодЗначенияСвойстваОтправленКлиенту = ""000000233""; // Отправлен клиенту
	КодЗначенияСвойстваОтправленЖдемОплату = ""000000236""; // Отгружен, ждем оплату
	
	НачальноеСостояниеСтатуса 	= КодЗначенияСвойстваОтправленКлиенту;
	КонечноеСостояниеСтатуса 	= КодЗначенияСвойстваОплачен;
	
	КодЗначениеСвойстваСтатусЗаказа = НачальноеСостояниеСтатуса; //КодЗначенияСвойстваНовый
	
	// Приминение статуса
	Если ДокументЗаказПодтвержден Тогда
		Если ЕстьРеализацияЗаказа И ДокументОплачен Тогда
			КодЗначениеСвойстваСтатусЗаказа = КонечноеСостояниеСтатуса; //КодЗначенияСвойстваОплачен
		ИначеЕсли ЕстьРеализацияЗаказа И НЕ ДокументОплачен Тогда
			КодЗначениеСвойстваСтатусЗаказа = КодЗначенияСвойстваОтправленЖдемОплату; // КодЗначенияСвойстваОтправленКлиенту
		ИначеЕсли НЕ ЕстьРеализацияЗаказа И НЕ ДокументОплачен Тогда
			КодЗначениеСвойстваСтатусЗаказа = КодЗначенияСвойстваПодтвержден;
		ИначеЕсли ДокументОплачен Тогда
			КодЗначениеСвойстваСтатусЗаказа = КодЗначенияСвойстваОплаченКОтгрузке;
		КонецЕсли; 
	Иначе
		Если ДокументОплачен Тогда
			Если ЕстьРеализацияЗаказа Тогда
				КодЗначениеСвойстваСтатусЗаказа = КонечноеСостояниеСтатуса; //КодЗначенияСвойстваОплачен
			Иначе
				КодЗначениеСвойстваСтатусЗаказа = КодЗначенияСвойстваОплаченКОтгрузке;
			КонецЕсли; 
		КонецЕсли;
	КонецЕсли; 
	//ЗадатьСтатусЗаказа(ДокументЗаказ, КодСвойстваЗаказа, КодЗначенияСвойстваОплаченКОтгрузке);	
	
	Если ТипЗнч(Документ.Объект) = Тип(""ДокументСсылка.ЗаказПокупателя"") Тогда
		ЗначениеСвойстваСтатусЗаказа 	= ПолучитьЗначениеСвойства(КодСвойстваЗаказа, КодЗначениеСвойстваСтатусЗаказа);
		Документ.СвойствоСтатусЗаказа 	= ЗначениеСвойстваСтатусЗаказа;
	КонецЕсли; 
	
	КонечныйСтатус = КодЗначениеСвойстваСтатусЗаказа = КодЗначенияСвойстваОплачен; // Совсем конечный статус (типа ""Выполнен"")
	
	Возврат КонечныйСтатус;
	
КонецФункции // СменаСтатуса()
 
// Дописать в ОМ -\ Б_ПроцедурыИФункцииВыгрузкиДанныхНаСайт -\ ВыгрузитьЗаказXDTO
// После строки: XDTOЗначенияРеквизитов 		= ПараметрыОбмена.МояФабрикаXDTO.Создать(XDTOЗначенияРеквизитовТип); 
//МожноВыводитьИнфоПоОплате 	= АйТи_Доработки.СменаСтатуса(Документ);
//Документ.Оплачен 			= МожноВыводитьИнфоПоОплате;

//--- ====== Битрикс. Статусы [ АйТи КучеровРМ 20.09.2018 ТЗ № ИС00-004698 ] ================================================ 

#КонецОбласти
"}
},
{0,
{"Модуль Статусы (НЕ загружая инфо о счетах)",0,0,"","
////////////////////////////////////////////////////////////////////////////////
// Влюбленная в свое дело команда ООО «АйТи-Консалтинг»,
// г. Ярославль, ул. Советская, д.69, к.2, этаж 1,
// тел. (4852) 59-33-33, info@allzon.ru,
// https://itcons99.ru/, http://itcons76.ru/
////////////////////////////////////////////////////////////////////////////////

#Область БитриксСтатусы
	
//+++ ====== Битрикс. Статусы [ АйТи КучеровРМ 20.09.2018 ТЗ № ИС00-004698 ] ================================================

////////////////////////////////////////////////////////////////////////////////
// Свойства 

Функция ЗадатьСтатусЗаказа(Объект, КодСвойстваЗаказа, КодЗначенияСвойства, СтиратьДату = Истина)

	ЗначениеСвойства 	= ПолучитьЗначениеСвойства(КодСвойстваЗаказа, КодЗначенияСвойства);
	ИзменениеУспех 		= ЗаписатьЗначениеСвойства(Объект, КодСвойстваЗаказа, ЗначениеСвойства); 
	
	Если СтиратьДату Тогда
		КодСвойстваДатаОплаты 	= ""00000000057""; // Свойство дата оплаты
		СвойствоДатаОплатыУспех = ЗаписатьЗначениеСвойства(Объект, КодСвойстваДатаОплаты, """");
	КонецЕсли; 
	
	Возврат ИзменениеУспех;
	
КонецФункции // ОбновитьСтатусЗаказа()
 
Функция ЗаписатьЗначениеСвойства(ОбъектСсылка, КодСвойстваОбъекта, Значение) 
	
	НаборЗаписейЗначенияСвойств = РегистрыСведений.ЗначенияСвойствОбъектов.СоздатьНаборЗаписей();
	
	Если Значение <> Неопределено Тогда
		Запись 			= НаборЗаписейЗначенияСвойств.Добавить();
		Запись.Объект   = ОбъектСсылка;
		Свойство 		= ПланыВидовХарактеристик.СвойстваОбъектов.НайтиПоКоду(КодСвойстваОбъекта);
		Запись.Свойство = Свойство.Ссылка;
		Запись.Значение = Значение;
		
		НаборЗаписейЗначенияСвойств.Отбор.Объект.Установить(ОбъектСсылка);
		НаборЗаписейЗначенияСвойств.Отбор.Свойство.Установить(Свойство); //.Ссылка
		
		Попытка
			НаборЗаписейЗначенияСвойств.Записать();
			Возврат Истина;
		Исключение
			//Сообщить(""Не удалось записать значения свойств:"" + Символы.ПС + ОписаниеОшибки());
			Возврат Ложь;
		КонецПопытки;
	КонецЕсли;
	
	Возврат Ложь; 
	
КонецФункции

Функция ЗаписатьЗначенияСвойстваСтруктура(ОбъектСсылка, СтруктураСвойства) 
	
	НаборЗаписейЗначенияСвойств = РегистрыСведений.ЗначенияСвойствОбъектов.СоздатьНаборЗаписей();
	
	Если ЗначениеЗаполнено(СтруктураСвойства.Значение) Тогда
		Запись 			= НаборЗаписейЗначенияСвойств.Добавить();
		Запись.Объект   = ОбъектСсылка;
		Свойство 		= ПланыВидовХарактеристик.СвойстваОбъектов.НайтиПоКоду(СтруктураСвойства.КодСвойстваОбъекта);
		Запись.Свойство = Свойство.Ссылка;
		Запись.Значение = СтруктураСвойства.Значение;
	КонецЕсли;
	
	НаборЗаписейЗначенияСвойств.Отбор.Объект.Установить(ОбъектСсылка);
	НаборЗаписейЗначенияСвойств.Отбор.Свойство.Установить(Свойство); //.Ссылка
	
	Попытка
		НаборЗаписейЗначенияСвойств.Записать();
	Исключение
		Сообщить(""Не удалось записать значения свойств:"" + Символы.ПС + ОписаниеОшибки());
		Возврат Ложь;
	КонецПопытки;
	
	Возврат Истина; 
	
КонецФункции

//Функция ПолучитьЗначениеСвойстваОбъекта
//-------------------------------------------------------------------------
//Параметры:
//		Объект - Ссылка - Ссылка на объект, свойство которого надо получить
//		КодСвойстваОбъекта - Строка - Код свойства, значения которого получаем
//		НазначениеСвойств - ПланВидовХарактеристикСсылка.НазначенияСвойствКатегорийОбъектов - Напр., ПланыВидовХарактеристик.НазначенияСвойствКатегорийОбъектов.Справочник_Контрагенты
//		Параметр - Тип - описание
//Возвращаемое значение:
//		СправочникСсылка.ЗначенияСвойствОбъектов - Значение свойства
//-------------------------------------------------------------------------
//автор: КучеровРМ 07.09.2018 
Функция ПолучитьЗначениеСвойстваОбъекта(Объект, КодСвойстваОбъекта, НазначениеСвойств) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	""ВЫБРАТЬ ПЕРВЫЕ 1
	|	СвойстваОбъектов.Наименование КАК СвойстваОбъектовНаименование,
	|	СвойстваОбъектов.ПометкаУдаления КАК ПометкаУдаления,
	|	СвойстваОбъектов.Ссылка КАК Свойство,
	|	ЗначенияСвойствОбъектов.Значение КАК Значение
	|ИЗ
	|	(ВЫБРАТЬ
	|		СвойстваОбъектов.Ссылка КАК Ссылка,
	|		СвойстваОбъектов.Наименование КАК Наименование,
	|		СвойстваОбъектов.ПометкаУдаления КАК ПометкаУдаления
	|	ИЗ
	|		ПланВидовХарактеристик.СвойстваОбъектов КАК СвойстваОбъектов
	|	ГДЕ
	|		СвойстваОбъектов.НазначениеСвойства В(&НазначениеСвойств)) КАК СвойстваОбъектов
	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ЗначенияСвойствОбъектов КАК ЗначенияСвойствОбъектов
	|		ПО (ЗначенияСвойствОбъектов.Свойство = СвойстваОбъектов.Ссылка)
	|			И (ЗначенияСвойствОбъектов.Объект = &ОбъектОтбораЗначений)
	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.НазначенияСвойствОбъектов КАК НазначенияСвойствОбъектов
	|		ПО (НазначенияСвойствОбъектов.Свойство = СвойстваОбъектов.Ссылка)
	|			И (ЗначенияСвойствОбъектов.Значение ЕСТЬ NULL )
	|ГДЕ
	|	(НазначенияСвойствОбъектов.Объект ЕСТЬ NULL 
	|			ИЛИ НазначенияСвойствОбъектов.Объект В (&СписокНазначенийСвойств))
	|	И СвойстваОбъектов.Ссылка.Код = &КодСвойстваОбъекта
	|
	|УПОРЯДОЧИТЬ ПО
	|	СвойстваОбъектовНаименование"";
	
	//КодСвойстваОбъекта 		= ""00000000048"";
	//НазначениеСвойств 		= ПланыВидовХарактеристик.НазначенияСвойствКатегорийОбъектов.Справочник_Контрагенты;
	ОбъектОтбораЗначений 	= Объект;
	СписокНазначенийСвойств = Объект;
	
	Запрос.УстановитьПараметр(""КодСвойстваОбъекта""	, КодСвойстваОбъекта);
	Запрос.УстановитьПараметр(""НазначениеСвойств""	, НазначениеСвойств);
	Запрос.УстановитьПараметр(""ОбъектОтбораЗначений"", ОбъектОтбораЗначений);
	Запрос.УстановитьПараметр(""СписокНазначенийСвойств"", СписокНазначенийСвойств);

	РезультатЗапроса = Запрос.Выполнить();
	
	ЗначениеСвойства = Неопределено;
	Если НЕ РезультатЗапроса.Пустой() Тогда
		ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
		Если ВыборкаДетальныеЗаписи.Следующий() Тогда
			ВыборкаДетальныеЗаписиЗначение = ВыборкаДетальныеЗаписи.Значение;
			Если ВыборкаДетальныеЗаписиЗначение <> NULL Тогда
				ЗначениеСвойства = ВыборкаДетальныеЗаписиЗначение;
			Иначе
				ЗначениеСвойства = Неопределено;
			КонецЕсли
		КонецЕсли;
	КонецЕсли;

	Возврат ЗначениеСвойства;
	
КонецФункции // ПолучитьЗначениеСвойстваОбъекта()

//Функция ПолучитьЗначениеСвойства
//-------------------------------------------------------------------------
//Параметры:
//		КодСвойства - Строка - КодСвойства
//		КодЗначенияСвойства - Строка - КодЗначенияСвойства
//Возвращаемое значение:
//		Массив - Массив Значений заданного свойства, с типом СправочникСсылка.ЗначенияСвойствОбъектов
//		СправочникСсылка.ЗначенияСвойствОбъектов - Значение свойства, если получаем 1 элемент по коду
//		Неопределено - Если элементов 0
//-------------------------------------------------------------------------
//автор: КучеровРМ 07.09.2018 
Функция ПолучитьЗначениеСвойства(КодСвойства, КодЗначенияСвойства = """") Экспорт

	КодЗначенияСвойстваЗаполнен = НЕ ПустаяСтрока(КодЗначенияСвойства);
	Если КодЗначенияСвойстваЗаполнен Тогда
		ЗапросВЫБРАТЬ = ""ПЕРВЫЕ 1"";
		ЗапросКодЗначенияСвойства = ""
		|	И ЗначенияСвойствОбъектов.Код = &КодЗначенияСвойства"";
	Иначе
		ЗапросВЫБРАТЬ = """";
		ЗапросКодЗначенияСвойства = """";
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	""ВЫБРАТЬ "" + ЗапросВЫБРАТЬ + ""
	|	ЗначенияСвойствОбъектов.Ссылка,
	|	ЗначенияСвойствОбъектов.ВерсияДанных,
	|	ЗначенияСвойствОбъектов.ПометкаУдаления,
	|	ЗначенияСвойствОбъектов.Предопределенный,
	|	ЗначенияСвойствОбъектов.Владелец,
	|	ЗначенияСвойствОбъектов.Родитель,
	|	ЗначенияСвойствОбъектов.ЭтоГруппа,
	|	ЗначенияСвойствОбъектов.Код,
	|	ЗначенияСвойствОбъектов.Наименование
	|ИЗ
	|	Справочник.ЗначенияСвойствОбъектов КАК ЗначенияСвойствОбъектов
	|ГДЕ
	|	ЗначенияСвойствОбъектов.Владелец.Код = &КодСвойства"";
	
	Если КодЗначенияСвойстваЗаполнен Тогда // Значит выводим одно значение соогласно переданому коду
		Запрос.Текст = Запрос.Текст + ЗапросКодЗначенияСвойства;
		Запрос.УстановитьПараметр(""КодЗначенияСвойства"", КодЗначенияСвойства);
	КонецЕсли;
	
	Запрос.УстановитьПараметр(""КодСвойства"", КодСвойства);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	ЗначениеСвойства = Новый Массив;
	Если НЕ РезультатЗапроса.Пустой() Тогда
		ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
		Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
			ВыборкаДетальныеЗаписиСсылка = ВыборкаДетальныеЗаписи.Ссылка;
			ЗначениеСвойства.Добавить(ВыборкаДетальныеЗаписиСсылка);
			
			Если КодЗначенияСвойстваЗаполнен Тогда // Значит ожидаем одно значение согласно коду
				Прервать; 	
			КонецЕсли; 
		КонецЦикла;
	КонецЕсли;

	ЗначениеСвойстваКоличество = ЗначениеСвойства.Количество();
	Если ЗначениеСвойстваКоличество > 0 Тогда
		Если ЗначениеСвойстваКоличество > 1 Тогда
			Возврат ЗначениеСвойства;
		Иначе
			Возврат ЗначениеСвойства[0];
		КонецЕсли;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат ЗначениеСвойства; // На всякий случай
	
КонецФункции // ПолучитьЗначениеЗначениеСвойства()

////////////////////////////////////////////////////////////////////////////////
// Битрикс 

Функция ПлатежноеПоручениеУстановитьСвойства(Источник)

	Успех = Ложь;
	
	ИсточникСсылка 		= Источник.Ссылка;
	ИсточникОплачено 	= Источник.Оплачено;
	ИсточникДатаОплаты 	= Источник.ДатаОплаты;
	
	ИсточникРасшифровкаПлатежа = Источник.РасшифровкаПлатежа;
	
	Сделка = Неопределено;
	Если ИсточникРасшифровкаПлатежа.Количество() > 0 Тогда
		Сделка = ИсточникРасшифровкаПлатежа[0].Сделка;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(Сделка) Тогда
		Возврат Успех;	
	КонецЕсли;
	
	КодСвойстваДатаОплаты 	= ""00000000057""; // Свойство дата оплаты
	
	Если ЗначениеЗаполнено(Сделка) Тогда
		СделкаЗаказПодтвержден 	= Сделка.ЗаказПодтвержден;
		
		КодСвойстваЗаказа 		= ""00000000048""; // Свойство заказов
		КодСвойстваДатаОплаты 	= ""00000000057""; // Свойство дата оплаты
		
		КодЗначенияСвойстваНовый 	= ""000000232""; // Новый
		КодЗначенияСвойстваОплачен 	= ""000000233""; // Оплачен
		КодЗначенияСвойстваПодтвержден 	= ""000000236""; // Подтвержден
		КодЗначенияСвойстваОплаченКОтгрузке = ""000000237""; // Оплачен, в стадии отгрузки
		
		ПлатежноеПоручениеДатаОплаты = ""00000000049"";
		
		Если НЕ СделкаЗаказПодтвержден Тогда
			Если ИсточникОплачено ИЛИ ЕстьОплатаЗаказа(Сделка) Тогда
				ЗадатьСтатусЗаказа(Сделка, КодСвойстваЗаказа, КодЗначенияСвойстваОплаченКОтгрузке);
				//Если ЗначениеЗаполнено(ИсточникДатаОплаты) Тогда
				//	НоваяДатаЗаказа 		= Формат(ИсточникДатаОплаты, ""ДФ=yyyy-MM-ddTHH:mm:ss"");
				//	СвойствоДатаОплатыУспех = ЗаписатьЗначениеСвойства(Сделка, КодСвойстваДатаОплаты, НоваяДатаЗаказа);
				//КонецЕсли;
			Иначе
				ЗадатьСтатусЗаказа(Сделка, КодСвойстваЗаказа, КодЗначенияСвойстваНовый);
			КонецЕсли;
			//ЗначениеСвойства 	= ПолучитьЗначениеСвойства(КодСвойстваЗаказа, КодЗначенияСвойства);
			ИзменениеУспех 		= ЗаписатьЗначениеСвойства(ИсточникСсылка, ПлатежноеПоручениеДатаОплаты, """"); // Т.к. на сайте дата оплаты сразу переводит сделку в завершённую
			//ЗадатьСтатусЗаказа(ИсточникСсылка, ПлатежноеПоручениеДатаОплаты, """"); // Т.к. на сайте дата оплаты сразу переводит сделку в завершённую 
		Иначе
			ЗадатьСтатусЗаказа(Сделка, КодСвойстваЗаказа, КодЗначенияСвойстваПодтвержден);	
		КонецЕсли;
		
		Успех = Истина;
		
	КонецЕсли;

	Возврат Успех;
	
КонецФункции // ПлатежноеПоручениеУстановитьСвойства()
 
Функция РеализацияТоваровУслугУстановитьСвойства(Источник)
	
	Успех = Ложь;
	
	ИсточникСсылка 		= Источник.Ссылка;
	ИсточникПроведен 	= Источник.Проведен;
	ИсточникСделка 		= Источник.Сделка;
	
	Если НЕ ЗначениеЗаполнено(ИсточникСделка) Тогда
		Возврат Успех;	
	КонецЕсли;
	
	КодСвойстваДатаОплаты 	= ""00000000057""; // Свойство дата оплаты
	
	ИсточникСделкаЗаказПодтвержден = ИсточникСделка.ЗаказПодтвержден;
	
	Если Истина Тогда // ИсточникПроведен Тогда
		КодСвойстваЗаказа 		= ""00000000048""; // Свойство заказов
		КодСвойстваДатаОплаты 	= ""00000000057""; // Свойство дата оплаты
		
		КодЗначенияСвойстваНовый 	= ""000000232""; // Новый
		КодЗначенияСвойстваОплачен 	= ""000000234""; // Оплачен
		КодЗначенияСвойстваПодтвержден 	= ""000000236""; // Подтвержден
		КодЗначенияСвойстваОтправленКлиенту = ""000000233""; // Отправлен клиенту
		
		КодЗначенияСвойстваОплаченКОтгрузке = ""000000237""; // Оплачен, в стадии отгрузки
		
		Если ИсточникСделкаЗаказПодтвержден Тогда
			ЗадатьСтатусЗаказа(ИсточникСделка, КодСвойстваЗаказа, КодЗначенияСвойстваОтправленКлиенту);
		ИначеЕсли ЕстьОплатаЗаказа(ИсточникСделка) Тогда
			ЗадатьСтатусЗаказа(ИсточникСделка, КодСвойстваЗаказа, КодЗначенияСвойстваОплачен);
			//	Если ЗначениеЗаполнено(ИсточникДатаОплаты) Тогда
			//		НоваяДатаЗаказа 		= Формат(ИсточникДатаОплаты, ""ДФ=yyyy-MM-ddTHH:mm:ss"");
			//		СвойствоДатаОплатыУспех = ЗаписатьЗначениеСвойства(ИсточникСделка, КодСвойстваДатаОплаты, НоваяДатаЗаказа);
			//	КонецЕсли;
			//Иначе
			//	ЗадатьСтатусЗаказа(ИсточникСделка, КодСвойстваЗаказа, КодЗначенияСвойстваНовый);
		КонецЕсли;
		
		Успех = Истина;
		
	КонецЕсли;

	Возврат Успех;	
	
КонецФункции // РеализацияТоваровУслугУстановитьСвойства()

Функция ЕстьОплатаЗаказа(ЗаказПокупателяСсылка) Экспорт
	
	Найден = Ложь;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	""ВЫБРАТЬ ПЕРВЫЕ 1
	|	ПлатежноеПоручениеВходящее.Ссылка,
	|	ПлатежноеПоручениеВходящее.ДокументОснование,
	|	ПлатежноеПоручениеВходящее.ДатаОплаты
	|ИЗ
	|	Документ.ПлатежноеПоручениеВходящее КАК ПлатежноеПоручениеВходящее
	|ГДЕ
	|	ПлатежноеПоручениеВходящее.ДокументОснование = &ДокументОснование
	|	И ПлатежноеПоручениеВходящее.Оплачено
	|	И НЕ ПлатежноеПоручениеВходящее.ПометкаУдаления"";
	
	Запрос.УстановитьПараметр(""ДокументОснование"", ЗаказПокупателяСсылка);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		Найден = Истина;
	КонецЕсли; 
	
	Возврат Найден;
	
КонецФункции // ЕстьОплатаЗаказа()

Функция ЕстьРеализацияЗаказа(ЗаказПокупателяСсылка) Экспорт
	
	Найден = Ложь;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	""ВЫБРАТЬ ПЕРВЫЕ 1
	|	РеализацияТоваровУслуг.Ссылка,
	|	РеализацияТоваровУслуг.Сделка
	|ИЗ
	|	Документ.РеализацияТоваровУслуг КАК РеализацияТоваровУслуг
	|ГДЕ
	|	РеализацияТоваровУслуг.Сделка = &Сделка
	|	И РеализацияТоваровУслуг.Проведен
	|	И НЕ РеализацияТоваровУслуг.ПометкаУдаления"";
	
	Запрос.УстановитьПараметр(""Сделка"", ЗаказПокупателяСсылка);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		Найден = Истина;
	КонецЕсли; 
	
	Возврат Найден;
	
КонецФункции // ЕстьОплатаЗаказа()

//Функция приминения статуса сделки на сайте (Б24) и в 1С
//-------------------------------------------------------------------------
//Параметры:
//		Документ - Тип - Переменная ""Документ"" из ОМ -\ Б_ПроцедурыИФункцииВыгрузкиДанныхНаСайт -\ ВыгрузитьЗаказXDTO, ВыгрузитьОплатуXDTO
//		ПрименитьСтатус - Булево - Нужно ли применять ""логичный"" статус к документу в 1С (приминяется для изменений документа уже вне изменений файла для отправки на сайт
//Возвращаемое значение:
//		Булево - КонечныйСтатус или МожноПрименитьПромежуточныйСтатус
//-------------------------------------------------------------------------
// ПрименитьПромежуточныйСтатус, т.к. иначе для конечного статуса ""Оплачен"" будет ""Status error"", конечный статус надо применять ничего не меняя,
// после чего надо заказу применить конечный статус ""Оплачено"", иначе он так и не присвоится и он будет ""скакать"" между последним и предпоследним.
// Основная логика такая, что пока на сайт не попадает инфо по оплате (Документ.Оплачен = Ложь), будут меняться промежуточные статусы, а для приминения
// конечного статуса вообще не надо ничего менять до отправки, но после формирования файла выгрузки надо применить конечный статус свойству в заказе. 
//-------------------------------------------------------------------------
//автор: КучеровРМ 09.10.2018 
Функция ПрименитьПромежуточныйСтатус(Документ, ПрименитьСтатус = Ложь) Экспорт

	КодСвойстваЗаказа 			= ""00000000048""; 	// Свойство заказов
	КодЗначенияСвойстваОплачен 	= ""000000234""; 		// Оплачен
	
	ДокументЗаказ 				= Документ.Заказ;
	ДокументОплачен 			= Документ.Оплачен;
	ДокументЗаказПодтвержден 	= Документ.Заказ.ЗаказПодтвержден;
	ЕстьРеализацияЗаказа 		= ЕстьРеализацияЗаказа(ДокументЗаказ);
	
	// Логика приминения статуса
	КодПриминениеСтатуса 		= ПриминениеСтатуса(ДокументЗаказПодтвержден, ЕстьРеализацияЗаказа, ДокументОплачен, КодСвойстваЗаказа, КодЗначенияСвойстваОплачен);
	
	Если ПрименитьСтатус Тогда
		КонечныйСтатус 		= СменаСтатуса(Документ, КодСвойстваЗаказа, КодЗначенияСвойстваОплачен, КодПриминениеСтатуса);
	    Возврат КонечныйСтатус;
	КонецЕсли;
	
	МожноПрименитьПромежуточныйСтатус = КодПриминениеСтатуса <> КодЗначенияСвойстваОплачен;
	
	Если МожноПрименитьПромежуточныйСтатус Тогда
		//Если НЕ Документ.Оплачен Тогда // Это магия, только при этом условии встанет конечное состояние статуса сделки
			КонечныйСтатус 		= СменаСтатуса(Документ, КодСвойстваЗаказа, КодЗначенияСвойстваОплачен, КодПриминениеСтатуса);
			Документ.Оплачен 	= КонечныйСтатус;
		//КонецЕсли;
	Иначе
		
	КонецЕсли;
	
	Возврат МожноПрименитьПромежуточныйСтатус;

КонецФункции // ПрименитьПромежуточныйСтатус()
 
// Тут логика приминения статуса
// Вернёт КодЗначениеСвойстваСтатусЗаказа для приминения в 1С и на сайта
Функция ПриминениеСтатуса(ДокументЗаказПодтвержден, ЕстьРеализацияЗаказа, ДокументОплачен, КодСвойстваЗаказа, КодЗначенияСвойстваОплачен) Экспорт

	// Коды свойств и их значений
	//КодСвойстваЗаказа = ""00000000048""; // Свойство заказов
	
	КодЗначенияСвойстваНовый 		= ""000000232""; // Новый
	КодЗначенияСвойстваПодтвержден 	= ""000000236""; // Подтвержден
	//КодЗначенияСвойстваОплачен 		= ""000000234""; // Оплачен
	КодЗначенияСвойстваОплаченКОтгрузке = ""000000237""; // Оплачен, в стадии отгрузки
	КодЗначенияСвойстваОтправленКлиенту = ""000000233""; // Отправлен клиенту
	КодЗначенияСвойстваОтправленЖдемОплату = ""000000238""; // Отгружен, ждем оплату
	
	НачальноеСостояниеСтатуса 	= КодЗначенияСвойстваОтправленКлиенту;
	КонечноеСостояниеСтатуса 	= КодЗначенияСвойстваОплачен;
	
	КодЗначениеСвойстваСтатусЗаказа = НачальноеСостояниеСтатуса; //КодЗначенияСвойстваНовый
	
	Если ДокументЗаказПодтвержден Тогда
		Если ЕстьРеализацияЗаказа И ДокументОплачен Тогда
			КодЗначениеСвойстваСтатусЗаказа = КонечноеСостояниеСтатуса; //КодЗначенияСвойстваОплачен
		ИначеЕсли ЕстьРеализацияЗаказа И НЕ ДокументОплачен Тогда
			КодЗначениеСвойстваСтатусЗаказа = КодЗначенияСвойстваОтправленЖдемОплату; // КодЗначенияСвойстваОтправленКлиенту
		ИначеЕсли НЕ ЕстьРеализацияЗаказа И НЕ ДокументОплачен Тогда
			КодЗначениеСвойстваСтатусЗаказа = КодЗначенияСвойстваПодтвержден;
		ИначеЕсли ДокументОплачен Тогда
			КодЗначениеСвойстваСтатусЗаказа = КодЗначенияСвойстваОплаченКОтгрузке;
		КонецЕсли; 
	Иначе
		Если ДокументОплачен Тогда
			Если ЕстьРеализацияЗаказа Тогда
				КодЗначениеСвойстваСтатусЗаказа = КонечноеСостояниеСтатуса; //КодЗначенияСвойстваОплачен
			Иначе
				КодЗначениеСвойстваСтатусЗаказа = КодЗначенияСвойстваОплаченКОтгрузке;
			КонецЕсли; 
		КонецЕсли;
	КонецЕсли;
	
	Возврат КодЗначениеСвойстваСтатусЗаказа;

КонецФункции // ПриминениеСтатуса()
 
Функция СменаСтатуса(Документ, КодСвойстваЗаказа, КодЗначенияСвойстваОплачен, КодЗначениеСвойстваСтатусЗаказа) Экспорт 
	
	//ДокументОплачен 			= Документ.Оплачен;
	//ДокументЗаказПодтвержден 	= Документ.Заказ.ЗаказПодтвержден;
	//
	//ЕстьРеализацияЗаказа 		= ЕстьРеализацияЗаказа(ДокументЗаказ);
	
	//КодСвойстваЗаказа 		= ""00000000048""; // Свойство заказов
	
	//КодЗначенияСвойстваОплачен 		= ""000000234""; // Оплачен
	
	// Приминение статуса
	//КодЗначениеСвойстваСтатусЗаказа = ПриминениеСтатуса(ДокументЗаказПодтвержден, ЕстьРеализацияЗаказа, ДокументОплачен, КодСвойстваЗаказа, КодЗначенияСвойстваОплачен);
	
	//ЗадатьСтатусЗаказа(ДокументЗаказ, КодСвойстваЗаказа, КодЗначенияСвойстваОплаченКОтгрузке);	
	
	КонечныйСтатус = КодЗначениеСвойстваСтатусЗаказа = КодЗначенияСвойстваОплачен; // Совсем конечный статус (типа ""Выполнен"")
	Если ТипЗнч(Документ.Объект) = Тип(""ДокументСсылка.ЗаказПокупателя"") Тогда
		ДокументЗаказ 					= Документ.Заказ;
		
		ЗначениеСвойстваСтатусЗаказа 	= ПолучитьЗначениеСвойства(КодСвойстваЗаказа, КодЗначениеСвойстваСтатусЗаказа);
		Документ.СвойствоСтатусЗаказа 	= ЗначениеСвойстваСтатусЗаказа;
		
		КодСвойстваДатаОплаты 	= ""00000000057""; // Свойство дата оплаты
		
		СтиратьДату = НЕ КонечныйСтатус;
		ЗадатьСтатусЗаказа(ДокументЗаказ, КодСвойстваЗаказа, КодЗначениеСвойстваСтатусЗаказа, СтиратьДату); // Это частичная магия, при этом встанет конечное состояние статуса сделки
		//Если КонечныйСтатус Тогда
		//	СвойствоДатаОплатыУспех = ЗаписатьЗначениеСвойства(ДокументЗаказ, КодСвойстваДатаОплаты, Формат(ДокументЗаказ.Дата, ""ДФ=yyyy-MM-ddTHH:mm:ss""));
		//Иначе
		//	СвойствоДатаОплатыУспех = ЗаписатьЗначениеСвойства(ДокументЗаказ, КодСвойстваДатаОплаты, """");
		//КонецЕсли;
	КонецЕсли; 
	
	Возврат КонечныйСтатус;
	
КонецФункции // СменаСтатуса()
 
// Дописать в ОМ -\ Б_ПроцедурыИФункцииВыгрузкиДанныхНаСайт 
//-\ ВыгрузитьЗаказXDTO
// После строки: XDTOЗначенияРеквизитов 		= ПараметрыОбмена.МояФабрикаXDTO.Создать(XDTOЗначенияРеквизитовТип); 
//+++ АйТи КучеровРМ 20.09.2018 ТЗ № ИС00-004698
//АйТи_Доработки.ПрименитьПромежуточныйСтатус(Документ);
//--- АйТи КучеровРМ 20.09.2018 ТЗ № ИС00-004698

//-\ ВыгрузитьОплатуXDTO
//+++ АйТи КучеровРМ 20.09.2018 ТЗ № ИС00-004698
//АйТи_Доработки.ПрименитьПромежуточныйСтатус(Документ);
//--- АйТи КучеровРМ 20.09.2018 ТЗ № ИС00-004698

// -\ ВыгрузитьДокументы
//Для каждого ТекЗаказ из МассивЗаказов Цикл 
//	
//	XDTOДокумент = ВыгрузитьЗаказXDTO(ПараметрыОбмена, лМенеджерВременныхТаблиц, ТекЗаказ, КоличествоЗаказов);
//	XDTOКонтейнер.Документ.Добавить(XDTOДокумент);
//	
//	ВыгруженныеДокументы.Добавить().Объект =  ТекЗаказ.Объект;
//	
//	//+++ АйТи КучеровРМ 20.09.2018 ТЗ № ИС00-004698
//	АйТи_Доработки.ПрименитьПромежуточныйСтатус(ТекЗаказ, Истина); // Чтобы применить конечный статус в 1С, иначе на сайте странно
//	//--- АйТи КучеровРМ 20.09.2018 ТЗ № ИС00-004698
//КонецЦикла;

//--- ====== Битрикс. Статусы [ АйТи КучеровРМ 20.09.2018 ТЗ № ИС00-004698 ] ================================================ 

#КонецОбласти
"}
}
},
{0,
{"Формат даты в свойстве заказа",0,0,"","ДокументДата = Формат(Документ.Дата, ""ДФ=yyyy-MM-ddTHH:mm:ss"");"}
},
{0,
{"1C сервер на Linux и обмен картинками с сайтом на 1C Bitrix",0,0,"","//1C сервер на Linux и обмен картинками с сайтом на 1C bitrix
//https://medium.com/abuga/1c-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80-%D0%BD%D0%B0-linux-%D0%B8-%D0%BE%D0%B1%D0%BC%D0%B5%D0%BD-%D0%BA%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B0%D0%BC%D0%B8-%D1%81-%D1%81%D0%B0%D0%B9%D1%82%D0%BE%D0%BC-%D0%BD%D0%B0-1c-bitrix-760cbf8f9b99

// ОМ -\ Б_ОбменССайтомСервер -\ Функция ПолучитьСписокФайловДляОтправки
// После
//СписокФайлов = Новый СписокЗначений;
//Маска = ""*.*"";

// Добавляем: 
СистемнаяИнформация = Новый СистемнаяИнформация;    
ЭтоLinuxКлиент = СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Linux_x86 ИЛИ СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Linux_x86_64;
Если ЭтоLinuxКлиент Тогда
	Маска = ""*""; // Если просто заменить Маска = ""*.*""; на Маска = ""*""; код будет работать и в Windows и в Linux. 
КонецЕсли;

// ОМ -\ Б_ОбменССайтомСервер -\ Функция ВыгрузитьДанныеНаСайт
// В коде цикла
//Для Каждого ТекФайл Из СписокФайловДляОтправки цикл
// перед строкой
//ОтветСервера = ПолучитьРезультатОтправкиФайлаНаСервер(ПараметрыОбмена, ТекФайл.Значение, Соединение, АдресДляРаботы + НастройкиПодключения.ПараметрЗапросаHTTP_ПередачаФайла + ТекФайл.Представление + Токен, ЗаголовкиЗапросов);

// Вставляем
// А ТУТ ПАТЧ потому что надо менять условия формирования --> ТекФайл.Представление.
// Ну или пересмотреть подход к формированию временого каталога 
СистемнаяИнформация = Новый СистемнаяИнформация;    
ЭтоLinuxКлиент = СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Linux_x86 ИЛИ СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Linux_x86_64;
Если ЭтоLinuxКлиент Тогда
	ТекФайл.Представление = СтрЗаменить(ТекФайл.Представление, КаталогДляВыгрузки + ""/"", """"); 
КонецЕсли;"}
},
{0,
{"Ошибка доступа к файлу",0,0,"","//Изменить в методах:
//ПолучитьРезультатОтправкиФайлаНаСервер
//ПолучитьДанныеССервера

// Функция - получает информацию от сайта процесс загрузки файла 
//
// Параметры:
//  ПараметрыОбмена	 - 	 Настройки узла обмена  
//  ПолноеИмяФайла	 - 	 Полное имя к выгружаемому файлу 
//  Соединение		 - 	 Http соединение к сайту 
//  ПараметрыЗапроса - 	 Параметры http запроса 
//  Заголовки		 - 	 Заголовки http запроса 
// Возвращаемое значение:
//   Ответ сайта 
Функция ПолучитьРезультатОтправкиФайлаНаСервер(ПараметрыОбмена,ПолноеИмяФайла, Соединение, ПараметрыЗапроса="""", Заголовки="""")
	
	ОтветСервера = Неопределено;
	ИмяФайлаОтвета = ПолучитьИмяВременногоФайла();
	
	Попытка
		
		HTTPОтвет = Соединение.ОтправитьДляОбработки(ПолноеИмяФайла, СокрЛП(ПараметрыЗапроса), ИмяФайлаОтвета, СокрЛП(Заголовки));
		ContentType = HTTPОтвет.Заголовки.Получить(""Content-Type"");
		лКодировка 	= Прав(ContentType, СтрДлина(ContentType) - (Найти(ContentType, ""charset="")+7));
		
	Исключение
		
		СообщитьПодробно(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()), ПараметрыОбмена, Истина, Истина);	
	КонецПопытки;
	
	ФайлОтвета = Новый Файл(ИмяФайлаОтвета);
	
	Если ФайлОтвета.Существует() Тогда
		
		//+++ АйТи КучеровРМ 31.10.2018 ТЗ № 0К00-000838
		// Причина заменты кода: иногда ""Ошибка при вызове конструктора""
		//+++ Было до 31.10.2018 12:03:57 // Далее тут старый код, который теперь заменён
		//ЧтениеТекста = Новый ЧтениеТекста(ИмяФайлаОтвета, лКодировка);          
		//--- Было до 31.10.2018 12:03:57
		ОшибкаЧтенияТекста = Ложь;
		Попытка
			
			ЧтениеТекста = Новый ЧтениеТекста(ИмяФайлаОтвета, лКодировка);
			
		Исключение
			ОшибкаЧтенияТекста 	= Истина;
			
			ИмяФайлаОтветаКопия = СтрЗаменить(ИмяФайлаОтвета, "".tmp"", ""_IT_Copy.tmp"");
			КопироватьФайл(ИмяФайлаОтвета, ИмяФайлаОтветаКопия);
			
			ЧтениеТекста = Новый ЧтениеТекста(ИмяФайлаОтветаКопия, лКодировка);
			
			СообщитьПодробно(""Ошибка при чтении файла: "" + ОписаниеОшибки() + Символы.ПС + ""Файл ("" + ИмяФайлаОтвета + "") был скопирован ("" + ИмяФайлаОтветаКопия + "") и прочитан."", ПараметрыОбмена, Истина, Истина);	
		КонецПопытки;
		//--- АйТи КучеровРМ 31.10.2018 ТЗ № 0К00-000838
		
		ТекстОтвета = ЧтениеТекста.Прочитать();
		
		Если НЕ ПустаяСтрока(ТекстОтвета) Тогда
			ОтветСервера = ТекстОтвета;
		Иначе
			СообщитьПодробно(""Получение данных с сервера: Получен пустой ответ сервера."", ПараметрыОбмена, Истина, Истина);	
			
		КонецЕсли;
		
	Иначе
		
		СообщитьПодробно(""Отправка файла на сервер: Ответ сервера не получен."", ПараметрыОбмена, Истина, Истина);	
		
	КонецЕсли;
	
	Попытка
		//+++ АйТи КучеровРМ 31.10.2018 ТЗ № 0К00-000838 >> Сначала проверим на удаление нашу копию, иначе можем словить исключение
		Если ОшибкаЧтенияТекста Тогда
			УдалитьФайлы(КаталогВременныхФайлов(), ИмяФайлаОтветаКопия);
		КонецЕсли;
		//--- АйТи КучеровРМ 31.10.2018 ТЗ № 0К00-000838 >> Сначала проверим на удаление нашу копию, иначе можем словить исключение
		УдалитьФайлы(КаталогВременныхФайлов(), ИмяФайлаОтвета);
		
	Исключение
	КонецПопытки;
	
	Возврат ОтветСервера;
	
КонецФункции"}
}
},
{3,
{"Б24",1,0,"",""},
{0,
{"Б24 Рег задание на синхронизацию + отправка письма",0,0,"","
////////////////////////////////////////////////////////////////////////////////
// АйТи Обмен с Битрикс
// Для пользователя с правами Б24_Роль (Роль по синхронизации с Битрикс24)
////////////////////////////////////////////////////////////////////////////////
 
Процедура ДобавитьВОчередьВыгрузки(СинхронизироватьСправочники = Ложь, СинхронизироватьТовары = Ложь, СинхронизироватьСчета = Ложь)
	
	ТипыДанныхДляОбменаСПорталом 	= Б24_ОбменСПорталомСерверПовтИсп.ПолучитьТипыДанныхДляОбменаСПорталом();
	
	ТипыОперацийСинхронизации 		= Б24_ОбменСПорталомСерверПовтИсп.ПолучитьТипыОперацийСинхронизации();
	
	Запрос = Новый Запрос;
	Запрос.Текст =""ВЫБРАТЬ
	|	Б24_ПакетыВыгрузки.ТипДанных КАК ТипДанных
	|ИЗ
	|	РегистрСведений.Б24_ПакетыВыгрузки КАК Б24_ПакетыВыгрузки
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	Б24_ТаблицаИзменений.ТипДанных
	|ИЗ
	|	РегистрСведений.Б24_ТаблицаИзменений КАК Б24_ТаблицаИзменений"";
	
	тзнДанных = Запрос.Выполнить().Выгрузить();
	тзнДанных.Свернуть(""ТипДанных"");
	
	Если СинхронизироватьСправочники Тогда
		Если тзнДанных.Найти(ТипыДанныхДляОбменаСПорталом.Компания) <> Неопределено тогда
			Б24_ОбменСПорталомВызовСервера.ДобавитьВОчередьВыгрузкиДанных(ТипыОперацийСинхронизации.Компании, Ложь);
		КонецЕсли;
		Если тзнДанных.Найти(ТипыДанныхДляОбменаСПорталом.Контакт) <> Неопределено тогда
			Б24_ОбменСПорталомВызовСервера.ДобавитьВОчередьВыгрузкиДанных(ТипыОперацийСинхронизации.Контакты, Ложь);
		КонецЕсли;
		Если тзнДанных.Найти(ТипыДанныхДляОбменаСПорталом.Реквизит) <> Неопределено тогда
			Б24_ОбменСПорталомВызовСервера.ДобавитьВОчередьВыгрузкиДанных(ТипыОперацийСинхронизации.Реквизиты, Ложь);
		КонецЕсли;
		Если тзнДанных.Найти(ТипыДанныхДляОбменаСПорталом.БанковскийСчетРеквизита) <> Неопределено тогда
			Б24_ОбменСПорталомВызовСервера.ДобавитьВОчередьВыгрузкиДанных(ТипыОперацийСинхронизации.БанковскиеСчета, Ложь);
		КонецЕсли;
		Если тзнДанных.Найти(ТипыДанныхДляОбменаСПорталом.ФактАдресРеквизита) <> Неопределено тогда
			Б24_ОбменСПорталомВызовСервера.ДобавитьВОчередьВыгрузкиДанных(ТипыОперацийСинхронизации.АдресаРеквизитов, Ложь);
		КонецЕсли;
		Если тзнДанных.Найти(ТипыДанныхДляОбменаСПорталом.ЮрАдресРеквизита) <> Неопределено тогда
			Б24_ОбменСПорталомВызовСервера.ДобавитьВОчередьВыгрузкиДанных(ТипыОперацийСинхронизации.АдресаРеквизитов, Ложь); 		
		КонецЕсли;
	КонецЕсли; 
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	
	Если СинхронизироватьТовары Тогда
		Если тзнДанных.Найти(ТипыДанныхДляОбменаСПорталом.ГруппаТовара) <> Неопределено тогда
			Б24_ОбменСПорталомВызовСервера.ДобавитьВОчередьВыгрузкиДанных(ТипыОперацийСинхронизации.ГруппыТоваров, Ложь);
		КонецЕсли;
		Если тзнДанных.Найти(ТипыДанныхДляОбменаСПорталом.ЕдиницаИзмерения) <> Неопределено тогда
			Б24_ОбменСПорталомВызовСервера.ДобавитьВОчередьВыгрузкиДанных(ТипыОперацийСинхронизации.ЕдиницыИзмерения, Ложь);
		КонецЕсли;
		Если тзнДанных.Найти(ТипыДанныхДляОбменаСПорталом.СвойствоТовара) <> Неопределено тогда
			Б24_ОбменСПорталомВызовСервера.ДобавитьВОчередьВыгрузкиДанных(ТипыОперацийСинхронизации.СвойстваТоваров, Ложь);
		КонецЕсли;
		Если тзнДанных.Найти(ТипыДанныхДляОбменаСПорталом.ЗначениеСвойства) <> Неопределено тогда
			Б24_ОбменСПорталомВызовСервера.ДобавитьВОчередьВыгрузкиДанных(ТипыОперацийСинхронизации.СвойстваТоваров, Ложь);
		КонецЕсли;
		Если тзнДанных.Найти(ТипыДанныхДляОбменаСПорталом.Товар) <> Неопределено тогда
			Б24_ОбменСПорталомВызовСервера.ДобавитьВОчередьВыгрузкиДанных(ТипыОперацийСинхронизации.Товары, Ложь);
		КонецЕсли;	
	КонецЕсли; 	
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	
	Если СинхронизироватьСчета Тогда
		Если тзнДанных.Найти(ТипыДанныхДляОбменаСПорталом.Счет) <> Неопределено тогда
			Б24_ОбменСПорталомВызовСервера.ДобавитьВОчередьВыгрузкиДанных(ТипыОперацийСинхронизации.Счета, Ложь);
		КонецЕсли;
		Если тзнДанных.Найти(ТипыДанныхДляОбменаСПорталом.РеквизитыСчета) <> Неопределено тогда
			Б24_ОбменСПорталомВызовСервера.ДобавитьВОчередьВыгрузкиДанных(ТипыОперацийСинхронизации.Счета, Ложь);
		КонецЕсли;
	КонецЕсли; 
	
КонецПроцедуры

Процедура АйТи_Б24_ЗаданиеОбменССайтом() Экспорт
	
	//ДобавитьВОчередьВыгрузки(,,Истина);
	
	ТекПользователь = ИмяПользователя();
	
	Если ТекПользователь = ""ОбменДанными"" Тогда
		
		АдресаПолучателей = Константы.АйТи_Б24_ПочтовыеАдреса.Получить(); // ""@mail.ru""
		
		УстановитьПривилегированныйРежим(Истина);
		
		Б24_ОбменСПорталомКлиентСервер.ВыполнитьСинхронизацию(2, Ложь, Истина, Ложь);
		
		Если НЕ ПустаяСтрока(АдресаПолучателей) Тогда
			Если МожноОтправитьПисьмо() Тогда
				ОтправитьПисьмо(АдресаПолучателей); 
			КонецЕсли;
		КонецЕсли;
		
		УстановитьПривилегированныйРежим(Ложь);
		
	КонецЕсли;

КонецПроцедуры

Функция МожноОтправитьПисьмо(Длительность = 7200)
	
	//Длительность = 7200; // Каждые 2 часа
	ТекДата = ТекущаяДата(); 
	
	ЧасТекДата = Час(ТекДата); 
	Если ЧасТекДата > 8 И ЧасТекДата < 18 Тогда // Рабочее время
		ЗаписьЖурналаПисьма = ПолучитьЗаписьЖурналаРегистрации();
		
		Если ЗаписьЖурналаПисьма = Неопределено Тогда // Записей нет
			// Отправка письма
			Возврат Истина;
		ИначеЕсли ТекДата - ЗаписьЖурналаПисьма > Длительность Тогда 
			Возврат Истина;
		КонецЕсли;
		
	КонецЕсли; 
	
	Возврат Ложь;
	
КонецФункции

Функция ПолучитьЗаписьЖурналаРегистрации()
	
	ТЗ = Новый ТаблицаЗначений;
	ТекДата = ТекущаяДата(); 
	
	ПараметрыОтбора = Новый Структура;
	ПараметрыОтбора.Вставить(""Пользователь"", ""ОбменДанными"");
	ПараметрыОтбора.Вставить(""Комментарий"", ""(АйТи, Б24) Отправка письма о запущенной синхронизации"");
	Колонки = ""Дата"";
	
	ВыгрузитьЖурналРегистрации(ТЗ, ПараметрыОтбора, , , 1);
	
	ТЗКоличество = ТЗ.Количество(); 
	Если ТЗКоличество = 0 Тогда
		Возврат Неопределено;
	ИначеЕсли ТЗКоличество = 1 Тогда
		Возврат ТЗ.ВыгрузитьКолонку(Колонки)[0];
	КонецЕсли;
	
	
КонецФункции // ПолучитьЗаписьЖурналаРегистрации()

Функция ОтправитьПисьмо(АдресаПолучателей)
	
	Если ПустаяСтрока(АдресаПолучателей) Тогда
		Возврат Неопределено;
	КонецЕсли; 
	//Профиль = Справочники.УчетныеЗаписиЭлектроннойПочты.НайтиПоНаименованию(""@mail.ru"");
	Профиль = Справочники.УчетныеЗаписиЭлектроннойПочты.СистемнаяУчетнаяЗаписьЭлектроннойПочты;
	
//  ПараметрыОтправки - Структура - содержит всю необходимую информацию о письме:
//
//   * Кому - Массив, Строка - интернет адреса получателей письма.
//          - Массив - коллекция структур адресов:
//              * Адрес         - Строка - почтовый адрес (должно быть обязательно заполнено).
//              * Представление - Строка - имя адресата.
//          - Строка - интернет адреса получателей письма, разделитель - "";"".
//
//   * ПолучателиСообщения - Массив - массив структур, описывающий получателей:
//      ** Адрес - Строка - Почтовый адрес получателя сообщения.
//      ** Представление - Строка - представление адресата.
//
//   * Копии        - Массив, Строка - адреса получателей копий письма. См. описание поля Кому.
//
//   * СкрытыеКопии - Массив, Строка - адреса получателей скрытых копий письма. См. описание поля Кому.
//
//   * Тема       - Строка - (обязательный) тема почтового сообщения.
//   * Тело       - Строка - (обязательный) текст почтового сообщения (простой текст в кодировке win-1251).

	ПараметрыОтправки = Новый Структура();
	ПараметрыОтправки.Вставить(""Кому"", АдресаПолучателей); // вида, ""йцу@mail.ru"" или несколько через "";"" 
	ПараметрыОтправки.Вставить(""Тема"", ""Синхронизация с Битрикс"");
	ПараметрыОтправки.Вставить(""Тело"", ""Синхронизация с Битрикс в активном состоянии."");
	
	Попытка
		РаботаСПочтовымиСообщениями.ОтправитьПочтовоеСообщение(Профиль, ПараметрыОтправки);
		
		ЗаписьЖурналаРегистрации(""Фоновое задание.Отправка письма"", 
		УровеньЖурналаРегистрации.Информация, Метаданные.ОбщиеМодули.АйТи_Б24_ОбменСПорталомСервер, , ""(АйТи, Б24) Отправка письма о запущенной синхронизации"");
	Исключение
		Сообщить(""Синхронизация с Битрикс. Не удалось подключиться к серверу"");
		Сообщить(ОписаниеОшибки());
	КонецПопытки;
	
КонецФункции // ОтправитьПисьмо()

//Имитация задержки
Процедура Пауза(Длительность) Экспорт
	ДатаНачалаОперации = ТекущаяДата();
	Пока ТекущаяДата() - ДатаНачалаОперации < Длительность Цикл
	КонецЦикла;
КонецПроцедуры

Процедура ТестСообщение(ПутьКПапке = ""D:\"", ИмяФайла = ""1C_Test"")
	
	ТекДата 		= ТекущаяДата();
	ТекДатаСтрока 	= Формат(ТекДата, ""ДФ='yyyy-MM-dd HH-mm-ss'"");
	Пользователь 	= ИмяПользователя();
	Инфо 			= """";
	
	ТекстТест 		= Пользователь + ?(НЕ ПустаяСтрока(Инфо), "" "" + Инфо + "" "", """") + ТекДатаСтрока;
	ТекстДок = Новый ТекстовыйДокумент;
	ТекстДок.ДобавитьСтроку(ТекстТест);
	
	//СетевоеИмяКомпьютера = ИмяКомпьютера();
	//Путь  = ""\\"" + СетевоеИмяКомпьютера + ""\шаблоны\word.doc"";
	ПутьКФайлу = ПутьКПапке + ИмяФайла + ""_"" + ТекДатаСтрока + "".txt""; // Путь сохранения файла
	ТекстДок.Записать(ПутьКФайлу);
	ТекстДок = Неопределено;
	
КонецПроцедуры
"}
},
{0,
{"Получение данных с сайта",0,0,"","Функция Тест4(пОбщиеНастройки, Ид = """") 
	//Получение свойств товаров
	СтруктураДанных = Новый Структура;
	СтруктураДанных.Вставить(""БанкСчета"", Новый Массив);
	
	МетодБанкСчета 	= ""crm.product.list"" + Ид; 	
	//МетодБанкСчета 	= ""crm.product.property.get?id="" + Ид; //Возвращает свойство товаров по идентификатору. 	
	
	ТелоHTTPЗапроса = """";
	ТелоHTTPЗапроса = ТелоHTTPЗапроса + ""&"" + ""cmd[]="" + Б24_Синхр_RestApiВызовСервера.ЗакодироватьСтрокуСервер(МетодБанкСчета);
	
	СтруктураОтвета = Б24_Синхр_RestApiВызовСервера.ОтправкаДанныхНаПорталЧерезBatch(пОбщиеНастройки, ТелоHTTPЗапроса);
	
	Если СтруктураОтвета = Неопределено тогда
		Возврат Справочники.БанковскиеСчета.ПустаяСсылка();
	КонецЕсли;
	
	Result = СтруктураОтвета.Получить(""result"");                                             
	Если result <> Неопределено тогда                                                         
		result2 = result.Получить(""result"");
		Если result2 <> Неопределено тогда 			
			Если result2.Количество() > 0 тогда
				СтруктураДанных.БанкСчета.добавить(result2[0]);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	ИнформацияОБанкСчете = Неопределено; //Б24_Синхр_СинхронизацияВызовСервера.ПолучитьЗначениеПоИдБ24Объекта(пОбщиеНастройки.Портал, пОбщиеНастройки.ТипыОбъектовОбмена.БанковскийСчетРеквизита, Ид);
	
	Если ИнформацияОБанкСчете = Неопределено тогда
		Возврат Справочники.БанковскиеСчета.ПустаяСсылка();	
	Иначе
		Возврат ИнформацияОБанкСчете.Объект; 	
	КонецЕсли;
	
КонецФункции"}
},
{0,
{"ПолучитьСделкуПоИД",0,0,"","Функция АйТи_ПолучитьСделкуПоИД(ОбщиеНастройки,  пИдСделки = """", пИдСчета = """") Экспорт
	
	лРезультат = Неопределено;
	
	лИдСделки 	= Строка(пИдСделки);
	лИдСчета 	= Строка(пИдСчета);
	
	лСразуСделку = НЕ ПустаяСтрока(лИдСделки);
	Если лСразуСделку Тогда
		//Значит сразу ИД сделки, вернём его данные
		Ид 			= лИдСделки;
		МетодЧасть	= ""deal"";
	ИначеЕсли НЕ ПустаяСтрока(лИдСчета) Тогда
		//Значит имеет ИД счета и надо сначала загрузить его, потом из него достать ИД сделки
		Ид 			= лИдСделки;
		МетодЧасть	= ""invoice"";
	КонецЕсли; 
	
	Метод				= ""crm."" + МетодЧасть + "".get?id="" + Ид;
	
	ТелоHTTPЗапроса 	= """";
	ТелоHTTPЗапроса 	= ТелоHTTPЗапроса + ""&"" + ""cmd[]="" + Б24_Синхр_RestApiВызовСервера.ЗакодироватьСтрокуСервер(Метод);
	
	СтруктураОтвета 	= Б24_Синхр_RestApiВызовСервера.ОтправкаДанныхНаПорталЧерезBatch(ОбщиеНастройки, ТелоHTTPЗапроса);
	лМассивДанных 		= АйТи_ПолучитьМассивДанныхСПортала(ОбщиеНастройки, СтруктураОтвета);
	
	Если лСразуСделку Тогда
		лРезультат 		= лМассивДанных;
	Иначе
		лСделкаСчетаИД 	= Б24_Синхр_СинхронизацияВызовСервера.ПолучитьЗначениеПоXML(Тип(""Строка""), Формат(лМассивДанных.Получить(""UF_DEAL_ID""),""ЧГ=0"")); //UF_DEAL_ID	Идентификатор связанной сделки 
		
		лРезультат 		= АйТи_ПолучитьСделкуПоИД(ОбщиеНастройки, лСделкаСчетаИД);
		
	КонецЕсли; 
	
	Возврат лРезультат;
	
КонецФункции // АйТи_ПолучитьСделкуПоИД()

Функция АйТи_ПолучитьМассивДанныхСПортала(ОбщиеНастройки, СтруктураОтвета, ДополнительныйКлюч = Неопределено)
	//ИЗ Б24_Синхр_СинхронизацияКлиентСервер.ОбработатьДанныеСПортала(), начлаьный кусок, полезный
	лДанные = Новый Массив;
	
	Если СтруктураОтвета = Неопределено тогда
		Возврат Неопределено;
	КонецЕсли;
	
	result = СтруктураОтвета.Получить(""result"");
	Если result <> Неопределено тогда
		
		Если ТипЗнч(result)=Тип(""Массив"") тогда
			лДанные = result;	
		Иначе
			
			result2 = result.Получить(""result"");
			Если result2 <> Неопределено Тогда
				Если ДополнительныйКлюч = Неопределено тогда
					
					лДанные = result2[0];
					
				Иначе                 
					
					result3 = result2[0].Получить(ДополнительныйКлюч); //Сразу обращаемся к элементу
					
					лДанные.Добавить(result3);
					
					//Если result3 <> Неопределено тогда
					//	
					//	Для каждого ТекЭлемент из result2 Цикл
					//		мДанных.Добавить(ТекЭлемент);
					//	КонецЦикла;
					//КонецЕсли;
				КонецЕсли;	
			КонецЕсли; 
		КонецЕсли;
		
	КонецЕсли;
	
	Если лДанные.количество() > 0 тогда
		Возврат лДанные;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции
"}
}
}
},
{1,
{"Счета",1,0,"",""},
{3,
{"Задолженность",1,0,"",""},
{0,
{"ПолучитьЗадолженность",0,0,"","Функция ПолучитьЗадолженность(Контрагент)
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	""ВЫБРАТЬ ПЕРВЫЕ 1
	|	ХозрасчетныйОстатки.СуммаОстатокДт КАК СуммаОстатокДт,
	|	ХозрасчетныйОстатки.СуммаОстатокКт КАК СуммаОстатокКт,
	|	ХозрасчетныйОстатки.СуммаОстатокДт - ХозрасчетныйОстатки.СуммаОстатокКт КАК ДтМинусКт
	|ПОМЕСТИТЬ ВТ_Счета
	|ИЗ
	|	РегистрБухгалтерии.Хозрасчетный.Остатки(, Счет В ИЕРАРХИИ (ЗНАЧЕНИЕ(ПланСчетов.Хозрасчетный.РасчетыСПокупателямиИЗаказчиками)), , Субконто1 = &Контрагент) КАК ХозрасчетныйОстатки
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ ПЕРВЫЕ 1
	|	ХозрасчетныйОстатки.СуммаОстатокДт,
	|	ХозрасчетныйОстатки.СуммаОстатокКт,
	|	ХозрасчетныйОстатки.СуммаОстатокДт - ХозрасчетныйОстатки.СуммаОстатокКт
	|ИЗ
	|	РегистрБухгалтерии.Хозрасчетный.Остатки(, Счет В ИЕРАРХИИ (ЗНАЧЕНИЕ(ПланСчетов.Хозрасчетный.РасчетыСПоставщикамиИПодрядчиками)), , Субконто1 = &Контрагент) КАК ХозрасчетныйОстатки
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	СУММА(ВТ_Счета.ДтМинусКт) КАК ДтМинусКт
	|ИЗ
	|	ВТ_Счета КАК ВТ_Счета"";
	
	//Запрос.УстановитьПараметр(""Договор"", Договор);
	Запрос.УстановитьПараметр(""Контрагент"", Контрагент);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
		Если ВыборкаДетальныеЗаписи.Следующий() Тогда
			Возврат ВыборкаДетальныеЗаписи.ДтМинусКт;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции // ПолучитьЗадолженность()
"}
},
{0,
{"ПолучитьЗадолженностьПоДоговору",0,0,"","Функция ПолучитьЗадолженностьПоДоговору(Контрагент, Договор)
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	""ВЫБРАТЬ ПЕРВЫЕ 1
	|	ХозрасчетныйОстатки.СуммаОстатокДт КАК СуммаОстатокДт,
	|	ХозрасчетныйОстатки.СуммаОстатокКт КАК СуммаОстатокКт,
	|	ХозрасчетныйОстатки.СуммаОстатокДт - ХозрасчетныйОстатки.СуммаОстатокКт КАК ДтМинусКт
	|ПОМЕСТИТЬ ВТ_Счета
	|ИЗ
	|	РегистрБухгалтерии.Хозрасчетный.Остатки(
	|			,
	|			Счет В ИЕРАРХИИ (ЗНАЧЕНИЕ(ПланСчетов.Хозрасчетный.РасчетыСПокупателямиИЗаказчиками)),
	|			,
	|			Субконто1 = &Контрагент
	|				И Субконто2 = &Договор) КАК ХозрасчетныйОстатки
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ ПЕРВЫЕ 1
	|	ХозрасчетныйОстатки.СуммаОстатокДт,
	|	ХозрасчетныйОстатки.СуммаОстатокКт,
	|	ХозрасчетныйОстатки.СуммаОстатокДт - ХозрасчетныйОстатки.СуммаОстатокКт
	|ИЗ
	|	РегистрБухгалтерии.Хозрасчетный.Остатки(
	|			,
	|			Счет В ИЕРАРХИИ (ЗНАЧЕНИЕ(ПланСчетов.Хозрасчетный.РасчетыСПоставщикамиИПодрядчиками)),
	|			,
	|			Субконто1 = &Контрагент
	|				И Субконто2 = &Договор) КАК ХозрасчетныйОстатки
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	СУММА(ВТ_Счета.ДтМинусКт) КАК ДтМинусКт
	|ИЗ
	|	ВТ_Счета КАК ВТ_Счета"";
	
	Запрос.УстановитьПараметр(""Договор"", Договор);
	Запрос.УстановитьПараметр(""Контрагент"", Контрагент);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
		Если ВыборкаДетальныеЗаписи.Следующий() Тогда
			Возврат ВыборкаДетальныеЗаписи.ДтМинусКт;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции // ПолучитьЗадолженностьПоДоговору()
"}
},
{0,
{"ПолучитьЗадолженностьПоДоговоруУниверсально",0,0,"","Функция ПолучитьЗадолженностьПоДоговоруУниверсально(Контрагент, Договор = Неопределено)
	
	Запрос = Новый Запрос;
	ЗапросТекст = 
	""ВЫБРАТЬ ПЕРВЫЕ 1
	|	ХозрасчетныйОстатки.СуммаОстатокДт КАК СуммаОстатокДт,
	|	ХозрасчетныйОстатки.СуммаОстатокКт КАК СуммаОстатокКт,
	|	ХозрасчетныйОстатки.СуммаОстатокДт - ХозрасчетныйОстатки.СуммаОстатокКт КАК ДтМинусКт
	|ПОМЕСТИТЬ ВТ_Счета
	|ИЗ
	|	РегистрБухгалтерии.Хозрасчетный.Остатки(
	|			,
	|			Счет В ИЕРАРХИИ (ЗНАЧЕНИЕ(ПланСчетов.Хозрасчетный.РасчетыСПокупателямиИЗаказчиками)),
	|			,
	|			Субконто1 = &Контрагент
	|				И &УчестьДоговор) КАК ХозрасчетныйОстатки
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ ПЕРВЫЕ 1
	|	ХозрасчетныйОстатки.СуммаОстатокДт,
	|	ХозрасчетныйОстатки.СуммаОстатокКт,
	|	ХозрасчетныйОстатки.СуммаОстатокДт - ХозрасчетныйОстатки.СуммаОстатокКт
	|ИЗ
	|	РегистрБухгалтерии.Хозрасчетный.Остатки(
	|			,
	|			Счет В ИЕРАРХИИ (ЗНАЧЕНИЕ(ПланСчетов.Хозрасчетный.РасчетыСПоставщикамиИПодрядчиками)),
	|			,
	|			Субконто1 = &Контрагент
	|				И &УчестьДоговор) КАК ХозрасчетныйОстатки
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	СУММА(ВТ_Счета.ДтМинусКт) КАК ДтМинусКт
	|ИЗ
	|	ВТ_Счета КАК ВТ_Счета"";
	
	Если ЗначениеЗаполнено(Договор) Тогда
		Запрос.Текст = СтрЗаменить(ЗапросТекст, ""И &УчестьДоговор"", ""И Субконто2 = &Договор"");
		Запрос.УстановитьПараметр(""Договор"", Договор);
	Иначе
		Запрос.Текст = СтрЗаменить(ЗапросТекст, ""И &УчестьДоговор"", """");
	КонецЕсли; 
	
	Запрос.УстановитьПараметр(""Контрагент"", Контрагент);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
		Если ВыборкаДетальныеЗаписи.Следующий() Тогда
			Возврат ВыборкаДетальныеЗаписи.ДтМинусКт;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции // ПолучитьЗадолженностьПоДоговоруУниверсально()"}
}
}
},
{4,
{"Буфер обмена",1,0,"",""},
{0,
{"Копирование из Эксель",0,0,"","//Для рабочего стола контент-менеджера понадобилось обеспечить перенос данных из Excel в 1с через буфер обмена.
//Чтобы получить данные из буфера можно воспользоваться COM-Объектом htmlfile. Если скопировать ячейки Excel в буфер обмена то строки будут разделены символами перевода строки, а колонки будут отделяться знаком табуляции.
//Ниже код с примером загрузки данных в таблицу из буфера 

Функция ПолучитьТекстИзБуфераОбмена() Экспорт
	
	#Если Клиент Тогда
		Объект = Новый COMОбъект(""htmlfile"");
		Возврат Объект.ParentWindow.ClipboardData.Getdata(""Text"");
	#КонецЕсли
	
КонецФункции

Процедура ЗапонитьОчередьСБуфера()
	
	ДанныеБуфера = ПолучитьТекстИзБуфераОбмена();
	
	Если СокрЛП(ДанныеБуфера) = """" Тогда
		Сообщить(""Буфер пуст!!!"");
		Возврат;
	КонецЕсли;
	НайденыйСимвол = Найти(ДанныеБуфера,""""+Символы.Таб+""""+Символы.Таб);
	
	//{{ проверка на пустые колонки
	Если НайденыйСимвол <> 0 Тогда
		МассивСтрок = ОбщегоНазначения.РазложитьСтрокуВМассивПодстрок(ДанныеБуфера, Символы.ПС);
		НеВоВсехСтроках = истина;
		Для Каждого СтрокаБуфера из МассивСтрок Цикл 
			НайденыйСимволСтрока = Найти(СтрокаБуфера,""""+Символы.Таб+""""+Символы.Таб);
			
			Если НайденыйСимволСтрока = 0 Тогда
				НеВоВсехСтроках = Ложь;
			КонецЕсли;
		КонецЦикла;
		
		Пока Найти(ДанныеБуфера,""""+Символы.Таб+""""+Символы.Таб) <> 0 Цикл
			ДанныеБуфера = СтрЗаменить(ДанныеБуфера,""""+Символы.Таб+""""+Символы.Таб,Символы.Таб);
		КонецЦикла; 
	КонецЕсли;
	//}} проверка на пустые колонки
	
	МассивСтрок = ОбщегоНазначения.РазложитьСтрокуВМассивПодстрок(ДанныеБуфера, Символы.ПС);
	
	Для Каждого СтрокаБуфера из МассивСтрок Цикл 
		Если СокрЛП(СтрокаБуфера) = """" Тогда
			Продолжить;
		КонецЕсли;
		НовСтрока = ЗаполняемаяТаблица.Добавить();
		МассивПодСтрок = ОбщегоНазначения.РазложитьСтрокуВМассивПодстрок(СтрокаБуфера, Символы.Таб);
		
		Сч = 0;
		Для Каждого ЗначениеКолонки Из  МассивПодСтрок Цикл
			Попытка
				Если ТипЗнч(НовСтрока[Сч]) = Тип(""Строка"") Тогда
					НовСтрока[Сч] = СокрЛП(ЗначениеКолонки);
				ИначеЕсли ТипЗнч(НовСтрока[Сч]) = Тип(""Число"") Тогда
					НовСтрока[Сч] = Число(СокрЛП(ЗначениеКолонки));
				ИначеЕсли ТипЗнч(НовСтрока[Сч]) = Тип(""Булево"") Тогда
					Если Найти(ЗначениеКолонки,""Да"") <> 0 Тогда
						НовСтрока[Сч] = Истина;
					иначе 
						НовСтрока[Сч] = Булево(СокрЛП(ЗначениеКолонки));
					КонецЕсли;
				Иначе 
					НайденыйСправоник = Неопределено;
					ТекТип = Строка(ТипЗнч(НовСтрока[Сч]));
					Для Каждого ТекСправоник ИЗ Метаданные.Справочники Цикл
						Если ТекСправоник.Синоним = СокрЛП(ТекТип) Тогда
							НайденыйСправоник = ТекСправоник;
							Прервать;
						КонецЕсли;
					КонецЦикла;
					Если НайденыйСправоник <> Неопределено Тогда
						НайденыйЭлемент = Справочники[НайденыйСправоник.Имя].НайтиПоНаименованию(СокрЛП(ЗначениеКолонки));
						НовСтрока[Сч] = НайденыйЭлемент;
					КонецЕсли;
				КонецЕсли;
			Исключение
			КонецПопытки;
			Сч = Сч+1;
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры"}
},
{0,
{"COMОбъект(""htmlfile"")",0,0,"","&НаКлиенте
Функция ПолучитьТекстБуфераОбмена() Экспорт
	
	фОбъект = Новый COMОбъект(""htmlfile"");
	Возврат Объект.ParentWindow.ClipboardData.Getdata(""Text"");
	
КонецФункции

&НаКлиенте
Функция УстановитьТекстВБуферОбмена(Текст) Экспорт
	
	фОбъект = Новый COMОбъект(""htmlfile"");
	фОбъект.ParentWindow.ClipboardData.Setdata(""Text"", Текст);
	Возврат Текст;
	
КонецФункции   
"}
},
{0,
{"WScript",0,0,"","// через SendKeys передаем Ctrl-C и Ctrl-V    
wsh=СоздатьОбъект(""WScript.Shell""); 
// Скопировать текст     
wsh.SendKeys(""^c"");  // или так:  wsh.SendKeys(""^(C)"");          
// Вставить текст  
wsh.SendKeys(""^v"");  // или так:  wsh.SendKeys(""^(V)"");  

//Объект Clipboard
WshExtra = СоздатьОбъект(""WshExtra.Clipboard"");  
// Скопировать текст   
WshExtra.Copy(""Запись в буфер обмена"");
// Вставить текст 
Текст = WshExtra.Paste(); "}
},
{0,
{"COMОбъект(""htmlfile"") ОФ И УФ",0,0,"","Для Обычного приложения:

Процедура ЗаписатьТекстВБуферОбмена (пСтрока)
#Если Клиент Тогда
хОбъект = Новый COMОбъект(«htmlfile»);
хОбъект.ParentWindow.ClipboardData.Setdata(«Text», пСтрока);
Возврат;
#КонецЕсли
КонецПроцедуры

Функция ПолучитьТекстИзБуфераОбмена ()
Результат = Неопределено;
#Если Клиент Тогда
хОбъект = Новый COMОбъект(«htmlfile»);
Результат = хОбъект.ParentWindow.ClipboardData.Getdata(«Text»);
#КонецЕсли
Возврат Результат;
КонецФункции

Для Управляемого приложения:

&НаКлиенте
Процедура ЗаписатьТекстВБуферОбмена (пСтрока)
хОбъект = Новый COMОбъект(«htmlfile»);
хОбъект.ParentWindow.ClipboardData.Setdata(«Text», пСтрока);
Возврат;
КонецПроцедуры

&НаКлиенте
Функция ПолучитьТекстИзБуфераОбмена ()
Результат = Неопределено;
хОбъект = Новый COMОбъект(«htmlfile»);
Результат = хОбъект.ParentWindow.ClipboardData.Getdata(«Text»);
Возврат Результат;
КонецФункции"}
}
},
{10,
{"ТЧ и ТЗ",1,0,"",""},
{0,
{"ТЧ_НайтиСтроки",0,0,"НайтиС[трок]","ПараметрыОтбора 	= Новый Структура;
ПараметрыОтбора.Вставить(""Параметр""	, Значение);
НайденныеСтроки 	= <?""Название ТЧ"">.НайтиСтроки(ПараметрыОтбора);

ВыполненоУсловие<?""Условие для поиска строки (Слитно)""> 	= НайденныеСтроки.Количество() > 0;
Если ВыполненоУсловие<?""Условие для поиска строки (Слитно)""> Тогда
	Результат = Истина;
КонецЕсли;"}
},
{0,
{"ТЧ_НайтиСтроки в строку отбора Структурой",0,0,"НайтиС[трок]","НайденныеСтроки 	= <?""Название ТЧ"">.НайтиСтроки(Новый Структура(""Параметр"", Значение));

ВыполненоУсловие<?""Условие для поиска строки (Слитно)""> 	= НайденныеСтроки.Количество() > 0;
Если ВыполненоУсловие<?""Условие для поиска строки (Слитно)""> Тогда
	Результат = Истина;
КонецЕсли;"}
},
{0,
{"ТЧ_ВыгрузитьПоОтбору",0,0,"ТЧ_Выг[рузить]","ПараметрыОтбора = Новый Структура;
ПараметрыОтбора.Вставить(""Параметр"", Значение);
НайденныеСтроки = <?""Название ТЧ"">.НайтиСтроки(ПараметрыОтбора);
Если ЗначениеЗаполнено(НайденныеСтроки) Тогда
	СтрокаТЗ = НайденныеСтроки[0];
КонецЕсли;
<?""Название ТЧ"">Отбор = Источник.<?""Название ТЧ"">.Выгрузить(ПараметрыОтбора);

Если ЗначениеЗаполнено(СтрокаТЗ) Тогда
	
КонецЕсли;"}
},
{0,
{"ТЧ_ВыполнитьПересчетНомерСтроки",0,0,"","&НаКлиентеНаСервереБезКонтекста
Процедура ВыполнитьПересчетНомерСтроки(Таблица)
	
	Инд = 1;
	Для Каждого СтрокаТЧ Из Таблица Цикл
		СтрокаТЧ.НомерСтроки 	= Инд;
		Инд						= Инд + 1;
	КонецЦикла;
	
КонецПроцедуры
"}
},
{0,
{"ТаблицаЗначений в запрос",0,0,"ТЗВЗ[апр]","Запрос 			= Новый Запрос;
Запрос.Текст 	= 
""ВЫБРАТЬ
|	<?""Название внешней таблицы"">.Номенклатура,
|	<?""Название внешней таблицы"">.НомерСтроки КАК НомерСтрокиСортировка
|ПОМЕСТИТЬ ВТ_<?""Название внешней таблицы"">
|ИЗ
|	&ВТ_<?""Название внешней таблицы""> КАК <?""Название внешней таблицы"">
|;"";

Запрос.УстановитьПараметр(""ВТ_<?""Название внешней таблицы"">"", <?""Название внешней таблицы"">);

РезультатЗапроса 	= Запрос.Выполнить();
РезультатТЗ 		= РезультатЗапроса.Выгрузить();"}
},
{0,
{"ТаблицаЗначений в запрос Выполнить",0,0,"ТЗВЗапрВып[олн]","Запрос 			= Новый Запрос;
Запрос.Текст 	= 
""ВЫБРАТЬ
|	<?""Название внешней таблицы"">.Номенклатура,
|	<?""Название внешней таблицы"">.НомерСтроки КАК НомерСтрокиСортировка
|ПОМЕСТИТЬ ВТ_<?""Название внешней таблицы"">
|ИЗ
|	&ВТ_<?""Название внешней таблицы""> КАК <?""Название внешней таблицы"">
|;"";

Запрос.УстановитьПараметр(""ВТ_<?""Название внешней таблицы"">"", <?""Название внешней таблицы"">);

РезультатЗапроса 	= Запрос.Выполнить();
РезультатТЗ 		= РезультатЗапроса.Выгрузить();"}
},
{0,
{"ТаблицаЗначений в запрос создавая таблицу",0,0,"","<?""Название внешней таблицы""> 	= Новый ТаблицаЗначений;
<?""Название внешней таблицы"">.Колонки.Добавить(""Номенклатура"", Новый ОписаниеТипов(""СправочникСсылка.Номенклатура"")); //Иначе ошибка ""Тип не может быть выбран в запросе""

Запрос 			= Новый Запрос;
Запрос.Текст 	= 
""ВЫБРАТЬ
|	<?""Название внешней таблицы"">.Номенклатура,
|	<?""Название внешней таблицы"">.НомерСтроки КАК НомерСтрокиСортировка
|ПОМЕСТИТЬ ВТ_<?""Название внешней таблицы"">
|ИЗ
|	&ВТ_<?""Название внешней таблицы""> КАК <?""Название внешней таблицы"">
|;"";

Запрос.УстановитьПараметр(""ВТ_<?""Название внешней таблицы"">""	, <?""Название внешней таблицы"">);

РезультатЗапроса 	= Запрос.Выполнить();
РезультатТЗ 		= РезультатЗапроса.Выгрузить();"}
},
{0,
{"ТЧ_ПометитьСтроки (дабавляя служебную колонку) (например, удалить строки)",0,0,"ПометитьСтр[оки]","Если <?""Имя таблицы"">.Количество() > 0 Тогда
	<?""Имя таблицы"">Колонка<?""Имя колонки (слитно и обязательно, напр., Пометка)""> = <?""Имя таблицы"">.Колонки.Добавить(""<?""Имя колонки (слитно и обязательно, напр., Пометка)"">"", Новый ОписаниеТипов(""Булево""));
	
	Для каждого <?""Имя таблицы"">Строка Из <?""Имя таблицы""> Цикл
		
		Если Истина Тогда
			<?""Имя таблицы"">Строка.<?""Имя колонки (слитно и обязательно, напр., Пометка)""> = Истина;
		КонецЕсли;
		
	КонецЦикла;
	
	лНайденныеСтроки 	= <?""Имя таблицы"">.НайтиСтроки(Новый Структура(""<?""Имя колонки (слитно и обязательно, напр., Пометка)"">"", Истина));
	
	Если лНайденныеСтроки.Количество() > 0 Тогда
		Для каждого лНайденныеСтрокиСтрока Из лНайденныеСтроки Цикл
			
			<?""Имя таблицы"">.Удалить(лНайденныеСтрокиСтрока);
			
		КонецЦикла;  
	КонецЕсли;	
	
	<?""Имя таблицы"">.Колонки.Удалить(""<?""Имя колонки (слитно и обязательно, напр., Пометка)"">"");
	
КонецЕсли;"}
},
{0,
{"Загрузка файла Ексель в ТЧ",0,0,"","ПутьФайла 		= ""C:\Temp\Buf.xls"";
ДвоичныеДанные 	= ПолучитьИзВременногоХранилища(Адрес);
ДвоичныеДанные.Записать(ПутьФайла);

ТабДок 	= Новый ТабличныйДокумент;
ТабДок.Прочитать(ПутьФайла, СпособЧтенияЗначенийТабличногоДокумента.Значение); 

ПЗ 		= Новый ПостроительЗапроса;
ПЗ.ИсточникДанных 			= Новый ОписаниеИсточникаДанных(ТабДок.Область());
ПЗ.ДобавлениеПредставлений 	= ТипДобавленияПредставлений.НеДобавлять;
ПЗ.ЗаполнитьНастройки();
ПЗ.Выполнить();

ТаблицаЗначений 	= ПЗ.Результат.Выгрузить();"}
},
{0,
{"Записи в Ексель (без Екселя на компьютере)",0,0,"","Способ и записи в ексель без Екселя:
Использовать ""ТабличныйДокумент""
Прям как ПФ делаешь
Только в конце сохраняешь как ексель
"}
}
},
{4,
{"Условное Оформление (УО)",1,0,"",""},
{0,
{"УсловноеОформление",0,0,"условное[оформление]","//Процедура ПрименитьУсловноеОфомление 
//-------------------------------------------------------------------------
//Параметры:
//		ИмяПроверяемогоЭлемента - Строка - Напр., ""Объект.Имя_Проверяемого_Элемента""
//		ИмяОформляемогоЭлемента - Строка - Напр., ""Имя_Оформляемого_Элемента""
//-------------------------------------------------------------------------
//автор: КучеровРМ 30.07.2018 
&НаСервере
Процедура ПрименитьУсловноеОфомление(ИмяПроверяемогоЭлемента, ИмяОформляемогоЭлемента)
	
	ЭлементОформления = УсловноеОформление.Элементы.Добавить();    
	// Создаем условие отбора
	ЭлементОтбора = ЭлементОформления.Отбор.Элементы.Добавить(Тип(""ЭлементОтбораКомпоновкиДанных""));
	ЭлементОтбора.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяПроверяемогоЭлемента); // ИмяПроверяемогоЭлемента = ""Объект.Имя_Проверяемого_Элемента""
	ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно; 
	//Значение для отбора
	ЭлементОтбора.ПравоеЗначение = Истина;
	ЭлементОтбора.Использование = Истина;
	// Установка значения элемента УО
	ЭлементОформления.Оформление.УстановитьЗначениеПараметра(""ЦветТекста"", WebЦвета.Серый);
	ЭлементОформления.Оформление.УстановитьЗначениеПараметра(""Шрифт"", Новый Шрифт(, 10, Истина,,,,,)); //Выделение жирным шрифтом
	// Создаем поля оформления
	ПолеОформления = ЭлементОформления.Поля.Элементы.Добавить();
	ПолеОформления.Поле = Новый ПолеКомпоновкиДанных(ИмяОформляемогоЭлемента); // ИмяОформляемогоЭлемента = ""Имя_Оформляемого_Элемента""
	ПолеОформления.Использование = Истина;
	
КонецПроцедуры
"}
},
{0,
{"Условное Оформление с идентификатором",0,0,"","//Процедура ПрименитьУсловноеОфомление 
//-------------------------------------------------------------------------
//Параметры:
//		ИмяПроверяемогоЭлемента - Строка - Напр., ""Объект.Имя_Проверяемого_Элемента""
//		ВидСравненияКД - ВидСравненияКомпоновкиДанных - ВидСравненияКомпоновкиДанных., напр ВидСравненияКомпоновкиДанных.Равно
//		ПравоеЗначениеОтбора - ЛюбойТип - Ннапр., Истина
//		ИмяОформляемогоЭлемента - Строка - Напр., ""Имя_Оформляемого_Элемента""
//		ИдентификаторПользовательскойНастройки - Строка - Напр., ""ИдентификаторПользовательскойНастройки"" (ИПН), 
//														если заданный ИПН не найден, будет добавлен слемент с этим ИПН
//-------------------------------------------------------------------------
//автор: КучеровРМ 30.07.2018 
&НаСервере
Процедура ПрименитьУсловноеОфомление(ИмяПроверяемогоЭлемента, ВидСравненияКД, ПравоеЗначениеОтбора, ИмяОформляемогоЭлемента, ИдентификаторПользовательскойНастройки = """")
	
	УсловноеОформлениеЭлементы = УсловноеОформление.Элементы;
	
	Если ПустаяСтрока(ИдентификаторПользовательскойНастройки) Тогда
		ПрисвоитьИдентификаторПользовательскойНастройки = ИмяПроверяемогоЭлемента + ""_"" + ИмяОформляемогоЭлемента;
	КонецЕсли;
	
	ЕстьЭлементСИПН = Ложь;
	
	Для каждого ЭлементУО Из УсловноеОформлениеЭлементы Цикл
		
		Если ЭлементУО.ИдентификаторПользовательскойНастройки = ПрисвоитьИдентификаторПользовательскойНастройки Тогда
			ЕстьЭлементСИПН = Истина;
		КонецЕсли; 
		
	КонецЦикла;
	
	Если НЕ ЕстьЭлементСИПН Тогда
		ДобавитьУсловноеОфомление(УсловноеОформлениеЭлементы, ИмяПроверяемогоЭлемента, ВидСравненияКД, ПравоеЗначениеОтбора, ИмяОформляемогоЭлемента, ПрисвоитьИдентификаторПользовательскойНастройки);
	КонецЕсли;
	
КонецПроцедуры

//Процедура ПрименитьУсловноеОфомление 
//-------------------------------------------------------------------------
//Параметры:
//		ИмяПроверяемогоЭлемента - Строка - Напр., ""Объект.Имя_Проверяемого_Элемента""
//		ВидСравненияКД - Строка - ВидСравненияКомпоновкиДанных., напр ВидСравненияКомпоновкиДанных.Равно
//		ПравоеЗначениеОтбора - ЛюбойТип - Ннапр., Истина
//		ИмяОформляемогоЭлемента - Строка - Напр., ""Имя_Оформляемого_Элемента""
//		ИдентификаторПользовательскойНастройки - Строка - Напр., ""ИдентификаторПользовательскойНастройки"" (ИПН), 
//														если заданный ИПН не найден, будет добавлен слемент с этим ИПН
//-------------------------------------------------------------------------
//автор: КучеровРМ 30.07.2018 
&НаСервере
Процедура ДобавитьУсловноеОфомление(УсловноеОформлениеЭлементы, ИмяПроверяемогоЭлемента, ВидСравненияКД, ПравоеЗначениеОтбора, ИмяОформляемогоЭлемента, ИдентификаторПользовательскойНастройки = """")
	
	//УсловноеОформлениеЭлементы = УсловноеОформление.Элементы;
	ЭлементОформления = УсловноеОформлениеЭлементы.Добавить();
	
	ЭлементОформления.ИдентификаторПользовательскойНастройки = ИдентификаторПользовательскойНастройки;
	// Создаем условие отбора
	ЭлементОтбора = ЭлементОформления.Отбор.Элементы.Добавить(Тип(""ЭлементОтбораКомпоновкиДанных""));
	ЭлементОтбора.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяПроверяемогоЭлемента); // ИмяПроверяемогоЭлемента = ""Объект.Имя_Проверяемого_Элемента""
	ЭлементОтбора.ВидСравнения = ВидСравненияКД; 
	//Значение для отбора
	ЭлементОтбора.ПравоеЗначение = ПравоеЗначениеОтбора;
	ЭлементОтбора.Использование = Истина;
	// Установка значения элемента УО
	//ЭлементОформления.Оформление.УстановитьЗначениеПараметра(""ЦветТекста"", WebЦвета.Черный);
	ЭлементОформления.Оформление.УстановитьЗначениеПараметра(""ЦветФона"", WebЦвета.Коралловый); // Томатный, Лосоль
	ЭлементОформления.Оформление.УстановитьЗначениеПараметра(""Шрифт"", Новый Шрифт(, 10, Истина,,,,,)); //Выделение жирным шрифтом
	// Создаем поля оформления
	ПолеОформления = ЭлементОформления.Поля.Элементы.Добавить();
	ПолеОформления.Поле = Новый ПолеКомпоновкиДанных(ИмяОформляемогоЭлемента); // ИмяОформляемогоЭлемента = ""Имя_Оформляемого_Элемента""
	ПолеОформления.Использование = Истина; 
	
КонецПроцедуры
"}
},
{0,
{"Условное оформление с инедтификатором и указанием внешнего вида",0,0,"","//Процедура ПрименитьУсловноеОфомление 
//-------------------------------------------------------------------------
//Параметры:
//		УсловноеОформлениеЭлементы - УсловноеОформление - Напр., ""УсловноеОформление.Элементы"" или для динамического списка ""Список.УсловноеОформление.Элементы""
//		ИмяПроверяемогоЭлемента - Строка - Напр., ""Объект.Имя_Проверяемого_Элемента""
//		ВидСравненияКД - ВидСравненияКомпоновкиДанных - ВидСравненияКомпоновкиДанных., напр ВидСравненияКомпоновкиДанных.Равно
//		ПравоеЗначениеОтбора - ЛюбойТип - Ннапр., Истина
//		ИмяОформляемогоЭлемента - Строка - Напр., ""Имя_Оформляемого_Элемента"". Несколько: ""Имя_Оформляемого_Элемента1,Имя_Оформляемого_Элемента2""
//		ИдентификаторПользовательскойНастройки - Строка - Напр., ""ИдентификаторПользовательскойНастройки"" (ИПН)
//														если заданный ИПН не найден, будет добавлен слемент с этим ИПН
//		ЦветТекста - WebЦвета - Напр., WebЦвета.Черный
//		ЦветФона - WebЦвета - Напр., WebЦвета.Лосоль
//		ЖирныйШрифт - Булево - Напр., Истина
//		СвоеОформление 	- Структура 	- Вида: СвоеОформление = Новый Структура(""ЦветТекста"", WebЦвета.Синий); 
//-------------------------------------------------------------------------
// Для динамического списка (ДС) для даты можно использовать ""Дата.ЧастиДат.Час"".
// Так же для ДС нужно обращаться прямо к реквизитам во всех частях
//-------------------------------------------------------------------------
//автор: КучеровРМ 12.02.2019
&НаСервере
Процедура ПрименитьУсловноеОфомление(УсловноеОформлениеЭлементы, ИмяПроверяемогоЭлемента, ВидСравненияКД, ПравоеЗначениеОтбора, ИмяОформляемогоЭлемента, ИдентификаторПользовательскойНастройки = """", ЦветТекста = Неопределено, ЦветФона = Неопределено, ЖирныйШрифт = Ложь, СвоеОформление = Неопределено) Экспорт
	
	//УсловноеОформлениеЭлементы = УсловноеОформление.Элементы;
	                                       
	Если ПустаяСтрока(ИдентификаторПользовательскойНастройки) Тогда
		ПрисвоитьИдентификаторПользовательскойНастройки 	= ИмяПроверяемогоЭлемента + ""_"" + ИмяОформляемогоЭлемента;
	КонецЕсли;
	
	ЕстьЭлементСИПН 	= Ложь; // ИдентификаторПользовательскойНастройки
	
	Для каждого ЭлементУО Из УсловноеОформлениеЭлементы Цикл
		
		Если ЭлементУО.ИдентификаторПользовательскойНастройки = ПрисвоитьИдентификаторПользовательскойНастройки Тогда
			ЕстьЭлементСИПН = Истина;
		КонецЕсли; 
		
	КонецЦикла;
	
	Если НЕ ЕстьЭлементСИПН Тогда // Добавляем новое условное офомление
		//УсловноеОформлениеЭлементы = УсловноеОформление.Элементы;
		ЭлементОформления = УсловноеОформлениеЭлементы.Добавить();
		
		ЭлементОформления.ИдентификаторПользовательскойНастройки = ПрисвоитьИдентификаторПользовательскойНастройки;
		// Создаем условие отбора
		ЭлементОтбора = ЭлементОформления.Отбор.Элементы.Добавить(Тип(""ЭлементОтбораКомпоновкиДанных""));
		ЭлементОтбора.ЛевоеЗначение 	= Новый ПолеКомпоновкиДанных(ИмяПроверяемогоЭлемента); // ИмяПроверяемогоЭлемента = ""Объект.Имя_Проверяемого_Элемента""
		ЭлементОтбора.ВидСравнения 		= ВидСравненияКД; 
		//Значение для отбора
		ЭлементОтбора.ПравоеЗначение 	= ПравоеЗначениеОтбора;
		ЭлементОтбора.Использование 	= Истина;
		// Установка значения элемента УО
		Если ЦветТекста <> Неопределено Тогда
			ЭлементОформления.Оформление.УстановитьЗначениеПараметра(""ЦветТекста"", ЦветТекста); // WebЦвета.Черный
		КонецЕсли; 
		Если ЦветФона <> Неопределено Тогда
			ЭлементОформления.Оформление.УстановитьЗначениеПараметра(""ЦветФона"", ЦветФона); // Томатный, Лосоль
		КонецЕсли;
		Если ЖирныйШрифт Тогда
			ЭлементОформления.Оформление.УстановитьЗначениеПараметра(""Шрифт"", Новый Шрифт(, 10, Истина,,,,,)); //Выделение жирным шрифтом
		КонецЕсли;
		
		Если СвоеОформление <> Неопределено Тогда
			Для каждого СтруктЭлем Из СвоеОформление Цикл
				
				ЭлементОформления.Оформление.УстановитьЗначениеПараметра(СтруктЭлем.Ключ, СтруктЭлем.Значение);
				
			КонецЦикла; 	
		КонецЕсли; 
		
		// Создаем поля оформления
		ИмяОформляемогоЭлементаМассив 	= СтрРазделить(СтрЗаменить(ИмяОформляемогоЭлемента, "" "", """"), "","", Ложь);
		Для каждого ИмяОформляемогоЭлементаМассивЭлем Из ИмяОформляемогоЭлементаМассив Цикл
			
			ПолеОформления 					= ЭлементОформления.Поля.Элементы.Добавить();
			ПолеОформления.Поле 			= Новый ПолеКомпоновкиДанных(ИмяОформляемогоЭлементаМассивЭлем); // ИмяОформляемогоЭлемента = ""Имя_Оформляемого_Элемента""
			ПолеОформления.Использование 	= Истина;
			
		КонецЦикла; 
		
	КонецЕсли;
	
КонецПроцедуры"}
},
{2,
{"Обычные формы (ОФ)",1,0,"",""},
{0,
{"УО ОФ",0,0,"","Процедура ЗаявкиКлиентаПриПолученииДанных(Элемент, ОформленияСтрок)
	
	Для каждого ОформлениеСтроки из ОформленияСтрок Цикл
		//ф=РаботаСДиалогами.ПолучитьТекстСчетаФактуры(УчетНДС.НайтиПодчиненныйСчетФактуру(ОформлениеСтроки.ДанныеСтроки.Ссылка,""СчетФактураВыданный""));
		//ОформлениеСтроки.Ячейки.СчетФактура.УстановитьТекст(?(ф=""Ввести счет-фактуру"","""",ф));
		//ЦветПогрузка=Новый Цвет(204, 255, 204 );
		//ЦветФона=Новый Цвет(255, 255, 255 );
		//Ф=?(ЯЗСК.ДаПогрузка(ОформлениеСтроки.ДанныеСтроки.Ссылка),204,255);
		//ОформлениеСтроки.ЦветФона=Новый Цвет(р,г,б);
		Если ОформлениеСтроки.ДанныеСтроки.Ссылка.Оплачено Тогда
			//ЦветФона=Новый Цвет(100,255,100);
			ЦветФона=Новый Цвет(176,196,222);
		Иначе
			ЦветФона=Новый Цвет(255, 255, 255 );
		КонецЕсли;
		ОформлениеСтроки.ЦветФона=ЦветФона;
		//кр= 255, 100,100
		//зел= 100, 255, 100
		//жел= 255, 255, 100
		//255, 204, 153
	КонецЦикла;
	
КонецПроцедуры"}
},
{0,
{"Жирный шрифт ОФ",0,0,"","Процедура РасчетПоказателейПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	Если Найти(ДанныеСтроки.Показатель.Наименование, ""Итого"") > 0 Тогда
		Шрифт = Новый Шрифт(ОформлениеСтроки.Шрифт, , , истина);
		Для каждого Ячейка Из ОформлениеСтроки.Ячейки Цикл
			Ячейка.Шрифт = Шрифт;    
		КонецЦикла;
	КонецЕсли;    
	
КонецПроцедуры"}
}
}
},
{2,
{"Транзакции",1,0,"",""},
{0,
{"НачатьТранзакцию",0,0,"НачатьТр[анзакцию]","НачатьТранзакцию();

<?>

ЗафиксироватьТранзакцию();"}
},
{0,
{"Начать с учетом ошибок",0,0,"","НачатьТранзакцию();

Попытка
	// Действия в транзакции
	<?>
Исключение
	Если ТранзакцияАктивна() Тогда
		ОтменитьТранзакцию();
	КонецЕсли;
	ВызватьИсключение;
КонецПопытки;

ЗафиксироватьТранзакцию();"}
}
},
{4,
{"Обычне формы",1,0,"",""},
{1,
{"Таблица",1,0,"",""},
{1,
{"Ячейки",1,0,"",""},
{0,
{"УстановитьТекстСостояния",0,0,"","// По переданныму состоянию документа устанавливает текст ячеек
//
// Параметры:
//	СостояниеДокумента - строка таблицы значений с состоянием текущей строки
//  Ячейки - фиксированную коллекцию значений ОформлениеЯчейки
//
Процедура УстановитьТекстСостояния(СостояниеДокумента, Ячейки) Экспорт
	
	ИменаЯчеек = Новый Массив;
	ИменаЯчеек.Добавить(""ХарактерВыплаты"");
	ИменаЯчеек.Добавить(""КОСГУ"");
	ИменаЯчеек.Добавить(""СтатьяФинансирования"");
	
	Если СостояниеДокумента <> Неопределено Тогда
		Для Каждого ИмяЯчейки Из ИменаЯчеек Цикл
			Ячейки[ИмяЯчейки].УстановитьТекст(СостояниеДокумента[ИмяЯчейки])
		КонецЦикла;	
	КонецЕсли;
	
КонецПроцедуры
"}
}
}
},
{0,
{"Свойства кнопок в ОсновныеДействияФормы",0,0,"","ЭлементыФормы.ОсновныеДействияФормы.Кнопки.<?""Имя кнопки (слитно)"">.Доступность = Ложь;"}
},
{0,
{"УстановитьКартинкиВСтрокахТЧ (ОФ)",0,0,"","Процедура ТоварыПриПолученииДанных(Элемент, ОформленияСтрок)
	
	РаботаСДиалогами.УстановитьКартинкиВСтрокахТЧ(ОформленияСтрок, мКартинкаСерийныеНомера, мКартинкаНаборКомплект);
	
КонецПроцедуры

Процедура УстановитьКартинкиВСтрокахТЧ(ОформленияСтрок, КартинкаСерийныеНомера, КартинкаНаборКомплект, ЕстьСерийныеНомера = Истина, ЕстьСоставНабора = Истина) Экспорт
	
	Если ОформленияСтрок.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	МассивНоменклатуры = Новый Массив;
	Для каждого ОформлениеСтроки Из ОформленияСтрок Цикл
		МассивНоменклатуры.Добавить(ОформлениеСтроки.ДанныеСтроки.Номенклатура);
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр(""МассивНоменклатуры"", МассивНоменклатуры);
	Запрос.Текст =
	""ВЫБРАТЬ
	|	Номенклатура.Ссылка КАК Номенклатура,""
	+ ?(ЕстьСерийныеНомера, ""
	|	Номенклатура.ВестиСерийныеНомера КАК ВестиСерийныеНомера"", """")
	+ ?(ЕстьСоставНабора, ?(ЕстьСерийныеНомера, "","", """") + ""
	|	Номенклатура.Комплект КАК Комплект"", """") + ""
	|ИЗ
	|	Справочник.Номенклатура КАК Номенклатура
	|ГДЕ
	|	Номенклатура.Ссылка В(&МассивНоменклатуры)"";
	
	ТаблицаНоменклатуры = Запрос.Выполнить().Выгрузить();
	ТаблицаНоменклатуры.Индексы.Добавить(""Номенклатура"");
	
	Для каждого ОформлениеСтроки Из ОформленияСтрок Цикл
		
		НайденнаяСтрока = ТаблицаНоменклатуры.Найти(ОформлениеСтроки.ДанныеСтроки.Номенклатура, ""Номенклатура"");
		Если НайденнаяСтрока <> Неопределено Тогда
			
			Если ЕстьСерийныеНомера И НайденнаяСтрока.ВестиСерийныеНомера Тогда
				Если КартинкаСерийныеНомера = Неопределено Тогда
					КартинкаСерийныеНомера = БиблиотекаКартинок.СерийныеНомера;
				КонецЕсли;
				ОформлениеСтроки.Ячейки.Номенклатура.УстановитьКартинку(КартинкаСерийныеНомера);
			ИначеЕсли ЕстьСоставНабора И НайденнаяСтрока.Комплект Тогда
				Если КартинкаНаборКомплект = Неопределено Тогда
					КартинкаНаборКомплект = БиблиотекаКартинок.НаборКомплект;
				КонецЕсли;
				ОформлениеСтроки.Ячейки.Номенклатура.УстановитьКартинку(КартинкаНаборКомплект);
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры
"}
},
{0,
{"ИнтерактивноНажатьКнопку",0,0,"","// Программное нажатие на кнопку (обычную или на командной панели) на *чужой* форме с вызовом связанного события
// через переопределение действия формы ПриПовторномОткрытии
// увы, без передачи элемента кнопки в качестве параметра
// для режима запуска ""обычное приложение""
Процедура ИнтерактивноНажатьКнопку(Кнопка, ФормаКнопки) Экспорт
	// Удостоверимся что есть права на нажатие
	// Кнопка
	стрОшибка = """";
	Попытка
		Если Кнопка.Видимость = Ложь Тогда
			стрОшибка = стрОшибка + "", Невидима"";
		КонецЕсли;    
	Исключение
	КонецПопытки;    
	Попытка
		Если Кнопка.Доступность = Ложь Тогда
			стрОшибка = стрОшибка + "", Недоступна"";
		КонецЕсли;    
	Исключение
	КонецПопытки;    
	Если стрОшибка <> """" Тогда
		стрОшибка = Сред(стрОшибка, 3)+"" кнопка, которую требуется нажать"";
		ВызватьИсключение(стрОшибка);
	КонецЕсли;    
	
	Если ТипЗнч(Кнопка) = Тип(""КнопкаКоманднойПанели"") Тогда
		Действие = Кнопка.Действие;
	ИначеЕсли ТипЗнч(Кнопка) = Тип(""Кнопка"") Тогда    
		Действие = Кнопка.ПолучитьДействие(""Нажатие"");
	КонецЕсли;    
	буфДействие = ФормаКнопки.ПолучитьДействие(""ПриПовторномОткрытии"");
	ФормаКнопки.УстановитьДействие(""ПриПовторномОткрытии"", Действие);
	Попытка
		// собственно вызов нажатия кнопки
		ФормаКнопки.Открыть();
		ФормаКнопки.УстановитьДействие(""ПриПовторномОткрытии"", буфДействие);
	Исключение    
		ФормаКнопки.УстановитьДействие(""ПриПовторномОткрытии"", буфДействие);
		ВызватьИсключение;
	КонецПопытки;    
КонецПроцедуры"}
}
},
{2,
{"АрхивZip",1,0,"",""},
{0,
{"РаспаковатьZIPАрхив",0,0,"","Функция РаспаковатьZIPАрхив(СтрокаZIP) Экспорт
	
	СтрокаСодержимого = ""ZIP_ERROR"";
	
	ИмяФайла    = ПолучитьИмяВременногоФайла(""zip"");
	ИмяКаталога = КаталогВременныхФайлов() + Строка(Новый УникальныйИдентификатор);
	СоздатьКаталог(ИмяКаталога);
	
	СтрокаВФайл = Новый ТекстовыйДокумент;
	СтрокаВФайл.УстановитьТекст(СтрокаZIP);
	Попытка
		СтрокаВФайл.Записать(ИмяФайла);
	Исключение
	КонецПопытки;
	
	ЧтениеZIP = Новый ЧтениеZIPФайла(ИмяФайла);
	ЧтениеZIP.ИзвлечьВсе(ИмяКаталога);
	ЧтениеZIP.Закрыть();
	
	РаспакованныеФайлы = НайтиФайлы(ИмяКаталога, ""*.xml"");
	
	Если РаспакованныеФайлы.Количество() = 1 Тогда
		СтрокаИзФайла 	  = Новый ТекстовыйДокумент;
		СтрокаИзФайла.Прочитать(РаспакованныеФайлы[0].ПолноеИмя);
		СтрокаСодержимого = СтрокаИзФайла.ПолучитьТекст();
	КонецЕсли;
	
	Попытка
		УдалитьФайлы(ИмяФайла);
		УдалитьФайлы(ИмяКаталога);
	Исключение
	КонецПопытки;
	
	Возврат СтрокаСодержимого;
	
КонецФункции"}
},
{0,
{"Архив (из Б24)",0,0,"","ПолноеИмяФайлаАрхива = ПолучитьПутьДляПлатформы(ПараметрыОбмена.ПлатформаWindows, ПараметрыОбмена.КаталогЛога + ""\reports\"" + ""Exchange_"" + ""("" + ПараметрыОбмена.ссылка.Наименование +  "")"" +  СокрЛП(Формат(ТекущаяДата(), ""ДФ=yyyy-MM-dd"")) + "".zip"");
ЗаписьАрхива = Новый ЗаписьZipФайла(ПолноеИмяФайлаАрхива);
НовыйСписокФайлов = Новый СписокЗначений;
ЗаписьАрхива.Добавить(ПолучитьПутьДляПлатформы(ПараметрыОбмена.ПлатформаWindows, ПараметрыОбмена.КаталогЛога + ""\reports\"" + ""Exchange_"" + ""("" + ПараметрыОбмена.ссылка.Наименование +  "")"" +  СокрЛП(Формат(ТекущаяДата(), ""ДФ=yyyy-MM-dd"")) + "".txt""));

Если ПараметрыОбмена.ХранитьФайлыОбменаНаСайте тогда
	МассивПодкаталогов = Новый Массив;
	МассивПодкаталогов.Добавить(СокрЛП(ПараметрыОбмена.ссылка.Код));
	
	ИмяАрхиваОбмена = ПолучитьПутьДляПлатформы(ПараметрыОбмена.ПлатформаWindows, ПараметрыОбмена.КаталогЛога + ""\reports\Exchange.zip"");
	
	СписокАрхивов 	= ПолучитьСписокZIPАрхивов(ПараметрыОбмена, ПолучитьПутьДляПлатформы(ПараметрыОбмена.ПлатформаWindows, ПараметрыОбмена.КаталогЛога + ""\reports""), МассивПодкаталогов, ИмяАрхиваОбмена);
	
	Если СписокАрхивов.Количество() > 0 тогда
		ЗаписьАрхива.Добавить(СписокАрхивов[0].значение);
	КонецЕсли;
КонецЕсли;
Попытка
	ЗаписьАрхива.Записать();
Исключение
	СообщитьПодробно(""Не удалось записать zip-архив на диск!"", ПараметрыОбмена);	
КонецПопытки;"}
}
},
{5,
{"Древовидные форматы",1,0,"",""},
{6,
{"Json",1,0,"",""},
{0,
{"Получить результат от сервера",0,0,"","Функция УстановитьСоединениеССервером(ПараметрыПодключения) 
	
	Соединение = Неопределено;
	
	Попытка
		
		Если НЕ ПараметрыПодключения.ЗащищенноеСоединение тогда
			ssl = Неопределено;
		Иначе
			
			ssl = Новый ЗащищенноеСоединениеOpenSSL(
			Неопределено,
			Неопределено);   
			
		КонецЕсли;
		
		Соединение = Новый HTTPСоединение(ПараметрыПодключения.Сервер, ПараметрыПодключения.Порт,,, ПараметрыПодключения.Прокси, ,ssl);
		
	Исключение
		
		Сообщить(НСтр(""ru = 'Не удалось установить соединение с серовером'"") + ПараметрыПодключения.Сервер + "":"" + Строка(ПараметрыПодключения.Порт) 
		+ НСтр(""ru = '.Проверьте правильность адреса сервера, порт, имя пользователя и пароль.'""));
		
		Соединение = Неопределено;
		
	КонецПопытки;
	
	Возврат Соединение;
	
КонецФункции

Функция ВызватьМетод(Метод, ПараметрыСтрокой) Экспорт
	
	СтруктрураВозврата = Новый Структура(""ЕстьОшибки, ОписаниеОшибки"", Ложь, """");
		
	НастройкиПодключения = Новый Структура;
	Соединение = Неопределено;
	
	Если НЕ ДобавлениеНастроекПодключения(НастройкиПодключения, Соединение) тогда
		
		СтруктрураВозврата.ОписаниеОшибки = ""Не удалось получить все данные для подключения"";
		СтруктрураВозврата.ЕстьОшибки = Истина;
		Возврат СтруктрураВозврата;

	КонецЕсли;
		
	Соединение = УстановитьСоединениеССервером(НастройкиПодключения);
		
	Если Соединение = Неопределено Тогда
			
		СтруктрураВозврата.ОписаниеОшибки = ""Авторизация не выполнена"";
		СтруктрураВозврата.ЕстьОшибки = Истина;
		Возврат СтруктрураВозврата;
			
	КонецЕсли;
		
	ОписаниеОшибки	= """";
	
	//	========================================================================
	HTTPЗапрос = Новый HTTPЗапрос;
	HTTPЗапрос.АдресРесурса = ""/rest/"" 
							+ НастройкиПодключения.ИДПользователяВэбХука + ""/""
							+ НастройкиПодключения.Токен + ""/""
							+ Метод + ""/"";
							
	HTTPЗапрос.УстановитьТелоИзСтроки(ПараметрыСтрокой);
	
	
	//	========================================================================
	ИмяФайлаОтвета = ПолучитьИмяВременногоФайла(""txt"");
	//ИмяФайлаОтвета = ""C:\Users\db3\Documents\2018-05-14 двусторонний обмен\Bitrix24.txt"";
	
	Попытка
		
		HTTPОтвет = Соединение.ОтправитьДляОбработки(HTTPЗапрос, ИмяФайлаОтвета);
		
	Исключение
		
		СтруктрураВозврата.ОписаниеОшибки = ОписаниеОшибки();
		СтруктрураВозврата.ЕстьОшибки = Истина;
		Возврат СтруктрураВозврата;
				
	КонецПопытки;
	
	//сообщить(ИмяФайлаОтвета);
	
	ФайлОтвета 		= Новый Файл(ИмяФайлаОтвета);
	ОтветСервера 	= Неопределено;
	
	Если НЕ ФайлОтвета.Существует() Тогда
		
		СтруктрураВозврата.ОписаниеОшибки = ""Получение данных с сервера: Ответ сервера не получен."";
		СтруктрураВозврата.ЕстьОшибки = Истина;
		Возврат СтруктрураВозврата;
		
	КонецЕсли;
	
	ЧтениниеТекста = Новый ЧтениеТекста(ИмяФайлаОтвета);
	ТекстОтвета = ЧтениниеТекста.Прочитать();
	ЧтениниеТекста.Закрыть();
	
	//	========================================================================
	Попытка
		ЧтениеОтвета = Новый ЧтениеJSON;
		ЧтениеОтвета.УстановитьСтроку(ТекстОтвета);
		ДанныеОтвета = ПрочитатьJSON(ЧтениеОтвета);
		Если ДанныеОтвета.Свойство(""result"") Тогда
			
			СтруктрураВозврата.Вставить(""result"",ДанныеОтвета.result);
			
		ИначеЕсли ДанныеОтвета.Свойство(""error"") Тогда
			
			СтруктрураВозврата.ОписаниеОшибки = ДанныеОтвета.error_description;
			СтруктрураВозврата.ЕстьОшибки = Истина;
			Возврат СтруктрураВозврата;
			
		Иначе
			
			СтруктрураВозврата.ОписаниеОшибки = ""Непредвиденная ошибка"";
			СтруктрураВозврата.ЕстьОшибки = Истина;
			Возврат СтруктрураВозврата;
			
		КонецЕсли; 
	Исключение
		СтруктрураВозврата.ОписаниеОшибки = ""Получение данных с сервера: Ошибка разбора ответа сервера"";
		СтруктрураВозврата.ЕстьОшибки = Истина;
		Возврат СтруктрураВозврата;
	КонецПопытки; 
		
	Попытка
		//УдалитьФайлы(ИмяФайлаОтвета);
	Исключение
		;
	КонецПопытки;
	
	Возврат СтруктрураВозврата;
	
КонецФункции

"}
},
{0,
{"ДесериализоватьИзJSON",0,0,"","Функция ДесериализоватьИзJSON(СтрокаJSON)
	
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(СтрокаJSON);
	Строка = ПрочитатьJSON(ЧтениеJSON);
	
	Возврат Строка;
	//	Строка.result[0].ID
	
КонецФункции"}
},
{0,
{"РаскодироватьJSON",0,0,"","Функция РаскодироватьJSON(URL) Экспорт

	Результат = URL; 
	
	СписокСимволов = Новый СписокЗначений;
	СписокСимволов.Добавить(""\u0430"", ""а"");
	СписокСимволов.Добавить(""\u0431"", ""б"");
	СписокСимволов.Добавить(""\u0432"", ""в"");
	СписокСимволов.Добавить(""\u0433"", ""г"");
	СписокСимволов.Добавить(""\u0434"", ""д"");
	СписокСимволов.Добавить(""\u0435"", ""е"");
	СписокСимволов.Добавить(""\u0451"", ""ё"");
	СписокСимволов.Добавить(""\u0436"", ""ж"");
	СписокСимволов.Добавить(""\u0437"", ""з"");
	СписокСимволов.Добавить(""\u0438"", ""и"");
	СписокСимволов.Добавить(""\u0439"", ""й"");
	СписокСимволов.Добавить(""\u043a"", ""к"");
	СписокСимволов.Добавить(""\u043b"", ""л"");
	СписокСимволов.Добавить(""\u043c"", ""м"");
	СписокСимволов.Добавить(""\u043d"", ""н"");
	СписокСимволов.Добавить(""\u043e"", ""о"");
	СписокСимволов.Добавить(""\u043f"", ""п"");
	СписокСимволов.Добавить(""\u0440"", ""р"");
	СписокСимволов.Добавить(""\u0441"", ""с"");
	СписокСимволов.Добавить(""\u0442"", ""т"");
	СписокСимволов.Добавить(""\u0443"", ""у"");
	СписокСимволов.Добавить(""\u0444"", ""ф"");
	СписокСимволов.Добавить(""\u0445"", ""х"");
	СписокСимволов.Добавить(""\u0446"", ""ц"");
	СписокСимволов.Добавить(""\u0447"", ""ч"");
	СписокСимволов.Добавить(""\u0448"", ""ш"");
	СписокСимволов.Добавить(""\u0448"", ""щ"");
	СписокСимволов.Добавить(""\u044a"", ""ъ"");
	СписокСимволов.Добавить(""\u044b"", ""ы"");
	СписокСимволов.Добавить(""\u044c"", ""ь"");
	СписокСимволов.Добавить(""\u044d"", ""э"");
	СписокСимволов.Добавить(""\u044e"", ""ю"");
	СписокСимволов.Добавить(""\u044f"", ""я"");
	
	СписокСимволов.Добавить(""\u0410"", ""А"");
	СписокСимволов.Добавить(""\u0411"", ""Б"");
	СписокСимволов.Добавить(""\u0412"", ""В"");
	СписокСимволов.Добавить(""\u0413"", ""Г"");
	СписокСимволов.Добавить(""\u0414"", ""Д"");
	СписокСимволов.Добавить(""\u0415"", ""Е"");
	СписокСимволов.Добавить(""\u0401"", ""Ё"");
	СписокСимволов.Добавить(""\u0416"", ""Ж"");
	СписокСимволов.Добавить(""\u0417"", ""З"");
	СписокСимволов.Добавить(""\u0418"", ""И"");
	СписокСимволов.Добавить(""\u0419"", ""Й"");
	СписокСимволов.Добавить(""\u041a"", ""К"");
	СписокСимволов.Добавить(""\u041b"", ""Л"");
	СписокСимволов.Добавить(""\u041c"", ""М"");
	СписокСимволов.Добавить(""\u041d"", ""Н"");
	СписокСимволов.Добавить(""\u041e"", ""О"");
	СписокСимволов.Добавить(""\u041f"", ""П"");
	СписокСимволов.Добавить(""\u0420"", ""Р"");
	СписокСимволов.Добавить(""\u0421"", ""С"");
	СписокСимволов.Добавить(""\u0422"", ""Т"");
	СписокСимволов.Добавить(""\u0423"", ""У"");
	СписокСимволов.Добавить(""\u0424"", ""Ф"");
	СписокСимволов.Добавить(""\u0425"", ""Х"");
	СписокСимволов.Добавить(""\u0426"", ""Ц"");
	СписокСимволов.Добавить(""\u0427"", ""Ч"");
	СписокСимволов.Добавить(""\u0428"", ""Ш"");
	СписокСимволов.Добавить(""\u0428"", ""Щ"");
	СписокСимволов.Добавить(""\u042a"", ""Ъ"");
	СписокСимволов.Добавить(""\u042b"", ""Ы"");
	СписокСимволов.Добавить(""\u042c"", ""Ь"");
	СписокСимволов.Добавить(""\u042d"", ""Э"");
	СписокСимволов.Добавить(""\u042e"", ""Ю"");
	СписокСимволов.Добавить(""\u042f"", ""Я"");
	
	
	СписокСимволов.Добавить(""\u0022"", ""'"");
	
	СписокСимволов.Добавить(""\u003E"", "">"");
	СписокСимволов.Добавить(""\u003е"", "">"");
	
	СписокСимволов.Добавить(""\u003C"", ""<"");
	СписокСимволов.Добавить(""\u003c"", ""<"");
	
	Для Каждого текЭлемент из СписокСимволов Цикл
		
		Результат = СтрЗаменить(Результат, текЭлемент.Значение, текЭлемент.Представление);	
		
	КонецЦикла;

    Возврат Результат;
	
КонецФункции"}
},
{0,
{"Сериализация и десериализация JSON",0,0,"","Сериализация и десериализация JSON
JSON (JavaScript Object Notation) - это универсальный текстовый формат представления данных, который используется для обмена данными между приложениями. Для работы с данным форматом во многих популярных языках программирования доступны специальные объекты, функции. Если преобразовать объект в данный формат, то текст будет понятным для чтения человеком. Данный текст можно просмотреть в любом текстовом редакторе.

Сериализация JSON может быть использована вместо функций ""ЗначениеВСтрокуВнутр()"" и ""ЗначениеИзСтрокиВнутр()"".

Преимуществом данного формата является лаконичность представления данных. Данные представленные в JSON, в отличии от XML, занимают меньший объем. Сериализация и десериализация выполняется быстрее чем с XML.

Вариант 1

Начиная с версии 1С:Предприятие 8.3.7.1759, объект СериализаторXDTO поддерживает сериализацию и десериализацию JSON. Это означает, что любой объект 1С:Предприятия (объект конфигурации или объект встроенного языка) можно автоматически сериализовать и десериализовать.

Процедура ЗаписьJSON()
	
	ЗаписьJSON = Новый ЗаписьJSON;
	//Или в строку
	ЗаписьJSON.УстановитьСтроку();
	//Или в файл
	ЗаписьJSON.ОткрытьФайл(""C:\test.txt"");
	 
	Номенклатура = Справочники.Номенклатура.НайтиПоКоду(""00000000001"").ПолучитьОбъект();
	СериализаторXDTO.ЗаписатьJSON(ЗаписьJSON, Номенклатура, НазначениеТипаXML.Явное);
	
	СериализованнаяСтрока = ЗаписьJSON.Закрыть();
	
КонецПроцедуры


Процедура ЧтениеJSON()
	
	ЧтениеJSON = Новый ЧтениеJSON;
	//Или из строки
	ЧтениеJSON.УстановитьСтроку("""");
	//Или из файла	
	ЧтениеJSON.ОткрытьФайл(""C:\test.txt"");
		
	Номенклатура = СериализаторXDTO.ПрочитатьJSON(ЧтениеJSON);	
	
	ЧтениеJSON.Закрыть();
		
КонецПроцедуры 


Вариант 2

ЗаписатьJSON() - это метод глобального контекста, который позволяет сериализовать значения следующих типов: Строка, Число, Булево, Дата, Массив, ФиксированныйМассив, Структура, ФиксированнаяСтруктура, Соответствие, ФиксированноеСоответствие. С помощью метода глобального контекста ПрочитатьJSON(), можно десериализовать значения этих же типов.

Процедура ЗаписьJSON()
	
	ЗаписьJSON = Новый ЗаписьJSON;
	//Или в строку
	ЗаписьJSON.УстановитьСтроку();
	//Или в файл
	ЗаписьJSON.ОткрытьФайл(""C:\test.txt"");
	 
	//Запись структуры
	Структура = Новый Структура; 
	Структура.Вставить(""Поле1"", ""Значение1""); 	
	Структура.Вставить(""Поле2"", ""Значение2"");
	Структура.Вставить(""Поле3"", ""Значение3"");
	ЗаписатьJSON(ЗаписьJSON, Структура);
		
	СериализованнаяСтрока = ЗаписьJSON.Закрыть();
	
КонецПроцедуры


Процедура ЧтениеJSON()
	
	ЧтениеJSON = Новый ЧтениеJSON;
	//Или из строки
	ЧтениеJSON.УстановитьСтроку("""");
	//Или из файла	
	ЧтениеJSON.ОткрытьФайл(""C:\test.txt"");
		
	Структура = ПрочитатьJSON(ЧтениеJSON);	
	
	ЧтениеJSON.Закрыть();
		
КонецПроцедуры 


Вариант 3

Данный вариант сериализации и десериализации выполняется полностью в ручном режиме, без использования специальных объектов сериализации встроенного языка. Чтение и запись сериализованных данных выполняется с помощью объектов ЗаписьJSON, ЧтениеJSON. Эти объекты не считывают файл целиком, а считывают поэлементно, поэтому расходуют меньше памяти компьютера.

Процедура ЗаписьJSON()
	 
	ЗаписьJSON = Новый ЗаписьJSON;
	//Или в строку
	ЗаписьJSON.УстановитьСтроку();
	//Или в файл
	ЗаписьJSON.ОткрытьФайл(""C:\test.txt"");
				
	ЗаписьJSON.ЗаписатьНачалоМассива();
		
			ЗаписьJSON.ЗаписатьЗначение(""Значение1"");
			ЗаписьJSON.ЗаписатьЗначение(""Значение2"");
			ЗаписьJSON.ЗаписатьЗначение(""Значение3"");
			
			ЗаписьJSON.ЗаписатьНачалоОбъекта();
			
				ЗаписьJSON.ЗаписатьИмяСвойства(""Свойство1"");
				ЗаписьJSON.ЗаписатьЗначение(""Значение1"");
				ЗаписьJSON.ЗаписатьИмяСвойства(""Свойство2"");
				ЗаписьJSON.ЗаписатьЗначение(""Значение2"");
					
			ЗаписьJSON.ЗаписатьКонецОбъекта();
			
		ЗаписьJSON.ЗаписатьКонецМассива();
				
	СериализованнаяСтрока = ЗаписьJSON.Закрыть();
	
КонецПроцедуры


Процедура ЧтениеJSON()
	
	ЧтениеJSON = Новый ЧтениеJSON;
	//Или из строки
	ЧтениеJSON.УстановитьСтроку("""");
	//Или из файла	
	ЧтениеJSON.ОткрытьФайл(""C:\test.txt"");
		
	Пока ЧтениеJSON.Прочитать() Цикл
	
		Если ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.НачалоМассива Тогда
		
			Пока ЧтениеJSON.Прочитать() Цикл
				
				Если ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.Строка Тогда	
					Сообщить(""Значение: "" + ЧтениеJSON.ТекущееЗначение);	
					
				ИначеЕсли ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.НачалоОбъекта Тогда
					
					Пока ЧтениеJSON.Прочитать() Цикл	
						
						Если ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.ИмяСвойства Тогда
							Сообщить(""Свойство: "" + ЧтениеJSON.ТекущееЗначение);	
							
						ИначеЕсли ЧтениеJSON.ТипТекущегоЗначения = ТипЗначенияJSON.Строка Тогда
							Сообщить(""Значение: "" + ЧтениеJSON.ТекущееЗначение);
							
						КонецЕсли;
						
					КонецЦикла;
					
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЦикла;
	
	ЧтениеJSON.Закрыть();
	
КонецПроцедуры "}
},
{0,
{"Парсер JSON (Штатные средства 1С 8.3.6)",0,0,"","//https://infostart.ru/public/551972/

// JSON парсер.
&НаКлиенте
Функция ПрочитатьJSONИзФайла(Значение, Стандарт = Истина, ПредставленияСсылок = Ложь) Экспорт 
    
    Попытка
        ЧтениеJSON = Новый ЧтениеJSON;
        ЧтениеJSON.Закрыть();
        
        Возврат jsonПрочитатьПлатформой(Значение);
    Исключение
        Возврат jsonПрочитатьИнициализация(Значение, Стандарт, ПредставленияСсылок);
    КонецПопытки;
    
КонецФункции // ПрочитатьJSON()

&НаКлиенте
Функция jsonПрочитатьПлатформой(Значение)

    ЧтениеJSON = Новый ЧтениеJSON;
    ЧтениеJSON.УстановитьСтроку(Значение);
    
    Результат = Неопределено;
    СформироватьДерево(ЧтениеJSON, Результат);
    
    ЧтениеJSON.Закрыть();
    
    Возврат Результат;

КонецФункции

&НаКлиенте
Процедура СформироватьДерево(ЧтениеJSON, Дерево)
    
    ИмяСвойства = Неопределено;
    
    Пока ЧтениеJSON.Прочитать() Цикл
        TипJSON = ЧтениеJSON.ТипТекущегоЗначения;
        
        Если TипJSON = ТипЗначенияJSON.НачалоОбъекта 
        ИЛИ TипJSON = ТипЗначенияJSON.НачалоМассива Тогда
            НовыйОбъект = ?(TипJSON = ТипЗначенияJSON.НачалоОбъекта, Новый Соответствие, Новый Массив);
            
            Если ТипЗнч(Дерево) = Тип(""Массив"") Тогда
                Дерево.Добавить(НовыйОбъект);
            ИначеЕсли ТипЗнч(Дерево) = Тип(""Соответствие"") И ЗначениеЗаполнено(ИмяСвойства) Тогда
                Дерево.Вставить(ИмяСвойства, НовыйОбъект);
            КонецЕсли;
            
            СформироватьДерево(ЧтениеJSON, НовыйОбъект);
            
            Если Дерево = Неопределено Тогда
                Дерево = НовыйОбъект;
            КонецЕсли;
        ИначеЕсли TипJSON = ТипЗначенияJSON.ИмяСвойства Тогда
            ИмяСвойства = ЧтениеJSON.ТекущееЗначение;
        ИначеЕсли TипJSON = ТипЗначенияJSON.Число 
        ИЛИ TипJSON = ТипЗначенияJSON.Строка 
        ИЛИ TипJSON = ТипЗначенияJSON.Булево 
        ИЛИ TипJSON = ТипЗначенияJSON.Null Тогда
            Если ТипЗнч(Дерево) = Тип(""Массив"") Тогда
                Дерево.Добавить(ЧтениеJSON.ТекущееЗначение);
            ИначеЕсли ТипЗнч(Дерево) = Тип(""Соответствие"") Тогда
                Дерево.Вставить(ИмяСвойства, ЧтениеJSON.ТекущееЗначение);
            КонецЕсли;
        Иначе
            Возврат;
        КонецЕсли;
    КонецЦикла;
    
КонецПроцедуры"}
},
{0,
{"Родная справка 1С (http://v8.1c.ru/o7/201410json/index.htm)",0,0,"","//http://v8.1c.ru/o7/201410json/index.htm

JSON (JavaScript Object Notation) это текстовый формат обмена данными, широко используемый в веб-приложениях. По сравнению с XML он является более лаконичным и занимает меньше места. Кроме этого все браузеры имеют встроенные средства для работы с JSON.

Необходимость работы с этим форматом на уровне платформы обусловлена не только тем, что это «модный современный» формат, который прикладные решения 1С:Предприятия сами по себе могут использовать для интеграции со сторонними приложениями. Другая причина заключается ещё и в том, что JSON активно используется в HTTP интерфейсах. А в 1С:Предприятии как раз есть такие механизмы, в которых хочется использовать этот формат. Это REST интерфейс приложения, автоматически генерируемый платформой, и HTTP-сервисы, которые вы можете создавать самостоятельно.

Мы видим несколько основных сценариев использования JSON.

Во-первых, это интеграция с внешними системами через их HTTP интерфейсы: Google Calendar, Salesforce.com, REST интерфейс 1С:Предприятия, SharePoint и т.д.

Во-вторых, это организация собственного HTTP интерфейса прикладного решения.

В-третьих, обмен файлами JSON с внешними системами. Формирование конфигурационных, настроечных файлов. Использование их в процедурах обмена данными, например, с интернет-магазинами.

В-четвертых, это использование файлов JSON для обмена данными между разными приложениями 1С:Предприятия.

В платформе мы реализовали несколько слоёв работы с JSON. Самые простые и гибкие - это низкоуровневые средства потоковой записи и чтения. Более высокоуровневые и не такие универсальные - средства сериализации в JSON примитивных типов и коллекций 1С:Предприятия.

Потоковое чтение и запись JSON
Объекты потоковой работы - это общие объекты ЧтениеJSON и ЗаписьJSON. Они последовательно читают JSON из файла или строки, или последовательно записывают JSON в файл или строку. Таким образом, чтение и запись JSON происходят без формирования всего документа в памяти.

В качестве иллюстрации потокового чтения JSON можно привести следующий пример:


При записи JSON вы самостоятельно формируете его структуру. Чтобы «подстраховать» вас от ошибок, объект ЗаписьJSON автоматически проверяет правильность записываемой структуры. Для увеличения скорости работы эту проверку можно отключить. В примере ниже это строка:


Также при записи вы можете управлять некоторыми параметрами формируемого текста, например использованием двойных кавычек, переносом строк, символами отступа и экранированием символов. В примере ниже для форматирования текста используется символ табуляции:


Потоковая запись JSON может выглядеть следующим образом. Записывается массив из четырёх элементов. Три из них примитивного типа, а четвёртый элемент - это объект с двумя свойствами:


Результат такой записи:

{
	""СвойствоТипаМассив"": [
		""Значение строка"",
		1.2345E1,
		true,
		{
			""СвойствоТипаСтрока"": ""Значение строка"",
			""СвойствоТипаНеопределено"": null
		}
	]
}
Сериализация примитивных типов и коллекций в JSON
Вторая группа средств работы с JSON хороша тем, что избавляет вас от рутинной работы по чтению/записи каждого отдельного значения или свойства. При чтении документы JSON отображаются в фиксированный набор типов платформы: Строка, Число, Булево, Неопределено, Массив, ФиксированныйМассив, Структура, ФиксированнаяСтруктура, Соответствие, Дата. Соответственно, в обратную сторону, композиция объектов этих типов позволяет сформировать в памяти и быстро записать в файл структуру JSON. Таким образом, чтение и запись небольшого объема JSON заранее известной структуры можно производить немногими строчками кода.

Основное назначение этих средств мы видим в обмене информацией с внешними системами, чтении конфигурационных файлов в формате JSON.

Сериализацию вы можете выполнять с помощью методов глобального контекста ПрочитатьJSON() и ЗаписатьJSON(). Они работают в связке с объектами ЧтениеJSON и ЗаписьJSON.

В качестве примера десериализации JSON можно рассмотреть чтение массива из двух объектов:

[
	{
		""имя"": ""Anton"",
		""фамилия"": ""Иванов"",
		""возраст"": 25
	},
	{
		""имя"": ""Ирина"",
		""фамилия"": ""Иванова"",
		""возраст"": 20
	}
]
Код 1С:Предприятия, выполняющий десериализацию, может выглядеть следующим образом:


А пример сериализации (записи) в JSON может выглядеть так:


Результат записи:

{
	""Фамилия"": ""Иванов"",
	""Имя"": ""Иван"",
	""Отчество"": ""Иванович"",
	""Возраст"": 40,
	""Женат"": true,
	""Телефоны"": [
		""8-999-999-99-90"",
		""8-999-999-99-91""
	]
}
Функции преобразования и восстановления при сериализации
Не всегда сериализация может быть выполнена полностью автоматически. В жизни встречаются самые разные ситуации. Поэтому мы добавили возможность использовать «самописную» функцию обработки значений при записи в JSON и при чтении из JSON.

В методе ЗаписатьJSON() она называется Функция преобразования и описывается с помощью трёх параметров:

ИмяФункцииПреобразования;
МодульФункцииПреобразования;
ДополнительныеПараметрыФункцииПреобразования.
В методе ПрочитатьJSON() она называется Функция восстановления и для неё есть аналогичные параметры:

ИмяФункцииВосстановления;
МодульФункцииВосстановления;
ДополнительныеПараметрыФункцииВосстановления.
При записи в JSON эта функция полезна потому, что позволяет самостоятельно преобразовать в JSON те типы, которые не подлежат автоматическому преобразованию. Или даже совсем отказаться от их сериализации.

Например, так оказалось, что в записываемой структуре одно из значений - это ссылка на элемент справочника ПодразделенияОрганизаций. Такое значение (ссылка на объект 1С:Предприятия) не может быть автоматически сериализовано средствами платформы. Тогда, используя функцию преобразования, мы можем получить для этого значения его строковое представление в удобном виде. Например, в виде строки «ИП Петров: Отдел рекламы».


Результат выполнения примера:

{
	""Фамилия"": ""Иванов"",
	""Имя"": ""Иван"",
	""Отчество"": ""Иванович"",
	""Подразделение"": ""ИП Петров: Отдел рекламы"",
	""Телефоны"": [
		""8-999-999-99-90"",
		""8-999-999-99-91""
	]
}
При чтении из JSON функция восстановления может использоваться для того, чтобы преобразовать данные JSON в типы 1С, которые не могут являться результатом автоматического преобразования, или для того, чтобы самостоятельно (не автоматически) преобразовать даты JSON в даты 1С:Предприятия.

Сериализация типа Дата
Данные типа Дата сериализуются в JSON автоматически, а вот обратное преобразование (десериализация) может быть выполнено не всегда. JSON не содержит типа Дата, значения даты представляются в нём строкой. Конечно, существуют некоторые форматы представления дат, но вообще говоря, внешний вид такой строки может быть самым разнообразным.

Для сериализации типа Дата в JSON у метода ЗаписатьJSON() вы можете использовать параметр НастройкиСериализации. Это объект встроенного языка, который позволяет указать, в каком варианте будет записана дата (UTC, локальная дата или локальная дата со смещением) и в каком формате (ISO, JavaScript или Microsoft).

Код 1С:Предприятия:



Текст JSON:

[
	{
		""Фамилия"": ""Иванов"",
		""ДатаРождения"": ""1987-05-14T00:00:00""
	},
	{
		""Фамилия"": ""Петров"",
		""ДатаРождения"": ""1993-11-21T00:00:00""
	}
]
При чтении даты из JSON всё обстоит сложнее. В параметре ИменаСвойствСоЗначениямиДата вы можете перечислить те свойства JSON, значения которых нужно преобразовать в дату 1С:Предприятия (тип Дата). А в параметре ОжидаемыйФорматДаты вам нужно указать, в каком формате эти данные содержатся в JSON (ISO, JavaScript или Microsoft).

Текст JSON:

[
	{
		""Фамилия"": ""Иванов"",
		""ДатаРождения"": ""1987-05-14T00:00:00""
	},
	{
		""Фамилия"": ""Петров"",
		""ДатаРождения"": ""1993-11-21T00:00:00""
	}
]
Код 1С:Предприятия:


Однако если окажется, что в какой-то момент формат данных JSON не совпадает с ожидаемым форматом, будет вызвано исключение.

В такой ситуации, для большей универсальности, вы можете включить те же самые свойства JSON в массив, подлежащий обработке функцией восстановления - ИменаСвойствДляОбработкиВосстановления. И уже в функции восстановления вы самостоятельно десериализуете даты JSON, в каком бы формате они ни были представлены.

Использование JSON в HTTP интерфейсах приложений
Автоматически генерируемый REST интерфейс прикладных решений
При обращении к REST интерфейсу прикладного решения вы можете получать ответ в формате JSON. Для этого в адресной строке вам нужно указать параметр $format=json. Либо указать MIME тип ""application/json"" в заголовке Accept HTTP запроса. Например:

Запрос:

GET /TestInfobase/odata/standard.odata/СправочникДляТестов?$format=json HTTP/1.1
MaxDataServiceVersion: 3.0;NetFx
Accept: application/json
Accept-Charset: UTF-8
User-Agent: Microsoft ADO.NET Data Services
Ответ:

HTTP/1.1 200 OK
Content-Length: 9429
Content-Type: application/json;charset=utf-8
Server: Microsoft-IIS/7.5
DataServiceVersion: 3.0
X-Powered-By: ASP.NET
Date: Mon, 12 Aug 2013 09:44:07 GMT
    
{
""odata.metadata"":""http://host/svc/$metadata#СправочникДляТестов"",
""value"":[
{
	""Ref_Key"":guid'cc6a7df3-8cfe-11dc-8ca0-000d8843cd1b',
	""DataVersion"":""AAAAAQAAAAE"",	
	""DeletionMark"":false,
	""Parent_Key"":guid'bbb079ae-8c51-11db-a9b0-00055d49b45e',
	""IsFolder"":false,
	""Code"":000000025,
	""Description"":""Пинетки"",
	""Поставщик_Key"":guid'd1cb82a7-8e8b-11db-a9b0-00055d49b45e',
	""Поставщик@navigationLinkUrl"":""СправочникДляТестов(guid'cc6a7df3-8cfe-11dc-8ca0-000d8843cd1b')/Поставщик"",
	""РеквизитХранилище_Type"": ""image/jpeg"",
	""РеквизитХранилище_Base64Data@mediaReadLink"": ""Catalog_ДемоСправочник(guid'cf2b1a24-1b96-11e3-8f11-5404a6a68c42')/РеквизитХранилище_Base64Data"",
	""РеквизитХранилище_Base64Data"": <строка с закодированными данными>
	…
},
{…},
{…}
]
}
Вы можете управлять объёмом передаваемой информации за счёт изменения детальности представления метаданных в выгрузке. Существуют три уровня: Nometadata, Minimalmetadata и Fullmetadata. По-умолчанию (на примере вверху) используется средний уровень - Minimalmetadata. На уровне Nometadata объём передаваемой информации минимальный, а на уровне Fullmetadata - максимальный. Однако при этом нужно понимать, что сокращение объёма передаваемой информации приводит к более интенсивным вычислениям на клиенте. И наоборот, когда вся информация включается в выгрузку, объём вычислений на клиенте будет минимальным.

Детальность представления метаданных вы можете указать, например, в адресной строке.

Сведения о метаданных не передаются:

GET /TestInfobase/odata/standard.odata/СправочникДляТестов/?$format=application/json;odata= minimalmetadata
Вся информация о метаданных включается в выгрузку:

GET /TestInfobase/odata/standard.odata/СправочникДляТестов/?$format=application/json;odata=fullmetadata
HTTP-сервисы прикладного решения
HTTP-сервисы, реализованные в прикладном решении, также могут возвращать ответ в формате JSON. Для этого вам проще всего сформировать тело ответа в JSON, получить его как строку, а затем установить из этой строки тело HTTP ответа сервиса. При этом желательно указать, что BOM (Byte Order Mark, метка порядка байтов) использоваться не должна.


Последний параметр (ИспользованиеByteOrderMark.НеИспользовать) вы можете и не указывать, если режим совместимости конфигурации не установлен, или он больше чем Версия8_3_5. Потому что в этом случае BOM автоматически будет использоваться только для кодировок UTF-16 и UTF-32, а для UTF-8, UTF-16LE/UTF-16BE, UTF-32LE/UTF-32BE и других она использоваться не будет.

Взаимодействие со сторонними HTTP сервисами
При взаимодействии со сторонними HTTP интерфейсами у вас также может возникнуть необходимость формирования запросов к ним в формате JSON. В этом случае алгоритм ваших действий будет аналогичным. Формируете тело запроса в JSON. Получаете тело в виде строки. Из этой строки устанавливаете тело HTTP запроса. BOM не используете.


Дальнейшее развитие
Мы думаем над тем, чтобы предоставить вам возможность сериализации в JSON прикладных типов 1С:Предприятия: ссылок, объектов, наборов записей и т.д. Поэтому есть вероятность появления ещё одного, третьего уровня средств работы с JSON. Этот уровень позволит вам преобразовывать в JSON любые типы 1С:Предприятия, для которых поддерживается XDTO-сериализация в XML."}
}
},
{3,
{"XML",1,0,"",""},
{0,
{"XML",0,0,"","&НаКлиенте
Процедура Выгрузить(ПутьКФайлу)
    //ПутьКФайлу = ""D:\1c.xml""; 
    Сериализатор = Новый СериализаторXDTO(ФабрикаXDTO);
    ЗаписьXML = Новый ЗаписьXML;
    ЗаписьXML.ОткрытьФайл(ПутьКФайлу);
    //XML.УстановитьСтроку();
    Сериализатор.ЗаписатьXML(ЗаписьXML, <?""Таблица (напр., Объект.ДанныеВход)"">);
    СтрокаXML = ЗаписьXML.Закрыть();
КонецПроцедуры

&НаСервере
Функция ЗагрузитьЗначенияНаСервере(ПутьКФайлу)
    //ПутьКФайлу = ""D:\1c.xml"";
    ЧтениеXML = Новый ЧтениеXML;
    ЧтениеXML.ОткрытьФайл(ПутьКФайлу);
    Сериализатор = Новый СериализаторXDTO(ФабрикаXDTO);
    Результат = Сериализатор.ПрочитатьXML(ЧтениеXML);
    РезультатЗначение = ДанныеФормыВЗначение(Результат, Тип(""ТаблицаЗначений""));
    <?""Таблица (напр., Объект.ДанныеВход)"">.Загрузить(РезультатЗначение);
    ЧтениеXML.Закрыть();
КонецФункции"}
},
{0,
{"ЧтениеXMLВДерево",0,0,""," 
 // Чтение XML
 
 &НаСервере
 Функция ЧтениеXMLВДерево(Путь)
	 
	 Дерево = Новый ДеревоЗначений;
	 Дерево.Колонки.Добавить(""Имя"");
	 Дерево.Колонки.Добавить(""Значение"");
	 
	 XMLФайл = Новый ЧтениеXML;
	 XMLФайл.ОткрытьФайл(Путь);
	 
	 ПрочитатьXMLПоТегам(XMLФайл, Дерево.Строки);
	 
	 XMLФайл.Закрыть();
	 
	 Возврат Дерево;
	 
 КонецФункции
 
 &НаСервереБезКонтекста
 Процедура ПрочитатьXMLПоТегам(XMLФайл, ТекущийНаборСтрок)
	 
	 Пока XMLФайл.Прочитать() Цикл
		 Если XMLФайл.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
			 
			 НоваяСтрока = ТекущийНаборСтрок.Добавить();
			 НоваяСтрока.Имя = XMLФайл.Имя;
			 НоваяСтрока.Значение = """";
			 
			 Пока XMLФайл.ПрочитатьАтрибут() Цикл
				 
				 НоваяСтрокаАтрибут = НоваяСтрока.Строки.Добавить();
				 НоваяСтрокаАтрибут.Имя = XMLФайл.Имя;
				 НоваяСтрокаАтрибут.Значение = СокрЛП(XMLФайл.Значение);
				 
			 КонецЦикла;
			 
			 ПрочитатьXMLПоТегам(XMLФайл, НоваяСтрока.Строки);
			 
		 ИначеЕсли XMLФайл.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
			 Возврат;
		 ИначеЕсли XMLФайл.ТипУзла = ТипУзлаXML.Текст Тогда
			 
			 ТекущийНаборСтрок.Родитель.Значение = СокрЛП(XMLФайл.Значение);
			 
		 Иначе
			 Сообщить(""Тип узла: "" + XMLФайл.ТипУзла + "" НЕ ОБРАБОТАН"", СтатусСообщения.Важное);
		 Конецесли;
	 КонецЦикла;
	 
 КонецПроцедуры
 
 "}
},
{0,
{"ПрочитатьФайлXML",0,0,"","/// Как прочитать файл в формате XML через DOM
/// в 1с 8.3, 8.2
 
&НаСервере
Процедура ПрочитатьФайлXMLЧерезDOM(ПутьКФайлу)
 
    // Разбор документа через DOM (document object model)
    // https://ru.wikipedia.org/wiki/Document_Object_Model
 
    // Разбираем файл test.xml, ссылка на его скачивание выше.
 
    Парсер = Новый ЧтениеXML;
    Парсер.ОткрытьФайл(ПутьКФайлу);
 
    Построитель = Новый ПостроительDOM;
 
    Документ = Построитель.Прочитать(Парсер);
 
    Для Каждого Элемент0 Из Документ.ЭлементДокумента.ДочерниеУзлы Цикл
        Если Элемент0.ИмяУзла = ""Страна"" Тогда
            Страна = Элемент0;
 
            Название = Страна.Атрибуты.ПолучитьИменованныйЭлемент(""Название"");
            Если Название <> Неопределено Тогда
                Сообщить(""== "" + Название.Значение + "" =="");
            КонецЕсли;
 
            Численность = Страна.Атрибуты.ПолучитьИменованныйЭлемент(""Численность"");
            Если Численность <> Неопределено Тогда
                Сообщить(""Численность: "" + Численность.Значение);
            КонецЕсли;
 
            Столица = Страна.Атрибуты.ПолучитьИменованныйЭлемент(""Столица"");
            Если Столица <> Неопределено Тогда
                Сообщить(""Столица: "" + Столица.Значение);
            КонецЕсли;
 
            Для Каждого Элемент1 Из Страна.ДочерниеУзлы Цикл
                Если Элемент1.ИмяУзла = ""ТрадиционныеБлюда"" Тогда
                    ТрадиционныеБлюда = Элемент1;
 
                    Сообщить(""Традиционные блюда:"");
 
                    Для Каждого Элемент2 Из ТрадиционныеБлюда.ДочерниеУзлы Цикл
                        Если Элемент2.ИмяУзла = ""Блюдо"" Тогда
                            Блюдо = Элемент2;
 
                            Название = Блюдо.Атрибуты.ПолучитьИменованныйЭлемент(""Название"");
                            Если Название <> Неопределено Тогда
                                Сообщить("" "" + Название.Значение);
                            КонецЕсли;
                        КонецЕсли;
                    КонецЦикла;                    
                ИначеЕсли Элемент1.ИмяУзла = ""ОбщееОписание"" Тогда
                    Сообщить(""Общее описание:"");
                    Сообщить(Элемент1.ТекстовоеСодержимое);
                КонецЕсли;                
            КонецЦикла;
        КонецЕсли;
    КонецЦикла;
 
    Парсер.Закрыть();
 
КонецПроцедуры
 
/// Как прочитать файл в формате XML последовательно
/// (способ 1) в 1с 8.3, 8.2
 
&НаСервере
Процедура ПрочитатьФайлXMLПоследовательноСпособ1(ПутьКФайлу)
 
    // Этот способ подойдёт для очень больших файлов,
    // для которых модель DOM неприменима.
 
    // Способ 1.
 
    // Разбираем файл test.xml, ссылка на его скачивание выше.
 
    Парсер = Новый ЧтениеXML;
    Парсер.ОткрытьФайл(ПутьКФайлу);
 
    Пока Парсер.Прочитать() Цикл
        Если 
            Парсер.ТипУзла = ТипУзлаXML.НачалоЭлемента И
            Парсер.Имя = ""Страна""
        Тогда
            Название = Парсер.ЗначениеАтрибута(""Название"");
            Если Название <> Неопределено Тогда
                Сообщить(""== "" + Название + "" =="");
            КонецЕсли;
 
            Численность = Парсер.ЗначениеАтрибута(""Численность"");
            Если Численность <> Неопределено Тогда
                Сообщить(""Численность: "" + Численность);
            КонецЕсли;
 
            Столица = Парсер.ЗначениеАтрибута(""Столица"");
            Если Столица <> Неопределено Тогда
                Сообщить(""Столица: "" + Столица);
            КонецЕсли;
 
            Пока Парсер.Прочитать() Цикл // <Страна>
                Если 
                    Парсер.ТипУзла = ТипУзлаXML.НачалоЭлемента И
                    Парсер.Имя = ""ТрадиционныеБлюда""
                Тогда                    
                    Сообщить(""Традиционные блюда:"");
 
                    Пока Парсер.Прочитать() Цикл // <ТрадиционныеБлюда>
                        Если 
                            Парсер.ТипУзла = ТипУзлаXML.НачалоЭлемента И
                            Парсер.Имя = ""Блюдо"" 
                        Тогда
                            Название = Парсер.ЗначениеАтрибута(""Название"");
                            Если Название <> Неопределено Тогда
                                Сообщить("" "" + Название);
                            КонецЕсли;
                        ИначеЕсли
                            Парсер.ТипУзла = ТипУзлаXML.КонецЭлемента И
                            Парсер.Имя = ""ТрадиционныеБлюда""
                        Тогда
                            Прервать;
                        КонецЕсли;
                    КонецЦикла; //  </ТрадиционныеБлюда>
 
                ИначеЕсли
                    Парсер.ТипУзла = ТипУзлаXML.НачалоЭлемента И
                    Парсер.Имя = ""ОбщееОписание""
                Тогда                
                    Парсер.Прочитать();
                    Если Парсер.ТипУзла = ТипУзлаXML.Текст Тогда
                        Сообщить(""Общее описание:"");
                        Сообщить(Парсер.Значение);
                    КонецЕсли;                
                ИначеЕсли
                    Парсер.ТипУзла = ТипУзлаXML.КонецЭлемента И
                    Парсер.Имя = ""Страна""
                Тогда
                    Прервать;
                КонецЕсли;
            КонецЦикла; // </Страна>
 
        КонецЕсли;
    КонецЦикла;
 
    Парсер.Закрыть();
 
КонецПроцедуры
 
/// Как прочитать файл в формате XML последовательно
/// (способ 2) в 1с 8.3, 8.2
 
&НаСервере
Процедура ПрочитатьФайлXMLПоследовательноСпособ2(ПутьКФайлу)
 
    // Этот способ подойдёт для очень больших файлов,
    // для которых модель DOM неприменима.
 
    // Способ 2.
 
    // Разбираем файл test.xml, ссылка на его скачивание выше.
 
    Парсер = Новый ЧтениеXML;
    Парсер.ОткрытьФайл(ПутьКФайлу);
 
    СтекИмен = Новый СписокЗначений;
 
    Пока Парсер.Прочитать() Цикл
        Если Парсер.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
            СтекИмен.Добавить(Парсер.Имя);
            ПолныйПуть = ПостроитьПуть(СтекИмен);
 
            Если ПолныйПуть = ""/Страны/Страна"" Тогда
                Название = Парсер.ЗначениеАтрибута(""Название"");
                Если Название <> Неопределено Тогда
                    Сообщить(""== "" + Название + "" =="");
                КонецЕсли;
 
                Численность = Парсер.ЗначениеАтрибута(""Численность"");
                Если Численность <> Неопределено Тогда
                    Сообщить(""Численность: "" + Численность);
                КонецЕсли;
 
                Столица = Парсер.ЗначениеАтрибута(""Столица"");
                Если Столица <> Неопределено Тогда
                    Сообщить(""Столица: "" + Столица);
                КонецЕсли;
            ИначеЕсли ПолныйПуть = ""/Страны/Страна/ТрадиционныеБлюда"" Тогда
                Сообщить(""Традиционные блюда:"");
            ИначеЕсли ПолныйПуть = ""/Страны/Страна/ТрадиционныеБлюда/Блюдо"" Тогда
                Название = Парсер.ЗначениеАтрибута(""Название"");
                Если Название <> Неопределено Тогда
                    Сообщить("" "" + Название);
                КонецЕсли;
            ИначеЕсли ПолныйПуть = ""/Страны/Страна/ОбщееОписание"" Тогда
                Парсер.Прочитать();
                Если Парсер.ТипУзла = ТипУзлаXML.Текст Тогда
                    Сообщить(""Общее описание:"");
                    Сообщить(Парсер.Значение);
                КонецЕсли;
            КонецЕсли;
        ИначеЕсли Парсер.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
            СтекИмен.Удалить(СтекИмен.Количество() - 1);
        КонецЕсли;
    КонецЦикла;
 
    Парсер.Закрыть();
 
КонецПроцедуры
 
/// Как записать данные в файл формата XML в 1с 8.3, 8.2
 
&НаКлиенте
Процедура ЗаписатьДанныеВФорматеXML(ПутьКФайлуДляЗаписи)
 
    // Предположим, что у нас есть данные о странах,
    // которые нужно записать во внешний файл в формате XML.    
 
    Страны = СоздатьДанныеДляЗаписиВXML();    
 
    // И эти данные хранятся во списке значений Страны,
    // который нам вернула внутренняя процедура (определена
    // ниже).
 
    ЗаписьXML = Новый ЗаписьXML;
 
    ЗаписьXML.ОткрытьФайл(ПутьКФайлуДляЗаписи);
 
    ЗаписьXML.ЗаписатьОбъявлениеXML();    
 
    ЗаписьXML.ЗаписатьНачалоЭлемента(""Страны"");
 
    Для Каждого Страна Из Страны Цикл
        ЗаписьXML.ЗаписатьНачалоЭлемента(""Страна"");
        ЗаписьXML.ЗаписатьАтрибут(""Название"", Страна.Значение.Название);
        ЗаписьXML.ЗаписатьАтрибут(""Численность"", Страна.Значение.Численность);
        ЗаписьXML.ЗаписатьАтрибут(""Столица"", Страна.Значение.Столица);
 
        ЗаписьXML.ЗаписатьНачалоЭлемента(""ТрадиционныеБлюда"");
        Для Каждого Блюдо Из Страна.Значение.ТрадиционныеБлюда Цикл
            ЗаписьXML.ЗаписатьНачалоЭлемента(""Блюдо"");
            ЗаписьXML.ЗаписатьАтрибут(""Название"", Блюдо.Значение.Название);
            ЗаписьXML.ЗаписатьКонецЭлемента(); // Блюдо
        КонецЦикла;
        ЗаписьXML.ЗаписатьКонецЭлемента(); // ТрадиционныеБлюда
 
        ЗаписьXML.ЗаписатьНачалоЭлемента(""ОбщееОписание"");
        ЗаписьXML.ЗаписатьТекст(Страна.Значение.ОбщееОписание);
        ЗаписьXML.ЗаписатьКонецЭлемента(); // ОбщееОписание
 
        ЗаписьXML.ЗаписатьКонецЭлемента(); // Страна
    КонецЦикла;
 
    ЗаписьXML.ЗаписатьКонецЭлемента(); // Страны
 
    ЗаписьXML.Закрыть();
 
КонецПроцедуры
 
&НаКлиенте
Функция СоздатьДанныеДляЗаписиВXML()
 
    Страны = Новый СписокЗначений;
 
    Россия = Новый Структура(""Название, Численность, Столица, ТрадиционныеБлюда, ОбщееОписание"");
    Россия.Название = ""Россия"";
    Россия.Численность = ""144000000"";
    Россия.Столица = ""Москва"";
    Россия.ТрадиционныеБлюда = Новый СписокЗначений;
    Россия.ТрадиционныеБлюда.Добавить(Новый Структура(""Название"", ""Щи""));
    Россия.ТрадиционныеБлюда.Добавить(Новый Структура(""Название"", ""Солянка""));
    Россия.ТрадиционныеБлюда.Добавить(Новый Структура(""Название"", ""Рассольник""));
    Россия.ОбщееОписание = ""Страна с очень"" + Символы.ПС + ""большой территорией"";    
    Страны.Добавить(Россия);
 
    Китай = Новый Структура(""Название, Численность, Столица, ТрадиционныеБлюда, ОбщееОписание"");
    Китай.Название = ""Китай"";
    Китай.Численность = ""1357000000"";
    Китай.Столица = ""Пекин"";
    Китай.ТрадиционныеБлюда = Новый СписокЗначений;
    Китай.ТрадиционныеБлюда.Добавить(Новый Структура(""Название"", ""Свинина в кисло-сладком соусе""));
    Китай.ТрадиционныеБлюда.Добавить(Новый Структура(""Название"", ""Курица гунбао""));
    Китай.ТрадиционныеБлюда.Добавить(Новый Структура(""Название"", ""Мапо тофу""));
    Китай.ОбщееОписание = ""Страна с очень"" + Символы.ПС + ""большим населением."";
    Страны.Добавить(Китай);
 
    Возврат Страны;
 
КонецФункции
 
&НаСервере
Функция ПостроитьПуть(СтекИмен)
    Путь = """";
 
    Для Каждого Имя Из СтекИмен Цикл
        Путь = Путь + ""/"" + Имя;
    КонецЦикла;
 
    Возврат Путь;
КонецФункции"}
}
},
{5,
{"Дерево значений",1,0,"",""},
{2,
{"ТЗ в ДеревоЗначений",1,0,"",""},
{0,
{"Через УникальныйИдентификатор (глобальная целостность)",0,0,"","////////////////////////////////////////////////////////////////////////////////
// 1С 8.3 : Дерево значений в таблицу значений или в табличную часть и обратно
// //https://helpf.pro/faq83/view/1588.html
////////////////////////////////////////////////////////////////////////////////

//ФОРМИРОВАНИЕ ТАБЛИЦЫ ИЗ ДЕРЕВА
&НаСервере
Процедура ДеревоВТаблицу(ДокОбъект, ДеревоЗначений, НаименованиеТабличнойЧастиДокумента, СтрокаДерева = Неопределено, КлючСвязи = Неопределено) Экспорт
	
	Если СтрокаДерева = Неопределено И КлючСвязи = Неопределено Тогда
		//ПЕРВЫЙ ВЫЗОВ ПРОЦЕДУРЫ (КОРНЕВЫЕ ЭЛЕМЕНТЫ)
		ПервыйВызов 	= Истина;
		ДокОбъект[НаименованиеТабличнойЧастиДокумента].Очистить();
		ИсточникВыборки = ДеревоЗначений.Строки;
		КлючСвязи 		= Новый УникальныйИдентификатор(""00000000-0000-0000-0000-000000000000""); // ЭЛЕМЕНТ ВЕРХНЕГО УРОВНЯ ИМЕЕТ НОМЕР СТРОКИ РОДИТЕЛЯ 0 (ОБЯЗАТЕЛЬНЫЙ РЕКВИЗИТ)
	Иначе
		//ВНУТРЕННИЙ ВЫЗОВ ПРОЦЕДУРЫ (ПОДЧИНЕННЫЕ ЭЛЕМЕНТЫ)
		ПервыйВызов 	= Ложь;
		ИсточникВыборки = СтрокаДерева.Строки;
	КонецЕсли;
	
	Для каждого Стр из ИсточникВыборки Цикл
		
		НС 	= ДокОбъект[НаименованиеТабличнойЧастиДокумента].Добавить();
		лМетаданныеТЧ 	= ДокОбъект.Метаданные().ТабличныеЧасти[НаименованиеТабличнойЧастиДокумента];
		
		ЗаполнитьЗначенияСвойств(НС, Стр);
		
		НС.КлючСвязи 	= КлючСвязи;
		
		лСтрКоличество 	= Стр.Строки.Количество();
		Если лСтрКоличество > 0 Тогда
			НС.Количество 	= лСтрКоличество;
			Стр.Количество 	= лСтрКоличество;
		КонецЕсли;
		
		//Для каждого Кол из лМетаданныеТЧ.Реквизиты Цикл
		//	Если Кол.Имя = ""КлючСвязи"" Тогда
		//		НС.КлючСвязи = КлючСвязи;
		//	ИначеЕсли Кол.Имя = ""НомерСтроки"" Тогда
		//		Продолжить;
		//	Иначе 
		//		ЗаполнитьЗначенияСвойств(НС, Стр);
		//		//НС[Кол.Имя] = Стр[Кол.Имя];
		//	КонецЕсли;
		//КонецЦикла;
		Если НЕ Стр.Строки.Количество() = 0 Тогда
			ДеревоВТаблицу(ДокОбъект,,НаименованиеТабличнойЧастиДокумента, Стр, НС.ЭлементИД);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры 

//ФОРМИРОВАНИЕ ДЕРЕВА ИЗ ТАБЛИЦЫ
&НаСервере
Функция ТаблицаВДерево(ДокОбъект, НаименованиеТабличнойЧастиДокумента, КлючСвязи = Неопределено, ЭлементРодитель = Неопределено) Экспорт	
	//ПОДГОТОВКА КОЛОНОК ДЕРЕВА
	КолонкиТаблицы 	= ДокОбъект.Метаданные().ТабличныеЧасти[НаименованиеТабличнойЧастиДокумента].Реквизиты;
	ДеревоЗначений2 = Новый ДеревоЗначений;
	
	НовыйИД 		= Новый УникальныйИдентификатор(""00000000-0000-0000-0000-000000000000"");
	Для каждого Кол из КолонкиТаблицы Цикл
		Если Кол.Имя = ""НомерСтроки"" ИЛИ Кол.Имя = ""КлючСвязи"" Тогда
			Продолжить;
		Иначе
			ДеревоЗначений2.Колонки.Добавить(Кол.Имя, Новый ОписаниеТипов(Кол.Тип));
		КонецЕсли;
	КонецЦикла;//ДеревоЗначений.Строки.Очистить();
	
	Если КлючСвязи = Неопределено И ЭлементРодитель = Неопределено Тогда
		//ПЕРВЫЙ ВЫЗОВ ПРОЦЕДУРЫ (КОРНЕВЫЕ ЭЛЕМЕНТЫ)
		ИсточникВыборки = ДеревоЗначений2.Строки;
		КлючСвязи 		= НовыйИД; // ЭЛЕМЕНТ ВЕРХНЕГО УРОВНЯ ИМЕЕТ НОМЕР СТРОКИ РОДИТЕЛЯ 0 (ОБЯЗАТЕЛЬНЫЙ РЕКВИЗИТ)
	Иначе
		//ВНУТРЕННИЙ ВЫЗОВ ПРОЦЕДУРЫ (ПОДЧИНЕННЫЕ ЭЛЕМЕНТЫ)
		ИсточникВыборки = ЭлементРодитель.Строки;
	КонецЕсли;
	
	Фильтр 					= Новый Структура(""КлючСвязи"", КлючСвязи);
	лДочерниеПоКлючуСвязи 	= ДокОбъект[НаименованиеТабличнойЧастиДокумента].НайтиСтроки(Фильтр);
	Если лДочерниеПоКлючуСвязи.Количество() = 0 Тогда
		Возврат ДеревоЗначений2;
	КонецЕсли;
	
	Для каждого Стр из лДочерниеПоКлючуСвязи Цикл
		
		//Для каждого Кол из КолонкиТаблицы Цикл
		//	Если Кол.Имя = ""НомерСтроки"" ИЛИ Кол.Имя = ""КлючСвязи"" Тогда
		//		Продолжить;
		//	Иначе
		//		Элемент[Кол.Имя] = Стр[Кол.Имя];
		//	КонецЕсли;
		//КонецЦикла;
		
		Если КлючСвязи = НовыйИД И ЭлементРодитель = Неопределено Тогда
			Элемент 	= ИсточникВыборки.Добавить();
			ЗаполнитьЗначенияСвойств(Элемент, Стр);
			ТаблицаВДерево(ДокОбъект, НаименованиеТабличнойЧастиДокумента, Стр.ЭлементИД, Элемент); //ДОБАВЛЕНИЕ ПОДЧИНЁННЫХ ЭЛЕМЕНТОВ В ДЕРЕВО
			Прервать; //Заполнив корневой уровень и выйдя, т.к. в нём все элементы
			
		Иначе
			Если Стр.ЭлементИД <> НовыйИД Тогда
				Элемент 	= ИсточникВыборки.Добавить();
				ЗаполнитьЗначенияСвойств(Элемент, Стр);
				ТаблицаВДерево(ДокОбъект, НаименованиеТабличнойЧастиДокумента, Стр.ЭлементИД, Элемент); //ДОБАВЛЕНИЕ ПОДЧИНЁННЫХ ЭЛЕМЕНТОВ В ДЕРЕВО
			КонецЕсли;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ДеревоЗначений2;
	
КонецФункции

//На форме
//Процедура КомандаТаблицуВДеревоНаСервере()
//	Дерево = ТаблицаВДерево(РеквизитФормыВЗначение(""Объект""), ""Товары"");//Товары - имя табличной части
//	ЗначениеВРеквизитФормы(Дерево, ""ДеревоЗначений"");//ДеревоЗначений - реквизит формы с типом дерево значений
//	Элементы.ДеревоЗначений.Обновить();
//КонецПроцедуры

//Процедура КомандаДеревоВТаблицуНаСервере()
//	Объект.Товары.Очистить();
//	ДОбъект = РеквизитФормыВЗначение(""Объект"");
//	ДеревоВТаблицу(ДОбъект, РеквизитФормыВЗначение(""ДеревоЗначений""), ""Товары"");
//	ЗначениеВРеквизитФормы(ДОбъект, ""Объект"");
//КонецПроцедуры

&НаКлиенте
Процедура ДеревоПриИзменении(Элемент)
	
	лТекущиеДанные 	= Элемент.ТекущиеДанные; 
	Если лТекущиеДанные <> Неопределено Тогда
		лЭлементыКорень 	= Дерево.ПолучитьЭлементы();
		
		Если лЭлементыКорень.Количество() = 1 Тогда
			лЭлементы 		= лЭлементыКорень[0].ПолучитьЭлементы();
			
			Если лЭлементы.Количество() > 0 Тогда
				Если НЕ ЗначениеЗаполнено(лТекущиеДанные.ЭлементИД) Тогда
					лТекущиеДанные.ЭлементИД 	= Новый УникальныйИдентификатор();
				КонецЕсли;	
			КонецЕсли; 
		Иначе
			лТекущиеДанные.ЭлементИД 	= Новый УникальныйИдентификатор(""00000000-0000-0000-0000-000000000000"");
		КонецЕсли; 
	КонецЕсли;  
	
КонецПроцедуры"}
},
{0,
{"Через НомерСтроки (целостность только в рамках себя)",0,0,"","1С 8.3 : Дерево значений в таблицу значений или в табличную часть и обратно

Для одной организации надо было реализовать документы, где вместо табличной части надо использовать дерево и все это на управляемых формах. Но дерево нельзя сохранить в базе в текущем виде. Пришлось использовать табличную часть документа для хранения данных дерева. И при открытии формы получать данные из ТЧ и выводить их в дерево. Далее все манипуляции производить с деревом и при сохранении документа помещать данные в обратно в ТЧ.

Поиск по интернету не дал нужного варианта, пришлось реализовавыть свой механизм, используя информацию которая была на просторах интернета.

Для реализации такого механизма в ТЧ был добавлен реквизит “КлючСвязи” (обязательный реквизит) с типом число, куда помещался “НомерСтроки” (стандартный реквизит ТЧ) родителя (верхний уровень). А самый верхний элемент дерева имеет “КлючСвязи” равный 0.

На картинке ниже видно структуру дерева и структуру ТЧ

Нагрузка на сервер осуществляется при окрытии и при сохранении документа. А с деревом работают уже на клиенте.

На рабочей базе обрабатывается около 200 строк в одном документе.

Открытие и сохранение документа происходит моментально. С большем количеством строк не тестировалось.

Чтобы алгорит правильно работал, у рекизита фомы с типом дерево значений должны быть все реквизиты табличной части, кроме “КлючСвязи” и “НомерСтроки”. Иначе платформа выдаст ошибку. В дерево можо добавлять свои реквизиты отличные от ТЧ, они будут использоваться только в дереве.

Ниже приведен код преобразования дерева в таблицу и обратно.
Код 1C v 8.2 УП

 &НаКлиенте
Процедура КомандаТаблицуВДерево(Команда)
	КомандаТаблицуВДеревоНаСервере();
КонецПроцедуры


&НаСервере
Процедура КомандаТаблицуВДеревоНаСервере()
	Дерево = ТаблицаВДерево(РеквизитФормыВЗначение(""Объект""), ""Товары"");//Товары - имя табличной части
	ЗначениеВРеквизитФормы(Дерево, ""ДеревоЗначений"");//ДеревоЗначений - реквизит формы с типом дерево значений
	Элементы.ДеревоЗначений.Обновить();
КонецПроцедуры


&НаКлиенте
Процедура КомандаДеревоВТаблицу(Команда)
	КомандаДеревоВТаблицуНаСервере();
КонецПроцедуры


&НаСервере
Процедура КомандаДеревоВТаблицуНаСервере()
	Объект.Товары.Очистить();
	ДОбъект = РеквизитФормыВЗначение(""Объект"");
	ДеревоВТаблицу(ДОбъект, РеквизитФормыВЗначение(""ДеревоЗначений""), ""Товары"");
	ЗначениеВРеквизитФормы(ДОбъект, ""Объект"");
КонецПроцедуры   

Формирование дерева из таблицы значений
Код 1C v 8.2 УП

 //ФОРМИРОВАНИЕ ДЕРЕВА ИЗ ТАБЛИЦЫ
&НаСервере
Функция ТаблицаВДерево(ДокОбъект, НаименованиеТабличнойЧастиДокумента, КлючСвязи = NULL, ЭлементРодитель = NULL) Экспорт	
	//ПОДГОТОВКА КОЛОНОК ДЕРЕВА
	КолонкиТаблицы = ДокОбъект.Метаданные().ТабличныеЧасти[НаименованиеТабличнойЧастиДокумента].Реквизиты;
	ДеревоЗначений2 = Новый ДеревоЗначений;
	Для каждого Кол из КолонкиТаблицы Цикл
		Если Кол.Имя = ""НомерСтроки"" ИЛИ Кол.Имя = ""КлючСвязи"" Тогда
			Продолжить;
		Иначе
			ДеревоЗначений2.Колонки.Добавить(Кол.Имя, Новый ОписаниеТипов(Кол.Тип));
		КонецЕсли;
	КонецЦикла;//ДеревоЗначений.Строки.Очистить();
	
	Если КлючСвязи = NULL И ЭлементРодитель = NULL Тогда
		//ПЕРВЫЙ ВЫЗОВ ПРОЦЕДУРЫ (КОРНЕВЫЕ ЭЛЕМЕНТЫ)
		ИсточникВыборки = ДеревоЗначений2.Строки;
		КлючСвязи = 0; // ЭЛЕМЕНТ ВЕРХНЕГО УРОВНЯ ИМЕЕТ НОМЕР СТРОКИ РОДИТЕЛЯ 0 (ОБЯЗАТЕЛЬНЫЙ РЕКВИЗИТ)
	Иначе
		//ВНУТРЕННИЙ ВЫЗОВ ПРОЦЕДУРЫ (ПОДЧИНЕННЫЕ ЭЛЕМЕНТЫ)
		ИсточникВыборки = ЭлементРодитель.Строки;
	КонецЕсли;
	Фильтр = Новый Структура(""КлючСвязи"", КлючСвязи);
	М = ДокОбъект[НаименованиеТабличнойЧастиДокумента].НайтиСтроки(Фильтр);
	Если М.Количество() = 0 Тогда
		Возврат ДеревоЗначений2;
	КонецЕсли;
	Для каждого Стр из М Цикл
		Элемент = ИсточникВыборки.Добавить();
		Для каждого Кол из КолонкиТаблицы Цикл
			Если Кол.Имя = ""НомерСтроки"" ИЛИ Кол.Имя = ""КлючСвязи"" Тогда
				Продолжить;
			Иначе
				Элемент[Кол.Имя] = Стр[Кол.Имя];
			КонецЕсли;
		КонецЦикла;
		ТаблицаВДерево(ДокОбъект, НаименованиеТабличнойЧастиДокумента, Стр.НомерСтроки, Элемент); //ДОБАВЛЕНИЕ ПОДЧИНЁННЫХ ЭЛЕМЕНТОВ В ДЕРЕВО
	КонецЦикла;
	Возврат ДеревоЗначений2;
КонецФункции
   

Формирование таблицы из дерева
Код 1C v 8.2 УП

 //ФОРМИРОВАНИЕ ТАБЛИЦЫ ИЗ ДЕРЕВА
&НаСервере
Процедура ДеревоВТаблицу(ДокОбъект, ДеревоЗначений, НаименованиеТабличнойЧастиДокумента, СтрокаДерева = NULL, КлючСвязи = NULL) Экспорт
	Если СтрокаДерева = NULL И КлючСвязи = NULL Тогда
		//ПЕРВЫЙ ВЫЗОВ ПРОЦЕДУРЫ (КОРНЕВЫЕ ЭЛЕМЕНТЫ)
		ПервыйВызов = Истина;
		ДокОбъект[НаименованиеТабличнойЧастиДокумента].Очистить();
		ИсточникВыборки = ДеревоЗначений.Строки;
		КлючСвязи = 0; // ЭЛЕМЕНТ ВЕРХНЕГО УРОВНЯ ИМЕЕТ НОМЕР СТРОКИ РОДИТЕЛЯ 0 (ОБЯЗАТЕЛЬНЫЙ РЕКВИЗИТ)
	Иначе
		//ВНУТРЕННИЙ ВЫЗОВ ПРОЦЕДУРЫ (ПОДЧИНЕННЫЕ ЭЛЕМЕНТЫ)
		ПервыйВызов = Ложь;
		ИсточникВыборки = СтрокаДерева.Строки;
	КонецЕсли;
	Для каждого Стр из ИсточникВыборки Цикл
		НС = ДокОбъект[НаименованиеТабличнойЧастиДокумента].Добавить();
		Для каждого Кол из ДокОбъект.Метаданные().ТабличныеЧасти[НаименованиеТабличнойЧастиДокумента].Реквизиты Цикл
			Если Кол.Имя = ""КлючСвязи"" Тогда
				НС.КлючСвязи = КлючСвязи
			ИначеЕсли Кол.Имя = ""НомерСтроки"" Тогда
				Продолжить;
			Иначе 
				НС[Кол.Имя] = Стр[Кол.Имя];
			КонецЕсли;
		КонецЦикла;
		Если НЕ Стр.Строки.Количество() = 0 Тогда
			ДеревоВТаблицу(ДокОбъект,,НаименованиеТабличнойЧастиДокумента, Стр, НС.НомерСтроки);
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры"}
}
},
{0,
{"Обход дерева значений (рекурсивно)",0,0,"","//Процедура обхода всего дерева значений
//-------------------------------------------------------------------------
//Параметры:
//		СтрокиДерева 	- Тип 	- описание
//-------------------------------------------------------------------------
//автор: КучеровРМ 06.11.2018 
Процедура ОбойтиСтрокиДерева(СтрокаДерева, АргументПроцедуры)
	
	Для Каждого ТекСтрока Из СтрокаДерева.Строки Цикл
		
		Сообщить(ТекСтрока.ИмяРеквизита);
		Если ТекСтрока.Строки.Количество()> 0 Тогда
			ОбновитьСтрокиДерева(ТекСтрока, АргументПроцедуры);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры"}
},
{0,
{"ОбойтиУровеньДерева",0,0,"","Процедура ОбойтиУровеньДерева(Строки)
	
	
	Для каждого Строка из Строки Цикл
		
		
		//что-то делаем со строкой, например:
		
		
		Сообщить(Строка.ИмяСуществующегоВСтрокеРеквизита); 
		
		
		ОбойтиУровеньДерева(Строка.Строки);
		
		
	КонецЦикла; 
	
	
КонецПроцедуры





//Вызываем перебор так:


Дерево = Новый ДеревоЗначений;


Запрос = Новый Запрос;


Запрос.Текст=""ВЫБРАТЬ


|Ном.Ссылка как ссылка


|ИЗ


| Справочник.Номенклатура КАК Ном


|ИТОГИ ПО


|Ном.Ссылка ТОЛЬКО ИЕРАРХИЯ"";


Дерево = Запрос.Выполнить().Выгрузить(ОбходРезультатаЗапроса.ПоГруппировкамСИерархией);


// перебор дерева значений


ОбойтиУровеньДерева(Дерево.Строки); "}
},
{0,
{"Обойти дерево с учетом РеквизитФормыВЗначение",0,0,"","//Процедура ОтметитьКатегориюДерева
//-------------------------------------------------------------------------
//Параметры:
//		КатегорияСтатьи 	- ДанныеФормыЭлементДерева 	- описание
//-------------------------------------------------------------------------
//автор: КучеровРМ 07.11.2018 
&НаСервере
Процедура ОтметитьКатегориюДерева(КатегорияСтатьи)
	
	КатегорииДеревоЗначение = РеквизитФормыВЗначение(""КатегорииДерево"");
	Если ЗначениеЗаполнено(КатегорииДеревоЗначение) Тогда
		ОбойтиПодстроки(КатегорииДеревоЗначение.Строки, КатегорияСтатьи);
	КонецЕсли;
	ЗначениеВРеквизитФормы(КатегорииДеревоЗначение, ""КатегорииДерево"");
	
КонецПроцедуры
 
//Процедура обхода всего дерева значений
//-------------------------------------------------------------------------
//Параметры:
//		СтрокиДерева 	- ДанныеФормыЭлементДерева 	- Результат от КатегорииДерево.ПолучитьЭлементы()
//-------------------------------------------------------------------------
//автор: КучеровРМ 06.11.2018
&НаСервере
Процедура ОбойтиПодстроки(СтрокиДерева, КатегорияСтатьи)
	
	Для Каждого Строка Из СтрокиДерева Цикл
		Если Строка.Категория = КатегорияСтатьи Тогда
			Строка.Использование = Истина;	
		КонецЕсли;
		ОбойтиПодстроки(Строка.Строки, КатегорияСтатьи);
	КонецЦикла;
	
КонецПроцедуры"}
},
{0,
{"Работа с деревом значений в 1С 8.3",0,0,"","Работа с деревом значений в 1С 8.3
http://qa.erpstat.ru/public/00052.html

%Заполнение дерева на основании запроса
&НаСервере
Процедура КомандаЗаполнитьНаСервере()
    ЗапросДанных    = Новый Запрос(""ВЫБРАТЬ
                                   |    Номенклатура.Ссылка КАК Номенклатура
                                   |ИЗ
                                   |    Справочник.Номенклатура КАК Номенклатура
                                   |ГДЕ
                                   |    НЕ Номенклатура.ЭтоГруппа
                                   |ИТОГИ ПО
                                   |    Номенклатура ТОЛЬКО ИЕРАРХИЯ"");
    ЗначениеВРеквизитФормы(
        ЗапросДанных.Выполнить().Выгрузить(ОбходРезультатаЗапроса.ПоГруппировкамСИерархией),
    ""Дерево"");
КонецПроцедуры

%Обойти строки рекурсивно на клиенте
&НаКлиенте
Процедура ОбойтиРекурсивно(Команда)
    ОбойтиРекурсивноСтрокиДереваНаКлиенте(Дерево.ПолучитьЭлементы());
КонецПроцедуры
 
&НаКлиенте
Процедура ОбойтиРекурсивноСтрокиДереваНаКлиенте(Строки)
    Для Каждого СтрокаДерева Из Строки Цикл
        Сообщить(СтрокаДерева.Номенклатура);
         
        ПодчиненныеСтроки   = СтрокаДерева.ПолучитьЭлементы();
         
        Если ПодчиненныеСтроки.Количество() > 0 Тогда
            ОбойтиРекурсивноСтрокиДереваНаКлиенте(ПодчиненныеСтроки);
        КонецЕсли;
    КонецЦикла;
КонецПроцедуры

%Обойти строки рекурсивно на сервере
&НаСервере
Процедура ОбойтиРекурсивноНаСервереНаСервере()
    ДЗ  = РеквизитФормыВЗначение(""Дерево"");
     
    ОбойтиРекурсивноСтрокиДереваНаСервере(ДЗ);
КонецПроцедуры
 
&НаСервере
Процедура ОбойтиРекурсивноСтрокиДереваНаСервере(ДЗ)
    Для Каждого СтрокаДерева Из ДЗ.Строки Цикл
        Сообщить(СтрокаДерева.Номенклатура);
         
        Если СтрокаДерева.Строки.Количество() > 0 Тогда
            ОбойтиРекурсивноСтрокиДереваНаСервере(СтрокаДерева);
        КонецЕсли;
    КонецЦикла;
КонецПроцедуры

%Очистить строки дерева значений
// На стороне клиента
Дерево.ПолучитьЭлементы().Очистить();
 
// На стороне сервера
ДЗ  = РеквизитФормыВЗначение(""Дерево"");
ДЗ.Строки.Очистить();
ЗначениеВРеквизитФормы(ДЗ, ""Дерево"");

%Добавить новую строку в текущую ветку (на клиенте)
ИдентификаторСтроки = Элементы.Дерево.ТекущаяСтрока;
ТекущаяСтрока       = Дерево.НайтиПоИдентификатору(ИдентификаторСтроки);
НоваяСтрокаДерева   = ТекущаяСтрока.ПолучитьЭлементы().Добавить();

%Удалить текущую строку (на клиенте)
ИдентификаторСтроки = Элементы.Дерево.ТекущаяСтрока;
ТекущаяСтрока       = Дерево.НайтиПоИдентификатору(ИдентификаторСтроки);
СтрокаРодитель      = ТекущаяСтрока.ПолучитьРодителя();
 
Если СтрокаРодитель = Неопределено Тогда
    Дерево.ПолучитьЭлементы().Удалить(ТекущаяСтрока);
Иначе
    СтрокаРодитель.ПолучитьЭлементы().Удалить(ТекущаяСтрока);
КонецЕсли;
"}
}
},
{0,
{"СериализироватьВXMLНаСервере и ДесериализоватьИзXMLНаСервере",0,0,"","&НаСервере
Процедура СериализироватьВXMLНаСервере();
	
	тСериализаторXDTO = Новый СериализаторXDTO(ФабрикаXDTO);
	
	тЗаписьXML = Новый ЗаписьXML;
	тЗаписьXML.ОткрытьФайл(""C:\test.xml"");
	
	тСериализаторXDTO.ЗаписатьXML(тЗаписьXML, Справочники.Тест.НайтиПоНаименованию(""Тест 1"").ПолучитьОбъект(), НазначениеТипаXML.Явное);
	
КонецПроцедуры

&НаСервере
Процедура ДесериализоватьИзXMLНаСервере()
	
	тСериализаторXDTO = Новый СериализаторXDTO(ФабрикаXDTO); 
	
	тЧтениеXML = Новый ЧтениеXML;
	тЧтениеXML.ОткрытьФайл(""C:\test.xml"");
	
	тСсылка = тСериализаторXDTO.ПрочитатьXML(тЧтениеXML);
	
КонецПроцедуры"}
},
{0,
{"СериализироватьВXMLНаСервере и ДесериализоватьИзXMLНаСервере 2",0,0,"","// Сериализировать
ОбъектXDTO 	= СериализаторXDTO.ЗаписатьXDTO(Объект);
ЗаписьXML 	= Новый ЗаписьXML; 
ЗаписьXML.ОткрытьФайл(ПутьКФайлу);

ФабрикаXDTO.ЗаписатьXML(ЗаписьXML, ОбъектXDTO);

ЗаписьXML.Закрыть();

// Десериализовать
ЧтениеXML 		= Новый ЧтениеXML; ЧтениеXML.ОткрытьФайл(ПутьКФайлу);
ТипОбъектаXDTO 	= ФабрикаXDTO.Тип(ТипОбъекта,ИмяОбъекта);
ОбъектXDTO 		= ФабрикаXDTO.ПрочитатьXML(ЧтениеXML,ТипОбъектаXDTO); ОбъектXDTO.Проверить();

ЧтениеXML.Закрыть();

Объект 			= СериализаторXDTO.ПрочитатьXDTO(ОбъектXDTO);"}
}
},
{2,
{"Преобразовать в значение (Реквизит, Данные формы)",1,0,"",""},
{0,
{"РеквизитФормыВЗначение",0,0,"РФВЗ","рфОбъектЗначение = РеквизитФормыВЗначение(""Объект"");

// Выполнение операций с Объектом ""рфОбъектЗначение""
<?>

ЗначениеВРеквизитФормы(рфОбъектЗначение, ""Объект"");"}
},
{0,
{"ДанныеФормыВЗначение",0,0,"ДФВЗ","дфОбъектЗначение = ДанныеФормыВЗначение(ОснРеквизит, Тип(""ДокументОбъект.АктСверкиВзаиморасчетов""));

// Выполнение операций с Объектом ""ОбъектЗначение""
<?>

ЗначениеВДанныеФормы(дфОбъектЗначение, ОснРеквизит);"}
}
},
{13,
{"Метаданные",1,0,"",""},
{0,
{"Быстро проверить Реквизит",0,0,"МетаРек","Если Компания.Метаданные().Реквизиты.Найти(""ИмяРеквизита"") <> Неопределено Тогда //Если найдены метаданные
		
КонецЕсли;"}
},
{0,
{"Быстро проверить ТЧ",0,0,"МетаТЧ","Если Компания.Метаданные().ТабличныеЧасти.Найти(""ИмяТЧ"") <> Неопределено Тогда //Если найдены метаданные
		
КонецЕсли;"}
},
{0,
{"Типовые УНФ ЦРМ",0,0,"","//Из CRM_ОбщегоНазначенияСервер
// Функция позволяет определить, есть ли среди реквизитов шапки документа
// реквизит с переданным именем.
//
// Параметры: 
//	ИмяРеквизита		- Строка		- Строковое имя искомого реквизита, 
//	МетаданныеДокумента	- Метаданные	- Объект описания метаданных документа, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//	Истина - Результат поиска
//
Функция ЕстьРеквизитДокумента(ИмяРеквизита, МетаданныеДокумента) Экспорт
	Возврат НЕ (МетаданныеДокумента.Реквизиты.Найти(ИмяРеквизита) = Неопределено);
КонецФункции // ЕстьРеквизитДокумента()

// Функция позволяет определить, есть ли среди реквизитов ТЧ объекта
// реквизит с переданным именем.
//
// Параметры: 
//	ИмяРеквизита		- Строка		- Строковое имя искомого реквизита, 
//	МетаданныеДокумента	- Метаданные	- Объект описания метаданных документа, среди реквизитов которого производится поиск.
//	ИмяТабличнойЧасти	- Строка	- Имя табличной части объекта, в которой проверяем наличие реквизита.
//
// Возвращаемое значение:
//	Истина - Результат поиска
//
Функция ЕстьРеквизитТабличнойЧастиОбъекта(ИмяРеквизита, МетаданныеДокумента, ИмяТабличнойЧасти) Экспорт
	Если МетаданныеДокумента.ТабличныеЧасти.Найти(ИмяТабличнойЧасти) = Неопределено Тогда
		Возврат Ложь;
	Иначе
		Возврат НЕ (МетаданныеДокумента.ТабличныеЧасти[ИмяТабличнойЧасти].Реквизиты.Найти(ИмяРеквизита) = Неопределено);
	КонецЕсли;
КонецФункции // ЕстьРеквизитТабличнойЧастиОбъекта()

// Процедура удаляет проверяемый реквизит из массива проверяемых реквизитов.
Процедура УдалитьПроверяемыйРеквизит(ПроверяемыеРеквизиты, ПроверяемыйРеквизит) Экспорт
	
	НайденныйРеквизит = ПроверяемыеРеквизиты.Найти(ПроверяемыйРеквизит);
	Если ЗначениеЗаполнено(НайденныйРеквизит) Тогда
		ПроверяемыеРеквизиты.Удалить(НайденныйРеквизит);
	КонецЕсли;
	
КонецПроцедуры // УдалитьПроверяемыйРеквизит()"}
},
{0,
{"ТипВсеСсылки Содержит",0,0,"","ВсеСсылки = Справочники.ТипВсеСсылки();
ВсеСсылки.Содержит(Объект.Ссылка)"}
},
{0,
{"Тип элемента метаданных",0,0,"","Если ТипЗнч(ЗаказыПоставщикамУТ.СтруктурнаяЕдиница) = Тип(""СправочникСсылка.Кассы"") Тогда
	ПостБух.СтруктурнаяЕдиница = Справочники.Кассы.НайтиПоКоду(Код);    
Иначе    
	ПостБух.СтруктурнаяЕдиница = Справочники.БанковскиеСчета.НайтиПоКоду(Код);    
КонецЕсли;"}
},
{0,
{"ТипВсеСсылки СодержитТип",0,0,"","спрКонтрагенты = Справочники.Контрагенты;
Объект = спрКонтрагенты.НайтиПоКоду(""0000004"");

Если Справочники.ТипВсеСсылки().СодержитТип(ТипЗнч(Объект)) Тогда
    Сообщить(1);
ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(ТипЗнч(Объект)) Тогда
    Сообщить(2);
КонецЕсли;"}
},
{0,
{"Реквизиты.Получить",0,0,"","Ссылка = Документ.Метаданные().Реквизиты.Получить(2).тип;"}
},
{0,
{"Метаданные().Имя",0,0,"","Документы.ВашДокумент.Метаданные().Имя
Справочники.ВашСправочник.Метаданные().Имя"}
},
{0,
{"Метаданные.<Имя>.Содержит",0,0,"","ТипЗначения = ТипЗнч(ВыбСчет);
ОбъектМетаданных = Метаданные.НайтиПоТипу(ТипЗначения);
Если Метаданные.Справочники.Содержит(ОбъектМетаданных) Тогда
    Сообщить(""Справочник"");
ИначеЕсли Метаданные.Документы.Содержит(ОбъектМетаданных) Тогда
    Сообщить(""Документ"");
КонецЕсли;"}
},
{0,
{"Присвоить Проверяя Метаданные реквизита",0,0,"","
// Значение - Чему присвоить
// ОбъектПроверки - Объект, реквизит которого проверяем, значение какого попытаемся присвоить
// ИмяРеквизита - Строка
// МетаданныеОбъекта - ОбъектМетаданных - Если они уже были получены раннее (чтобы не грузить систему лишний раз)
Функция ПрисвоитьРеквизитПроверяяМетаданные(Значение, ОбъектПроверки, ИмяРеквизита, МетаданныеОбъекта = Неопределено)
	
	Значение = Неопределено;
	
	Если МетаданныеОбъекта = Неопределено Тогда
		МетаданныеОбъекта = ОбъектПроверки.Метаданные();	
	КонецЕсли; 
	
	ТипПодходит = ТипЗнч(МетаданныеОбъекта) = Тип(""ОбъектМетаданных"");
	Если НЕ ТипПодходит Тогда
		Возврат Неопределено;	
	КонецЕсли; 
	
	ЕстьМетаданные = МетаданныеОбъекта.Реквизиты.Найти(ИмяРеквизита) <> Неопределено;
	
	Если ЕстьМетаданные Тогда
		Значение = ОбъектПроверки[ИмяРеквизита];
	Иначе
		Сообщить(""Не было присвоено значение, т.к. не найден нужный реквизит '"" + ИмяРеквизита + ""' в '"" + Строка(ОбъектПроверки) + ""'"");
	КонецЕсли;
	
	Возврат Значение;
	
КонецФункции // ПрисвоитьРеквизитПроверяяМетаданные()
 "}
},
{0,
{"Присвоить Проверяя Метаданные Универсально",0,0,"","// Значение - Чему присвоить
// ОбъектПроверки - Объект, реквизит которого проверяем, значение какого попытаемся присвоить
// ИмяРеквизита - Строка
// МетаданныеОбъекта - ОбъектМетаданных - Если они уже были получены раннее (чтобы не грузить систему лишний раз)
// ЭтоРеквизит - Истина, если это просто реквизит Объекта, иначе будет рассмотрен реквизит ТЧ (есть ли он)(но его значение не вернёт!) 
Функция ПрисвоитьРеквизитПроверяяМетаданные(Значение, ОбъектПроверки, ИмяРеквизита = """", ЭтоРеквизит = Истина, ИмяТабличнойЧасти = """", НомерСтрокиТЧ = 0, МетаданныеОбъекта = Неопределено,  ВозвращатьЕслиНетЗначения = Неопределено, ВыводитьСообщениеОбОшибке = Ложь)
	
	Значение = Неопределено;
	
	Если МетаданныеОбъекта = Неопределено Тогда
		МетаданныеОбъекта = ОбъектПроверки.Метаданные();	
	КонецЕсли; 
	
	ТипПодходит = ТипЗнч(МетаданныеОбъекта) = Тип(""ОбъектМетаданных"");
	Если НЕ ТипПодходит Тогда
		Возврат Неопределено;	
	КонецЕсли; 
	
	ЕстьИмяТабличнойЧасти 	= НЕ ПустаяСтрока(ИмяТабличнойЧасти);
	ЕстьИмяРеквизита 		= НЕ ПустаяСтрока(ИмяРеквизита);
	
	ЕстьМетаданные = Неопределено;
	
	Если ЭтоРеквизит Тогда
		ЕстьМетаданные = МетаданныеОбъекта.Реквизиты.Найти(ИмяРеквизита) <> Неопределено;
	Иначе
		Если ЕстьИмяТабличнойЧасти Тогда
			ОбъектТЧ = МетаданныеОбъекта.ТабличныеЧасти.Найти(ИмяТабличнойЧасти);
			ТЧЕстьМетаданные = ОбъектТЧ <> Неопределено;
			Если ТЧЕстьМетаданные Тогда
				ЕстьМетаданные = ?(ЕстьИмяРеквизита, ОбъектТЧ.Реквизиты.Найти(ИмяРеквизита) <> Неопределено, ТЧЕстьМетаданные);
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
	
	ТочноЕстьМетаданные = ЕстьМетаданные <> Неопределено;
	Если ТочноЕстьМетаданные И ЕстьМетаданные Тогда
		Если ЭтоРеквизит Тогда
			Значение = ОбъектПроверки[ИмяРеквизита];
		Иначе // Это ТЧ	
			Если ЕстьИмяТабличнойЧасти Тогда
				//Если ЕстьИмяРеквизита Тогда // Это надо отладить
				//	ЕстьСтрокиТЧ = ОбъектПроверки[ИмяТабличнойЧасти].Количество() > 0;
				//	Если ЕстьСтрокиТЧ И НомерСтрокиТЧ > 0 Тогда
				//		Значение = ОбъектПроверки[ИмяТабличнойЧасти][НомерСтрокиТЧ][ИмяРеквизита];	
				//	КонецЕсли; 
				//КонецЕсли; 
				//Значение = ?(ЕстьИмяРеквизита, ОбъектПроверки[ИмяТабличнойЧасти][ИмяРеквизита], ОбъектПроверки[ИмяТабличнойЧасти]); // Не прокатит, т.к. надо задавать номер строки, реквизит которой нужен
				Значение = ОбъектПроверки[ИмяТабличнойЧасти];
			КонецЕсли;	
		КонецЕсли; 
	Иначе
		Значение = ВозвращатьЕслиНетЗначения;
		Если ВыводитьСообщениеОбОшибке Тогда
			Сообщить(""Не было присвоено значение, т.к. не найден нужный реквизит '"" + ИмяРеквизита + ""' в '"" + Строка(ОбъектПроверки) + ""'"");	
		КонецЕсли; 
	КонецЕсли;
	
	Возврат Значение;
	
КонецФункции // ПрисвоитьРеквизитПроверяяМетаданные()
"}
},
{0,
{"ЕстьРеквизитОбъекта - Есть ли среди реквизитов объекта реквизит с переданным именем",0,0,"","//Функция позволяет определить есть ли среди реквизитов объекта, реквизит с переданным именем
//-------------------------------------------------------------------------
//Параметры:
//		пОбъект - Именованная структура данных - любой объект имеющий именованные свойства
//		пИмяРек - Строка - Имя искомого реквизита
//		пТипЗначения - Тип Ожидаемый тип реквизита. Если параметр задан, то производится проверка типа
//						имеет смысл, если просто наличие реквизита не может считаться достаточны, и реквизит должен иметь строго определённый тип
//Возвращаемое значение:
//		Булево - Истина если реквизит существует. При проверке типа, Истина вернётся только при совпадении типов
//-------------------------------------------------------------------------
//автор: Майаров Артано 
Функция ЕстьРеквизитОбъекта(пОбъект, пИмяРек, пТипЗначения = Неопределено) Экспорт
	КонтрольноеЗначение = Новый УникальныйИдентификатор;
	СтруктураРеквизита 	= Новый Структура(пИмяРек, КонтрольноеЗначение);
	ПроверятьТип 		= ТипЗнч(пТипЗначения) = Тип(""Тип"");
	
	ЗаполнитьЗначениеСвойств(СтруктураРеквизита, пОбъект);
	Результат 	= Ложь;
	Значение 	= СтруктураРеквизита[пИмяРек];
	Если Значение <> КонтрольноеЗначение Тогда
		Если ПроверятьТип Тогда
			Результат = пТипЗначения = ТипЗнч(Значение);
		Иначе
			Результат = Истина;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции"}
},
{6,
{"Найти (проверить)",1,0,"",""},
{0,
{"Найти в Константы",0,0,"","Метаданные.Константы.Найти(""<?""Имя константы"", Константа>"");"}
},
{0,
{"Найти в Документы",0,0,"","Метаданные.Документы.Найти(""<?""Имя документа"", Документ>"");"}
},
{0,
{"Найти в Справочники",0,0,"","Метаданные.Справочники.Найти(""<?""Имя справочника"", Справочник>"");"}
},
{0,
{"Цикл",0,0,"","Для Каждого ИмяКонстанты<?""Элемент"", ВыборВарианта, ""Констранты"", ""Констранты"", ""Документы"", ""Документы"", ""Справочники"", ""Справочники""> Из <?""Элемент"", ВыборВарианта, ""Констранты"", ""Констранты"", ""Документы"", ""Документы"", ""Справочники"", ""Справочники""> Цикл
	Сообщить(Имя<?""Элемент"", ВыборВарианта, ""Констранты"", ""Констранты"", ""Документы"", ""Документы"", ""Справочники"", ""Справочники"">);
КонецЦикла"}
},
{3,
{"Найти реквизит, ТЧ",1,0,"",""},
{0,
{"ЕстьРеквизитОбъекта",0,0,"","&НаСервере
Функция ЕстьРеквизитОбъекта(ИмяРеквизита, Объект) Экспорт
	
	МетаданныеОбъекта 	= Объект.Метаданные();
	Результат 			= МетаданныеОбъекта.Реквизиты.Найти(ИмяРеквизита) <> Неопределено;
	
	Возврат Результат;
	
КонецФункции"}
},
{0,
{"ЕстьТЧОбъекта",0,0,"","&НаСервере
Функция ЕстьТЧОбъекта(ИмяТЧ, Объект) Экспорт
	
	МетаданныеОбъекта 	= Объект.Метаданные();
	Результат 			= МетаданныеОбъекта.ТабличныеЧасти.Найти(ИмяТЧ) <> Неопределено;
	
	Возврат Результат;
	
КонецФункции
"}
},
{0,
{"ПроверитьМетаданные Универсально",0,0,"","//Функция ПроверитьМетаданные
//-------------------------------------------------------------------------
//Параметры:
//		МетаданныеДляПроверки - Строка, Массив - МетаданныеДляПроверки
//		МетаданныеДляПроверки - Объект - Объект
//		ИмяМетаданныхОбъекта - Строка - Напр., ""Реквизиты"", ""ТабличныеЧасти"" 
//Возвращаемое значение:
//		СписокЗначений - Пометка - Пометка отмечена, если есть метаданные
//-------------------------------------------------------------------------
//автор: КучеровРМ 21.09.2018 
&НаСервере
Функция ПроверитьМетаданные(МетаданныеДляПроверки, ОбъектДляПроверки, ИмяМетаданныхОбъекта = ""Реквизиты"", ВернутьТолькоСуществующие = Истина)
	
	ИмяМетаданныхЗнач = СокрЛП(ИмяМетаданныхОбъекта);
	Если ПустаяСтрока(ИмяМетаданныхЗнач) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ТипЗнчМетаданныеДляПроверки = ТипЗнч(МетаданныеДляПроверки);
	Если ТипЗнчМетаданныеДляПроверки = Тип(""Строка"") Тогда
		МетаданныеДляПроверкиМассив = СтрРазделить(МетаданныеДляПроверки, "","", Ложь);
	ИначеЕсли ТипЗнчМетаданныеДляПроверки = Тип(""Массив"") Тогда
		МетаданныеДляПроверкиМассив = МетаданныеДляПроверки;
	КонецЕсли;	
	
	МетаданныеДляПроверкиСписок = Новый СписокЗначений;
	МетаданныеДляПроверкиСписок.ЗагрузитьЗначения(МетаданныеДляПроверкиМассив);
	
	МетаданныеОбъекта = ОбъектДляПроверки.Метаданные();
	Для каждого ЭлМетаданныеДляПроверки Из МетаданныеДляПроверкиСписок Цикл
		
		ЭлМетаданныеДляПроверкиЗначение = ЭлМетаданныеДляПроверки.Значение;
		ЭлМетаданныеДляПроверки.Пометка = МетаданныеОбъекта[ИмяМетаданныхОбъекта].Найти(ЭлМетаданныеДляПроверкиЗначение) <> Неопределено; // Значит метаданные найден	
		
		Если ВернутьТолькоСуществующие И НЕ ЭлМетаданныеДляПроверки.Пометка Тогда
			МетаданныеДляПроверкиСписок.Удалить(ЭлМетаданныеДляПроверки);	
		КонецЕсли; 
		
	КонецЦикла;
	
	МетаданныеДляПроверкиСписокКоличество = МетаданныеДляПроверкиСписок.Количество();
	Если МетаданныеДляПроверкиСписокКоличество > 0 Тогда
		Результат = МетаданныеДляПроверкиСписок;
	Иначе
		Результат = Неопределено;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции // МетаданныеДляПроверки()

// Использование
ЕстьМетаданные = ПроверитьМетаданные(Имя, ОбъектЗначение, ""ТабличныеЧасти"");
Если ЕстьМетаданные <> Неопределено Тогда
	МетаданныеНайти = ""МетаданныеИмя"";
	ЕстьИскомыеМетаданные = ЕстьМетаданные.НайтиПоЗначению(МетаданныеНайти) <> Неопределено;
КонецЕсли;"}
}
},
{0,
{"Относится ли реквизит к расширению",0,0,"","//  Метод определения относится ли реквизит к расширению
Реквизиты = Метаданные.Справочники.Номенклатура.Реквизиты;
Для Каждого Реквизит Из РЕквизиты Цикл
	ЭтоРеквизитРасширения = НЕ Реквизит.РасширениеКонфигурации() = Неопределено;
	Сообщить(Строка(ЭтоРеквизитРасширения) + "" "" + Реквизит.Имя);
КонецЦикла;"}
}
}
},
{5,
{"Использование макета 1С как внутренего справочника",1,0,"",""},
{0,
{"МакетВТаблицуЗначений",0,0,"","//Дешево и сердито, часто нужно считывать данные из макета в таблицу значений (константа типа таблица значений). :) Уж лучше так, чем как это делают 1С-ники в своих регламентированных отчетах. 
//Макет - макет из которого читаем. 
//_ТЗ - если грузим в существующую таблицу (добавляет в конец). 
//флДобавлятьКолонки - если ложь, то новые колонки не добавляются. 
Функция МакетВТаблицуЗначений(Макет, _ТЗ=Неопределено, флДобавлятьКолонки=истина) Экспорт
	Перем ТЗ;
	
	Если _ТЗ=Неопределено Тогда
		ТЗ=Новый ТаблицаЗначений();
		флЗаполняем=ложь;
	Иначе
		ТЗ=_ТЗ;
		флЗаполняем=истина;
	КонецЕсли;
	
	//Считываем колонки
	КоличествоКолонок=0;
	ИменаКолонок=Новый Массив();
	Кол=1;
	Пока истина Цикл
		Адрес=""R1C""+Формат(Кол,""ЧГ="");
		ИмяКол=Макет.Область(Адрес).Текст;
		Если ПустаяСтрока(ИмяКол) Тогда
			Прервать;
		КонецЕсли;
		КоличествоКолонок=КоличествоКолонок+1;
		Если НЕ флЗаполняем или (флЗаполняем И флДобавлятьКолонки) И ТЗ.Колонки.Найти(ИмяКол)=Неопределено Тогда
			ТЗ.Колонки.Добавить(ИмяКол);
		КонецЕсли;
		ИменаКолонок.Добавить(ИмяКол);
		Кол=Кол+1;
	КонецЦикла;
	
	//Считываем строки
	Стр=2; Кол=1;
	Пока истина Цикл
		Вставлено=ложь; Первая=истина;
		Для Инд=1 По КоличествоКолонок Цикл
			Адрес=""R""+Формат(Стр,""ЧГ="")+""C""+Формат(Инд,""ЧГ="");
			Зн=СокрЛП(Макет.Область(Адрес).Текст);
			Если ПустаяСтрока(Зн) Тогда
				Продолжить;
			КонецЕсли;
			Если Первая Тогда
				ТСтр=ТЗ.Добавить();
				Первая=ложь;
				Вставлено=истина;
			КонецЕсли;
			ИмяКолонки=ИменаКолонок[Инд-1];
			Если ТЗ.Колонки.Найти(ИмяКолонки)<>Неопределено Тогда
				Если флЗаполняем Тогда
					//Проверяем тип - число, строка, булево
					ОписаниеТипаКолонки=ТЗ.Колонки[ИмяКолонки].ТипЗначения;
					Если ОписаниеТипаКолонки.СодержитТип(Тип(""Число"")) Тогда
						РезЗн=Число(Зн);
					ИначеЕсли ОписаниеТипаКолонки.СодержитТип(Тип(""Строка"")) Тогда
						РезЗн=Строка(Зн);
					ИначеЕсли ОписаниеТипаКолонки.СодержитТип(Тип(""Булево"")) Тогда
						РезЗн=Булево(Зн);
					ИначеЕсли ОписаниеТипаКолонки.СодержитТип(Тип(""Дата"")) Тогда
						РезЗн=Дата(Зн);
					Иначе
						РезЗн=Зн;
					КонецЕсли;
				Иначе
					РезЗн=Зн;
				КонецЕсли;
				ТСтр[ИмяКолонки]=РезЗн;
			КонецЕсли;
		КонецЦикла;
		Если Не вставлено Тогда
			Прервать;
		КонецЕсли;
		Стр=Стр+1;
		Кол=1;
	КонецЦикла;
	
	Возврат ТЗ;
	
КонецФункции"}
},
{0,
{"Типовой",0,0,"","Функция ПолучитьРеквизитыСчетовУчета(ИмяДокумента, ИмяТабличнойЧасти)
	
	Макет = ПолучитьОбщийМакет(""СчетаУчетаВДокументах"");
	ПостроительЗапроса = Новый ПостроительЗапроса;
	ПостроительЗапроса.ИсточникДанных = Новый ОписаниеИсточникаДанных(Макет.Область(""ОписаниеСчетовУчета""));
	
	// Установим отборы
	УстановитьОтборПоПолю(ПостроительЗапроса, ""Документ"",       ИмяДокумента);
	УстановитьОтборПоПолю(ПостроительЗапроса, ""ТабличнаяЧасть"", ИмяТабличнойЧасти);
	
	// Возвращаем таблицу значений с отобранными из макета данными 
	ПостроительЗапроса.Выполнить();
	Возврат ПостроительЗапроса.Результат.Выгрузить();
	
КонецФункции

"}
},
{0,
{"Чтение в список значений",0,0,"","//Чтение в список значений (Должности). Данные находятся в первой колонке.
Должности.Очистить();
МакетДолжности = ПолучитьМакет(""Должности"");
Стр = 1;
Пока истина Цикл
	Адрес=""R""+Формат(Стр,""ЧГ="")+""C1"";
	Значение=МакетДолжности.Область(Адрес).Текст;
	Если ПустаяСтрока(Значение) Тогда
		Прервать;
	КонецЕсли;      
	Должности.Добавить(Значение);
	Стр = Стр + 1;
КонецЦикла; "}
},
{0,
{"Загружает весь табличный документ в таблицу значений > Автор : dimoff",0,0,"","// Вариант 1
// По переданному табличному документу возвращает таблицу значений,

// при условии что в первой строке таблицы - идентификаторы колонок 
// Автор : dimoff
Функция ПолучитьТЗИзМакета(ТабДок, КолонкаИндекса = 1) Экспорт
	
	ТаблицаДанных = Новый ТаблицаЗначений;
	НомерКолонки = 0;
	Пока Истина Цикл
		НомерКолонки = НомерКолонки + 1;
		ИмяКолонки = ТабДок.Область(1, НомерКолонки).Текст;
		Если ПустаяСтрока(ИмяКолонки) Тогда
			Прервать;
		КонецЕсли; 
		ТаблицаДанных.Колонки.Добавить(ИмяКолонки);
	КонецЦикла;
	
	СчетчикКолонок = НомерКолонки - 1;
	
	НомерСтроки = 1; ФлагПрерывания = Ложь;
	Пока Истина Цикл
		НомерСтроки = НомерСтроки + 1;
		Стр = ТаблицаДанных.Добавить();
		
		Для А = 1 ПО СчетчикКолонок Цикл
			ТекстКолонки = ТабДок.Область(НомерСтроки, А).Текст;
			Если ПустаяСтрока(ТекстКолонки) Тогда
				Если А = КолонкаИндекса Тогда
					Флагпрерывания = Истина;
					ТаблицаДанных.Удалить(Стр);
				КонецЕсли;
			Иначе
				Стр[А - 1] = ТекстКолонки
			КонецЕсли;
			
			Если Флагпрерывания Тогда
				Прервать
			КонецЕсли;
		КонецЦикла;
		
		Если Флагпрерывания Тогда
			Прервать
		КонецЕсли;
	КонецЦикла;
	
	Возврат ТаблицаДанных
КонецФункции

"}
},
{0,
{"Загружает весь табличный документ в таблицу значений > Автор : Гений1С",0,0,"","//Код 1C v 8.х
// Варинат 2
//Функция загружает весь макет, табличный документ в таблицу значений
//Первая строка содержит подписи колонок (должны быть правильные идентификаторы)
//Пустые строки (состоящией из пробелов, переводов строки и т.п.) заменяет на Неопределено
//Если в ячейке есть значение, в ячейку таблицы значений попадает именно это значение
//Автор : Гений1С
Функция обМакетВТаблицуЗначений(Макет) Экспорт
	Перем ТЗ;
	ТЗ=Новый ТаблицаЗначений();
	#Если Клиент Тогда
		//Считываем колонки
		Для Стр=1 По Макет.ВысотаТаблицы Цикл
			Если Стр>1 Тогда
				ТекСтр=ТЗ.Добавить();
			КонецЕсли;
			ПустаяСтрока=истина;
			Для Кол=1 По Макет.ШиринаТаблицы Цикл
				Яч=Макет.Область(Стр, Кол);
				Если Яч.СодержитЗначение Тогда
					Зн=Яч.Значение;
				Иначе
					Зн=Яч.Текст;
				КонецЕсли;
				Если ТипЗнч(Зн)=Тип(""Строка"") И ПустаяСтрока(Зн) Тогда
					Зн=Неопределено;
				КонецЕсли;
				
				//Добавляем колонку
				Если Стр=1 Тогда
					ТЗ.Колонки.Добавить(Зн);
				Иначе
					ТекСтр[Кол-1]=Зн;
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
	#КонецЕсли
	Возврат ТЗ;
КонецФункции "}
}
},
{7,
{"Внешняя навигационная ссылка",1,0,"",""},
{0,
{"Типовое",0,0,"","ОбщегоНазначения.АдресПубликацииИнформационнойБазыВЛокальнойСети() + ""/#"" + ПолучитьНавигационнуюСсылку(Документ)"}
},
{0,
{"ПолучитьНавигационнуюСсылкуИнформационнойБазы",0,0,"ПНСИБ","ПолучитьНавигационнуюСсылкуИнформационнойБазы();"}
},
{0,
{"ПолучитьПолнуюНавигационнуюСсылку",0,0,"","&НаСервере
Функция ПолучитьПолнуюНавигационнуюСсылку(Ссылка, УчестьИнформационнуюБазу = Ложь)
	
	СсылкуИнформационнойБазы = """";
	Если УчестьИнформационнуюБазу Тогда
		СсылкуИнформационнойБазы = СсылкуИнформационнойБазы + ПолучитьНавигационнуюСсылкуИнформационнойБазы() + ""/#"";
	КонецЕсли;
	
	НавигационнаяСсылка = """";
	Если Метаданные.Константы.Найти(""АдресВебСервера"") <> Неопределено Тогда
		
		Если ЗначениеЗаполнено(Константы.АдресВебСервера.Получить()) Тогда 
			НавигационнаяСсылка = СокрЛП(Константы.АдресВебСервера.Получить()) + ""/#"" + ПолучитьНавигационнуюСсылку(Ссылка); 
		Иначе 
			НавигационнаяСсылка = СсылкуИнформационнойБазы + ПолучитьНавигационнуюСсылку(Ссылка); 
		КонецЕсли;
	Иначе
		НавигационнаяСсылка = СсылкуИнформационнойБазы + ПолучитьНавигационнуюСсылку(Ссылка); 
	КонецЕсли;
	
	Возврат НавигационнаяСсылка;
	
КонецФункции // ПолучитьПолнуюНавигационнуюСсылку()
 
"}
},
{0,
{"При использовании в web-клиенте",0,0,"","//При использовании в web-клиенте 
//Стояла следующая задача: отправлять уведомления о изменениях в документах на почту и вкладывать в письмо гиперссылку на измененный документ. База опубликована на web-севере. Полученная в 1С ссылка методом ПолучитьНавигационнуюСсылку() имела следующий вид 
//https://localhost/#e1cib/data/Документы.Счет?ref=""ab99005056c0000811e00f627bcddd55"" 

//Вложенная в таком виде ссылка не открывала нужный документ, а лишь инициировала переход в базу. 
//Как оказалось проблема была в следующем, в URL-адресах не должны присутствовать кавычки, их заменяем на %22 
//https://localhost/#e1cib/data/Документы.Счет?ref=%22ab99005056c0000811e00f627bcddd55%22"}
},
{0,
{"ПолучитьНавигационнуюСсылку",0,0,"ПНС","ПолучитьНавигационнуюСсылку();"}
},
{0,
{"СозданоИзДокумента",0,0,"","// Описание, Комментарий
СозданоИзДокумента 	= """";
Если ЗначениеЗаполнено(ЭлементСсылка) Тогда
	НавигационнаяСсылка = ПолучитьПолнуюНавигационнуюСсылку(ЭлементСсылка);
	СозданоИзДокумента 	= ""Создано из документа: "" 	+ Строка(ЭлементСсылка) + ""
	|Ссылка на документ: "" + НавигационнаяСсылка + ""
	|
	|"";
КонецЕсли; 
ОписаниеЗадания 			= СозданоИзДокумента + ""Описание:"" + Символы.ПС;

// Не получается так: ПолучитьПолнуюНавигационнуюСсылку + Символы.ПС"}
},
{0,
{"ПолучитьСсылкуИзНавигационной",0,0,"","Функция ПолучитьСсылкуИзНавигационной(НС)
    
    ПерваяТочка 	= Найти(НС, ""e1cib/data/"");
    ВтораяТочка 	= Найти(НС, ""?ref="");
    
    ПредставлениеТипа   = Сред(НС, ПерваяТочка + 11, ВтораяТочка - ПерваяТочка - 11);
    ШаблонЗначения 	= ЗначениеВСтрокуВнутр(ПредопределенноеЗначение(ПредставлениеТипа + "".ПустаяСсылка""));
    ЗначениеСсылки 	= СтрЗаменить(ШаблонЗначения, ""00000000000000000000000000000000"", Сред(НС, ВтораяТочка + 5));
    Ссылка 			= ЗначениеИзСтрокиВнутр(ЗначениеСсылки);
	
	Возврат Ссылка;
	
КонецФункции"}
}
},
{1,
{"Сообщения для пользователей",1,0,"",""},
{0,
{"Блокировка пользователей",0,0,"","Будет производиться резервная копия программы. Процесс займёт 1-3 часа, в зависимости от размера базы. 
Будет производиться резервная копия программы (1-3 часа, в зависимости от размера базы) и приминение изменений (1-2 часа). Всего процесс займёт 2-5 часов.

Будет производиться резервная копия программы (1-3 часа, в зависимости от размера базы) и интеграция модуля Битрикс (1-2 часа). Всего процесс займёт 2-5 часов.

Прошу предоставить доступ в 1С в рамках задачи устранения проблем с синхронизацией с Битрикс. 
Прошу предоставить доступ в 1С в рамках задачи настройки синхронизации с Битрикс.

Доп параметр запуска 1С: /UC123"}
}
},
{2,
{"Должность сотрудника",1,0,"",""},
{0,
{"ПолучитьДолжностьСотрудника",0,0,"","Функция ПолучитьДолжностьСотрудника(Сотрудник)
	
	ЗапросПоСотрудникам = Новый Запрос;
	ЗапросПоСотрудникам.Текст = ""ВЫБРАТЬ ТекущиеКадровыеДанныеСотрудников.ТекущаяДолжность
	|ИЗ РегистрСведений.ТекущиеКадровыеДанныеСотрудников КАК ТекущиеКадровыеДанныеСотрудников
	|ГДЕ ТекущиеКадровыеДанныеСотрудников.Сотрудник = &Сотрудник"";
	
	ЗапросПоСотрудникам.Параметры.Вставить(""Сотрудник"", Сотрудник);
	
	Результат = ЗапросПоСотрудникам.Выполнить(); 
	Если Не Результат.Пустой() Тогда
		Выборка = Результат.Выбрать();
		Выборка.Следующий();
		Возврат Выборка.ТекущаяДолжность;
	Иначе
		Возврат Неопределено
	КонецЕсли;    
	
КонецФункции"}
},
{0,
{"ДолжностьСотрудника Типовое",0,0,"","&НаСервереБезКонтекста
Функция ДолжностьСотрудника(Сотрудник)
	
	МассивСотрудников = Новый Массив;
	МассивСотрудников.Добавить(Сотрудник);
	ТЗСведения = КадровыйУчет.КадровыеДанныеСотрудников(Истина, МассивСотрудников, ""Организация,Должность"");
	Если ТЗСведения.Количество() > 0 Тогда
		Должность = ТЗСведения[0].Должность;
	Иначе
		Должность = ПредопределенноеЗначение(""Справочник.Должности.ПустаяСсылка"");
	КонецЕсли;
	
	Возврат Должность;
	
КонецФункции"}
}
},
{9,
{"Цвета",1,0,"",""},
{0,
{"WebЦвета",0,0,"ВЦ[вета]","WebЦвета"}
},
{0,
{"WebЦвета.СветлоКоралловый",0,0,"ВЦК","WebЦвета.СветлоКоралловый"}
},
{0,
{"WebЦвета.БледноЗеленый",0,0,"ВЦЗ","WebЦвета.БледноЗеленый"}
},
{0,
{"WebЦвета.Лосось",0,0,"ВЦЛ","WebЦвета.Лосось"}
},
{0,
{"WebЦвета.Оранжевый",0,0,"ВЦО","WebЦвета.Оранжевый"}
},
{0,
{"WebЦвета.СветлоНебесноГолубой",0,0,"ВЦГ","WebЦвета.СветлоНебесноГолубой"}
},
{0,
{"WebЦвета.Бирюзовый",0,0,"ВЦБ","WebЦвета.Бирюзовый"}
},
{0,
{"WebЦвета.СеребристоСерый",0,0,"ВЦС","WebЦвета.СеребристоСерый"}
},
{0,
{"WebЦвета.СветлоЗолотистый",0,0,"ВЦЖ","WebЦвета.СветлоЗолотистый"}
}
},
{55,
{"ТОП",1,0,"",""},
{0,
{"Быстрое присваивание левой части правой (для присвоения названия с точками) (==)",0,0,"==","л<?""Введите текст присвоения""> 	= <?""Введите текст присвоения"">;"}
},
{0,
{"Быстрое присваивание левой части правой (для присвоения названия с точками) (2 табуляции == )",0,0,"==	","л<?""Введите текст присвоения""> 		= <?""Введите текст присвоения"">;"}
},
{0,
{"Быстрое присваивание левой части правой (для присвоения названия с точками) (3 табуляции == )",0,0,"==		","л<?""Введите текст присвоения""> 			= <?""Введите текст присвоения"">;"}
},
{0,
{"Быстрое присваивание левой части правой = ЗначениеЗаполнено",0,0,"==З","лЕсть<?""Введите текст присвоения""> 	= ЗначениеЗаполнено(<?""Введите текст присвоения"">); "}
},
{0,
{"ЗначениеЗаполнено",0,0,"ЗЗ","ЗначениеЗаполнено(<?""Введите какое значение"">)"}
},
{0,
{"= Неопределено",0,0,"=Н","= Неопределено"}
},
{0,
{"= Неопределено;",0,0,"=Н;","= Неопределено;"}
},
{0,
{"<> Неопределено",0,0,"бюН","<> Неопределено"}
},
{0,
{"= Новый Массив",0,0,"=НМ","= Новый Массив"}
},
{0,
{"= Новый Массив;",0,0,"=НМ;","= Новый Массив;"}
},
{0,
{"= Новый Структура",0,0,"=НС","= Новый Структура"}
},
{0,
{"= Новый Структура;",0,0,"=НС;","= Новый Структура;"}
},
{0,
{"= Истина",0,0,"=И","= Истина"}
},
{0,
{"= Истина;",0,0,"=И;","= Истина;"}
},
{0,
{"= Ложь",0,0,"=Л","= Ложь"}
},
{0,
{"= Ложь;",0,0,"=Л;","= Ложь;"}
},
{0,
{"= Новый СписокЗначений",0,0,"=НСЗ","= Новый СписокЗначений"}
},
{0,
{"= Новый СписокЗначений;",0,0,"=НСЗ;","= Новый СписокЗначений;"}
},
{0,
{"= Новый ТаблицаЗначений",0,0,"=НТЗ","= Новый ТаблицаЗначений"}
},
{0,
{"= Новый ТаблицаЗначений;",0,0,"=НТЗ;","= Новый ТаблицаЗначений;"}
},
{0,
{"= Новый ОписаниеТипов",0,0,"=ОТ","= Новый ОписаниеТипов(""Строка"")"}
},
{0,
{"Если ЗначениеЗаполнено",0,0,"ЕслиЗЗ","Если ЗначениеЗаполнено(<?""Значение на проверку заполненности"">) Тогда
	<?>
КонецЕсли;"}
},
{0,
{"Если ЗначениеЗаполнено с локальной переменной",0,0,"ЕслиЛЗЗ","лЕсть<?""Значение на проверку заполненности""> 	= ЗначениеЗаполнено(<?""Значение на проверку заполненности"">);
Если лЕсть<?""Значение на проверку заполненности""> Тогда
	<?>
КонецЕсли;"}
},
{0,
{"ЕслиПС",0,0,"ЕслиПС[трока]","Если ПустаяСтрока(<?""Имя переменной со строкой"">) Тогда			   
	<?>
КонецЕсли;"}
},
{0,
{"ЕслиПС с локальной переменной",0,0,"ЕслиЛПС[трока]","лПустаяСтрока<?""Имя переменной со строкой""> 	= ПустаяСтрока(<?""Имя переменной со строкой"">)
Если лПустаяСтрока<?""Имя переменной со строкой""> Тогда			   
	<?>
КонецЕсли;"}
},
{0,
{"Если ТипЗнч",0,0,"ЕслиТ[ипЗнч]","Если ТипЗнч(<?""Переменная для проверки"">) = Тип(""Строка"") Тогда
	<?>
ИначеЕсли ТипЗнч(<?""Переменная для проверки"">) = Тип(""Массив"") Тогда
	
ИначеЕсли ТипЗнч(<?""Переменная для проверки"">) = Тип(""ДокументСсылка.РеализацияТоваров"") Тогда
	
КонецЕсли;"}
},
{0,
{"Если ТипЗнч с локальной переменной",0,0,"ЕслиЛТ[ипЗнч]","лТипЗнч<?""Переменная для проверки""> = ТипЗнч(<?""Переменная для проверки"">);
Если лТипЗнч<?""Переменная для проверки""> = Тип(""Строка"") Тогда
	<?>
ИначеЕсли лТипЗнч<?""Переменная для проверки""> = Тип(""Массив"") Тогда
	
ИначеЕсли лТипЗнч<?""Переменная для проверки""> = Тип(""ДокументСсылка.РеализацияТоваров"") Тогда
	
КонецЕсли;"}
},
{0,
{"Если Неопределено",0,0,"ЕслиН[еопред]","Если <?""Условие""> <> Неопределено Тогда
	<?>
КонецЕсли;"}
},
{0,
{"Если Неопределено И Количество <> 0 ",0,0,"ЕслиНК[оличество]","Если <?""Имя элемента для подсчета количества (слитно)""> <> Неопределено Тогда
	Если <?""Имя элемента для подсчета количества (слитно)"">.Количество() > 0 Тогда
		<?>
	КонецЕсли; 
КонецЕсли;"}
},
{0,
{"Если Параметры.Свойство",0,0,"ЕслиП[араметр]","Если Параметры.Свойство(""<?""ИмяСвойства"">"") Тогда
	лПараметр<?""ИмяСвойства""> = Параметры.<?""ИмяСвойства"">;
КонецЕсли;"}
},
{0,
{"Если >  (Больше)",0,0,"ЕслиБ","Если <?""Имя элемента""> > <?> Тогда
	<?>
КонецЕсли;"}
},
{0,
{"Если > 0 (БольшеНуля)",0,0,"ЕслиБН","Если <?""Имя элемента""> > 0 Тогда
	<?>
КонецЕсли;"}
},
{0,
{"Если <  (Меньше)",0,0,"ЕслиМ","Если <?""Имя элемента""> < <?> Тогда
	<?>
КонецЕсли;"}
},
{0,
{"Если < 0 (МеньшеНуля)",0,0,"ЕслиМН","Если <?""Имя элемента""> < 0 Тогда
	<?>
КонецЕсли;"}
},
{0,
{"Если Количество <> 0",0,0,"ЕслиК[оличество]","Если <?""Имя элемента для подсчета количества (слитно)"">.Количество() <> 0 Тогда
	<?>
КонецЕсли;"}
},
{0,
{"Если СтрНайти() > 0 (есть строка)",0,0,"ЕслиСН","Если <?""Имя строки (слитно)"">.СтрНайти() > 0 Тогда
	
КонецЕсли;"}
},
{0,
{"Если ТЗ.Найти() <> Неопределено",0,0,"ЕслиТЗН","Если <?""Имя таблицы (слитно)"">.Найти(<?>) <> Неопределено Тогда
	
КонецЕсли;"}
},
{0,
{"Если Следующий() (для запроса)",0,0,"ЕслиСл[едующий]","Если <?""Имя элемента для условия (слитно)"">.Следующий() Тогда
	<?>
КонецЕсли;"}
},
{0,
{"Если Количество <> 0  с локальной переменной",0,0,"ЕслиЛК[оличество]","л<?""Имя элемента для подсчета количества (слитно)"">Количество = <?""Имя элемента для подсчета количества (слитно)"">.Количество(); 
Если л<?""Имя элемента для подсчета количества (слитно)"">Количество <> 0 Тогда
	<?>
КонецЕсли;"}
},
{0,
{"Если Свойство",0,0,"ЕслиСв[ойство]","Если <?""Имя структуры для проверки свойства"">.Свойство(""Свойство"") Тогда
	<?>
КонецЕсли;"}
},
{0,
{"Если Свойство и Значение",0,0,"ЕслиСвЗнач","л<?""Свойство структуры (слитно вроде и по её правилам)""> 	= Неопределено;
Если Структура.Свойство(""<?""Свойство структуры (слитно вроде и по её правилам)"">"", л<?""Свойство структуры (слитно вроде и по её правилам)"">) Тогда
	<?>
КонецЕсли;"}
},
{0,
{"Если Свойство Булево",0,0,"ЕслиСвБул","Если Структура.Свойство(""<?""Свойство структуры (слитно вроде и по её правилам)"">"") Тогда
	Если Структура.<?""Свойство структуры (слитно вроде и по её правилам)""> Тогда
		<?>
	КонецЕсли;
КонецЕсли;"}
},
{0,
{"Если Вопрос",0,0,"ЕслиВ[опрос]","Если Вопрос(""<?""Тест вопроса"">"", РежимДиалогаВопрос.ДаНет) = КодВозвратаДиалога.Да Тогда
	<?>
КонецЕсли;"}
},
{0,
{"Если Роль Доступна",0,0,"ЕслиРД","Если РольДоступна(""<?""Имя роли (слитно)"">"") Тогда
	
КонецЕсли;"}
},
{0,
{"Однострочное условие ?(",0,0,"?(","?(<?""Условие"">, <?>,);"}
},
{0,
{"Однострочное условие ЗначениеЗаполнено",0,0,"?З","?(ЗначениеЗаполнено(<?""Значение на проверку заполненности"">), <?>,);"}
},
{0,
{"Однострочное условие ПустаяСтрока",0,0,"?П","?(ПустаяСтрока(<?""Имя переменной со строкой"">), <?>,);"}
},
{0,
{"Однострочное условие ТипЗнч",0,0,"?Т","?(ТипЗнч(<?""Переменная для проверки"">) = Тип(""Строка""), <?>,);"}
},
{0,
{"Однострочное условие Неопределено",0,0,"?Н","?(<?""Условие""> <> Неопределено, <?>,);"}
},
{0,
{"Однострочное условие Количество <> 0",0,0,"?К","?(<?""Имя элемента для подсчета количества (слитно)"">.Количество <> 0, <?>,);"}
},
{0,
{"Однострочное условие СтрНайти > 0 (есть строка)",0,0,"?СтрН","?(<?""Имя строки (слитно)"">.СтрНайти() > 0, <?>,);"}
},
{0,
{"Однострочное условие ТЗ.Найти <> Неопределено",0,0,"?ТЗН","?(<?""Имя таблицы (слитно)"">.Найти(<?>) <> Неопределено, <?>,);"}
},
{0,
{"Пока Следующий() (для запроса)",0,0,"ПокаС[ледующий]","Пока <?""Имя элемента для условия (слитно)"">.Следующий() Цикл
	
	<?>
	
КонецЦикла;"}
},
{0,
{"ЗаполнитьЗначенияСвойств",0,0,"ЗЗС[войств]","ЗаполнитьЗначенияСвойств(<?>,);"}
},
{0,
{"Возврат Неопределено",0,0,"ВН[еопределено]","Возврат Неопределено;"}
}
},
{3,
{"Дополнительные реквизиты",1,0,"",""},
{7,
{"Реквизиты (они в ТЧ объекта)",1,0,"",""},
{0,
{"Типове по наименованию доп свойства",0,0,"","лТЗСвойств<?""Смысл дополнительного реквизита (слитно)""> 	= УправлениеСвойствами.ЗначенияСвойств(лОбъект,, Ложь, ""УникальноеИмяДополнительногоСвойства"");

лДопРеквизит<?""Смысл дополнительного реквизита (слитно)"">Значение 	= Неопределено;
Если ЗначениеЗаполнено(лТЗСвойств<?""Смысл дополнительного реквизита (слитно)"">) Тогда
	Если лТЗСвойств<?""Смысл дополнительного реквизита (слитно)"">.Количество() = 1 Тогда
		лДопРеквизит<?""Смысл дополнительного реквизита (слитно)"">Значение 	= лТЗСвойств<?""Смысл дополнительного реквизита (слитно)"">[0].Значение; //Получаем текущее значение свойства
	КонецЕсли;	
КонецЕсли;"}
},
{0,
{"Типовые УНФ",0,0,"","УправлениеСвойствами.ПолучитьСписокСвойств
УправлениеСвойствами.ПолучитьЗначенияСвойств
УправлениеСвойствами.ПроверитьСвойствоУОбъекта"}
},
{0,
{"Типовое использование (получая несколько свойств) (ЗУП 3)",0,0,"ДопРеквизитМасс","лЗначенияДопРеквизитов<?""Имя подумента с доп свойствами (слитно)""> 	= УправлениеСвойствами.ЗначенияСвойств(МассивОбъектов, Истина, Ложь);
лДопРеквизит<?""Смысл дополнительного реквизита (слитно)""> 	= ПланыВидовХарактеристик.ДополнительныеРеквизитыИСведения.НайтиПоНаименованию(""Основание приказа (Приемы на работу)"");

лДопРеквизит<?""Смысл дополнительного реквизита (слитно)"">Значение 	= Неопределено;
Если ЗначениеЗаполнено(лДопРеквизит<?""Смысл дополнительного реквизита (слитно)"">) Тогда
	лСтруктураНайтиСтроки 	= Новый Структура(""ВладелецСвойств, Свойство"", Объект.Ссылка, лДопРеквизит<?""Смысл дополнительного реквизита (слитно)"">);
	лМассивЗначенийСвойств 	= лЗначенияДопРеквизитов<?""Имя подумента с доп свойствами (слитно)"">.НайтиСтроки(лСтруктураНайтиСтроки);
	
	Если лМассивЗначенийСвойств.Количество() > 0 Тогда
		лМассивЗначенийСвойствЗначение = лМассивЗначенийСвойств[0].Значение;
		Если ЗначениеЗаполнено(лМассивЗначенийСвойствЗначение) Тогда
			лДопРеквизит<?""Смысл дополнительного реквизита (слитно)"">Значение 	= лМассивЗначенийСвойствЗначение;
		КонецЕсли; 
	КонецЕсли;	
КонецЕсли; 
"}
},
{0,
{"Типовое. Присвоить значение реквизиту (ЗаписатьСвойстваУОбъекта)",0,0,"ДопРекв","Если лОбъект <> Неопределено Тогда
	лИмяДопРеквизит 			= ""<?""Имя реквизита (слитно)"">"";
	лДопРеквизит<?""Имя реквизита (слитно)""> 			= ПланыВидовХарактеристик.ДополнительныеРеквизитыИСведения.НайтиПоНаименованию(лИмяДопРеквизит);
	лМассивДопРеквизит 			= Новый Массив;
	лМассивДопРеквизит.Добавить(лДопРеквизит<?""Имя реквизита (слитно)"">);
	
	лЗначенияДопРеквизит<?""Имя элемента с доп свойствами (слитно)""> 	= УправлениеСвойствами.ЗначенияСвойств(лОбъект,, Ложь, лМассивДопРеквизит);
	
	Если лЗначенияДопРеквизит<?""Имя элемента с доп свойствами (слитно)"">.Количество() > 0 Тогда
		лЕстьСвойство<?""Имя реквизита (слитно)""> 			= УправлениеСвойствами.ПроверитьСвойствоУОбъекта(лОбъект, лДопРеквизит<?""Имя реквизита (слитно)"">);
		Если лЕстьСвойство<?""Имя реквизита (слитно)""> Тогда
			Если ЗначениеЗаполнено(лДопРеквизит<?""Имя реквизита (слитно)"">) Тогда
				лСтруктураНайтиСтроки 	= Новый Структура(""ВладелецСвойств, Свойство"", лОбъект, лДопРеквизит<?""Имя реквизита (слитно)"">);
				лМассивЗначенийСвойств 	= лЗначенияДопРеквизит<?""Имя элемента с доп свойствами (слитно)"">.НайтиСтроки(лСтруктураНайтиСтроки);
				
				Если лМассивЗначенийСвойств.Количество() = 1 Тогда
					//лЗначение = лМассивЗначенийСвойств[0].Значение; //Получаем текущее значение свойства
					лМассивЗначенийСвойств[0].Значение 	= 2; //Изменяем значение свойства
					УправлениеСвойствами.ЗаписатьСвойстваУОбъекта(лОбъект, лЗначенияДопРеквизит<?""Имя элемента с доп свойствами (слитно)"">);
				КонецЕсли;	
			КонецЕсли;
		КонецЕсли;	
	КонецЕсли;
КонецЕсли;

"}
},
{0,
{"Типовое. Есть свойство (ПроверитьСвойствоУОбъекта)",0,0,"","лИмяДопРеквизита 				= ""<?""Имя реквизита"">"";
лДопРеквизит<?""Имя реквизита""> 	= ПланыВидовХарактеристик.ДополнительныеРеквизитыИСведения.НайтиПоНаименованию(лИмяДопРеквизита);

лЕстьСвойство<?""Имя реквизита""> 			= УправлениеСвойствами.ПроверитьСвойствоУОбъекта(лОбъект, лДопРеквизит<?""Имя реквизита"">);
"}
},
{0,
{"ДополнительныеРеквизиты через ТЧ",0,0,"","НайденноеСвойствоТЧ = Сделка.ДополнительныеРеквизиты.Найти(ИнформацияОСтатусах.СвойствоЗаказов, ""Свойство"");
Если НайденноеСвойствоТЧ = Неопределено тогда
	НовыйРеквизит = Сделка.ДополнительныеРеквизиты.Добавить();
	НовыйРеквизит.Свойство = ИнформацияОСтатусах.СвойствоЗаказов;
	НовыйРеквизит.Значение = ЗначениеСвойства;
Иначе
	НайденноеСвойствоТЧ.Значение = ЗначениеСвойства;	
КонецЕсли;"}
},
{0,
{"Типовое использование 1 свойства (ЗУП 3)",0,0,"","Функция ПолучитьСвойство<?""Смысл дополнительного реквизита (слитно)"">(пСсылка, НаименованиеПВХ = """", ДописатьВНачало = """", ДописатьВКонец = """")
	
	лРезультат = """";
	
	Если ПустаяСтрока(НаименованиеПВХ) Тогда			   
		Возврат """";
	КонецЕсли;
	
	лДопРеквизит<?""Смысл дополнительного реквизита (слитно)""> 	= ПланыВидовХарактеристик.ДополнительныеРеквизитыИСведения.НайтиПоНаименованию(НаименованиеПВХ); //Вида: ""Основание приказа (Приемы на работу)""

	Если ЗначениеЗаполнено(лДопРеквизит<?""Смысл дополнительного реквизита (слитно)"">) Тогда
		лЗначениеСвойства<?""Смысл дополнительного реквизита (слитно)""> 		= УправлениеСвойствами.ЗначениеСвойства(пСсылка, лДопРеквизит<?""Смысл дополнительного реквизита (слитно)"">); //Вернёт чисто значение
		
		Если ЗначениеЗаполнено(лЗначениеСвойства) Тогда
			Если НЕ ПустаяСтрока(ДописатьВНачало) Тогда			   
				лРезультат 	= ДописатьВНачало + лЗначениеСвойства<?""Смысл дополнительного реквизита (слитно)"">;	
			КонецЕсли;
			Если НЕ ПустаяСтрока(ДописатьВКонец) Тогда			   
				лРезультат 	= лЗначениеСвойства<?""Смысл дополнительного реквизита (слитно)""> + ДописатьВКонец;	
			КонецЕсли;
		КонецЕсли; 
	КонецЕсли;
	
	Возврат лРезультат;
	
КонецФункции // ПолучитьСвойство<?""Смысл дополнительного реквизита (слитно)"">()"}
}
},
{2,
{"Свойства (сведения) (они в отдельном регистре)",1,0,"",""},
{0,
{"! НЕ рабоатет! Типовое. Присвоить значение свойству (ЗаписатьСвойстваУОбъекта)",0,0,"","лИмяДопСвойство 			= ""<?""Имя свойства (слитно)"">"";
лДопСвойство<?""Имя свойства (слитно)""> 			= ПланыВидовХарактеристик.ДополнительныеРеквизитыИСведения.НайтиПоНаименованию(лИмяДопСвойство);
лМассивДопСвойство 			= Новый Массив;
лМассивДопСвойство.Добавить(лДопСвойство<?""Имя свойства (слитно)"">);

лЗначенияДопСвойство<?""Имя элемента с доп свойствами (слитно)""> 	= УправлениеСвойствами.ЗначенияСвойств(лОбъект,, Ложь, лМассивДопСвойство);

Если лЗначенияДопСвойство<?""Имя элемента с доп свойствами (слитно)"">.Количество() > 0 Тогда
	лЕстьСвойство<?""Имя свойства (слитно)""> 			= УправлениеСвойствами.ПроверитьСвойствоУОбъекта(лОбъект, лДопСвойство<?""Имя свойства (слитно)"">);
	Если лЕстьСвойство<?""Имя свойства (слитно)""> Тогда
		Если ЗначениеЗаполнено(лДопСвойство<?""Имя свойства (слитно)"">) Тогда
			лСтруктураНайтиСтроки 	= Новый Структура(""ВладелецСвойств, Свойство"", лОбъект, лДопСвойство<?""Имя свойства (слитно)"">);
			лМассивЗначенийСвойств 	= лЗначенияДопСвойство<?""Имя элемента с доп свойствами (слитно)"">.НайтиСтроки(лСтруктураНайтиСтроки);
			
			Если лМассивЗначенийСвойств.Количество() = 1 Тогда
				//лЗначение = лМассивЗначенийСвойств[0].Значение; //Получаем текущее значение свойства
				лМассивЗначенийСвойств[0].Значение 	= 2; //Изменяем значение свойства
				УправлениеСвойствами.ЗаписатьСвойстваУОбъекта(лОбъект, лЗначенияДопСвойство<?""Имя элемента с доп свойствами (слитно)"">);
			КонецЕсли;	
		КонецЕсли;
	КонецЕсли;	
КонецЕсли; 
	

"}
},
{0,
{"СоздатьПолучитьСвойство",0,0,"","Функция СоздатьПолучитьСвойство() 
	
	НаименованиеСвойства = ""Направление сделки Битрикс24"";
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр(""НаименованиеСвойства"", НаименованиеСвойства);
	Запрос.Текст = ""ВЫБРАТЬ ПЕРВЫЕ 1
	|	ДополнительныеРеквизитыИСведения.Ссылка КАК Ссылка
	|ИЗ
	|	ПланВидовХарактеристик.ДополнительныеРеквизитыИСведения КАК ДополнительныеРеквизитыИСведения
	|ГДЕ
	|	ДополнительныеРеквизитыИСведения.Заголовок = &НаименованиеСвойства
	|	И ДополнительныеРеквизитыИСведения.НаборСвойств = ЗНАЧЕНИЕ(Справочник.НаборыДополнительныхРеквизитовИСведений.Документ_СчетНаОплатуПокупателю)""; // АйТи КучеровРМ 
	ВыполненныйЗапрос = Запрос.Выполнить();	
	
	Если ВыполненныйЗапрос.Пустой() Тогда
		
		СвойствоОбъект 	= ПланыВидовХарактеристик.ДополнительныеРеквизитыИСведения.СоздатьЭлемент();
		СвойствоОбъект.Комментарий 	= НСтр(""ru = 'Создано автоматически при синхронизации с Битрикс24'"");
		СвойствоОбъект.Наименование = НаименованиеСвойства + "" (Заказ покупателя)"";
		СвойствоОбъект.Заголовок 	= НаименованиеСвойства;
		СвойствоОбъект.ЗаголовокФормыВыбораЗначения = НаименованиеСвойства;
		СвойствоОбъект.ЗаголовокФормыЗначения 		= НаименованиеСвойства;
		СвойствоОбъект.НаборСвойств = Справочники.НаборыДополнительныхРеквизитовИСведений.Документ_СчетНаОплатуПокупателю; // АйТи КучеровРМ 
		
		
		лТип = Тип(""СправочникСсылка.ЗначенияСвойствОбъектов"");
		МассивТипов = Новый Массив;
		МассивТипов.Добавить(лТип);
		
		СвойствоОбъект.ЭтоДополнительноеСведение = Истина; // АйТи КучеровРМ
		СвойствоОбъект.ТипЗначения 	= Новый ОписаниеТипов(МассивТипов);
		СвойствоОбъект.Доступен 	= Ложь;
		СвойствоОбъект.Виден 		= Ложь;
		СвойствоОбъект.ДополнительныеЗначенияИспользуются 	= Истина;
		СвойствоОбъект.ДополнительныеСвойства.Вставить(""ЗагрузкаСБитрикс24"", Истина);
		СвойствоОбъект.Записать();
		СвойствоСсылка = СвойствоОбъект.Ссылка; 
		
		лНабор = Справочники.НаборыДополнительныхРеквизитовИСведений.Документ_СчетНаОплатуПокупателю.ПолучитьОбъект(); // АйТи КучеровРМ
		лНабор.ДополнительныеСведения.Добавить().Свойство = СвойствоСсылка; //Или ДополнительныеРеквизиты
		лНабор.Записать();
		
		СвойствоСсылка =  СвойствоСсылка; 
		
	Иначе
		
		Выборка = ВыполненныйЗапрос.Выбрать();
		
		Пока Выборка.Следующий() Цикл
			СвойствоСсылка = Выборка.Ссылка; 
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат СвойствоСсылка;
	
КонецФункции"}
}
},
{6,
{"ЗначенияСвойствОбъектов",1,0,"",""},
{0,
{"Список значений свойства",0,0,"","Функция ПолучитьЗначениеСвойства(КодСвойства, КодЗначенияСвойства = """")

	Запрос = Новый Запрос;
	Запрос.Текст = 
	""ВЫБРАТЬ ПЕРВЫЕ 1
	|	ЗначенияСвойствОбъектов.Ссылка,
	|	ЗначенияСвойствОбъектов.ВерсияДанных,
	|	ЗначенияСвойствОбъектов.ПометкаУдаления,
	|	ЗначенияСвойствОбъектов.Предопределенный,
	|	ЗначенияСвойствОбъектов.Владелец,
	|	ЗначенияСвойствОбъектов.Родитель,
	|	ЗначенияСвойствОбъектов.ЭтоГруппа,
	|	ЗначенияСвойствОбъектов.Код,
	|	ЗначенияСвойствОбъектов.Наименование
	|ИЗ
	|	Справочник.ЗначенияСвойствОбъектов КАК ЗначенияСвойствОбъектов
	|ГДЕ
	|	ЗначенияСвойствОбъектов.Владелец.Код = &КодСвойства 
	|	И ЗначенияСвойствОбъектов.Код = &КодЗначенияСвойства"";
	
	// Чтобы вывести все возмножные значения свойства, надо убрать ""ЗначенияСвойствОбъектов.Код = &КодЗначенияСвойства""
	
	Запрос.УстановитьПараметр(""КодЗначенияСвойства""	, КодЗначенияСвойства);
	Запрос.УстановитьПараметр(""КодСвойства""			, КодСвойства);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	ЗначениеСвойства = Неопределено;
	Если НЕ РезультатЗапроса.Пустой() Тогда
		ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
		Если ВыборкаДетальныеЗаписи.Следующий() Тогда
			ВыборкаДетальныеЗаписиСсылка = ВыборкаДетальныеЗаписи.Ссылка;
			ЗначениеСвойства = ВыборкаДетальныеЗаписиСсылка;
		КонецЕсли;
	КонецЕсли;

	Возврат ЗначениеСвойства;
	
КонецФункции // ПолучитьЗначениеЗначениеСвойства()
 "}
},
{0,
{"ПолучитьЗначениеСвойстваОбъекта",0,0,"","//Функция ПолучитьЗначениеСвойстваОбъекта
//-------------------------------------------------------------------------
//Параметры:
//		Объект - Ссылка - Ссылка на объект, свойство которого надо получить
//		КодСвойстваОбъекта - Строка - Код свойства, значения которого получаем
//		НазначениеСвойств - ПланВидовХарактеристикСсылка.НазначенияСвойствКатегорийОбъектов - Напр., ПланыВидовХарактеристик.НазначенияСвойствКатегорийОбъектов.Справочник_Контрагенты
//Возвращаемое значение:
//		СправочникСсылка.ЗначенияСвойствОбъектов - Значение свойства
//-------------------------------------------------------------------------
//автор: КучеровРМ 07.09.2018 
Функция ПолучитьЗначениеСвойстваОбъекта(Объект, КодСвойстваОбъекта, НазначениеСвойств)
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	""ВЫБРАТЬ ПЕРВЫЕ 1
	|	СвойстваОбъектов.Наименование КАК СвойстваОбъектовНаименование,
	|	СвойстваОбъектов.ПометкаУдаления КАК ПометкаУдаления,
	|	СвойстваОбъектов.Ссылка КАК Свойство,
	|	ЗначенияСвойствОбъектов.Значение КАК Значение
	|ИЗ
	|	(ВЫБРАТЬ
	|		СвойстваОбъектов.Ссылка КАК Ссылка,
	|		СвойстваОбъектов.Наименование КАК Наименование,
	|		СвойстваОбъектов.ПометкаУдаления КАК ПометкаУдаления
	|	ИЗ
	|		ПланВидовХарактеристик.СвойстваОбъектов КАК СвойстваОбъектов
	|	ГДЕ
	|		СвойстваОбъектов.НазначениеСвойства В(&НазначениеСвойств)) КАК СвойстваОбъектов
	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ЗначенияСвойствОбъектов КАК ЗначенияСвойствОбъектов
	|		ПО (ЗначенияСвойствОбъектов.Свойство = СвойстваОбъектов.Ссылка)
	|			И (ЗначенияСвойствОбъектов.Объект = &ОбъектОтбораЗначений)
	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.НазначенияСвойствОбъектов КАК НазначенияСвойствОбъектов
	|		ПО (НазначенияСвойствОбъектов.Свойство = СвойстваОбъектов.Ссылка)
	|			И (ЗначенияСвойствОбъектов.Значение ЕСТЬ NULL )
	|ГДЕ
	|	(НазначенияСвойствОбъектов.Объект ЕСТЬ NULL 
	|			ИЛИ НазначенияСвойствОбъектов.Объект В (&СписокНазначенийСвойств))
	|	И СвойстваОбъектов.Ссылка.Код = &КодСвойстваОбъекта
	|
	|УПОРЯДОЧИТЬ ПО
	|	СвойстваОбъектовНаименование"";
	
	//КодСвойстваОбъекта 		= ""00000000048"";
	//НазначениеСвойств 		= ПланыВидовХарактеристик.НазначенияСвойствКатегорийОбъектов.Справочник_Контрагенты;
	ОбъектОтбораЗначений 	= Объект;
	СписокНазначенийСвойств = Объект;
	
	Запрос.УстановитьПараметр(""КодСвойстваОбъекта""	, КодСвойстваОбъекта);
	Запрос.УстановитьПараметр(""НазначениеСвойств""	, НазначениеСвойств);
	Запрос.УстановитьПараметр(""ОбъектОтбораЗначений"", ОбъектОтбораЗначений);
	Запрос.УстановитьПараметр(""СписокНазначенийСвойств"", СписокНазначенийСвойств);

	РезультатЗапроса = Запрос.Выполнить();
	
	ЗначениеСвойства = Неопределено;
	Если НЕ РезультатЗапроса.Пустой() Тогда
		ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
		Если ВыборкаДетальныеЗаписи.Следующий() Тогда
			ВыборкаДетальныеЗаписиЗначение = ВыборкаДетальныеЗаписи.Значение;
			Если ВыборкаДетальныеЗаписиЗначение <> NULL Тогда
				ЗначениеСвойства = ВыборкаДетальныеЗаписиЗначение;
			Иначе
				ЗначениеСвойства = Неопределено;
			КонецЕсли
		КонецЕсли;
	КонецЕсли;

	Возврат ЗначениеСвойства;
	
КонецФункции // ПолучитьЗначениеСвойстваОбъекта()

"}
},
{0,
{"ЗаписатьЗначенияСвойства",0,0,"","Функция ЗаписатьЗначенияСвойства(ОбъектСсылка, СтруктураСвойства) 
	
	НаборЗаписейЗначенияСвойств = РегистрыСведений.ЗначенияСвойствОбъектов.СоздатьНаборЗаписей();
	
	Если ЗначениеЗаполнено(СтруктураСвойства.Значение) Тогда
		Запись 			= НаборЗаписейЗначенияСвойств.Добавить();
		Запись.Объект   = ОбъектСсылка;
		Свойство 		= ПланыВидовХарактеристик.СвойстваОбъектов.НайтиПоКоду(СтруктураСвойства.КодСвойстваОбъекта);
		Запись.Свойство = Свойство.Ссылка;
		Запись.Значение = СтруктураСвойства.Значение;
	КонецЕсли;
	
	НаборЗаписейЗначенияСвойств.Отбор.Объект.Установить(ОбъектСсылка);
	НаборЗаписейЗначенияСвойств.Отбор.Свойство.Установить(Свойство); //.Ссылка
	
	Попытка
		НаборЗаписейЗначенияСвойств.Записать();
	Исключение
		Предупреждение(""Не удалось записать значения свойств:"" + Символы.ПС + ОписаниеОшибки());
		Возврат Ложь;
	КонецПопытки;
	
	Возврат Истина; 
	
КонецФункции

СтруктураСвойства = Новый Структура;
//СтруктураСвойства.Вставить(""Свойство"", ИмяСвойства);
СтруктураСвойства.Вставить(""КодСвойстваОбъекта"", КодСвойстваОбъекта);
СтруктураСвойства.Вставить(""Значение"", ЗначениеСвойства);


"}
},
{0,
{"ПолучитьЗначениеСвойства Или нескольких",0,0,"","//Функция ПолучитьЗначениеСвойства
//-------------------------------------------------------------------------
//Параметры:
//		КодСвойства - Строка - КодСвойства
//		КодЗначенияСвойства - Строка - КодЗначенияСвойства
//Возвращаемое значение:
//		Массив - Массив Значений заданного свойства, с типом СправочникСсылка.ЗначенияСвойствОбъектов
//		СправочникСсылка.ЗначенияСвойствОбъектов - Значение свойства, если получаем 1 элемент по коду
//		Неопределено - Если элементов 0
//-------------------------------------------------------------------------
// Если КодЗначенияСвойства пустой, то вернёт все значения свойства,
// иначе вернёт свойство по заданному коду
//------------------------------------------------------------------------- 
//автор: КучеровРМ 07.09.2018 
Функция ПолучитьЗначениеСвойства(КодСвойства, КодЗначенияСвойства = """")

	КодЗначенияСвойстваЗаполнен = НЕ ПустаяСтрока(КодЗначенияСвойства);
	Если КодЗначенияСвойстваЗаполнен Тогда
		ЗапросВЫБРАТЬ = ""ПЕРВЫЕ 1"";
		ЗапросКодЗначенияСвойства = ""
		|	И ЗначенияСвойствОбъектов.Код = &КодЗначенияСвойства"";
	Иначе
		ЗапросВЫБРАТЬ = """";
		ЗапросКодЗначенияСвойства = """";
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	""ВЫБРАТЬ "" + ЗапросВЫБРАТЬ + ""
	|	ЗначенияСвойствОбъектов.Ссылка,
	|	ЗначенияСвойствОбъектов.ВерсияДанных,
	|	ЗначенияСвойствОбъектов.ПометкаУдаления,
	|	ЗначенияСвойствОбъектов.Предопределенный,
	|	ЗначенияСвойствОбъектов.Владелец,
	|	ЗначенияСвойствОбъектов.Родитель,
	|	ЗначенияСвойствОбъектов.ЭтоГруппа,
	|	ЗначенияСвойствОбъектов.Код,
	|	ЗначенияСвойствОбъектов.Наименование
	|ИЗ
	|	Справочник.ЗначенияСвойствОбъектов КАК ЗначенияСвойствОбъектов
	|ГДЕ
	|	ЗначенияСвойствОбъектов.Владелец.Код = &КодСвойства"";
	
	Если КодЗначенияСвойстваЗаполнен Тогда // Значит выводим одно значение соогласно переданому коду
		Запрос.Текст = Запрос.Текст + ЗапросКодЗначенияСвойства;
		Запрос.УстановитьПараметр(""КодЗначенияСвойства"", КодЗначенияСвойства);
	КонецЕсли;
	
	Запрос.УстановитьПараметр(""КодСвойства"", КодСвойства);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	ЗначениеСвойства = Новый Массив;
	Если НЕ РезультатЗапроса.Пустой() Тогда
		ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
		Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
			ВыборкаДетальныеЗаписиСсылка = ВыборкаДетальныеЗаписи.Ссылка;
			ЗначениеСвойства.Добавить(ВыборкаДетальныеЗаписиСсылка);
			
			Если КодЗначенияСвойстваЗаполнен Тогда // Значит ожидаем одно значение согласно коду
				Прервать; 	
			КонецЕсли; 
		КонецЦикла;
	КонецЕсли;

	ЗначениеСвойстваКоличество = ЗначениеСвойства.Количество();
	Если ЗначениеСвойстваКоличество > 0 Тогда
		Если ЗначениеСвойстваКоличество > 1 Тогда
			Возврат ЗначениеСвойства;
		Иначе
			Возврат ЗначениеСвойства[0];
		КонецЕсли;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат ЗначениеСвойства; // На всякий случай
	
КонецФункции // ПолучитьЗначениеЗначениеСвойства()
  
ЗначенияСвойства 		= ПолучитьЗначениеСвойства(КодСвойстваОбъекта);
ТипЗнчЗначенийСвойств 	= ТипЗнч(ЗначенияСвойства);
Если ТипЗнчЗначенийСвойств = Тип(""Массив"") Тогда
	Сообщить(""Массив"");	
ИначеЕсли ТипЗнчЗначенийСвойств = Тип(""СправочникСсылка.ЗначенияСвойствОбъектов"") Тогда
	Сообщить(""ЗначенияСвойствОбъектов"");
КонецЕсли;"}
},
{0,
{"ПолучитьТекстЗапроса",0,0,"ПТЗ","Запрос = Новый Запрос;
Запрос.Текст = <?""Префикс теста запроса (слитно, можно пустой)"">ПолучитьТекстЗапроса();

Запрос.УстановитьПараметр("""", );

РезультатЗапроса = Запрос.Выполнить();

Если НЕ РезультатЗапроса.Пустой() Тогда
	ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
	Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
		// Вставить обработку выборки ВыборкаДетальныеЗаписи
		ВДЗ_ = ВыборкаДетальныеЗаписи.;
		Прервать;
	КонецЦикла;
Иначе
КонецЕсли;

Функция <?""Префикс теста запроса (слитно, можно пустой)"">ПолучитьТекстЗапроса()
	
	ТекстЗапроса = """";
	
	Возврат ТекстЗапроса;
	
КонецФункции
"}
},
{0,
{"Доп свойство (в реквизит)",0,0,"","лИмяДопСвойство 			= ""Статус сделки Битрикс24 (Счета покупателям)"";
лДопСвойствоСтатусСледки 	= ПланыВидовХарактеристик.ДополнительныеРеквизитыИСведения.НайтиПоНаименованию(лИмяДопСвойство);
лЗначенияСтатусСледки 		= Справочники.ЗначенияСвойствОбъектов.НайтиПоНаименованию(""Закупка товара (услуг)"",,, лДопСвойствоСтатусСледки); 

ТаблицаПредСвойств = Новый ТаблицаЗначений;
ТаблицаПредСвойств.Колонки.Добавить(""Свойство"");
ТаблицаПредСвойств.Колонки.Добавить(""ЗначениеСвойства"");

НовСтрока = ТаблицаПредСвойств.Добавить();
НовСтрока.Свойство 			= лДопСвойствоСтатусСледки; 
НовСтрока.ЗначениеСвойства 	= лЗначенияСтатусСледки;

НаборЗаписей = РегистрыСведений.ДополнительныеСведения.СоздатьНаборЗаписей();
НаборЗаписей.Отбор.Объект.Установить(лСчетНаОплатуПокупателю);
НаборЗаписей.Прочитать();

Для Каждого ТекСвойство из ТаблицаПредСвойств Цикл
	
	ЕстьСвойство = Ложь;
	
	Для Каждого ТекСтрока из НаборЗаписей Цикл
		Если ТекСтрока.Свойство = ТекСвойство.Свойство тогда
			ЕстьСвойство = Истина;
			ТекСтрока.Значение = ТекСвойство.ЗначениеСвойства;	
		КонецЕсли;
	КонецЦикла;
	
	Если ЕстьСвойство = Ложь тогда
		НоваяЗапись = НаборЗаписей.Добавить();
		НоваяЗапись.Объект = лСчетНаОплатуПокупателю;
		НоваяЗапись.Свойство = ТекСвойство.Свойство;
		НоваяЗапись.Значение = ТекСвойство.ЗначениеСвойства;
	КонецЕсли;
КонецЦикла;"}
}
}
},
{2,
{"Полнотекстовый поиск",1,0,"",""},
{0,
{"Полнотекстовый поиск",0,0,"","Полнотекстовый поиск в 1С (что это и пример использования)
https://helpf.pro/faq/view/1741.html

Полнотекстовый поиск -  позволит найти текстовую информацию, размещенную практически в любом месте используемой конфигурации. При этом искать нужные данные можно либо по всей конфигурации в целом, либо сузив область поиска до нескольких объектов (например, определенных видов документов или справочников). Сами критерии поиска могут варьироваться в довольно широком диапазоне. То есть найти нужные данные можно, даже не помня точно, где они хранятся в конфигурации и как именно записаны.

Полнотекстовый поиск предоставляет следующие возможности:

Есть поддержка транслитерации (написание русских слов символами латиницы в соответствии с ГОСТ 7.79-2000). Пример: ""русская фраза"" = ""russkaya fraza"".
Есть поддержка замещения (написание части символов в русских словах одноклавишными латинскими символами). Пример: ""руссrfz фраpf"" (окончания каждого слова набраны латиницей, допустим, в результате ошибки оператора).
Есть возможность нечеткого поиска (буквы в найденных словах могут отличаться) с указанием порога нечеткости. Пример: указав в строке поиска слово ""привет"" и нечеткость 17 %, найдем все аналогичные слова с ошибками и без: ""привет"", ""превет"", ""привед"".
Есть возможность указать область выполнения поиска по выбранным объектам метаданных.
Полнотекстовое индексирование названий стандартных полей (""Код"", ""Наименование"" и т. д.) производится на всех языках конфигурации.
Поиск выполняется с учетом синонимов русского, английского и украинского языков.
Морфологический словарь русского языка содержит ряд специфических слов, относящихся к областям деятельности, автоматизируемым с помощью системы программ ""1С:Предприятие"".
Стандартно в состав поставляемых словарей включены словарные базы и словари тезауруса и синонимов русского, украинского и английского языков, которые предоставлены компанией ""Информатик"".
Поиск можно осуществлять с использованием подстановочных символов (""*""), а также с указанием поисковых операторов (""И"", ""ИЛИ"", ""НЕ"", ""РЯДОМ"") и спецсимволов.
Полнотекстовый поиск можно осуществлять в любой конфигурации на платформе 1С:Предприятие 8

Для того чтобы открыть окно управления полнотекстовым поиском необходимо выполнить следующее: 

Обычное приложение - пункт меню Операции - Управление полнотекстовым поиском.



Управляемое приложение - пункт меню Главное меню - Все функции - Стандартные - Управление полнотекстовым поиском.



Обновить индекс – Создание индекса/Обновление индекса; 
Очистить индекс – обнуление индекса(рекомендуется после обновления всех данных); 
пункт Разрешить слияние индексов – отвечает за слияние основного и дополнительного индекса.
Полнотекстовый поиск осуществляется при помощи полнотекстового индекса. При отсутствии индекса полнотекстовый поиск как таковой не возможен. Для того чтобы поиск имел результат, все необходимые данные должны быть включены в полнотекстовый индекс. Если пользователем введены в базу новые данные, их следует включить в рассматриваемый индекс, иначе они не будут участвовать в поиске. Чтобы этого избежать, необходимо обновлять полнотекстовый индекс. При обновлении система анализирует только определенные типы данных: Строка, Данные ссылочного типа (ссылки на документы, справочники),Число, Дата, ХранилищеЗначения. Если пользователь не имеет прав доступа к определенной информации, то он не сможет увидеть ее в результатах поиска. Следует также помнить и о том, что в свойствах объектов, по которым будет происходить поиск должно быть установлено значение Полнотекстовый Поиск – Использовать, которое задано по умолчанию.

Как вы можете заметить свойство Использовать установлено для всего справочника Контрагенты, но сделать это можно и для каждого его реквизита соответствующего типа.

Рассмотрим более подробно полнотекстовый индекс, который состоит из двух частей (индексов): основного индекса и дополнительного. Высокая скорость поиска данных обеспечивается за счет основного индекса, но обновление его происходит относительно медленно, в зависимости от объема данных. Дополнительный индекс ему противоположен. Данные добавляются в него намного быстрее, но поиск осуществляется медленнее. Система осуществляет поиск одновременно в обоих индексах. Большая часть данных находится в основном индексе, а данные добавляемые в систему попадают в дополнительный индекс. Пока объем данных в дополнительном индексе небольшой, поиск по нему происходит относительно быстро. В тот момент, когда нагрузка на систему невелика, происходит операция слияния индексов, в результате чего дополнительный индекс очищается, а все данные помещаются в основной индекс. Слияние индексов предпочтительнее выполнять в тот момент времени, когда нагрузка на систему минимальна. С этой целью можно создавать регламентированные задания и задания по расписанию.

Специальные операторы, допустимые при задании поискового выражения
Механизм полнотекстового поиска допускает написание части символов русского слова одноклавишными латинскими символами. Результат поиска при этом не измениться.



Два оператора РЯДОМ

упрощенный. На расстоянии 8 слов друг от друга
РЯДОМ/[+/-]n – поиск данных в одном реквизите на расстоянии n-1 слов между ними.
Знак указывает в каком направлении от первого слова будет поиск второго. (+ - после, - до)

Групповой символ «*» может использоваться только в качестве замены конца слова

Оператор нечеткости «#». Если неизвестно точное написание названия, имени.

Программными средствами и средствами 1с: программирование.

Оператор синонимов «!». Позволяет найти слово и его синонимы

Как программно обновить индекс полнотекстового поиска?
Код 1C v 8.х
 Процедура ОбновлениеИндексы() Экспорт
ПолнотекстовыйПоиск.ОбновитьИндекс();
КонецПроцедуры   
Пример полнотекстового поиска данных
Определение переменной СписокПоиска

Код 1C v 8.х
 Перем СписокПоиска;   
Кроме этого в процедуре обработки события ПриОткрыии формы определим, что эта переменная будет содержать список полнотекстового поиска, с помощью которого мы и будем осуществлять поиск в данных

Код 1C v 8.х
 Процедура ПриОткрытии()
СписокПоиска = ПолнотекстовыйПоиск.СоздатьСписок();
КонецПроцедуры   
Теперь для события нажатия на кнопку Найти напишем код, который позволит нам выполнять поиск в соответствии с тем выражением, которое задано в поле ПоисковоеВыражение

Код 1C v 8.х
 Процедура НайтиНажатие(Элемент)
СписокПоиска.СтрокаПоиска = ПоисковоеВыражение;
Попытка
СписокПоиска.ПерваяЧасть();
Исключение
Предупреждение(ОписаниеОшибки());
КонецПопытки;
Если СписокПоиска.ПолноеКоличество() = 0 Тогда
ЭлементыФормы.СообщениеОРезультате.Значение = ""Не найдено"";
ЭлементыФормы.РезультатПоиска.УстановитьТекст("""");
Иначе
ВывестиРезультатПоиска();
КонецЕсли;
КонецПроцедуры   
Сначала в этой процедуре мы устанавливаем поисковое выражение, введенное пользователем, в качестве строки поиска для полнотекстового поиска. Затем выполняем метод ПерваяЧасть(), который собственно запускает полнотекстовый поиск и возвращает первую порцию результатов. По умолчанию порция содержит 20 элементов. После этого мы анализируем количество элементов в списке поиска. Если он не содержит ни одного элемента, то мы выводим в форму соответствующее сообщение. В противном случае вызывается процедура ВывестиРезультатПоиска(), которая отображает полученные результаты пользователю.

Создадим в модуле формы процедуру с таким именем и напишем в ней код,

Код 1C v 8.х
 Процедура ВывестиРезультатПоиска()
ЭлементыФормы.СообщениеОРезультате.Значение = ""Показаны "" + Строка(СписокПоиска.НачальнаяПозиция() + 1) + "" - "" + Строка(СписокПоиска.НачальнаяПозиция() +СписокПоиска.Количество()) + "" из "" + СписокПоиска.ПолноеКоличество();
Результат = СписокПоиска.ПолучитьОтображение(ВидОтображенияПолнотекстовогоПоиска.HTMLТекст);
ЭлементыФормы.РезультатПоиска.УстановитьТекст(Результат);
ДоступностьКнопок();
КонецПроцедуры   
Действия, выполняемые в этой процедуре, просты. Сначала мы формируем сообщение о том, какие элементы отображены и сколько всего элементов найдено. Затем получаем результат полнотекстового поиска в виде HTML-текста и выводим этот текст в поле HTML-документа, расположенное в форме.

В заключение передаем управление в процедуру ДоступностьКнопок() для того, чтобы сделать доступными или, наоборот, запретить доступ к кнопкам Предыдущая порция и Следующая порция (в зависимости от того, какая порция полученных результатов отображена). Текст этой процедуры представлен в Коде

Код 1C v 8.х
 Процедура ДоступностьКнопок()
ЭлементыФормы.СледующаяПорция.Доступность = (СписокПоиска.ПолноеКоличество() - СписокПоиска.НачальнаяПозиция()) > СписокПоиска.Количество();
ЭлементыФормы.ПредыдущаяПорция.Доступность = (СписокПоиска.НачальнаяПозиция() > 0);
КонецПроцедуры   
Теперь необходимо создать обработчики событий нажатия на кнопки ПредыдущаяПорция() и СледующаяПорция().

Код 1C v 8.х
 Процедура ПредыдущаяПорцияНажатие(Элемент)
СписокПоиска.ПредыдущаяЧасть();
ВывестиРезультатПоиска();
КонецПроцедуры
Процедура СледующаяПорцияНажатие(Элемент)
СписокПоиска.СледующаяЧасть();
ВывестиРезультатПоиска();
КонецПроцедуры   
Заключительным «штрихом» будет создание обработчика события onclick поля HTML-документа, расположенного в форме. Дело в том, что результат полнотекстового поиска, представленный в виде HTML-текста, содержит гиперссылки на номера элементов списка поиска. И нам хотелось бы, чтобы при переходе пользователя на эту ссылку система открывала бы форму того объекта, который содержится в этом элементе списка. Для этого мы будем перехватывать событие onclick HTML-документа, содержащегося в поле HTML-документа, получать номер элемента списка из гиперссылки и открывать форму соответствующего объекта. Текст обработчика события onclick поля HTML-документа представлен в коде

Код 1C v 8.х
 Процедура РезультатПоискаonclick(Элемент, pEvtObj)
htmlElement = pEvtObj.srcElement;
// Проверить идентификатор элемента
Если (htmlElement.id = ""FullTextSearchListItem"") Тогда
// Получить имя файла (номер строки списка поиска),
// содержащегося в гиперссылке
НомерВСписке = Число(htmlElement.nameProp);
// Получить строку списка поиска по номеру
ВыбраннаяСтрока = СписокПоиска[НомерВСписке];
// Открыть форму найденного объекта
ОткрытьЗначение(ВыбраннаяСтрока.Значение);
pEvtObj.returnValue = Ложь;
КонецЕсли;
КонецПроцедуры "}
},
{1,
{"Типовой в УНФ",1,0,"",""},
{0,
{"ПолнотекстовыйПоискНаСервереБезКонтекста",0,0,"","&НаКлиенте
// Функция добавляет в строку ПП поиска служебные символы в зависимости от включенных опций
//
Функция СформироватьУниверсальнуюСтрокуПоиска(ТекстПоиска)
	
	Возврат ?(Элементы.ФормаПолнотекстовыйПоискОпечатки.Пометка, ""#"", """") + ТекстПоиска + ?(Элементы.ФормаПолнотекстовыйПоискЛюбыеОкончания.Пометка, ""*"", """");
	
КонецФункции // СформироватьУниверсальнуюСтрокуПоиска()

&НаКлиенте
// Процедура устанавливает отбор по ссылкам полученными полнотекстовым поиском
//
Процедура ПолнотекстовыйПоискНаКлиенте(РезультатПоиска)
	
	Если ПустаяСтрока(ТекстПоиска) Тогда
		
		Возврат;
		
	КонецЕсли;
	
	УниверсальнаяCтрокаПоиска = СформироватьУниверсальнуюСтрокуПоиска(ТекстПоиска);
	ОписаниеОшибки = ПолнотекстовыйПоискНаСервереБезКонтекста(УниверсальнаяCтрокаПоиска, РезультатПоиска);
	
	Если НЕ ПустаяСтрока(ОписаниеОшибки) Тогда
		
		РезультатПоиска = Неопределено;
		ПоказатьПредупреждение(Неопределено, ОписаниеОшибки, 5, ""Поиск..."");
		
	КонецЕсли;
	
КонецПроцедуры // ПолнотекстовыйПоискНаКлиенте()

&НаСервереБезКонтекста
// Функция заполняет массив ссылок результата поиска или возвращает описание ошибки
//
//
Функция ПолнотекстовыйПоискНаСервереБезКонтекста(СтрокаПоиска, РезультатПоиска)
	
	ОписаниеОшибки = """";
	РезультатПоиска = ПодборНоменклатурыВДокументахПереопределяемый.ПоискТоваров(СтрокаПоиска, ОписаниеОшибки);
	
	Возврат ОписаниеОшибки;
	
КонецФункции // ПолнотекстовыйПоискНаСервереБезКонтекста()

// Полнотекстовый поиск

Функция ПоискТоваров(СтрокаПоиска, ОписаниеОшибки) Экспорт
	
	РезультатПоиска = Новый Структура;
	РезультатПоиска.Вставить(""Номенклатура"", Новый Массив);
	РезультатПоиска.Вставить(""ХарактеристикиНоменклатуры"", Новый Массив);
	
	Результат = ПолнотекстовыйПоискТоваров(СтрокаПоиска, РезультатПоиска);
	
	Если Результат = ""ВыполненоУспешно"" Тогда
		
		Возврат РезультатПоиска;
		
	ИначеЕсли Результат = ""СлишкомМногоРезультатов"" Тогда
		
		ОписаниеОшибки = НСтр(""ru = 'Слишком много результатов. Уточните запрос.'"");
		Возврат РезультатПоиска;
		
	ИначеЕсли Результат = ""НичегоНеНайдено"" Тогда
		
		ОписаниеОшибки = НСтр(""ru = 'Ничего не найдено'"");
		Возврат РезультатПоиска;
		
	Иначе
		
		ВызватьИсключение НСтр(""ru = 'Неизвестная ошибка'"");
		
	КонецЕсли;
	
КонецФункции

Функция ПолнотекстовыйПоискТоваров(СтрокаПоиска, РезультатПоиска)
	
	МассивШтрихкодов = Новый Массив;
	
	// Поиск данных
	РазмерПорции = 200;
	ОбластьПоиска = Новый Массив;
	ОбластьПоиска.Добавить(Метаданные.Справочники.Номенклатура);
	ОбластьПоиска.Добавить(Метаданные.Справочники.ХарактеристикиНоменклатуры);
	ОбластьПоиска.Добавить(Метаданные.РегистрыСведений.ДополнительныеСведения);
	ОбластьПоиска.Добавить(Метаданные.РегистрыСведений.ШтрихкодыНоменклатуры);
	
	СписокПоиска = ПолнотекстовыйПоиск.СоздатьСписок(СтрокаПоиска, РазмерПорции);
	СписокПоиска.ПолучатьОписание = Ложь;
	СписокПоиска.ОбластьПоиска = ОбластьПоиска;
	СписокПоиска.ПерваяЧасть();
	
	Если СписокПоиска.СлишкомМногоРезультатов() Тогда
		
		Возврат ""СлишкомМногоРезультатов"";
		
	КонецЕсли;
	
	Если СписокПоиска.ПолноеКоличество() = 0 Тогда
		
		Возврат ""НичегоНеНайдено"";
		
	КонецЕсли;
	
	Пока Истина Цикл
		
		Для Каждого Элемент Из СписокПоиска Цикл
			
			Если Элемент.Метаданные = Метаданные.Справочники.Номенклатура Тогда
				
				РезультатПоиска.Номенклатура.Добавить(Элемент.Значение);
				
			ИначеЕсли Элемент.Метаданные = Метаданные.Справочники.ХарактеристикиНоменклатуры Тогда
				
				РезультатПоиска.ХарактеристикиНоменклатуры.Добавить(Элемент.Значение);
				
			ИначеЕсли Элемент.Метаданные = Метаданные.РегистрыСведений.ДополнительныеСведения Тогда
				
				Если ТипЗнч(Элемент.Значение.Объект) = Тип(""СправочникСсылка.Номенклатура"") Тогда
					
					РезультатПоиска.Номенклатура.Добавить(Элемент.Значение.Объект);
					
				КонецЕсли;
				
			ИначеЕсли Элемент.Метаданные = Метаданные.РегистрыСведений.ШтрихкодыНоменклатуры Тогда
				
				МассивШтрихкодов.Добавить(Элемент.Значение.Штрихкод);
				
			Иначе
				
				ВызватьИсключение НСтр(""ru = 'Неизвестная ошибка'"");
				
			КонецЕсли;
			
		КонецЦикла;
		
		Попытка
			
			// Работать с общим размером выборки нельзя, так как он динамичен:
			// - пока мы обрабатываем результат может пройти операция обновления индекса
			//   поэтому работаем до первого исключения, после выходим с полученными данными.
			СписокПоиска.СледующаяЧасть();
			
		Исключение
			
			Прервать;
			
		КонецПопытки;
		
	КонецЦикла;
	
	Если МассивШтрихкодов.Количество() > 0 Тогда
		
		Запрос = Новый Запрос;
		Запрос.Текст = 
		""ВЫБРАТЬ
		|	ШтрихкодыНоменклатуры.Номенклатура КАК Номенклатура,
		|	ШтрихкодыНоменклатуры.Характеристика КАК Характеристика
		|ИЗ
		|	РегистрСведений.ШтрихкодыНоменклатуры КАК ШтрихкодыНоменклатуры
		|ГДЕ
		|	ШтрихкодыНоменклатуры.Штрихкод В(&МассивШтрихкодов)
		|	И ШтрихкодыНоменклатуры.Номенклатура ССЫЛКА Справочник.Номенклатура"";
		
		Запрос.УстановитьПараметр(""МассивШтрихкодов"", МассивШтрихкодов);
		
		Выборка = Запрос.Выполнить().Выбрать();
		Пока Выборка.Следующий() Цикл
			
			РезультатПоиска.Номенклатура.Добавить(Выборка.Номенклатура);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат ""ВыполненоУспешно"";
	
КонецФункции

// Конец Полнотекстовый поиск

"}
}
}
},
{1,
{"ОбщегоНазначенияКлиентСервер  (популярные типовые ништяки)",1,0,"",""},
{0,
{"ОбщегоНазначенияКлиентСервер ЗУП Типовое",0,0,"","////////////////////////////////////////////////////////////////////////////////
// Клиентские и серверные процедуры и функции общего назначения:
// - для поддержки формирования печатных форм;
// - для работы с файлами;
// - для работы с управляемыми формами; 
// - для работы с почтовыми адресами;
// - для работы с отборами динамических списков;
// - прочее.
// ОбщегоНазначенияКлиентСервер
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

// Формирует и выводит сообщение, которое может быть связано с элементом 
// управления формы.
//
// Параметры:
//  ТекстСообщенияПользователю - Строка - текст сообщения.
//  КлючДанных                 - ЛюбаяСсылка - объект или ключ записи информационной базы, к которому это сообщение относится.
//  Поле                       - Строка - наименование реквизита формы.
//  ПутьКДанным                - Строка - путь к данным (путь к реквизиту формы).
//  Отказ                      - Булево - выходной параметр, всегда устанавливается в значение Истина.
//
// Пример:
//
//  1. Для вывода сообщения у поля управляемой формы, связанного с реквизитом объекта:
//  ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//   НСтр(""ru = 'Сообщение об ошибке.'""), ,
//   ""ПолеВРеквизитеФормыОбъект"",
//   ""Объект"");
//
//  Альтернативный вариант использования в форме объекта:
//  ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//   НСтр(""ru = 'Сообщение об ошибке.'""), ,
//   ""Объект.ПолеВРеквизитеФормыОбъект"");
//
//  2. Для вывода сообщения рядом с полем управляемой формы, связанным с реквизитом формы:
//  ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//   НСтр(""ru = 'Сообщение об ошибке.'""), ,
//   ""ИмяРеквизитаФормы"");
//
//  3. Для вывода сообщения связанного с объектом информационной базы:
//  ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//   НСтр(""ru = 'Сообщение об ошибке.'""), ОбъектИнформационнойБазы, ""Ответственный"",,Отказ);
//
//  4. Для вывода сообщения по ссылке на объект информационной базы:
//  ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//   НСтр(""ru = 'Сообщение об ошибке.'""), Ссылка, , , Отказ);
//
//  Случаи некорректного использования:
//   1. Передача одновременно параметров КлючДанных и ПутьКДанным.
//   2. Передача в параметре КлючДанных значения типа отличного от допустимых.
//   3. Установка ссылки без установки поля (и/или пути к данным).
//
Процедура СообщитьПользователю(
		Знач ТекстСообщенияПользователю,
		Знач КлючДанных = Неопределено,
		Знач Поле = """",
		Знач ПутьКДанным = """",
		Отказ = Ложь) Экспорт
	
	Сообщение = Новый СообщениеПользователю;
	Сообщение.Текст = ТекстСообщенияПользователю;
	Сообщение.Поле = Поле;
	
	ЭтоОбъект = Ложь;
	
#Если НЕ ТонкийКлиент И НЕ ВебКлиент И НЕ МобильныйКлиент Тогда
	Если КлючДанных <> Неопределено
	   И XMLТипЗнч(КлючДанных) <> Неопределено Тогда
		ТипЗначенияСтрокой = XMLТипЗнч(КлючДанных).ИмяТипа;
		ЭтоОбъект = СтрНайти(ТипЗначенияСтрокой, ""Object."") > 0;
	КонецЕсли;
#КонецЕсли
	
	Если ЭтоОбъект Тогда
		Сообщение.УстановитьДанные(КлючДанных);
	Иначе
		Сообщение.КлючДанных = КлючДанных;
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(ПутьКДанным) Тогда
		Сообщение.ПутьКДанным = ПутьКДанным;
	КонецЕсли;
		
	Сообщение.Сообщить();
	
	Отказ = Истина;
	
КонецПроцедуры

// Добавляет в список ошибок новую ошибку пользователя для дальнейшей отправки с помощью
// процедуры СообщитьОшибкиПользователю().
// Предназначена для накопления списка ошибок с последующей обработкой этого списка перед тем, как вывести
// пользователю. Полученный список ошибок можно, например, отсортировать по важности, очистить от дублей,
// а также вывести пользователю в ином виде, чем выводит метод СообщитьПользователю, например, в табличный документ.
//
// Параметры:
//  Ошибки          - Неопределено - будет создан новый список,
//                  - значение, установленное при первом вызове этой процедуры со значением Неопределено.
//
//  ПолеОшибки      - Строка - значение, которое задается в свойстве Поле объекта СообщениеПользователю.
//                    Для автоподстановки номера строки должна содержать ""%1"".
//                    Например, ""Объект.ИНН"" или ""Объект.Пользователи[%1].Пользователь"".
//
//  ТекстДляОднойОшибки - Строка - текст ошибки для случая, когда ГруппаОшибок в коллекции только одна,
//                    например, НСтр(""ru = 'Пользователь не выбран.'"").
//
//  ГруппаОшибок    - Произвольный - используется для выбора либо текста для одной ошибки,
//                    либо текста для нескольких ошибок, например, имя ""Объект.Пользователи"".
//                    Если значение не заполнено, тогда используется текст для одной ошибки.
//
//  НомерСтроки     - Число - значение от 0 ... , определяющее номер строки, который нужно подставить
//                    в строку ПолеОшибки и в ТекстДляНесколькихОшибок (подставляется НомерСтроки + 1).
//
//  ТекстДляНесколькихОшибок - Строка - текст ошибки для случая, когда добавлено несколько ошибок с одинаковым
//                    свойством ГруппаОшибок, например, НСтр(""ru = 'Пользователь в строке %1 не выбран.'"").
//
//  ИндексСтроки    - Неопределено - совпадает со значением параметра НомерСтроки.
//                    Число - значение от 0 ... , определяющее номер строки, который нужно подставить
//                    в строку ПолеОшибки.
//
Процедура ДобавитьОшибкуПользователю(Ошибки, ПолеОшибки, ТекстДляОднойОшибки, ГруппаОшибок, НомерСтроки = 0, ТекстДляНесколькихОшибок = """", ИндексСтроки = Неопределено) Экспорт
	
	Если Ошибки = Неопределено Тогда
		Ошибки = Новый Структура;
		Ошибки.Вставить(""СписокОшибок"", Новый Массив);
		Ошибки.Вставить(""ГруппыОшибок"", Новый Соответствие);
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(ГруппаОшибок) Тогда
		// При незаполненной группе ошибок используется текст для одной ошибки.
	Иначе
		Если Ошибки.ГруппыОшибок[ГруппаОшибок] = Неопределено Тогда
			// Группа ошибок использовалась один раз, используется текст для одной ошибки.
			Ошибки.ГруппыОшибок.Вставить(ГруппаОшибок, Ложь);
		Иначе
			// Группа ошибок использовалась несколько раз, используется текст для нескольких ошибок.
			Ошибки.ГруппыОшибок.Вставить(ГруппаОшибок, Истина);
		КонецЕсли;
	КонецЕсли;
	
	Ошибка = Новый Структура;
	Ошибка.Вставить(""ПолеОшибки"",               ПолеОшибки);
	Ошибка.Вставить(""ТекстДляОднойОшибки"",      ТекстДляОднойОшибки);
	Ошибка.Вставить(""ГруппаОшибок"",             ГруппаОшибок);
	Ошибка.Вставить(""НомерСтроки"",              НомерСтроки);
	Ошибка.Вставить(""ТекстДляНесколькихОшибок"", ТекстДляНесколькихОшибок);
	Ошибка.Вставить(""ИндексСтроки"",             ИндексСтроки);
	
	Ошибки.СписокОшибок.Добавить(Ошибка);
	
КонецПроцедуры

// Выводит накопленные методом ДобавитьОшибкуПользователю ошибки, при этом использует нужные шаблоны текстов ошибок
// в зависимости от количества однотипных ошибок.
//
// Параметры:
//  Ошибки  - Неопределено, Структура - коллекция ошибок.
//  Отказ   - Булево - устанавливается Истина, если ошибки сообщались.
//
Процедура СообщитьОшибкиПользователю(Ошибки, Отказ = Ложь) Экспорт
	
	Если Ошибки = Неопределено Тогда
		Возврат;
	Иначе
		Отказ = Истина;
	КонецЕсли;
	
	Для каждого Ошибка Из Ошибки.СписокОшибок Цикл
		
		Если Ошибка.ИндексСтроки = Неопределено Тогда
			ИндексСтроки = Ошибка.НомерСтроки;
		Иначе
			ИндексСтроки = Ошибка.ИндексСтроки;
		КонецЕсли;
		
		Если Ошибки.ГруппыОшибок[Ошибка.ГруппаОшибок] <> Истина Тогда
			
			СообщитьПользователю(
				Ошибка.ТекстДляОднойОшибки,
				,
				СтрЗаменить(Ошибка.ПолеОшибки, ""%1"", Формат(ИндексСтроки, ""ЧН=0; ЧГ="")));
		Иначе
			СообщитьПользователю(
				СтрЗаменить(Ошибка.ТекстДляНесколькихОшибок, ""%1"", Формат(Ошибка.НомерСтроки + 1, ""ЧН=0; ЧГ="")),
				,
				СтрЗаменить(Ошибка.ПолеОшибки, ""%1"", Формат(ИндексСтроки, ""ЧН=0; ЧГ="")));
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Формирует текст ошибок заполнения полей и списков.
//
// Параметры:
//  ВидПоля       - Строка - может принимать значения:
//                  Поле, Колонка, Список;
//  ВидСообщения  - Строка - может принимать значения:
//                  Заполнение, Корректность;
//  ИмяПоля        - Строка - имя поля;
//  НомерСтроки    - Строка, Число - номер строки;
//  ИмяСписка      - Строка - имя списка;
//  ТекстСообщения - Строка - детальная расшифровка ошибки заполнения.
//
// Возвращаемое значение:
//   Строка - текст ошибки заполнения.
//
Функция ТекстОшибкиЗаполнения(ВидПоля = ""Поле"", ВидСообщения = ""Заполнение"",
	ИмяПоля = """", НомерСтроки = """", ИмяСписка = """", ТекстСообщения = """") Экспорт

	Если ВРег(ВидПоля) = ""ПОЛЕ"" Тогда
		Если ВРег(ВидСообщения) = ""ЗАПОЛНЕНИЕ"" Тогда
			Шаблон = НСтр(""ru = 'Поле """"%1"""" не заполнено'"");
		ИначеЕсли ВРег(ВидСообщения) = ""КОРРЕКТНОСТЬ"" Тогда
			Шаблон = НСтр(""ru = 'Поле """"%1"""" заполнено некорректно.
								|%4'"");
		КонецЕсли;
	ИначеЕсли ВРег(ВидПоля) = ""КОЛОНКА"" Тогда
		Если ВРег(ВидСообщения) = ""ЗАПОЛНЕНИЕ"" Тогда
			Шаблон = НСтр(""ru = 'Не заполнена колонка """"%1"""" в строке %2 списка """"%3""""'"");
		ИначеЕсли ВРег(ВидСообщения) = ""КОРРЕКТНОСТЬ"" Тогда
			Шаблон = НСтр(""ru = 'Некорректно заполнена колонка """"%1"""" в строке %2 списка """"%3"""".
								|%4'"");
		КонецЕсли;
	ИначеЕсли ВРег(ВидПоля) = ""СПИСОК"" Тогда
		Если ВРег(ВидСообщения) = ""ЗАПОЛНЕНИЕ"" Тогда
			Шаблон = НСтр(""ru = 'Не введено ни одной строки в список """"%3""""'"");
		ИначеЕсли ВРег(ВидСообщения) = ""КОРРЕКТНОСТЬ"" Тогда
			Шаблон = НСтр(""ru = 'Некорректно заполнен список """"%3"""".
								|%4'"");
		КонецЕсли;
	КонецЕсли;

	Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(Шаблон, ИмяПоля, НомерСтроки, ИмяСписка, ТекстСообщения);

КонецФункции

// Формирует путь к заданной строке НомерСтроки и колонке ИмяРеквизита 
// табличной части ИмяТабличнойЧасти для выдачи сообщений в форме.
// Для совместного использования с процедурой СообщитьПользователю
// (для передачи в параметры Поле или ПутьКДанным). 
//
// Параметры:
//  ИмяТабличнойЧасти - Строка - имя табличной части.
//  НомерСтроки       - Число - номер строки табличной части.
//  ИмяРеквизита      - Строка - имя реквизита.
//
// Возвращаемое значение:
//  Строка - путь к ячейке таблицы.
//
Функция ПутьКТабличнойЧасти(Знач ИмяТабличнойЧасти, Знач НомерСтроки, 
	Знач ИмяРеквизита) Экспорт

	Возврат ИмяТабличнойЧасти + ""["" + Формат(НомерСтроки - 1, ""ЧН=0; ЧГ=0"") + ""]."" + ИмяРеквизита;

КонецФункции

// Дополняет таблицу значений-приемник данными из таблицы значений-источник.
//
// Параметры:
//  ТаблицаИсточник - ТаблицаЗначений - таблица, из которой будут браться строки для заполнения;
//  ТаблицаПриемник - ТаблицаЗначений - таблица, в которую будут добавлены строки из таблицы-источника.
//  
Процедура ДополнитьТаблицу(ТаблицаИсточник, ТаблицаПриемник) Экспорт
	
	Для Каждого СтрокаТаблицыИсточник Из ТаблицаИсточник Цикл
		
		ЗаполнитьЗначенияСвойств(ТаблицаПриемник.Добавить(), СтрокаТаблицыИсточник);
		
	КонецЦикла;
	
КонецПроцедуры

// Дополняет таблицу значений Таблица значениями из массива Массив.
//
// Параметры:
//  Таблица - ТаблицаЗначений - таблица, которую необходимо заполнить значениями из массива;
//  Массив  - Массив - массив значений для заполнения таблицы;
//  ИмяПоля - Строка - имя поля таблицы значений, в которое необходимо загрузить значения из массива.
// 
Процедура ДополнитьТаблицуИзМассива(Таблица, Массив, ИмяПоля) Экспорт

	Для каждого Значение Из Массив Цикл
		
		Таблица.Добавить()[ИмяПоля] = Значение;
		
	КонецЦикла;
	
КонецПроцедуры

// Дополняет массив МассивПриемник значениями из массива МассивИсточник.
//
// Параметры:
//  МассивПриемник - Массив - массив, в который необходимо добавить значения.
//  МассивИсточник - Массив - массив значений для заполнения.
//  ТолькоУникальныеЗначения - Булево - если истина, то в массив будут включены только уникальные значения.
//
Процедура ДополнитьМассив(МассивПриемник, МассивИсточник, ТолькоУникальныеЗначения = Ложь) Экспорт
	
	Если ТолькоУникальныеЗначения Тогда
		
		УникальныеЗначения = Новый Соответствие;
		
		Для Каждого Значение Из МассивПриемник Цикл
			УникальныеЗначения.Вставить(Значение, Истина);
		КонецЦикла;
		
		Для Каждого Значение Из МассивИсточник Цикл
			Если УникальныеЗначения[Значение] = Неопределено Тогда
				МассивПриемник.Добавить(Значение);
				УникальныеЗначения.Вставить(Значение, Истина);
			КонецЕсли;
		КонецЦикла;
		
	Иначе
		
		Для Каждого Значение Из МассивИсточник Цикл
			МассивПриемник.Добавить(Значение);
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Дополняет структуру значениями из другой структуры.
//
// Параметры:
//   Приемник - Структура - коллекция, в которую будут добавляться новые значения.
//   Источник - Структура - коллекция, из которой будут считываться пары Ключ и Значение для заполнения.
//   Заменять - Булево, Неопределено - Что делать в местах пересечения ключей источника и приемника:
//                                       Истина - Заменять значения приемника (самый быстрый способ),
//                                       Ложь   - Не заменять значения приемника (пропускать),
//                                       Неопределено - Значение по умолчанию. Бросать исключение.
//
Процедура ДополнитьСтруктуру(Приемник, Источник, Заменять = Неопределено) Экспорт
	
	Для Каждого Элемент Из Источник Цикл
		Если Заменять <> Истина И Приемник.Свойство(Элемент.Ключ) Тогда
			Если Заменять = Ложь Тогда
				Продолжить;
			Иначе
				ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр(""ru = 'Пересечение ключей источника и приемника: """"%1"""".'""), Элемент.Ключ);
			КонецЕсли
		КонецЕсли;
		Приемник.Вставить(Элемент.Ключ, Элемент.Значение);
	КонецЦикла;
	
КонецПроцедуры

// Дополняет соответствие значениями из другого соответствия.
//
// Параметры:
//   Приемник - Соответствие - коллекция, в которую будут добавляться новые значения.
//   Источник - Соответствие - коллекция, из которой будут считываться пары Ключ и Значение для заполнения.
//   Заменять - Булево, Неопределено - Что делать в местах пересечения ключей источника и приемника:
//                                       Истина - Заменять значения приемника (самый быстрый способ),
//                                       Ложь   - Не заменять значения приемника (пропускать),
//                                       Неопределено - Значение по умолчанию. Бросать исключение.
//
Процедура ДополнитьСоответствие(Приемник, Источник, Заменять = Неопределено) Экспорт
	
	Для Каждого Элемент Из Источник Цикл
		Если Заменять <> Истина И Приемник[Элемент.Ключ] <> Неопределено Тогда
			Если Заменять = Ложь Тогда
				Продолжить;
			Иначе
				ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр(""ru = 'Пересечение ключей источника и приемника: """"%1"""".'""), Элемент.Ключ);
			КонецЕсли
		КонецЕсли;
		Приемник.Вставить(Элемент.Ключ, Элемент.Значение);
	КонецЦикла;
	
КонецПроцедуры

// Проверяет наличие реквизита или свойства у произвольного объекта без обращения к метаданным.
//
// Параметры:
//  Объект       - Произвольный - объект, у которого нужно проверить наличие реквизита или свойства;
//  ИмяРеквизита - Строка       - имя реквизита или свойства.
//
// Возвращаемое значение:
//  Булево - Истина, если есть.
//
Функция ЕстьРеквизитИлиСвойствоОбъекта(Объект, ИмяРеквизита) Экспорт
	
	КлючУникальности   = Новый УникальныйИдентификатор;
	СтруктураРеквизита = Новый Структура(ИмяРеквизита, КлючУникальности);
	ЗаполнитьЗначенияСвойств(СтруктураРеквизита, Объект);
	
	Возврат СтруктураРеквизита[ИмяРеквизита] <> КлючУникальности;
	
КонецФункции

// Снимает один элемент условного оформления, если это список значений.
// 
// Параметры:
//  УсловноеОформление - УсловноеОформление - условное оформление элемента формы;
//  ИдентификаторПользовательскойНастройки - Строка - идентификатор настройки;
//  Значение - Произвольный -  значение, которое требуется удалить из списка оформления.
//
Процедура СнятьУсловноеОформлениеСпискаЗначений(УсловноеОформление, Знач ИдентификаторПользовательскойНастройки, 
	Знач Значение) Экспорт
	
	Для каждого ЭлементУсловногоОформления Из УсловноеОформление.Элементы Цикл
		Если ЭлементУсловногоОформления.ИдентификаторПользовательскойНастройки = ИдентификаторПользовательскойНастройки Тогда
			Если ЭлементУсловногоОформления.Отбор.Элементы.Количество() = 0 Тогда
				Возврат;
			КонецЕсли;
			ЭлементСписокОтбора = ЭлементУсловногоОформления.Отбор.Элементы[0];
			Если ЭлементСписокОтбора.ПравоеЗначение = Неопределено Тогда
				Возврат;
			КонецЕсли;
			ЭлементСписка = ЭлементСписокОтбора.ПравоеЗначение.НайтиПоЗначению(Значение);
			Если ЭлементСписка <> Неопределено Тогда
				ЭлементСписокОтбора.ПравоеЗначение.Удалить(ЭлементСписка);
			КонецЕсли;
			ЭлементСписокОтбора.ПравоеЗначение = ЭлементСписокОтбора.ПравоеЗначение;
			Возврат;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Удаляет все вхождения переданного значения из массива.
//
// Параметры:
//  Массив - Массив - массив, из которого необходимо удалить значение;
//  Значение - Произвольный - удаляемое значение из массива.
// 
Процедура УдалитьВсеВхожденияЗначенияИзМассива(Массив, Значение) Экспорт
	
	КоличествоЭлементовКоллекции = Массив.Количество();
	
	Для ОбратныйИндекс = 1 По КоличествоЭлементовКоллекции Цикл
		
		Индекс = КоличествоЭлементовКоллекции - ОбратныйИндекс;
		
		Если Массив[Индекс] = Значение Тогда
			
			Массив.Удалить(Индекс);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Удаляет все вхождения значений указанного типа.
//
// Параметры:
//  Массив - Массив - массив, из которого необходимо удалить значения;
//  Тип - Тип - тип значений, которые подлежат удалению из массива.
// 
Процедура УдалитьВсеВхожденияТипаИзМассива(Массив, Тип) Экспорт
	
	КоличествоЭлементовКоллекции = Массив.Количество();
	
	Для ОбратныйИндекс = 1 По КоличествоЭлементовКоллекции Цикл
		
		Индекс = КоличествоЭлементовКоллекции - ОбратныйИндекс;
		
		Если ТипЗнч(Массив[Индекс]) = Тип Тогда
			
			Массив.Удалить(Индекс);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Удаляет одно значение из массива.
//
// Параметры:
//  Массив - Массив - массив, из которого необходимо удалить значение;
//  Значение - Массив - удаляемое значение из массива.
// 
Процедура УдалитьЗначениеИзМассива(Массив, Значение) Экспорт
	
	Индекс = Массив.Найти(Значение);
	
	Если Индекс <> Неопределено Тогда
		
		Массив.Удалить(Индекс);
		
	КонецЕсли;
	
КонецПроцедуры

// Удаляет повторяющиеся элементы массива.
//
// Параметры:
//  Массив - Массив - массив произвольных значений.
//
// Возвращаемое значение:
//  Массив - коллекция уникальных элементов.
//
Функция СвернутьМассив(Массив) Экспорт
	Результат = Новый Массив;
	ДополнитьМассив(Результат, Массив, Истина);
	Возврат Результат;
КонецФункции

// Заполняет коллекцию-приемник значениями из коллекции-источник.
// В качестве коллекций источника и приемника могут выступать типы:
// ТаблицаЗначений; ДеревоЗначений; СписокЗначений и пр.
//
// Параметры:
//  КоллекцияИсточник - ЛюбаяКоллекция - коллекция значений, которая является источником для заполнения данных;
//  КоллекцияПриемник - ЛюбаяКоллекция - коллекция значений, которая является приемником для заполнения данных.
// 
Процедура ЗаполнитьКоллекциюСвойств(КоллекцияИсточник, КоллекцияПриемник) Экспорт
	
	Для Каждого Элемент Из КоллекцияИсточник Цикл
		
		ЗаполнитьЗначенияСвойств(КоллекцияПриемник.Добавить(), Элемент);
		
	КонецЦикла;
	
КонецПроцедуры

// Получает массив значений из отмеченных элементов списка значений.
//
// Параметры:
//  Список - СписокЗначений - список значений из которого будет формироваться массив значений;
// 
// Возвращаемое значение:
//  Массив - массив значений из отмеченных элементов списка значений.
//
Функция ОтмеченныеЭлементы(Список) Экспорт
	
	// Возвращаемое значение функции.
	Массив = Новый Массив;
	
	Для Каждого Элемент Из Список Цикл
		
		Если Элемент.Пометка Тогда
			
			Массив.Добавить(Элемент.Значение);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Массив;
КонецФункции

// Вычисляет разность массивов. Разностью массивов А и В является массив, содержащий
// все элементы массива А не существующие в массиве В.
//
// Параметры:
//  Массив - Массив - массив элементов, из которого необходимо выполнить вычитание;
//  МассивВычитания - Массив - массив элементов, который будет вычитаться.
// 
// Возвращаемое значение:
//  Массив - дополнение массива В до А.
//
// Пример:
//	//А = [1, 3, 5, 7];
//	//В = [3, 7, 9];
//	Результат = РазностьМассивов(А, В);
//	//Результат = [1, 5];
//
Функция РазностьМассивов(Массив, МассивВычитания) Экспорт
	
	Результат = Новый Массив;
	
	Для Каждого Элемент Из Массив Цикл
		
		Если МассивВычитания.Найти(Элемент) = Неопределено Тогда
			
			Результат.Добавить(Элемент);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Преобразует РасписаниеРегламентногоЗадания в структуру.
//
// Параметры:
//  Расписание - РасписаниеРегламентногоЗадания - исходное расписание.
// 
// Возвращаемое значение:
//  Структура - расписание в виде структуры.
//
Функция РасписаниеВСтруктуру(Знач Расписание) Экспорт
	
	ЗначениеРасписания = Расписание;
	Если ЗначениеРасписания = Неопределено Тогда
		ЗначениеРасписания = Новый РасписаниеРегламентногоЗадания();
	КонецЕсли;
	СписокПолей = ""ВремяЗавершения,ВремяКонца,ВремяНачала,ДатаКонца,ДатаНачала,ДеньВМесяце,ДеньНеделиВМесяце,""
		+ ""ДниНедели,ИнтервалЗавершения,Месяцы,ПаузаПовтора,ПериодНедель,ПериодПовтораВТечениеДня,ПериодПовтораДней"";
	Результат = Новый Структура(СписокПолей);
	ЗаполнитьЗначенияСвойств(Результат, ЗначениеРасписания, СписокПолей);
	ДетальныеРасписанияДня = Новый Массив;
	Для каждого РасписаниеДля Из Расписание.ДетальныеРасписанияДня Цикл
		ДетальныеРасписанияДня.Добавить(РасписаниеВСтруктуру(РасписаниеДля));
	КонецЦикла;
	Результат.Вставить(""ДетальныеРасписанияДня"", ДетальныеРасписанияДня);
	Возврат Результат;
	
КонецФункции

// Преобразует структуру в РасписаниеРегламентногоЗадания.
//
// Параметры:
//  СтруктураРасписания - Структура - расписание в виде структуры.
// 
// Возвращаемое значение:
//  РасписаниеРегламентногоЗадания - расписание.
//
Функция СтруктураВРасписание(Знач СтруктураРасписания) Экспорт
	
	Если СтруктураРасписания = Неопределено Тогда
		Возврат Новый РасписаниеРегламентногоЗадания();
	КонецЕсли;
	СписокПолей = ""ВремяЗавершения,ВремяКонца,ВремяНачала,ДатаКонца,ДатаНачала,ДеньВМесяце,ДеньНеделиВМесяце,""
		+ ""ДниНедели,ИнтервалЗавершения,Месяцы,ПаузаПовтора,ПериодНедель,ПериодПовтораВТечениеДня,ПериодПовтораДней"";
	Результат = Новый РасписаниеРегламентногоЗадания;
	ЗаполнитьЗначенияСвойств(Результат, СтруктураРасписания, СписокПолей);
	ДетальныеРасписанияДня = Новый Массив;
	Для каждого Расписание Из СтруктураРасписания.ДетальныеРасписанияДня Цикл
		ДетальныеРасписанияДня.Добавить(СтруктураВРасписание(Расписание));
	КонецЦикла;
	Результат.ДетальныеРасписанияДня = ДетальныеРасписанияДня;  
	Возврат Результат;
	
КонецФункции

// Создает полную копию структуры, соответствия, массива, списка или таблицы значений, рекурсивно, 
// с учетом типов дочерних элементов. При этом содержимое значений объектных типов 
// (СправочникОбъект, ДокументОбъект и т.п.) не копируются, а возвращаются ссылки на исходный объект.
//
// Параметры:
//  Источник - Структура, Соответствие, Массив, СписокЗначений, ТаблицаЗначений - объект, который необходимо 
//             скопировать.
//
// Возвращаемое значение:
//  Структура, Соответствие, Массив, СписокЗначений, ТаблицаЗначений - копия объекта, переданного в параметре Источник.
//
Функция СкопироватьРекурсивно(Источник) Экспорт
	
	Перем Приемник;
	
	ТипИсточника = ТипЗнч(Источник);
	
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
	Если ТипИсточника = Тип(""ТаблицаЗначений"") Тогда
		Возврат Источник.Скопировать();
	КонецЕсли;
#КонецЕсли	
	Если ТипИсточника = Тип(""Структура"") Тогда
		Приемник = СкопироватьСтруктуру(Источник);
	ИначеЕсли ТипИсточника = Тип(""Соответствие"") Тогда
		Приемник = СкопироватьСоответствие(Источник);
	ИначеЕсли ТипИсточника = Тип(""Массив"") Тогда
		Приемник = СкопироватьМассив(Источник);
	ИначеЕсли ТипИсточника = Тип(""СписокЗначений"") Тогда
		Приемник = СкопироватьСписокЗначений(Источник);
	Иначе
		Приемник = Источник;
	КонецЕсли;
	
	Возврат Приемник;
	
КонецФункции

// Создает копию значения типа Структура, рекурсивно, с учетом типов значений свойств. 
// Если свойства структуры содержат значения объектных типов (СправочникОбъект, ДокументОбъект и т.п.),
// то их содержимое не копируются, а возвращаются ссылки на исходный объект.
//
// Параметры:
//  СтруктураИсточник - Структура - копируемая структура.
// 
// Возвращаемое значение:
//  Структура - копия исходной структуры.
//
Функция СкопироватьСтруктуру(СтруктураИсточник) Экспорт
	
	СтруктураРезультат = Новый Структура;
	
	Для Каждого КлючИЗначение Из СтруктураИсточник Цикл
		СтруктураРезультат.Вставить(КлючИЗначение.Ключ, СкопироватьРекурсивно(КлючИЗначение.Значение));
	КонецЦикла;
	
	Возврат СтруктураРезультат;
	
КонецФункции

// Создает копию значения типа Соответствие, рекурсивно, с учетом типов значений.
// Если значения соответствия содержат значения объектных типов (СправочникОбъект, ДокументОбъект и т.п.),
// то их содержимое не копируются, а возвращаются ссылки на исходный объект.
//
// Параметры:
//  СоответствиеИсточник - Соответствие - соответствие, копию которого необходимо получить.
// 
// Возвращаемое значение:
//  Соответствие - копия исходного соответствия.
//
Функция СкопироватьСоответствие(СоответствиеИсточник) Экспорт
	
	СоответствиеРезультат = Новый Соответствие;
	
	Для Каждого КлючИЗначение Из СоответствиеИсточник Цикл
		СоответствиеРезультат.Вставить(КлючИЗначение.Ключ, СкопироватьРекурсивно(КлючИЗначение.Значение));
	КонецЦикла;
	
	Возврат СоответствиеРезультат;

КонецФункции

// Создает копию значения типа Массив, рекурсивно, с учетом типов значений элементов массива.
// Если элементы массива содержат значения объектных типов (СправочникОбъект, ДокументОбъект и т.п.),
// то их содержимое не копируются, а возвращаются ссылки на исходный объект.
//
// Параметры:
//  МассивИсточник - Массив - массив, копию которого необходимо получить.
// 
// Возвращаемое значение:
//  Массив - копия исходного массива.
//
Функция СкопироватьМассив(МассивИсточник) Экспорт
	
	МассивРезультат = Новый Массив;
	
	Для Каждого Элемент Из МассивИсточник Цикл
		МассивРезультат.Добавить(СкопироватьРекурсивно(Элемент));
	КонецЦикла;
	
	Возврат МассивРезультат;
	
КонецФункции

// Создает копию значения типа СписокЗначений, рекурсивно, с учетом типов его значений.
// Если в списке значений есть значения объектных типов (СправочникОбъект, ДокументОбъект и т.п.),
// то их содержимое не копируются, а возвращаются ссылки на исходный объект.
//
// Параметры:
//  СписокИсточник - СписокЗначений - список значений, копию которого необходимо получить.
// 
// Возвращаемое значение:
//  СписокЗначений - копия исходного списка значений.
//
Функция СкопироватьСписокЗначений(СписокИсточник) Экспорт
	
	СписокРезультат = Новый СписокЗначений;
	
	Для Каждого ЭлементСписка Из СписокИсточник Цикл
		СписокРезультат.Добавить(
			СкопироватьРекурсивно(ЭлементСписка.Значение), 
			ЭлементСписка.Представление, 
			ЭлементСписка.Пометка, 
			ЭлементСписка.Картинка);
	КонецЦикла;
	
	Возврат СписокРезультат;
	
КонецФункции

// Сравнивает элементы списков значений или массивов по значениям.
//
// Параметры:
//  Список1 - Массив, СписокЗначений - сравниваемая коллекция элементов.
//  Список2 - Массив, СписокЗначений - сравниваемая коллекция элементов.
//
// Возвращаемое значение:
//  Булево - Истина, если идентичны.
//
Функция СпискиЗначенийИдентичны(Список1, Список2) Экспорт
	
	СпискиИдентичны = Истина;
	
	Для Каждого ЭлементСписка1 Из Список1 Цикл
		Если НайтиВСписке(Список2, ЭлементСписка1) = Неопределено Тогда
			СпискиИдентичны = Ложь;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если СпискиИдентичны Тогда
		Для Каждого ЭлементСписка2 Из Список2 Цикл
			Если НайтиВСписке(Список1, ЭлементСписка2) = Неопределено Тогда
				СпискиИдентичны = Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Возврат СпискиИдентичны;
	
КонецФункции

// Создает массив и помещает в него переданное значение.
//
// Параметры:
//  Значение - Произвольный - любое значение.
//
// Возвращаемое значение:
//  Массив - массив из одного элемента.
//
Функция ЗначениеВМассиве(Значение) Экспорт
	
	Массив = Новый Массив;
	Массив.Добавить(Значение);
	
	Возврат Массив;
	
КонецФункции

// Процедура управляет состояние поля табличного документа.
//
// Параметры:
//  ПолеТабличногоДокумента - ПолеФормы - поле формы с видом ПолеТабличногоДокумента,
//                            для которого необходимо установить состояние.
//  Состояние               - Строка - задает вид состояния.
//
Процедура УстановитьСостояниеПоляТабличногоДокумента(ПолеТабличногоДокумента, Состояние = ""НеИспользовать"") Экспорт
	
	Если ТипЗнч(ПолеТабличногоДокумента) = Тип(""ПолеФормы"") 
		И ПолеТабличногоДокумента.Вид = ВидПоляФормы.ПолеТабличногоДокумента Тогда
		ОтображениеСостояния = ПолеТабличногоДокумента.ОтображениеСостояния;
		Если ВРег(Состояние) = ""НЕИСПОЛЬЗОВАТЬ"" Тогда
			ОтображениеСостояния.Видимость                      = Ложь;
			ОтображениеСостояния.ДополнительныйРежимОтображения = ДополнительныйРежимОтображения.НеИспользовать;
			ОтображениеСостояния.Картинка                       = Новый Картинка;
			ОтображениеСостояния.Текст                          = """";
		ИначеЕсли ВРег(Состояние) = ""НЕАКТУАЛЬНОСТЬ"" Тогда
			ОтображениеСостояния.Видимость                      = Истина;
			ОтображениеСостояния.ДополнительныйРежимОтображения = ДополнительныйРежимОтображения.Неактуальность;
			ОтображениеСостояния.Картинка                       = Новый Картинка;
			ОтображениеСостояния.Текст                          = НСтр(""ru = 'Отчет не сформирован. Нажмите """"Сформировать"""" для получения отчета.'"");;
		ИначеЕсли ВРег(Состояние) = ""ФОРМИРОВАНИЕОТЧЕТА"" Тогда  
			ОтображениеСостояния.Видимость                      = Истина;
			ОтображениеСостояния.ДополнительныйРежимОтображения = ДополнительныйРежимОтображения.Неактуальность;
			ОтображениеСостояния.Картинка                       = БиблиотекаКартинок.ДлительнаяОперация48;
			ОтображениеСостояния.Текст                          = НСтр(""ru = 'Отчет формируется...'"");
		Иначе
			ВызватьИсключение(НСтр(""ru = 'Недопустимое значение параметра (параметр номер ''2'')'""));
		КонецЕсли;
	Иначе
		ВызватьИсключение(НСтр(""ru = 'Недопустимое значение параметра (параметр номер ''1'')'""));
	КонецЕсли;
	
КонецПроцедуры

// Получает номер версии конфигурации без номера сборки.
//
// Параметры:
//  Версия - Строка - версия конфигурации в формате РР.ПП.ЗЗ.СС,
//                    где СС - номер сборки, который будет удален.
// 
// Возвращаемое значение:
//  Строка - номер версии конфигурации без номера сборки в формате РР.ПП.ЗЗ.
//
Функция ВерсияКонфигурацииБезНомераСборки(Знач Версия) Экспорт
	
	Массив = СтрРазделить(Версия, ""."");
	
	Если Массив.Количество() < 3 Тогда
		Возврат Версия;
	КонецЕсли;
	
	Результат = ""[Редакция].[Подредакция].[Релиз]"";
	Результат = СтрЗаменить(Результат, ""[Редакция]"",    Массив[0]);
	Результат = СтрЗаменить(Результат, ""[Подредакция]"", Массив[1]);
	Результат = СтрЗаменить(Результат, ""[Релиз]"",       Массив[2]);
	
	Возврат Результат;
КонецФункции

// Сравнить две строки версий.
//
// Параметры:
//  СтрокаВерсии1  - Строка - номер версии в формате РР.{П|ПП}.ЗЗ.СС.
//  СтрокаВерсии2  - Строка - второй сравниваемый номер версии.
//
// Возвращаемое значение:
//   Число   - больше 0, если СтрокаВерсии1 > СтрокаВерсии2; 0, если версии равны.
//
Функция СравнитьВерсии(Знач СтрокаВерсии1, Знач СтрокаВерсии2) Экспорт
	
	Строка1 = ?(ПустаяСтрока(СтрокаВерсии1), ""0.0.0.0"", СтрокаВерсии1);
	Строка2 = ?(ПустаяСтрока(СтрокаВерсии2), ""0.0.0.0"", СтрокаВерсии2);
	Версия1 = СтрРазделить(Строка1, ""."");
	Если Версия1.Количество() <> 4 Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр(""ru = 'Неправильный формат параметра СтрокаВерсии1: %1'""), СтрокаВерсии1);
	КонецЕсли;
	Версия2 = СтрРазделить(Строка2, ""."");
	Если Версия2.Количество() <> 4 Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
	    	НСтр(""ru = 'Неправильный формат параметра СтрокаВерсии2: %1'""), СтрокаВерсии2);
	КонецЕсли;
	
	Результат = 0;
	Для Разряд = 0 По 3 Цикл
		Результат = Число(Версия1[Разряд]) - Число(Версия2[Разряд]);
		Если Результат <> 0 Тогда
			Возврат Результат;
		КонецЕсли;
	КонецЦикла;
	Возврат Результат;
	
КонецФункции

// Сравнить две строки версий.
//
// Параметры:
//  СтрокаВерсии1  - Строка - номер версии в формате РР.{П|ПП}.ЗЗ.
//  СтрокаВерсии2  - Строка - второй сравниваемый номер версии.
//
// Возвращаемое значение:
//   Число   - больше 0, если СтрокаВерсии1 > СтрокаВерсии2; 0, если версии равны.
//
Функция СравнитьВерсииБезНомераСборки(Знач СтрокаВерсии1, Знач СтрокаВерсии2) Экспорт
	
	Строка1 = ?(ПустаяСтрока(СтрокаВерсии1), ""0.0.0"", СтрокаВерсии1);
	Строка2 = ?(ПустаяСтрока(СтрокаВерсии2), ""0.0.0"", СтрокаВерсии2);
	Версия1 = СтрРазделить(Строка1, ""."");
	Если Версия1.Количество() <> 3 Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр(""ru = 'Неправильный формат параметра СтрокаВерсии1: %1'""), СтрокаВерсии1);
	КонецЕсли;
	Версия2 = СтрРазделить(Строка2, ""."");
	Если Версия2.Количество() <> 3 Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
	    	НСтр(""ru = 'Неправильный формат параметра СтрокаВерсии2: %1'""), СтрокаВерсии2);
	КонецЕсли;
	
	Результат = 0;
	Для Разряд = 0 По 2 Цикл
		Результат = Число(Версия1[Разряд]) - Число(Версия2[Разряд]);
		Если Результат <> 0 Тогда
			Возврат Результат;
		КонецЕсли;
	КонецЦикла;
	Возврат Результат;
	
КонецФункции

// Получает строку, содержащую ключи структуры, разделенные символом разделителя.
//
// Параметры:
//	Структура - Структура - Структура, ключи которой преобразуются в строку.
//	Разделитель - Строка - Разделитель, который вставляется в строку между ключами структуры.
//
// Возвращаемое значение:
//	Строка - Строка, содержащая ключи структуры разделенные разделителем.
//
Функция КлючиСтруктурыВСтроку(Структура, Разделитель = "","") Экспорт
	
	Результат = """";
	
	Для Каждого Элемент Из Структура Цикл
		СимволРазделителя = ?(ПустаяСтрока(Результат), """", Разделитель);
		Результат = Результат + СимволРазделителя + Элемент.Ключ;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Возвращает значение свойства структуры.
//
// Параметры:
//   Структура - Структура, ФиксированнаяСтруктура - Объект, из которого необходимо прочитать значение ключа.
//   Ключ - Строка - Имя свойства структуры, для которого необходимо прочитать значение.
//   ЗначениеПоУмолчанию - Произвольный - Необязательный. Возвращается когда в структуре нет значения по указанному
//                                        ключу.
//       Для скорости рекомендуется передавать только быстро вычисляемые значения (например примитивные типы),
//       а инициализацию более тяжелых значений выполнять после проверки полученного значения (только если это
//       требуется).
//
// Возвращаемое значение:
//   Произвольный - Значение свойства структуры. ЗначениеПоУмолчанию если в структуре нет указанного свойства.
//
Функция СвойствоСтруктуры(Структура, Ключ, ЗначениеПоУмолчанию = Неопределено) Экспорт
	
	Если Структура = Неопределено Тогда
		Возврат ЗначениеПоУмолчанию;
	КонецЕсли;
	
	Результат = ЗначениеПоУмолчанию;
	Если Структура.Свойство(Ключ, Результат) Тогда
		Возврат Результат;
	Иначе
		Возврат ЗначениеПоУмолчанию;
	КонецЕсли;
	
КонецФункции

// Возвращает имя COM-класса для работы с 1С:Предприятием 8 через COM-соединение.
//
// Возвращаемое значение:
//  Строка - имя COM-класса для работы с 1С:Предприятием 8 через COM-соединение.
//
Функция ИмяCOMСоединителя() Экспорт
	СистемнаяИнфо = Новый СистемнаяИнформация;
	ПодстрокиВерсии = СтрРазделить(СистемнаяИнфо.ВерсияПриложения, ""."");
	Возврат ""v"" + ПодстрокиВерсии[0] + ПодстрокиВерсии[1] + "".COMConnector"";
КонецФункции

// Устанавливает внешнее соединение с информационной базой по переданным параметрам подключения и возвращает указатель
// на это соединение.
// 
// Параметры:
//  Параметры - Структура - параметры для установки внешнего соединения с информационной базой.
//                          Свойства см. в функции
//                          ОбщегоНазначенияКлиентСервер.СтруктураПараметровДляУстановкиВнешнегоСоединения):
//
//    * ВариантРаботыИнформационнойБазы             - Число - Вариант работы информационной базы: 0 - файловый; 1 -
//                                                            клиент-серверный;
//    * КаталогИнформационнойБазы                   - Строка - Каталог информационной базы для файлового режима работы;
//    * ИмяСервера1СПредприятия                     - Строка - Имя сервера1С:Предприятия;
//    * ИмяИнформационнойБазыНаСервере1СПредприятия - Строка - Имя информационной базы на сервере1С:Предприятия;
//    * АутентификацияОперационнойСистемы           - Булево - Признак аутентификации операционной системы при создании
//                                                             внешнего подключения к информационной базе;
//    * ИмяПользователя                             - Строка - Имя пользователя информационной базы;
//    * ПарольПользователя                          - Строка - Пароль пользователя информационной базы.
// 
//  СтрокаСообщенияОбОшибке - Строка - если в процессе установки внешнего соединения возникает ошибка,
//                                     то подробное описание ошибки помещается в этот параметр.
//  ОшибкаПодключенияКомпоненты - Булево - (возвращаемый параметр) устанавливается Истина, если была ошибка при подключении.
//
// Возвращаемое значение:
//  COMОбъект, Неопределенно - в случае успешной установки внешнего соединения возвращается указатель на COM-объект соединения;
//    в случае ошибки возвращается Неопределенно.
//
Функция УстановитьВнешнееСоединение(Параметры, СтрокаСообщенияОбОшибке = """", ОшибкаПодключенияКомпоненты = Ложь) Экспорт
	Результат = УстановитьВнешнееСоединениеСБазой(Параметры);
	ОшибкаПодключенияКомпоненты = Результат.ОшибкаПодключенияКомпоненты;
	СтрокаСообщенияОбОшибке     = Результат.ПодробноеОписаниеОшибки;
	
	Возврат Результат.Соединение;
КонецФункции

// Устанавливает внешнее соединение с информационной базой по переданным параметрам подключения и возвращает указатель
// на это соединение.
// 
// Параметры:
//  Параметры - Структура - параметры для установки внешнего соединения с информационной базой.
//                          Свойства см. в функции
//                          ОбщегоНазначенияКлиентСервер.СтруктураПараметровДляУстановкиВнешнегоСоединения):
//
//   * ВариантРаботыИнформационнойБазы             - Число  - Вариант работы информационной базы: 0 - файловый; 1 -
//                                                            клиент-серверный;
//   * КаталогИнформационнойБазы                   - Строка - Каталог информационной базы для файлового режима работы;
//   * ИмяСервера1СПредприятия                     - Строка - Имя сервера1С:Предприятия;
//   * ИмяИнформационнойБазыНаСервере1СПредприятия - Строка - Имя информационной базы на сервере1С:Предприятия;
//   * АутентификацияОперационнойСистемы           - Булево - Признак аутентификации операционной системы при создании
//                                                            внешнего подключения к информационной базе;
//   * ИмяПользователя                             - Строка - Имя пользователя информационной базы;
//   * ПарольПользователя                          - Строка - Пароль пользователя информационной базы.
// 
// Возвращаемое значение:
//  Структура - информация о соединении:
//    * Соединение                  - COMОбъект, Неопределено - указатель на COM-объект соединения или Неопределено в
//                                    случае ошибки;
//    * КраткоеОписаниеОшибки       - Строка - краткое описание ошибки;
//    * ПодробноеОписаниеОшибки     - Строка - подробное описание ошибки;
//    * ОшибкаПодключенияКомпоненты - Булево - флаг ошибки подключения COM.
//
Функция УстановитьВнешнееСоединениеСБазой(Параметры) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить(""Соединение"");
	Результат.Вставить(""КраткоеОписаниеОшибки"", """");
	Результат.Вставить(""ПодробноеОписаниеОшибки"", """");
	Результат.Вставить(""ОшибкаПодключенияКомпоненты"", Ложь);
	
	#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
		ПодключениеНедоступно = ОбщегоНазначения.ЭтоLinuxСервер();
		КраткоеОписаниеОшибки = НСтр(""ru = 'Прямое подключение к информационной базе недоступно на сервере под управлением ОС Linux.'"");
	#Иначе
		ПодключениеНедоступно = ЭтоLinuxКлиент() Или ЭтоOSXКлиент();
		КраткоеОписаниеОшибки = НСтр(""ru = 'Прямое подключение к информационной базе доступно только на клиенте под управлением ОС Windows.'"");
	#КонецЕсли
	
	Если ПодключениеНедоступно Тогда
		Результат.Соединение = Неопределено;
		Результат.КраткоеОписаниеОшибки = КраткоеОписаниеОшибки;
		Результат.ПодробноеОписаниеОшибки = КраткоеОписаниеОшибки;
		Возврат Результат;
	КонецЕсли;
	
	Попытка
		COMConnector = Новый COMObject(ИмяCOMСоединителя()); // ""V83.COMConnector""
	Исключение
		Информация = ИнформацияОбОшибке();
		СтрокаСообщенияОбОшибке = НСтр(""ru = 'Не удалось подключится к другой программе: %1'"");
		
		Результат.ОшибкаПодключенияКомпоненты = Истина;
		Результат.ПодробноеОписаниеОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, ПодробноеПредставлениеОшибки(Информация));
		Результат.КраткоеОписаниеОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, КраткоеПредставлениеОшибки(Информация));
		
		Возврат Результат;
	КонецПопытки;
	
	ФайловыйВариантРаботы = Параметры.ВариантРаботыИнформационнойБазы = 0;
	
	// Проверка корректности указания параметров.
	ОшибкаПроверкиЗаполнения = Ложь;
	Если ФайловыйВариантРаботы Тогда
		
		Если ПустаяСтрока(Параметры.КаталогИнформационнойБазы) Тогда
			СтрокаСообщенияОбОшибке = НСтр(""ru = 'Не задано месторасположение каталога информационной базы.'"");
			ОшибкаПроверкиЗаполнения = Истина;
		КонецЕсли;
		
	Иначе
		
		Если ПустаяСтрока(Параметры.ИмяСервера1СПредприятия) Или ПустаяСтрока(Параметры.ИмяИнформационнойБазыНаСервере1СПредприятия) Тогда
			СтрокаСообщенияОбОшибке = НСтр(""ru = 'Не заданы обязательные параметры подключения: """"Имя сервера""""; """"Имя информационной базы на сервере"""".'"");
			ОшибкаПроверкиЗаполнения = Истина;
		КонецЕсли;
		
	КонецЕсли;
	
	Если ОшибкаПроверкиЗаполнения Тогда
		
		Результат.ПодробноеОписаниеОшибки = СтрокаСообщенияОбОшибке;
		Результат.КраткоеОписаниеОшибки   = СтрокаСообщенияОбОшибке;
		Возврат Результат;
		
	КонецЕсли;
	
	// Формирование строки соединения.
	ШаблонСтрокиСоединения = ""[СтрокаБазы][СтрокаАутентификации]"";
	
	Если ФайловыйВариантРаботы Тогда
		СтрокаБазы = ""File = """"&КаталогИнформационнойБазы"""""";
		СтрокаБазы = СтрЗаменить(СтрокаБазы, ""&КаталогИнформационнойБазы"", Параметры.КаталогИнформационнойБазы);
	Иначе
		СтрокаБазы = ""Srvr = """"&ИмяСервера1СПредприятия""""; Ref = """"&ИмяИнформационнойБазыНаСервере1СПредприятия"""""";
		СтрокаБазы = СтрЗаменить(СтрокаБазы, ""&ИмяСервера1СПредприятия"",                     Параметры.ИмяСервера1СПредприятия);
		СтрокаБазы = СтрЗаменить(СтрокаБазы, ""&ИмяИнформационнойБазыНаСервере1СПредприятия"", Параметры.ИмяИнформационнойБазыНаСервере1СПредприятия);
	КонецЕсли;
	
	Если Параметры.АутентификацияОперационнойСистемы Тогда
		СтрокаАутентификации = """";
	Иначе
		
		Если СтрНайти(Параметры.ИмяПользователя, """""""") Тогда
			Параметры.ИмяПользователя = СтрЗаменить(Параметры.ИмяПользователя, """""""", """""""""""");
		КонецЕсли;
		
		Если СтрНайти(Параметры.ПарольПользователя, """""""") Тогда
			Параметры.ПарольПользователя = СтрЗаменить(Параметры.ПарольПользователя, """""""", """""""""""");
		КонецЕсли;
		
		СтрокаАутентификации = ""; Usr = """"&ИмяПользователя""""; Pwd = """"&ПарольПользователя"""""";
		СтрокаАутентификации = СтрЗаменить(СтрокаАутентификации, ""&ИмяПользователя"",    Параметры.ИмяПользователя);
		СтрокаАутентификации = СтрЗаменить(СтрокаАутентификации, ""&ПарольПользователя"", Параметры.ПарольПользователя);
	КонецЕсли;
	
	СтрокаСоединения = СтрЗаменить(ШаблонСтрокиСоединения, ""[СтрокаБазы]"", СтрокаБазы);
	СтрокаСоединения = СтрЗаменить(СтрокаСоединения, ""[СтрокаАутентификации]"", СтрокаАутентификации);
	
	Попытка
		Результат.Соединение = COMConnector.Connect(СтрокаСоединения);
	Исключение
		Информация = ИнформацияОбОшибке();
		СтрокаСообщенияОбОшибке = НСтр(""ru = 'Не удалось подключиться к другой программе: %1'"");
		
		Результат.ОшибкаПодключенияКомпоненты = Истина;
		Результат.ПодробноеОписаниеОшибки     = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, ПодробноеПредставлениеОшибки(Информация));
		Результат.КраткоеОписаниеОшибки       = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СтрокаСообщенияОбОшибке, КраткоеПредставлениеОшибки(Информация));
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Получает картинку для вывода на странице с комментарием в зависимости
// от наличия текста в комментарии.
//
// Параметры:
//  Комментарий  - Строка - текст комментария.
//
// Возвращаемое значение:
//  Картинка - Картинка, которая должна отображаться на странице с комментарием.
//
Функция КартинкаКомментария(Комментарий) Экспорт

	Если НЕ ПустаяСтрока(Комментарий) Тогда
		Картинка = БиблиотекаКартинок.Комментарий;
	Иначе
		Картинка = Новый Картинка;
	КонецЕсли;
	
	Возврат Картинка;
	
КонецФункции

// Преобразует локальную дату к формату ""YYYY-MM-DDThh:mm:ssTZD"" согласно ISO 8601.
//
// Параметры:
//  ЛокальнаяДата - Дата - дата в часовом поясе сеанса.
// 
// Возвращаемое значение:
//   Строка - представление даты.
//
Функция ПредставлениеЛокальнойДатыСоСмещением(ЛокальнаяДата) Экспорт
	#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
		Смещение = СмещениеСтандартногоВремени(ЧасовойПоясСеанса());
	#Иначе
		Смещение = СтандартныеПодсистемыКлиент.ПараметрыРаботыКлиента().СмещениеСтандартногоВремени;
	#КонецЕсли
	ПредставлениеСмещения = ""Z"";
	Если Смещение > 0 Тогда
		ПредставлениеСмещения = ""+"";
	ИначеЕсли Смещение < 0 Тогда
		ПредставлениеСмещения = ""-"";
		Смещение = -Смещение;
	КонецЕсли;
	Если Смещение <> 0 Тогда
		ПредставлениеСмещения = ПредставлениеСмещения + Формат('00010101' + Смещение, ""ДФ=HH:mm"");
	КонецЕсли;
	
	Возврат Формат(ЛокальнаяДата, ""ДФ=yyyy-MM-ddTHH:mm:ss; ДП=0001-01-01T00:00:00"") + ПредставлениеСмещения;
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Функции для работы с файлами.
//

// Добавляет к переданному пути каталога конечный символ-разделитель, если он отсутствует.
//
// Параметры:
//  ПутьКаталога - Строка - путь к каталогу.
//  Платформа - ТипПлатформы - параметр устарел, больше не используется.
//
// Возвращаемое значение:
//  Строка - путь к каталогу с конечным символом-разделителем.
//
// Пример:
//  Результат = ДобавитьКонечныйРазделительПути(""C:\Мой каталог""); // возвращает ""C:\Мой каталог\"".
//  Результат = ДобавитьКонечныйРазделительПути(""C:\Мой каталог\""); // возвращает ""C:\Мой каталог\"".
//  Результат = ДобавитьКонечныйРазделительПути(""%APPDATA%""); // возвращает ""%APPDATA%\"".
//
Функция ДобавитьКонечныйРазделительПути(Знач ПутьКаталога, Знач Платформа = Неопределено) Экспорт
	Если ПустаяСтрока(ПутьКаталога) Тогда
		Возврат ПутьКаталога;
	КонецЕсли;
	
	ДобавляемыйСимвол = ПолучитьРазделительПути();
	
	Если СтрЗаканчиваетсяНа(ПутьКаталога, ДобавляемыйСимвол) Тогда
		Возврат ПутьКаталога;
	Иначе 
		Возврат ПутьКаталога + ДобавляемыйСимвол;
	КонецЕсли;
КонецФункции

// Составляет полное имя файла из имени каталога и имени файла.
//
// Параметры:
//  ИмяКаталога  - Строка - путь к каталогу файла на диске.
//  ИмяФайла     - Строка - имя файла, без имени каталога.
//
// Возвращаемое значение:
//   Строка - полное имя файла с учетом каталога.
//
Функция ПолучитьПолноеИмяФайла(Знач ИмяКаталога, Знач ИмяФайла) Экспорт

	Если НЕ ПустаяСтрока(ИмяФайла) Тогда
		
		Слэш = """";
		Если (Прав(ИмяКаталога, 1) <> ""\"") И (Прав(ИмяКаталога, 1) <> ""/"") Тогда
			Слэш = ?(СтрНайти(ИмяКаталога, ""\"") = 0, ""/"", ""\"");
		КонецЕсли;
		
		Возврат ИмяКаталога + Слэш + ИмяФайла;
		
	Иначе
		
		Возврат ИмяКаталога;
		
	КонецЕсли;

КонецФункции

// Раскладывает полное имя файла на составляющие.
//
// Параметры:
//  ПолноеИмяФайла - Строка - полный путь к файлу.
//  ЭтоПапка - Булево - признак того, что требуется разложить полное имя папки, а не файла.
//
// Возвращаемое значение:
//   Структура - имя файла, разложенное на составные части(аналогично свойствам объекта Файл):
//		ПолноеИмя - Содержит полный путь к файлу, т.е. полностью соответствует входному параметру ПолноеИмяФайла.
//		Путь - Содержит путь к каталогу, в котором лежит файл.
//		Имя - Содержит имя файла с расширением, без пути к файлу.
//		Расширение - Содержит расширение файла.
//		ИмяБезРасширения - Содержит имя файла без расширения и без пути к файлу.
//			Пример: если ПолноеИмяФайла = ""c:\temp\test.txt"", то структура заполнится следующим образом:
//				ПолноеИмя: ""c:\temp\test.txt"".
//				Путь: ""c:\temp\""
//				Имя: ""test.txt""
//				Расширение: "".txt""
//				ИмяБезРасширения: ""test"".
//
Функция РазложитьПолноеИмяФайла(Знач ПолноеИмяФайла, ЭтоПапка = Ложь) Экспорт
	
	СтруктураИмениФайла = Новый Структура(""ПолноеИмя,Путь,Имя,Расширение,ИмяБезРасширения"");
	
	// Убираем из полного имени файла завершающий слеш и сохраняем получившееся полное имя в структуре.
	Если ЭтоПапка И (Прав(ПолноеИмяФайла, 1) = ""/"" Или Прав(ПолноеИмяФайла, 1) = ""\"") Тогда
		Если ЭтоПапка Тогда
			ПолноеИмяФайла = Сред(ПолноеИмяФайла, 1, СтрДлина(ПолноеИмяФайла) - 1);
		Иначе
			// Если путь к файлу заканчивается слешем, то у файла нет имени.
			СтруктураИмениФайла.Вставить(""ПолноеИмя"", ПолноеИмяФайла); 
			СтруктураИмениФайла.Вставить(""Путь"", ПолноеИмяФайла); 
			СтруктураИмениФайла.Вставить(""Имя"", """"); 
			СтруктураИмениФайла.Вставить(""Расширение"", """"); 
			СтруктураИмениФайла.Вставить(""ИмяБезРасширения"", """"); 
			Возврат СтруктураИмениФайла;
		КонецЕсли;
	КонецЕсли;
	СтруктураИмениФайла.Вставить(""ПолноеИмя"", ПолноеИмяФайла); 
	
	// Если полное имя файла оказалось пустым, то остальные параметры структуры возвращаем пустыми.
	Если СтрДлина(ПолноеИмяФайла) = 0 Тогда 
		СтруктураИмениФайла.Вставить(""Путь"", """"); 
		СтруктураИмениФайла.Вставить(""Имя"", """"); 
		СтруктураИмениФайла.Вставить(""Расширение"", """"); 
		СтруктураИмениФайла.Вставить(""ИмяБезРасширения"", """"); 
		Возврат СтруктураИмениФайла;
	КонецЕсли;
	
	// Выделяем путь к файлу и имя файла.
	Если СтрНайти(ПолноеИмяФайла, ""/"") > 0 Тогда
		ПозицияРазделителя = СтрНайти(ПолноеИмяФайла, ""/"", НаправлениеПоиска.СКонца);
	ИначеЕсли СтрНайти(ПолноеИмяФайла, ""\"") > 0 Тогда
		ПозицияРазделителя = СтрНайти(ПолноеИмяФайла, ""\"", НаправлениеПоиска.СКонца);
	Иначе
		ПозицияРазделителя = 0;
	КонецЕсли;
	СтруктураИмениФайла.Вставить(""Путь"", Лев(ПолноеИмяФайла, ПозицияРазделителя)); 
	СтруктураИмениФайла.Вставить(""Имя"", Сред(ПолноеИмяФайла, ПозицияРазделителя + 1));
	
	// Папки не имеют расширений, а для файла выделяем расширение.
	Если ЭтоПапка Тогда
		СтруктураИмениФайла.Вставить(""Расширение"", """");
		СтруктураИмениФайла.Вставить(""ИмяБезРасширения"", СтруктураИмениФайла.Имя);
	Иначе
		ПозицияТочки = СтрНайти(СтруктураИмениФайла.Имя, ""."", НаправлениеПоиска.СКонца);
		Если ПозицияТочки = 0 Тогда
			СтруктураИмениФайла.Вставить(""Расширение"", """");
			СтруктураИмениФайла.Вставить(""ИмяБезРасширения"", СтруктураИмениФайла.Имя);
		Иначе
			СтруктураИмениФайла.Вставить(""Расширение"", Сред(СтруктураИмениФайла.Имя, ПозицияТочки));
			СтруктураИмениФайла.Вставить(""ИмяБезРасширения"", Лев(СтруктураИмениФайла.Имя, ПозицияТочки - 1));
		КонецЕсли;
	КонецЕсли;
	
	Возврат СтруктураИмениФайла;
	
КонецФункции

// Разбирает строку URI на составные части и возвращает в виде структуры.
// На основе RFC 3986.
//
// Параметры:
//  СтрокаURI - Строка - ссылка на ресурс в формате:
//                       <схема>://<логин>:<пароль>@<хост>:<порт>/<путь>?<параметры>#<якорь>.
//
// Возвращаемое значение:
//  Структура - составные части URI согласно формату:
//   * Схема         - Строка - схема из URI.
//   * Логин         - Строка - логин из URI.
//   * Пароль        - Строка - пароль из URI.
//   * ИмяСервера    - Строка - часть <хост>:<порт> из URI.
//   * Хост          - Строка - хост из URI.
//   * Порт          - Строка - порт из URI.
//   * ПутьНаСервере - Строка - часть <путь>?<параметры>#<якорь> из URI.
//
Функция СтруктураURI(Знач СтрокаURI) Экспорт
	
	СтрокаURI = СокрЛП(СтрокаURI);
	
	// схема
	Схема = """";
	Позиция = СтрНайти(СтрокаURI, ""://"");
	Если Позиция > 0 Тогда
		Схема = НРег(Лев(СтрокаURI, Позиция - 1));
		СтрокаURI = Сред(СтрокаURI, Позиция + 3);
	КонецЕсли;
	
	// Строка соединения и путь на сервере.
	СтрокаСоединения = СтрокаURI;
	ПутьНаСервере = """";
	Позиция = СтрНайти(СтрокаСоединения, ""/"");
	Если Позиция > 0 Тогда
		ПутьНаСервере = Сред(СтрокаСоединения, Позиция + 1);
		СтрокаСоединения = Лев(СтрокаСоединения, Позиция - 1);
	КонецЕсли;
	
	// Информация пользователя и имя сервера.
	СтрокаАвторизации = """";
	ИмяСервера = СтрокаСоединения;
	Позиция = СтрНайти(СтрокаСоединения, ""@"");
	Если Позиция > 0 Тогда
		СтрокаАвторизации = Лев(СтрокаСоединения, Позиция - 1);
		ИмяСервера = Сред(СтрокаСоединения, Позиция + 1);
	КонецЕсли;
	
	// логин и пароль
	Логин = СтрокаАвторизации;
	Пароль = """";
	Позиция = СтрНайти(СтрокаАвторизации, "":"");
	Если Позиция > 0 Тогда
		Логин = Лев(СтрокаАвторизации, Позиция - 1);
		Пароль = Сред(СтрокаАвторизации, Позиция + 1);
	КонецЕсли;
	
	// хост и порт
	Хост = ИмяСервера;
	Порт = """";
	Позиция = СтрНайти(ИмяСервера, "":"");
	Если Позиция > 0 Тогда
		Хост = Лев(ИмяСервера, Позиция - 1);
		Порт = Сред(ИмяСервера, Позиция + 1);
		Если Не СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке(Порт) Тогда
			Порт = """";
		КонецЕсли;
	КонецЕсли;
	
	Результат = Новый Структура;
	Результат.Вставить(""Схема"", Схема);
	Результат.Вставить(""Логин"", Логин);
	Результат.Вставить(""Пароль"", Пароль);
	Результат.Вставить(""ИмяСервера"", ИмяСервера);
	Результат.Вставить(""Хост"", Хост);
	Результат.Вставить(""Порт"", ?(ПустаяСтрока(Порт), Неопределено, Число(Порт)));
	Результат.Вставить(""ПутьНаСервере"", ПутьНаСервере);
	
	Возврат Результат;
	
КонецФункции

// Функция раскладывает Строку в массив строк, используя ""./\"" как разделитель.
//
// Параметры:
//  Строка - Строка - исходная строка.
//
// Возвращаемое значение:
//  Массив - коллекция фрагментов строки.
//
Функция РазложитьСтрокуПоТочкамИСлэшам(Знач Строка) Экспорт
	
	Перем ТекущаяПозиция;
	
	Фрагменты = Новый Массив;
	
	НачальнаяПозиция = 1;
	
	Для ТекущаяПозиция = 1 По СтрДлина(Строка) Цикл
		ТекущийСимвол = Сред(Строка, ТекущаяПозиция, 1);
		Если ТекущийСимвол = ""."" Или ТекущийСимвол = ""/"" Или ТекущийСимвол = ""\"" Тогда
			ТекущийФрагмент = Сред(Строка, НачальнаяПозиция, ТекущаяПозиция - НачальнаяПозиция);
			НачальнаяПозиция = ТекущаяПозиция + 1;
			Фрагменты.Добавить(ТекущийФрагмент);
		КонецЕсли;
	КонецЦикла;
	
	Если НачальнаяПозиция <> ТекущаяПозиция Тогда
		ТекущийФрагмент = Сред(Строка, НачальнаяПозиция, ТекущаяПозиция - НачальнаяПозиция);
		Фрагменты.Добавить(ТекущийФрагмент);
	КонецЕсли;
	
	Возврат Фрагменты;
	
КонецФункции

// Выделяет из имени файла его расширение (набор символов после последней точки).
//
// Параметры:
//  ИмяФайла - Строка - имя файла с именем каталога или без.
//
// Возвращаемое значение:
//   Строка - расширение файла.
//
Функция ПолучитьРасширениеИмениФайла(Знач ИмяФайла) Экспорт
	
	Расширение = """";
	
	ПозицияСимвола = СтрДлина(ИмяФайла);
	Пока ПозицияСимвола >= 1 Цикл
		
		Если Сред(ИмяФайла, ПозицияСимвола, 1) = ""."" Тогда
			
			Расширение = Сред(ИмяФайла, ПозицияСимвола + 1);
			Прервать;
		КонецЕсли;
		
		ПозицияСимвола = ПозицияСимвола - 1;
	КонецЦикла;

	Возврат Расширение;
	
КонецФункции

// Преобразует расширение файла в нижний регистр без точки.
//
// Параметры:
//  Расширение - Строка - Расширение для преобразования.
//
// Возвращаемое значение:
//  Строка - преобразованное расширение.
//
Функция РасширениеБезТочки(Знач Расширение) Экспорт
	
	Расширение = НРег(СокрЛП(Расширение));
	
	Если Сред(Расширение, 1, 1) = ""."" Тогда
		Расширение = Сред(Расширение, 2);
	КонецЕсли;
	
	Возврат Расширение;
	
КонецФункции

// Возвращает имя файла с расширением.
// Если расширение пустое, тогда точка не добавляется.
//
// Параметры:
//  ИмяБезРасширения - Строка - имя файла без расширения.
//  Расширение       - Строка - расширение.
//
// Возвращаемое значение:
//  Строка - имя файла с расширением.
//
Функция ПолучитьИмяСРасширением(ИмяБезРасширения, Расширение) Экспорт
	
	ИмяСРасширением = ИмяБезРасширения;
	
	Если Расширение <> """" Тогда
		ИмяСРасширением = ИмяСРасширением + ""."" + Расширение;
	КонецЕсли;
	
	Возврат ИмяСРасширением;
	
КонецФункции

// Возвращает строку недопустимых символов.
// Согласно http://en.wikipedia.org/wiki/Filename - в разделе ""Reserved characters and words"".
// Возвращаемое значение:
//   Строка - строка недопустимых символов.
Функция ПолучитьНедопустимыеСимволыВИмениФайла() Экспорт

	НедопустимыеСимволы = """"""/\[]:;|=?*<>"";
	НедопустимыеСимволы = НедопустимыеСимволы + Символы.Таб;
	Возврат НедопустимыеСимволы;

КонецФункции

// Проверяет наличие недопустимых символов в имени файла.
//
// Параметры:
//  ИмяФайла  - Строка - имя файла.
//
// Возвращаемое значение:
//   Массив   - массив обнаруженных в имени файла недопустимых символов.
//              Если недопустимых символов не обнаружено - возвращается пустой массив.
Функция НайтиНедопустимыеСимволыВИмениФайла(ИмяФайла) Экспорт

	НедопустимыеСимволы = ПолучитьНедопустимыеСимволыВИмениФайла();
	
	МассивНайденныхНедопустимыхСимволов = Новый Массив;
	
	Для ПозицияСимвола = 1 По СтрДлина(НедопустимыеСимволы) Цикл
		ПроверяемыйСимвол = Сред(НедопустимыеСимволы,ПозицияСимвола,1);
		Если СтрНайти(ИмяФайла,ПроверяемыйСимвол) <> 0 Тогда
			МассивНайденныхНедопустимыхСимволов.Добавить(ПроверяемыйСимвол);
		КонецЕсли;
	КонецЦикла;
	
	Возврат МассивНайденныхНедопустимыхСимволов;

КонецФункции

// Заменяет недопустимые символы в имени файла.
//
// Параметры:
//  ИмяФайла     - Строка - исходное имя файла.
//  НаЧтоМенять  - Строка - строка, на которую необходимо заменить недопустимые символы.
//
// Возвращаемое значение:
//   Строка - преобразованное имя файла.
//
Функция ЗаменитьНедопустимыеСимволыВИмениФайла(Знач ИмяФайла, НаЧтоМенять = "" "") Экспорт

	Результат = ИмяФайла;
	МассивНайденныхНедопустимыхСимволов = НайтиНедопустимыеСимволыВИмениФайла(Результат);
	Для Каждого НедопустимыйСимвол Из МассивНайденныхНедопустимыхСимволов Цикл
		Результат = СтрЗаменить(Результат, НедопустимыйСимвол, НаЧтоМенять);
	КонецЦикла;
	
	Возврат Результат;

КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Функции для работы с почтовыми адресами.
//

// Разбирает строку с адресами электронной почты. При разборе проверяет корректность адресов.
//
// Параметры:
//  СписокАдресов - Строка - адреса электронной почты, разделитель - запятая, либо точка с запятой:
//                           Получатель1 <Адрес1>, Получатель 2 <Адрес2>... Получатель N <АдресN>.
//
// Возвращаемое значение:
//  Массив - содержит массив структур адресов.
//           Поля структуры:
//             Псевдоним      - Строка - представление адресата.
//             Адрес          - Строка - найденный и соответствующий требованиям почтовый адрес;
//                                       Если текст, похожий на адрес найден, но не соответствует требованиям
//                                       стандартов, то такой текст записывается в поле ""Псевдоним"".
//             ОписаниеОшибки - Строка - текстовое представление ошибки, либо пустая строка, если ошибок нет.
//
Функция АдресаЭлектроннойПочтыИзСтроки(Знач СписокАдресов) Экспорт
	
	Результат = Новый Массив;
	
	// заменяем скобки на пробелы
	СимволыСкобок = ""<>()[]"";
	Строка = ЗаменитьСимволыВСтрокеНаПробелы(СписокАдресов, СимволыСкобок);
	
	// Приводим разделители к одному виду.
	Строка = СтрЗаменить(Строка, "","", "";"");
	
	// Раскладываем mailbox-list на mailbox'ы.
	МассивАдресов = СтрРазделить(Строка, "";"", Ложь);
	
	// Допустимые символы для псевдонима (display-name).
	Буквы = ""abcdefghijklmnopqrstuvwxyzабвгдеёжзийклмнопрстуфхцчшщъыьэюя"";
	Цифры = ""0123456789"";
	ДополнительныеСимволы = ""._- :+"""""";
	
	// Выделяем из строки адреса (mailbox'а) псевдоним (display-name) и адрес (addr-spec).
	Для Каждого СтрокаАдреса Из МассивАдресов Цикл
		Если ПустаяСтрока(СтрокаАдреса) Тогда
			Продолжить;
		КонецЕсли;
		
		Псевдоним = """";
		Адрес = """";
		ОписаниеОшибки = """";
		
		Если СтрЧислоВхождений(СтрокаАдреса, ""@"") <> 1 Тогда
			Псевдоним = СтрокаАдреса;
		Иначе
			// Все, что не подходит в качестве адреса, складываем в псевдоним.
			Для Каждого Подстрока Из СтрРазделить(СтрокаАдреса, "" "", Ложь) Цикл
				Если ПустаяСтрока(Адрес) И АдресЭлектроннойПочтыСоответствуетТребованиям(Подстрока) Тогда
					Адрес = Подстрока;
				Иначе
					Псевдоним = Псевдоним + "" "" + Подстрока;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		Псевдоним = СокрЛП(Псевдоним);
		
		// проверки
		ЕстьНедопустимыеСимволыВПсевдониме = Не СтрокаСодержитТолькоДопустимыеСимволы(НРег(Псевдоним), Буквы + Цифры + ДополнительныеСимволы);
		АдресОпределен = Не ПустаяСтрока(Адрес);
		ЕстьПризнакНаличияАдресаВСтроке = СтрНайти(СтрокаАдреса, ""@"") > 0;
		
		Если АдресОпределен Тогда 
			Если ЕстьНедопустимыеСимволыВПсевдониме Тогда
				ОписаниеОшибки = НСтр(""ru = 'Представление содержит недопустимые символы'"");
			КонецЕсли;
		Иначе
			Если ЕстьПризнакНаличияАдресаВСтроке Тогда 
				ОписаниеОшибки = НСтр(""ru = 'Адрес электронной почты содержит ошибки'"");
			Иначе
				ОписаниеОшибки = НСтр(""ru = 'Строка не содержит адреса электронной почты'"");
			КонецЕсли;
		КонецЕсли;
		
		СтруктураАдреса = Новый Структура(""Псевдоним,Адрес,ОписаниеОшибки"", Псевдоним, Адрес, ОписаниеОшибки);
		Результат.Добавить(СтруктураАдреса);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Проверяет email адрес на соответствие требованиям стандартов RFC 5321, RFC 5322,
// а также RFC 5335, RFC 5336 и RFC 3696.
// Кроме того, функция ограничивает использование спецсимволов.
// 
// Параметры:
//  Адрес - Строка - проверяемый email.
//  РазрешитьЛокальныеАдреса - Булево - не выдавать ошибку в случае отсутствия зоны домена в адресе.
//
// Возвращаемое значение:
//  Булево - Истина, если ошибок нет.
//
Функция АдресЭлектроннойПочтыСоответствуетТребованиям(Знач Адрес, РазрешитьЛокальныеАдреса = Ложь) Экспорт
	
	// Допустимые символы для email.
	Буквы = ""abcdefghijklmnopqrstuvwxyzабвгдеёжзийклмнопрстуфхцчшщъыьэюя"";
	Цифры = ""0123456789"";
	СпецСимволы = "".@_-:+"";
	
	// проверяем символ @
	Если СтрЧислоВхождений(Адрес, ""@"") <> 1 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Разрешаем двоеточие только один раз.
	Если СтрЧислоВхождений(Адрес, "":"") > 1 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// проверяем две точки подряд
	Если СтрНайти(Адрес, "".."") > 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Приводим строку адреса к нижнему регистру.
	Адрес = НРег(Адрес);
	
	// Проверяем допустимые символы.
	Если Не СтрокаСодержитТолькоДопустимыеСимволы(Адрес, Буквы + Цифры + СпецСимволы) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Разбираем адрес на local-part и domain.
	Позиция = СтрНайти(Адрес,""@"");
	ЛокальноеИмя = Лев(Адрес, Позиция - 1);
	Домен = Сред(Адрес, Позиция + 1);
	
	// Проверяем на заполненность и допустимость длины.
	Если ПустаяСтрока(ЛокальноеИмя)
	 	Или ПустаяСтрока(Домен)
		Или СтрДлина(ЛокальноеИмя) > 64
		Или СтрДлина(Домен) > 255 Тогда
		
		Возврат Ложь;
	КонецЕсли;
	
	// Проверяем наличие спецсимволов в начале и в конце домена.
	Если ЕстьСимволыВНачалеВКонце(Домен, СпецСимволы) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// В домене должна быть минимум одна точка.
	Если Не РазрешитьЛокальныеАдреса И СтрНайти(Домен,""."") = 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// В домене не должно быть символа подчеркивания.
	Если СтрНайти(Домен,""_"") > 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// В домене не должно быть символа двоеточие.
	Если СтрНайти(Домен,"":"") > 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// В домене не должно быть символа ""плюс"".
	Если СтрНайти(Домен,""+"") > 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Выделяем зону (TLD) из имени домена.
	Зона = Домен;
	Позиция = СтрНайти(Зона,""."");
	Пока Позиция > 0 Цикл
		Зона = Сред(Зона, Позиция + 1);
		Позиция = СтрНайти(Зона,""."");
	КонецЦикла;
	
	// Проверяем зону домена (минимум 2 символа, только буквы).
	Возврат РазрешитьЛокальныеАдреса Или СтрДлина(Зона) >= 2 И СтрокаСодержитТолькоДопустимыеСимволы(Зона,Буквы);
	
КонецФункции

// Функция проверяет, что введенная строка с e-mail адресами введена правильно.
//
//  Формат строки:
//  Z = ИмяПользователя|[Имя Пользователя] [<]пользователь@почтовый_сервер[>], Строка = Z[<разделитель*>Z].
// 
//   Прим.: разделитель* - имеется ввиду любой разделитель адресов.
//
// Параметры:
//  СтрокаПереданныхАдресов - Строка - правильная строка с почтовыми адресами.
//  ВызыватьИсключение - Булево - необходимо передать Ложь, чтобы в случае неуспешного разбора не выдавалось исключение.
//
// Возвращаемое значение:
//  Структура - результат разбора:
//   * Статус - Булево - успех или неуспех преобразования
//   * Значение - Массив - (параметр доступен, если Статус = Истина) коллекция адресов в виде структур:
//    ** Адрес - Строка - e-mail получателя.
//    ** Представление - Строка - имя получателя.
//   * СообщениеОбОшибке - Строка - (параметр доступен, если Статус = Ложь) информация об ошибке.
//
//  ВАЖНО: Функция возвращает массив структур, в которых одно поле (любое)
//         может быть незаполнено. Может использоваться различными
//         подсистемами для собственного сопоставления имени пользователя
//         некому e-mail адресу. Поэтому, необходимо перед непосредственной
//         отправкой проверить, что поле почтового адреса заполнено.
//
Функция РазобратьСтрокуСПочтовымиАдресами(Знач СтрокаПереданныхАдресов, ВызыватьИсключение = Истина) Экспорт
	
	Результат = Новый Массив;
	
	НедопустимыеСимволы = ""!#$%^&*()`~|\/="";
	
	СообщениеНедопустимыеСимволы = НСтр(""ru = 'Недопустимый символ """"%1"""" в адресе электронной почты """"%2""""'"");
	СообщениеНеверныйФорматПочтовогоАдреса = НСтр(""ru = 'Некорректный адрес электронной почты """"%1""""'"");
	
	СтрокаПереданныхАдресов = СтрЗаменить(СтрокаПереданныхАдресов, "","", "";"");
	МассивПодстрокКОбработке = СтрРазделить(СокрЛП(СтрокаПереданныхАдресов), "";"", Ложь);
	
	Для Каждого СтрокаАдреса Из МассивПодстрокКОбработке Цикл
		
		Индекс = 1;               // Номер обрабатываемого символа.
		Накопитель = """";          // Накопитель символов, после анализа перемещается либо в полное имя
		// либо в почтовый адрес.
		ПолноеИмяАдресата = """";   // Переменная, накапливающая имя адресата.
		ПочтовыйАдрес = """";       // Переменная, накапливающая e-mail адрес
		// 1 - формирование полного имени: ожидаются любые допустимые символы имени адресата
		// 2 - формирование почтового адреса: ожидаются любые допустимые символы email адреса
		// 3 - завершение формирования очередного почтового адреса - ожидаются символы разделители либо пробелы.
		СтадияРазбора = 1; 
		
		Пока Индекс <= СтрДлина(СтрокаАдреса) Цикл
			
			Символ = Сред(СтрокаАдреса, Индекс, 1);
			
			Если      Символ = "" "" Тогда
				Индекс = ? ((ПропуститьПробелы(СтрокаАдреса, Индекс, "" "") - 1) > Индекс,
				ПропуститьПробелы(СтрокаАдреса, Индекс, "" "") - 1,
				Индекс);
				Если      СтадияРазбора = 1 Тогда
					ПолноеИмяАдресата = ПолноеИмяАдресата + Накопитель + "" "";
				ИначеЕсли СтадияРазбора = 2 Тогда
					ПочтовыйАдрес = Накопитель;
					СтадияРазбора = 3;
				КонецЕсли;
				Накопитель = """";
			ИначеЕсли Символ = ""@"" Тогда
				Если      СтадияРазбора = 1 Тогда
					СтадияРазбора = 2;
					
					Для ИндексПоискаНС = 1 По СтрДлина(Накопитель) Цикл
						Если СтрНайти(НедопустимыеСимволы, Сред(Накопитель, ИндексПоискаНС, 1)) > 0 И ВызыватьИсключение Тогда
							ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СообщениеНедопустимыеСимволы,
								Сред(Накопитель, ИндексПоискаНС, 1),СтрокаАдреса);
						КонецЕсли;
					КонецЦикла;
					
					Накопитель = Накопитель + Символ;
				ИначеЕсли СтадияРазбора = 2 И ВызыватьИсключение Тогда
					ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СообщениеНеверныйФорматПочтовогоАдреса,СтрокаАдреса);
				ИначеЕсли СтадияРазбора = 3 И ВызыватьИсключение Тогда
					ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СообщениеНеверныйФорматПочтовогоАдреса,СтрокаАдреса);
				КонецЕсли;
			Иначе
				Если СтадияРазбора = 2 ИЛИ СтадияРазбора = 3 Тогда
					Если СтрНайти(НедопустимыеСимволы, Символ) > 0 И ВызыватьИсключение Тогда
						ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СообщениеНедопустимыеСимволы,Символ,СтрокаАдреса);
					КонецЕсли;
				КонецЕсли;
				
				Накопитель = Накопитель + Символ;
			КонецЕсли;
			
			Индекс = Индекс + 1;
		КонецЦикла;
		
		Если      СтадияРазбора = 1 Тогда
			ПолноеИмяАдресата = ПолноеИмяАдресата + Накопитель;
		ИначеЕсли СтадияРазбора = 2 Тогда
			ПочтовыйАдрес = Накопитель;
		КонецЕсли;
		
		Если ПустаяСтрока(ПочтовыйАдрес) И (Не ПустаяСтрока(ПолноеИмяАдресата)) И ВызыватьИсключение Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СообщениеНеверныйФорматПочтовогоАдреса, ПолноеИмяАдресата);
		ИначеЕсли СтрЧислоВхождений(ПочтовыйАдрес, ""@"") <> 1 И ВызыватьИсключение Тогда 
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(СообщениеНеверныйФорматПочтовогоАдреса,ПочтовыйАдрес);
		КонецЕсли;
		
		Если НЕ (ПустаяСтрока(ПолноеИмяАдресата) И ПустаяСтрока(ПочтовыйАдрес)) Тогда
			Результат.Добавить(ПроверитьИПодготовитьПочтовыйАдрес(ПолноеИмяАдресата, ПочтовыйАдрес));
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Функции для работы с отборами и параметрами динамических списков.
//

// Найти элемент или группу отбора по заданному имени поля или представлению.
//
// Параметры:
//  ОбластьПоиска - ОтборКомпоновкиДанных, КоллекцияЭлементовОтбораКомпоновкиДанных,
//                  ГруппаЭлементовОтбораКомпоновкиДанных - контейнер
//                  с элементами и группами отбора, например Список.Отбор или группа в отборе.
//  ИмяПоля       - Строка - имя поля компоновки (не используется для групп).
//  Представление - Строка - представление поля компоновки.
//
// Возвращаемое значение:
//  Массив - коллекция отборов.
//
Функция НайтиЭлементыИГруппыОтбора(Знач ОбластьПоиска,
									Знач ИмяПоля = Неопределено,
									Знач Представление = Неопределено) Экспорт
	
	Если ЗначениеЗаполнено(ИмяПоля) Тогда
		ЗначениеПоиска = Новый ПолеКомпоновкиДанных(ИмяПоля);
		СпособПоиска = 1;
	Иначе
		СпособПоиска = 2;
		ЗначениеПоиска = Представление;
	КонецЕсли;
	
	МассивЭлементов = Новый Массив;
	
	НайтиРекурсивно(ОбластьПоиска.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);
	
	Возврат МассивЭлементов;
	
КонецФункции

// Добавить группу отбора в коллекцию КоллекцияЭлементов.
//
// Параметры:
//  КоллекцияЭлементов - ОтборКомпоновкиДанных, КоллекцияЭлементовОтбораКомпоновкиДанных,
//                       ГруппаЭлементовОтбораКомпоновкиДанных - контейнер
//                       с элементами и группами отбора, например Список.Отбор или группа в отборе.
//  Представление      - Строка - представление группы.
//  ТипГруппы          - ТипГруппыЭлементовОтбораКомпоновкиДанных - тип группы.
//
// Возвращаемое значение:
//  ГруппаЭлементовОтбораКомпоновкиДанных - группа отбора.
//
Функция СоздатьГруппуЭлементовОтбора(Знач КоллекцияЭлементов, Представление, ТипГруппы) Экспорт
	
	Если ТипЗнч(КоллекцияЭлементов) = Тип(""ГруппаЭлементовОтбораКомпоновкиДанных"") Тогда
		КоллекцияЭлементов = КоллекцияЭлементов.Элементы;
	КонецЕсли;
	
	ГруппаЭлементовОтбора = НайтиЭлементОтбораПоПредставлению(КоллекцияЭлементов, Представление);
	Если ГруппаЭлементовОтбора = Неопределено Тогда
		ГруппаЭлементовОтбора = КоллекцияЭлементов.Добавить(Тип(""ГруппаЭлементовОтбораКомпоновкиДанных""));
	Иначе
		ГруппаЭлементовОтбора.Элементы.Очистить();
	КонецЕсли;
	
	ГруппаЭлементовОтбора.Представление    = Представление;
	ГруппаЭлементовОтбора.Применение       = ТипПримененияОтбораКомпоновкиДанных.Элементы;
	ГруппаЭлементовОтбора.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный;
	ГруппаЭлементовОтбора.ТипГруппы        = ТипГруппы;
	ГруппаЭлементовОтбора.Использование    = Истина;
	
	Возврат ГруппаЭлементовОтбора;
	
КонецФункции

// Добавить элемент компоновки в контейнер элементов компоновки.
//
// Параметры:
//  ОбластьДобавления - КоллекцияЭлементовОтбораКомпоновкиДанных - контейнер с элементами и группами отбора,
//                                                                 например, Список.Отбор или группа в отборе.
//  ИмяПоля                 - Строка - имя поля компоновки данных (заполняется всегда).
//  ПравоеЗначение          - Произвольный - сравниваемое значение.
//  ВидСравнения            - ВидСравненияКомпоновкиДанных - вид сравнения.
//  Представление           - Строка - представление элемента компоновки данных.
//  Использование           - Булево - использование элемента.
//  РежимОтображения        - РежимОтображенияЭлементаНастройкиКомпоновкиДанных - режим отображения.
//  ИдентификаторПользовательскойНастройки - Строка - см. ОтборКомпоновкиДанных.ИдентификаторПользовательскойНастройки
//                                                    в синтакс-помощнике.
// Возвращаемое значение:
//  ЭлементОтбораКомпоновкиДанных - элемент компоновки.
//
Функция ДобавитьЭлементКомпоновки(ОбластьДобавления,
									Знач ИмяПоля,
									Знач ВидСравнения,
									Знач ПравоеЗначение = Неопределено,
									Знач Представление  = Неопределено,
									Знач Использование  = Неопределено,
									знач РежимОтображения = Неопределено,
									знач ИдентификаторПользовательскойНастройки = Неопределено) Экспорт
	
	Элемент = ОбластьДобавления.Элементы.Добавить(Тип(""ЭлементОтбораКомпоновкиДанных""));
	Элемент.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяПоля);
	Элемент.ВидСравнения = ВидСравнения;
	
	Если РежимОтображения = Неопределено Тогда
		Элемент.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный;
	Иначе
		Элемент.РежимОтображения = РежимОтображения;
	КонецЕсли;
	
	Если ПравоеЗначение <> Неопределено Тогда
		Элемент.ПравоеЗначение = ПравоеЗначение;
	КонецЕсли;
	
	Если Представление <> Неопределено Тогда
		Элемент.Представление = Представление;
	КонецЕсли;
	
	Если Использование <> Неопределено Тогда
		Элемент.Использование = Использование;
	КонецЕсли;
	
	// Важно: установка идентификатора должна выполняться
	// в конце настройки элемента, иначе он будет скопирован
	// в пользовательские настройки частично заполненным.
	Если ИдентификаторПользовательскойНастройки <> Неопределено Тогда
		Элемент.ИдентификаторПользовательскойНастройки = ИдентификаторПользовательскойНастройки;
	ИначеЕсли Элемент.РежимОтображения <> РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный Тогда
		Элемент.ИдентификаторПользовательскойНастройки = ИмяПоля;
	КонецЕсли;
	
	Возврат Элемент;
	
КонецФункции

// Изменить элемент отбора с заданным именем поля или представлением.
//
// Параметры:
//  ОбластьПоиска - КоллекцияЭлементовОтбораКомпоновкиДанных - контейнер с элементами и группами отбора,
//                                                             например, Список.Отбор или группа в отборе.
//  ИмяПоля                 - Строка - имя поля компоновки данных (заполняется всегда).
//  Представление           - Строка - представление элемента компоновки данных.
//  ПравоеЗначение          - Произвольный - сравниваемое значение.
//  ВидСравнения            - ВидСравненияКомпоновкиДанных - вид сравнения.
//  Использование           - Булево - использование элемента.
//  РежимОтображения        - РежимОтображенияЭлементаНастройкиКомпоновкиДанных - режим отображения.
//  ИдентификаторПользовательскойНастройки - Строка - см. ОтборКомпоновкиДанных.ИдентификаторПользовательскойНастройки
//                                                    в синтакс-помощнике.
//
// Возвращаемое значение:
//  Число - количество измененных элементов.
//
Функция ИзменитьЭлементыОтбора(ОбластьПоиска,
								Знач ИмяПоля = Неопределено,
								Знач Представление = Неопределено,
								Знач ПравоеЗначение = Неопределено,
								Знач ВидСравнения = Неопределено,
								Знач Использование = Неопределено,
								Знач РежимОтображения = Неопределено,
								Знач ИдентификаторПользовательскойНастройки = Неопределено) Экспорт
	
	Если ЗначениеЗаполнено(ИмяПоля) Тогда
		ЗначениеПоиска = Новый ПолеКомпоновкиДанных(ИмяПоля);
		СпособПоиска = 1;
	Иначе
		СпособПоиска = 2;
		ЗначениеПоиска = Представление;
	КонецЕсли;
	
	МассивЭлементов = Новый Массив;
	
	НайтиРекурсивно(ОбластьПоиска.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);
	
	Для Каждого Элемент Из МассивЭлементов Цикл
		Если ИмяПоля <> Неопределено Тогда
			Элемент.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяПоля);
		КонецЕсли;
		Если Представление <> Неопределено Тогда
			Элемент.Представление = Представление;
		КонецЕсли;
		Если Использование <> Неопределено Тогда
			Элемент.Использование = Использование;
		КонецЕсли;
		Если ВидСравнения <> Неопределено Тогда
			Элемент.ВидСравнения = ВидСравнения;
		КонецЕсли;
		Если ПравоеЗначение <> Неопределено Тогда
			Элемент.ПравоеЗначение = ПравоеЗначение;
		КонецЕсли;
		Если РежимОтображения <> Неопределено Тогда
			Элемент.РежимОтображения = РежимОтображения;
		КонецЕсли;
		Если ИдентификаторПользовательскойНастройки <> Неопределено Тогда
			Элемент.ИдентификаторПользовательскойНастройки = ИдентификаторПользовательскойНастройки;
		КонецЕсли;
	КонецЦикла;
	
	Возврат МассивЭлементов.Количество();
	
КонецФункции

// Удалить элементы отбора с заданным именем поля или представлением.
//
// Параметры:
//  ОбластьУдаления - КоллекцияЭлементовОтбораКомпоновкиДанных - контейнер с элементами и группами отбора,
//                                                               например, Список.Отбор или группа в отборе..
//  ИмяПоля         - Строка - имя поля компоновки (не используется для групп).
//  Представление   - Строка - представление поля компоновки.
//
Процедура УдалитьЭлементыГруппыОтбора(Знач ОбластьУдаления, Знач ИмяПоля = Неопределено, Знач Представление = Неопределено) Экспорт
	
	Если ЗначениеЗаполнено(ИмяПоля) Тогда
		ЗначениеПоиска = Новый ПолеКомпоновкиДанных(ИмяПоля);
		СпособПоиска = 1;
	Иначе
		СпособПоиска = 2;
		ЗначениеПоиска = Представление;
	КонецЕсли;
	
	МассивЭлементов = Новый Массив;
	
	НайтиРекурсивно(ОбластьУдаления.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);
	
	Для Каждого Элемент Из МассивЭлементов Цикл
		Если Элемент.Родитель = Неопределено Тогда
			ОбластьУдаления.Элементы.Удалить(Элемент);
		Иначе
			Элемент.Родитель.Элементы.Удалить(Элемент);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Добавить или заменить существующий элемент отбора.
//
// Параметры:
//  ОбластьПоискаДобавления - КоллекцияЭлементовОтбораКомпоновкиДанных - контейнер с элементами и группами отбора,
//                                     например, Список.Отбор или группа в отборе.
//  ИмяПоля                 - Строка - имя поля компоновки данных (заполняется всегда).
//  ПравоеЗначение          - произвольный - сравниваемое значение.
//  ВидСравнения            - ВидСравненияКомпоновкиДанных - вид сравнения.
//  Представление           - Строка - представление элемента компоновки данных.
//  Использование           - Булево - использование элемента.
//  РежимОтображения        - РежимОтображенияЭлементаНастройкиКомпоновкиДанных - режим отображения.
//  ИдентификаторПользовательскойНастройки - Строка - см. ОтборКомпоновкиДанных.ИдентификаторПользовательскойНастройки
//                                                    в синтакс-помощнике.
//
Процедура УстановитьЭлементОтбора(ОбластьПоискаДобавления,
								Знач ИмяПоля,
								Знач ПравоеЗначение = Неопределено,
								Знач ВидСравнения = Неопределено,
								Знач Представление = Неопределено,
								Знач Использование = Неопределено,
								Знач РежимОтображения = Неопределено,
								Знач ИдентификаторПользовательскойНастройки = Неопределено) Экспорт
	
	ЧислоИзмененных = ИзменитьЭлементыОтбора(ОбластьПоискаДобавления, ИмяПоля, Представление,
							ПравоеЗначение, ВидСравнения, Использование, РежимОтображения, ИдентификаторПользовательскойНастройки);
	
	Если ЧислоИзмененных = 0 Тогда
		Если ВидСравнения = Неопределено Тогда
			Если ТипЗнч(ПравоеЗначение) = Тип(""Массив"")
				Или ТипЗнч(ПравоеЗначение) = Тип(""ФиксированныйМассив"")
				Или ТипЗнч(ПравоеЗначение) = Тип(""СписокЗначений"") Тогда
				ВидСравнения = ВидСравненияКомпоновкиДанных.ВСписке;
			Иначе
				ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
			КонецЕсли;
		КонецЕсли;
		Если РежимОтображения = Неопределено Тогда
			РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный;
		КонецЕсли;
		ДобавитьЭлементКомпоновки(ОбластьПоискаДобавления, ИмяПоля, ВидСравнения,
								ПравоеЗначение, Представление, Использование, РежимОтображения, ИдентификаторПользовательскойНастройки);
	КонецЕсли;
	
КонецПроцедуры

// Добавить или заменить существующий элемент отбора динамического списка.
//
// Параметры:
//   ДинамическийСписок - ДинамическийСписок - Список, в котором требуется установить отбор.
//   ИмяПоля            - Строка - Поле, по которому необходимо установить отбор.
//   ПравоеЗначение     - Произвольный - Значение отбора.
//       Необязательный. Значение по умолчанию: Неопределено.
//       Внимание! Если передать Неопределено, то значение не будет изменено.
//   ВидСравнения  - ВидСравненияКомпоновкиДанных - Условие отбора.
//   Представление - Строка - Представление элемента компоновки данных.
//       Необязательный. Значение по умолчанию: Неопределено.
//       Если указано, то выводится только флажок использования с указанным представлением (значение не выводится).
//       Для очистки (чтобы значение снова выводилось) следует передать пустую строку.
//   Использование - Булево - Флажок использования этого отбора.
//       Необязательный. Значение по умолчанию: Неопределено.
//   РежимОтображения - РежимОтображенияЭлементаНастройкиКомпоновкиДанных - Способ отображения этого отбора
//                                                                          пользователю.
//       * РежимОтображенияЭлементаНастройкиКомпоновкиДанных.БыстрыйДоступ - В группе быстрых настроек над списком.
//       * РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Обычный       - В настройка списка (в подменю Еще).
//       * РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный   - Запретить пользователю менять этот отбор.
//   ИдентификаторПользовательскойНастройки - Строка - Уникальный идентификатор этого отбора.
//       Используется для связи с пользовательскими настройками.
//
Процедура УстановитьЭлементОтбораДинамическогоСписка(ДинамическийСписок, ИмяПоля,
	ПравоеЗначение = Неопределено,
	ВидСравнения = Неопределено,
	Представление = Неопределено,
	Использование = Неопределено,
	РежимОтображения = Неопределено,
	ИдентификаторПользовательскойНастройки = Неопределено) Экспорт
	
	Если РежимОтображения = Неопределено Тогда
		РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный;
	КонецЕсли;
	
	Если РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный Тогда
		ОтборДинамическогоСписка = ДинамическийСписок.КомпоновщикНастроек.ФиксированныеНастройки.Отбор;
	Иначе
		ОтборДинамическогоСписка = ДинамическийСписок.КомпоновщикНастроек.Настройки.Отбор;
	КонецЕсли;
	
	УстановитьЭлементОтбора(
		ОтборДинамическогоСписка,
		ИмяПоля,
		ПравоеЗначение,
		ВидСравнения,
		Представление,
		Использование,
		РежимОтображения,
		ИдентификаторПользовательскойНастройки);
	
КонецПроцедуры

// Удалить элемент группы отбора динамического списка.
//
// Параметры:
//  ДинамическийСписок - ДинамическийСписок - реквизит формы, для которого требуется установить отбор.
//  ИмяПоля         - Строка - имя поля компоновки (не используется для групп).
//  Представление   - Строка - представление поля компоновки.
//
Процедура УдалитьЭлементыГруппыОтбораДинамическогоСписка(ДинамическийСписок, ИмяПоля = Неопределено, Представление = Неопределено) Экспорт
	
	УдалитьЭлементыГруппыОтбора(
		ДинамическийСписок.КомпоновщикНастроек.ФиксированныеНастройки.Отбор,
		ИмяПоля,
		Представление);
	
	УдалитьЭлементыГруппыОтбора(
		ДинамическийСписок.КомпоновщикНастроек.Настройки.Отбор,
		ИмяПоля,
		Представление);
	
КонецПроцедуры

// Установить или обновить значение параметра ИмяПараметра динамического списка Список.
//
// Параметры:
//  Список          - ДинамическийСписок - реквизит формы, для которого требуется установить параметр.
//  ИмяПараметра    - Строка             - имя параметра динамического списка.
//  Значение        - Произвольный        - новое значение параметра.
//  Использование   - Булево             - признак использования параметра.
//
Процедура УстановитьПараметрДинамическогоСписка(Список, ИмяПараметра, Значение, Использование = Истина) Экспорт
	
	ЗначениеПараметраКомпоновкиДанных = Список.Параметры.НайтиЗначениеПараметра(Новый ПараметрКомпоновкиДанных(ИмяПараметра));
	Если ЗначениеПараметраКомпоновкиДанных <> Неопределено Тогда
		Если Использование И ЗначениеПараметраКомпоновкиДанных.Значение <> Значение Тогда
			ЗначениеПараметраКомпоновкиДанных.Значение = Значение;
		КонецЕсли;
		Если ЗначениеПараметраКомпоновкиДанных.Использование <> Использование Тогда
			ЗначениеПараметраКомпоновкиДанных.Использование = Использование;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Функции для работы с управляемыми формами.
//

// Получает значение реквизита формы.
//
// Параметры:
//  Форма - УправляемаяФорма - форма.
//  ПутьРеквизита - Строка - путь к данным реквизита формы, например: ""Объект.МесяцНачисления"".
//
// Возвращаемое значение:
//  Произвольный - реквизит формы.
//
Функция ПолучитьРеквизитФормыПоПути(Форма, ПутьРеквизита) Экспорт
	
	МассивИмен = СтрРазделить(ПутьРеквизита, ""."");
	
	Объект        = Форма;
	ПоследнееПоле = МассивИмен[МассивИмен.Количество()-1];
	
	Для Сч = 0 По МассивИмен.Количество()-2 Цикл
		Объект = Объект[МассивИмен[Сч]]
	КонецЦикла;
	
	Возврат Объект[ПоследнееПоле];
	
КонецФункции

// Устанавливает значение реквизиту формы.
// Параметры:
//  Форма - УправляемаяФорма - форма-владелец реквизита.
//  ПутьРеквизита - Строка - путь к данным, например: ""Объект.МесяцНачисления"".
//  Значение - Произвольный - устанавливаемое значение.
//  ТолькоЕслиНеЗаполнен - Булево - позволяет не устанавливать значение реквизита,
//                                  если у него уже установлено какое-то значение.
Процедура УстановитьРеквизитФормыПоПути(Форма, ПутьРеквизита, Значение, ТолькоЕслиНеЗаполнен = Ложь) Экспорт
	
	МассивИмен = СтрРазделить(ПутьРеквизита, ""."");
	
	Объект        = Форма;
	ПоследнееПоле = МассивИмен[МассивИмен.Количество()-1];
	
	Для Сч = 0 По МассивИмен.Количество()-2 Цикл
		Объект = Объект[МассивИмен[Сч]]
	КонецЦикла;
	Если НЕ ТолькоЕслиНеЗаполнен ИЛИ НЕ ЗначениеЗаполнено(Объект[ПоследнееПоле]) Тогда
		Объект[ПоследнееПоле] = Значение;
	КонецЕсли;
	
КонецПроцедуры

// Выполняет поиск элемента отбора в коллекции по заданному представлению.
//
// Параметры:
//  КоллекцияЭлементов - КоллекцияЭлементовОтбораКомпоновкиДанных - контейнер с элементами и группами отбора,
//                                                                  например, Список.Отбор.Элементы или группа в отборе.
//  Представление - Строка - представление группы.
// 
// Возвращаемое значение:
//  ЭлементОтбораКомпоновкиДанных - элемент отбора.
//
Функция НайтиЭлементОтбораПоПредставлению(КоллекцияЭлементов, Представление) Экспорт
	
	ВозвращаемоеЗначение = Неопределено;
	
	Для каждого ЭлементОтбора Из КоллекцияЭлементов Цикл
		Если ЭлементОтбора.Представление = Представление Тогда
			ВозвращаемоеЗначение = ЭлементОтбора;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ВозвращаемоеЗначение
	
КонецФункции

// Устанавливает свойство ИмяСвойства элемента формы с именем ИмяЭлемента в значение Значение.
// Применяется в тех случаях, когда элемент формы может не быть на форме из-за отсутствия прав у пользователя
// на объект, реквизит объекта или команду.
//
// Параметры:
//  ЭлементыФормы - ВсеЭлементФормы, ЭлементыФормы - коллекция элементов управляемой формы.
//  ИмяЭлемента   - Строка       - имя элемента формы.
//  ИмяСвойства   - Строка       - имя устанавливаемого свойства элемента формы.
//  Значение      - Произвольный - новое значение элемента.
// 
Процедура УстановитьСвойствоЭлементаФормы(ЭлементыФормы, ИмяЭлемента, ИмяСвойства, Значение) Экспорт
	
	ЭлементФормы = ЭлементыФормы.Найти(ИмяЭлемента);
	Если ЭлементФормы <> Неопределено И ЭлементФормы[ИмяСвойства] <> Значение Тогда
		ЭлементФормы[ИмяСвойства] = Значение;
	КонецЕсли;
	
КонецПроцедуры 

// Возвращает значение свойства ИмяСвойства элемента формы с именем ИмяЭлемента.
// Применяется в тех случаях, когда элемент формы может не быть на форме из-за отсутствия прав у пользователя
// на объект, реквизит объекта или команду.
//
// Параметры:
//  ЭлементыФормы - ВсеЭлементФормы, ЭлементыФормы - коллекция элементов управляемой формы.
//  ИмяЭлемента   - Строка       - имя элемента формы.
//  ИмяСвойства   - Строка       - имя свойства элемента формы.
// 
// Возвращаемое значение:
//   Произвольный - значение свойства ИмяСвойства элемента формы ИмяЭлемента.
// 
Функция ЗначениеСвойстваЭлементаФормы(ЭлементыФормы, ИмяЭлемента, ИмяСвойства) Экспорт
	
	ЭлементФормы = ЭлементыФормы.Найти(ИмяЭлемента);
	Возврат ?(ЭлементФормы <> Неопределено, ЭлементФормы[ИмяСвойства], Неопределено);
	
КонецФункции 

////////////////////////////////////////////////////////////////////////////////
// Работа с предопределенными данными.
//

// Получает ссылку предопределенного элемента по его полному имени.
// Предопределенные элементы могут содержаться только в следующих объектах:
//   - Справочники;
//   - Планы видов характеристик;
//   - Планы счетов;
//   - Планы видов расчета.
// После изменения состава предопределенных следует выполнить метод
// ОбновитьПовторноИспользуемыеЗначения(), который сбросит кэш ПовтИсп в текущем сеансе.
//
// Параметры:
//   ПолноеИмяПредопределенного - Строка - Полный путь к предопределенному элементу, включая его имя.
//     Формат аналогичен функции глобального контекста ПредопределенноеЗначение().
//     Например:
//       ""Справочник.ВидыКонтактнойИнформации.EmailПользователя""
//       ""ПланСчетов.Хозрасчетный.Материалы""
//       ""ПланВидовРасчета.Начисления.ОплатаПоОкладу"".
//
// Возвращаемое значение: 
//   ЛюбаяСсылка - ссылка на предопределенный элемент.
//   Неопределено - если предопределенный есть в метаданных, но не создан в ИБ.
//
Функция ПредопределенныйЭлемент(ПолноеИмяПредопределенного) Экспорт
	
	// Используется стандартная функция платформы для получения:
	//  - пустых ссылок; 
	//  - значений перечислений;
	//  - точек маршрута бизнес-процессов.
	Если "".ПУСТАЯССЫЛКА"" = ВРег(Прав(ПолноеИмяПредопределенного, 13))
		Или ""ПЕРЕЧИСЛЕНИЕ."" = ВРег(Лев(ПолноеИмяПредопределенного, 13)) 
		Или ""БИЗНЕСПРОЦЕСС."" = ВРег(Лев(ПолноеИмяПредопределенного, 14)) Тогда
		
		Возврат ПредопределенноеЗначение(ПолноеИмяПредопределенного);
	КонецЕсли;
	
	// Разбор полного имени предопределенного.
	ЧастиПолногоИмени = СтрРазделить(ПолноеИмяПредопределенного, ""."");
	Если ЧастиПолногоИмени.Количество() <> 3 Тогда 
		ВызватьИсключение ТекстОшибкиПредопределенноеЗначениеНеНайдено(ПолноеИмяПредопределенного);
	КонецЕсли;
	
	ПолноеИмяОбъектаМетаданных = ВРег(ЧастиПолногоИмени[0] + ""."" + ЧастиПолногоИмени[1]);
	ИмяПредопределенного = ЧастиПолногоИмени[2];
	
	// В зависимости от контекста выполняется обращение к разному кэшу.
	
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
	ПредопределенныеЗначения = СтандартныеПодсистемыПовтИсп.СсылкиПоИменамПредопределенных(ПолноеИмяОбъектаМетаданных);
#Иначе
	ПредопределенныеЗначения = СтандартныеПодсистемыКлиентПовтИсп.СсылкиПоИменамПредопределенных(ПолноеИмяОбъектаМетаданных);
#КонецЕсли

	// Если ошибка в имени метаданных.
	Если ПредопределенныеЗначения = Неопределено Тогда 
		ВызватьИсключение ТекстОшибкиПредопределенноеЗначениеНеНайдено(ПолноеИмяПредопределенного);
	КонецЕсли;

	// Получение результата из кэша.
	Результат = ПредопределенныеЗначения.Получить(ИмяПредопределенного);
	
	// Если предопределенного нет в метаданных.
	Если Результат = Неопределено Тогда 
		ВызватьИсключение ТекстОшибкиПредопределенноеЗначениеНеНайдено(ПолноеИмяПредопределенного);
	КонецЕсли;
	
	// Если предопределенный есть в метаданных, но не создан в ИБ.
	Если Результат = Null Тогда 
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Прочие функции
//

// Возвращает шаблон структуры параметров для установки внешнего соединения.
// Параметрам необходимо задать требуемые значения и передать.
// В метод ОбщегоНазначения.УстановитьВнешнееСоединение().
//
// Возвращаемое значение:
//  Структура - коллекция параметров.
//
Функция СтруктураПараметровДляУстановкиВнешнегоСоединения() Экспорт
	
	СтруктураПараметров = Новый Структура;
	СтруктураПараметров.Вставить(""ВариантРаботыИнформационнойБазы"", 0);
	СтруктураПараметров.Вставить(""КаталогИнформационнойБазы"", """");
	СтруктураПараметров.Вставить(""ИмяСервера1СПредприятия"", """");
	СтруктураПараметров.Вставить(""ИмяИнформационнойБазыНаСервере1СПредприятия"", """");
	СтруктураПараметров.Вставить(""АутентификацияОперационнойСистемы"", Ложь);
	СтруктураПараметров.Вставить(""ИмяПользователя"", """");
	СтруктураПараметров.Вставить(""ПарольПользователя"", """");
	
	Возврат СтруктураПараметров;
КонецФункции

// Извлекает из строки соединения с информационной базой параметры подключения
// и передает параметры в структуру для установки внешнего соединения.
//
// Параметры:
//  СтрокаСоединения - Строка - строка соединения ИБ.
// 
// Возвращаемое значение:
//  Структура - см. СтруктураПараметровДляУстановкиВнешнегоСоединения.
//
Функция ПолучитьПараметрыПодключенияИзСтрокиСоединенияИнформационнойБазы(Знач СтрокаСоединения) Экспорт
	
	Результат = СтруктураПараметровДляУстановкиВнешнегоСоединения();
	
	Параметры = СтроковыеФункцииКлиентСервер.ПараметрыИзСтроки(СтрокаСоединения);
	
	Параметры.Свойство(""File"", Результат.КаталогИнформационнойБазы);
	Параметры.Свойство(""Srvr"", Результат.ИмяСервера1СПредприятия);
	Параметры.Свойство(""Ref"",  Результат.ИмяИнформационнойБазыНаСервере1СПредприятия);
	
	Результат.ВариантРаботыИнформационнойБазы = ?(Параметры.Свойство(""File""), 0, 1);
	
	Возврат Результат;
КонецФункции

// Для файлового режима работы возвращает полное имя каталога, в котором расположена информационная база.
// Если режим работы клиент-серверный, то возвращается пустая строка.
//
// Возвращаемое значение:
//  Строка - Полное имя каталога, в котором расположена файловая информационная база.
//
Функция КаталогФайловойИнформационнойБазы() Экспорт
	
	ПараметрыСоединения = СтроковыеФункцииКлиентСервер.ПараметрыИзСтроки(СтрокаСоединенияИнформационнойБазы());
	
	Если ПараметрыСоединения.Свойство(""File"") Тогда
		Возврат ПараметрыСоединения.File;
	КонецЕсли;
	
	Возврат """";
КонецФункции

// Получает идентификатор (метод ПолучитьИдентификатор()) строки дерева значений для заданного значения поля строки
// дерева.
// Используется для позиционирования курсора в иерархических списках.
//
// Параметры:
//  ИмяПоля - Строка - Имя колонки дерева значений, по которому выполняется поиск.
//  ИдентификаторСтроки - Число - полученный в результате поиска идентификатор строки дерева значений.
//  КоллекцияЭлементовДерева - ДанныеФормыКоллекцияЭлементовДерева - коллекция, в которой следует выполнять поиск.
//  КлючСтроки - Произвольный - искомое значение поля.
//  ПрекратитьПоиск - Булево - признак прекращения поиска.
// 
Процедура ПолучитьИдентификаторСтрокиДереваПоЗначениюПоля(ИмяПоля, ИдентификаторСтроки, КоллекцияЭлементовДерева, КлючСтроки, ПрекратитьПоиск) Экспорт
	
	Для Каждого СтрокаДерева Из КоллекцияЭлементовДерева Цикл
		
		Если ПрекратитьПоиск Тогда
			Возврат;
		КонецЕсли;
		
		Если СтрокаДерева[ИмяПоля] = КлючСтроки Тогда
			
			ИдентификаторСтроки = СтрокаДерева.ПолучитьИдентификатор();
			
			ПрекратитьПоиск = Истина;
			
			Возврат;
			
		КонецЕсли;
		
		КоллекцияЭлементов = СтрокаДерева.ПолучитьЭлементы();
		
		Если КоллекцияЭлементов.Количество() > 0 Тогда
			
			ПолучитьИдентификаторСтрокиДереваПоЗначениюПоля(ИмяПоля, ИдентификаторСтроки, КоллекцияЭлементов, КлючСтроки, ПрекратитьПоиск);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Заменяет недопустимые символы в XML-строке на заданные символы.
//
// Параметры:
//   Текст - Строка - строка, в которой требуется выполнить замену недопустимых символов.
//   СимволЗамены - Строка - строка, на которую требуется выполнить замену недопустимого символа в XML-строке.
// 
// Возвращаемое значение:
//    Строка - строка, полученная заменой недопустимых символов в XML-строке.
//
Функция ЗаменитьНедопустимыеСимволыXML(Знач Текст, СимволЗамены = "" "") Экспорт
	
#Если НЕ ВебКлиент Тогда
	ПозицияНачала = 1;
	Позиция = НайтиНедопустимыеСимволыXML(Текст, ПозицияНачала);
	Пока Позиция > 0 Цикл
		НедопустимыйСимвол = Сред(Текст, Позиция, 1);
		Текст = СтрЗаменить(Текст, НедопустимыйСимвол, СимволЗамены);
		ПозицияНачала = Позиция + СтрДлина(СимволЗамены);
		Если ПозицияНачала > СтрДлина(Текст) Тогда
			Прервать;
		КонецЕсли;
		Позиция = НайтиНедопустимыеСимволыXML(Текст, ПозицияНачала);
	КонецЦикла;
	
	Возврат Текст;
#Иначе
	// Коды символов от 0 до 2^16-1, которые метод НайтиНедопустимыеСимволыXML
	// считает недопустимыми: 0-8, 11-12, 14-31, 55296-57343.
	Итог = """";
	ДлинаСтроки = СтрДлина(Текст);
	
	Для НомерСимвола = 1 По ДлинаСтроки Цикл
		Символ = Сред(Текст, НомерСимвола, 1);
		КодСимвола = КодСимвола(Символ);
		
		Если КодСимвола < 9
		 Или КодСимвола > 10    И КодСимвола < 13
		 Или КодСимвола > 13    И КодСимвола < 32
		 Или КодСимвола > 55295 И КодСимвола < 57344 Тогда
			
			Символ = СимволЗамены;
		КонецЕсли;
		Итог = Итог + Символ;
	КонецЦикла;
	
	Возврат Итог;
#КонецЕсли
	
КонецФункции

// Удаляет недопустимые символы в XML-строке.
//
// Параметры:
//  Текст - Строка - строка, в которой требуется удалить недопустимые символы.
// 
// Возвращаемое значение:
//  Строка - Строка, полученная при удалении недопустимых символов в XML-строке.
//
Функция УдалитьНедопустимыеСимволыXML(Знач Текст) Экспорт
	
	Возврат ЗаменитьНедопустимыеСимволыXML(Текст, """");
	
КонецФункции

// Сравнивает два расписания между собой.
//
// Параметры:
//	Расписание1 - РасписаниеРегламентногоЗадания - первое расписание.
//  Расписание2 - РасписаниеРегламентногоЗадания - второе расписание.
//
// Возвращаемое значение:
//  Булево - Истина, если одинаковые.
//
Функция РасписанияОдинаковые(Знач Расписание1, Знач Расписание2) Экспорт
	
	Возврат Строка(Расписание1) = Строка(Расписание2);
	
КонецФункции

// Возвращает код основного языка конфигурации, например ""ru"".
//
// Возвращаемое значение:
//  Строка - код языка.
//
Функция КодОсновногоЯзыка() Экспорт
	#Если НЕ ТонкийКлиент И НЕ ВебКлиент И НЕ МобильныйКлиент Тогда
		Возврат Метаданные.ОсновнойЯзык.КодЯзыка;
	#Иначе
		Возврат СтандартныеПодсистемыКлиент.ПараметрКлиента(""КодОсновногоЯзыка"");
	#КонецЕсли
КонецФункции

// Возвращает Истина, если клиентское приложение подключено к базе через веб-сервер.
// Если нет клиентского приложения, возвращается Ложь.
//
// Возвращаемое значение:
//  Булево - Истина, если подключен.
//
Функция КлиентПодключенЧерезВебСервер() Экспорт
	
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Тогда
	УстановитьПривилегированныйРежим(Истина);
	
	СтрокаСоединенияИнформационнойБазы = СтандартныеПодсистемыСервер.ПараметрыКлиентаНаСервере().Получить(""СтрокаСоединенияИнформационнойБазы"");
	
	Если СтрокаСоединенияИнформационнойБазы = Неопределено Тогда
		Возврат Ложь; // Нет клиентского приложения.
	КонецЕсли;
#Иначе
	СтрокаСоединенияИнформационнойБазы = СтрокаСоединенияИнформационнойБазы();
#КонецЕсли
	
	Возврат СтрНайти(ВРег(СтрокаСоединенияИнформационнойБазы), ""WS="") = 1;
	
КонецФункции

// Возвращает Истина, если клиентское приложение запущено под управлением ОС Windows.
//
// Возвращаемое значение:
//  Булево - если нет клиентского приложения, возвращается Ложь.
//
Функция ЭтоWindowsКлиент() Экспорт
	
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Тогда
	УстановитьПривилегированныйРежим(Истина);
	
	ЭтоWindowsКлиент = СтандартныеПодсистемыСервер.ПараметрыКлиентаНаСервере().Получить(""ЭтоWindowsКлиент"");
	
	Если ЭтоWindowsКлиент = Неопределено Тогда
		Возврат Ложь; // Нет клиентского приложения.
	КонецЕсли;
#Иначе
	СистемнаяИнформация = Новый СистемнаяИнформация;
	
	ЭтоWindowsКлиент = СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86
	             ИЛИ СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86_64;
#КонецЕсли
	
	Возврат ЭтоWindowsКлиент;
	
КонецФункции

// Возвращает Истина, если клиентское приложение запущено под управлением ОС X.
//
// Возвращаемое значение:
//  Булево - если нет клиентского приложения, возвращается Ложь.
//
Функция ЭтоOSXКлиент() Экспорт
	
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Тогда
	УстановитьПривилегированныйРежим(Истина);
	
	ЭтоOSXКлиент = СтандартныеПодсистемыСервер.ПараметрыКлиентаНаСервере().Получить(""ЭтоOSXКлиент"");
	
	Если ЭтоOSXКлиент = Неопределено Тогда
		Возврат Ложь; // Нет клиентского приложения.
	КонецЕсли;
#Иначе
	СистемнаяИнформация = Новый СистемнаяИнформация;
	
	ЭтоOSXКлиент = СистемнаяИнформация.ТипПлатформы = ТипПлатформы.MacOS_x86
	             ИЛИ СистемнаяИнформация.ТипПлатформы = ТипПлатформы.MacOS_x86_64;
#КонецЕсли
	
	Возврат ЭтоOSXКлиент;
	
КонецФункции

// Возвращает Истина, если клиентское приложение запущено под управлением ОС Linux.
//
// Возвращаемое значение:
//  Булево - если нет клиентского приложения, возвращается Ложь.
//
Функция ЭтоLinuxКлиент() Экспорт
	
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Тогда
	УстановитьПривилегированныйРежим(Истина);
	
	ЭтоLinuxКлиент = СтандартныеПодсистемыСервер.ПараметрыКлиентаНаСервере().Получить(""ЭтоLinuxКлиент"");
	
	Если ЭтоLinuxКлиент = Неопределено Тогда
		Возврат Ложь; // Нет клиентского приложения.
	КонецЕсли;
#Иначе
	СистемнаяИнформация = Новый СистемнаяИнформация;
	
	ЭтоLinuxКлиент = СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Linux_x86
	             ИЛИ СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Linux_x86_64;
#КонецЕсли
	
	Возврат ЭтоLinuxКлиент;
	
КонецФункции

// Возвращает Истина, если клиентское приложение является Веб-клиентом.
//
// Возвращаемое значение:
//  Булево - если нет клиентского приложения, возвращается Ложь.
//
Функция ЭтоВебКлиент() Экспорт
	
#Если ВебКлиент Тогда
	Возврат Истина;
#ИначеЕсли Сервер Или ТолстыйКлиентОбычноеПриложение Тогда
	УстановитьПривилегированныйРежим(Истина);
	
	ЭтоВебКлиент = СтандартныеПодсистемыСервер.ПараметрыКлиентаНаСервере().Получить(""ЭтоВебКлиент"");
	
	Если ЭтоВебКлиент = Неопределено Тогда
		Возврат Ложь; // Нет клиентского приложения.
	КонецЕсли;
	
	Возврат ЭтоВебКлиент;
#Иначе
	Возврат Ложь;
#КонецЕсли
	
КонецФункции

// Возвращает Истина, если это веб клиент в Mac OS.
//
// Возвращаемое значение:
//  Булево - Истина, если сеанс запущен под веб-клиентом и в Mac OS.
//
Функция ЭтоВебКлиентПодMacOS() Экспорт
	
#Если ВебКлиент Тогда
	Возврат ОбщегоНазначенияКлиентПовтИсп.ЭтоВебКлиентПодMacOS();
#ИначеЕсли Сервер Или ТолстыйКлиентОбычноеПриложение Тогда
	УстановитьПривилегированныйРежим(Истина);
	
	ЭтоВебКлиентПодMacOS = СтандартныеПодсистемыСервер.ПараметрыКлиентаНаСервере().Получить(""ЭтоВебКлиентПодMacOS"");
	
	Если ЭтоВебКлиентПодMacOS = Неопределено Тогда
		Возврат Ложь; // Нет клиентского приложения.
	КонецЕсли;
	
	Возврат ЭтоВебКлиентПодMacOS;
#Иначе
	Возврат Ложь;
#КонецЕсли
	
КонецФункции

// Возвращает Истина, если клиентское приложение является мобильным клиентом.
//
// Возвращаемое значение:
//  Булево - если нет клиентского приложения, возвращается Ложь.
//
Функция ЭтоМобильныйКлиент() Экспорт
	
#Если МобильныйКлиент Тогда
	Возврат Истина;
#ИначеЕсли Сервер Или ТолстыйКлиентОбычноеПриложение Тогда
	УстановитьПривилегированныйРежим(Истина);
	
	ЭтоМобильныйКлиент = СтандартныеПодсистемыСервер.ПараметрыКлиентаНаСервере().Получить(""ЭтоМобильныйКлиент"");
	
	Если ЭтоМобильныйКлиент = Неопределено Тогда
		Возврат Ложь; // Нет клиентского приложения.
	КонецЕсли;
	
	Возврат ЭтоМобильныйКлиент;
#Иначе
	Возврат Ложь;
#КонецЕсли
	
КонецФункции

// Возвращает объем оперативной памяти, доступной клиентскому  приложению.
//
// Возвращаемое значение:
//  Число - количество гигабайт оперативной памяти с точностью до десятых долей.
//  Неопределено - нет клиентского приложения, то есть ТекущийРежимЗапуска() = Неопределено.
//
Функция ОперативнаяПамятьДоступнаяКлиентскомуПриложению() Экспорт
	
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или  ВнешнееСоединение Тогда
	УстановитьПривилегированныйРежим(Истина);
	ДоступныйОбъем = ПараметрыСеанса.ПараметрыКлиентаНаСервере.Получить(""ОперативнаяПамять"");
#Иначе
	СистемнаяИнформация = Новый  СистемнаяИнформация;
	ДоступныйОбъем = Окр(СистемнаяИнформация.ОперативнаяПамять / 1024,  1);
#КонецЕсли
	
	Возврат ДоступныйОбъем;
	
КонецФункции

// Возвращает Истина, если включен режим отладки.
//
// Возвращаемое значение:
//  Булево - Истина, если включен режим отладки.
Функция РежимОтладки() Экспорт
	
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
	ПараметрЗапускаПриложения = ПараметрыСеанса.ПараметрыКлиентаНаСервере.Получить(""ПараметрЗапуска"");
#Иначе
	ПараметрЗапускаПриложения = ПараметрЗапуска;
#КонецЕсли
	
	Возврат СтрНайти(ПараметрЗапускаПриложения, ""РежимОтладки"") > 0;
КонецФункции

// Вызывает исключение с текстом Сообщение, если Условие не равно Истина.
// Применяется для самодиагностики кода.
//
// Параметры:
//   Условие                - Булево - если не равно Истина, то вызывается исключение.
//   КонтекстПроверки       - Строка - например, имя процедуры или функции, в которой выполняется проверка.
//   Сообщение              - Строка - текст сообщения. Если не задан, то исключение вызывается с сообщением по
//                                     умолчанию.
//
Процедура Проверить(Знач Условие, Знач Сообщение = """", Знач КонтекстПроверки = """") Экспорт
	
	Если Условие <> Истина Тогда
		Если ПустаяСтрока(Сообщение) Тогда
			ТекстИсключения = НСтр(""ru = 'Недопустимая операция'""); // Assertion failed
		Иначе
			ТекстИсключения = Сообщение;
		КонецЕсли;
		Если Не ПустаяСтрока(КонтекстПроверки) Тогда
			ТекстИсключения = ТекстИсключения + "" "" + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр(""ru = 'в %1'""), КонтекстПроверки);
		КонецЕсли;
		ВызватьИсключение ТекстИсключения;
	КонецЕсли;
	
КонецПроцедуры

// Вызывает исключение, если тип значения параметра ИмяПараметра процедуры или функции ИмяПроцедурыИлиФункции
// отличается от ожидаемого.
// Для быстрой диагностики типов параметров, передаваемых в процедуры и функции программного интерфейса.
//
// Параметры:
//   ИмяПроцедурыИлиФункции - Строка             - имя процедуры или функции, параметр которой проверяется.
//   ИмяПараметра           - Строка             - имя проверяемого параметра процедуры или функции.
//   ЗначениеПараметра      - Произвольный       - фактическое значение параметра.
//   ОжидаемыеТипы  - ОписаниеТипов, Тип, Массив - тип(ы) параметра процедуры или функции.
//   ОжидаемыеТипыСвойств   - Структура          - если ожидаемый тип - структура, то 
//                                                 в этом параметре можно указать типы ее свойств.
//
Процедура ПроверитьПараметр(Знач ИмяПроцедурыИлиФункции, Знач ИмяПараметра, Знач ЗначениеПараметра, 
	Знач ОжидаемыеТипы, Знач ОжидаемыеТипыСвойств = Неопределено) Экспорт
	
	Контекст = ""ОбщегоНазначенияКлиентСервер.ПроверитьПараметр"";
	Проверить(ТипЗнч(ИмяПроцедурыИлиФункции) = Тип(""Строка""), 
		НСтр(""ru = 'Недопустимое значение параметра ИмяПроцедурыИлиФункции'""), Контекст);
	Проверить(ТипЗнч(ИмяПараметра) = Тип(""Строка""), 
		НСтр(""ru = 'Недопустимое значение параметра ИмяПараметра'""), Контекст);
		
	ЭтоКорректныйТип = ЗначениеОжидаемогоТипа(ЗначениеПараметра, ОжидаемыеТипы);
	Проверить(ЭтоКорректныйТип <> Неопределено, 
		НСтр(""ru = 'Недопустимое значение параметра ОжидаемыеТипы'""), Контекст);
		
	НедопустимыйПараметр = НСтр(""ru = 'Недопустимое значение параметра %1 в %2. 
		|Ожидалось: %3; передано значение: %4 (тип %5).'"");
	Проверить(ЭтоКорректныйТип, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НедопустимыйПараметр,
		ИмяПараметра,
		ИмяПроцедурыИлиФункции,
		ПредставлениеТипов(ОжидаемыеТипы), 
		?(ЗначениеПараметра <> Неопределено, ЗначениеПараметра, НСтр(""ru = 'Неопределено'"")),
		ТипЗнч(ЗначениеПараметра)));
			
	Если ТипЗнч(ЗначениеПараметра) = Тип(""Структура"") И ОжидаемыеТипыСвойств <> Неопределено Тогда
		
		Проверить(ТипЗнч(ОжидаемыеТипыСвойств) = Тип(""Структура""), 
			НСтр(""ru = 'Недопустимое значение параметра ИмяПроцедурыИлиФункции'""), Контекст);
			
		НетСвойства = НСтр(""ru = 'Недопустимое значение параметра %1 (Структура) в %2. 
			|В структуре ожидалось свойство %3 (тип %4).'"");
		НедопустимоеСвойство = НСтр(""ru = 'Недопустимое значение свойства %1 в параметре %2 (Структура) в %3. 
			|Ожидалось: %4; передано значение: %5 (тип %6).'"");
		Для каждого Свойство Из ОжидаемыеТипыСвойств Цикл
			
			ОжидаемоеИмяСвойства = Свойство.Ключ;
			ОжидаемыйТипСвойства = Свойство.Значение;
			ЗначениеСвойства = Неопределено;
			
			Проверить(ЗначениеПараметра.Свойство(ОжидаемоеИмяСвойства, ЗначениеСвойства), 
				СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НетСвойства, ИмяПараметра, ИмяПроцедурыИлиФункции, 
					ОжидаемоеИмяСвойства, ОжидаемыйТипСвойства));
				
			ЭтоКорректныйТип = ЗначениеОжидаемогоТипа(ЗначениеСвойства, ОжидаемыйТипСвойства);
			Проверить(ЭтоКорректныйТип, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НедопустимоеСвойство, 
				ОжидаемоеИмяСвойства,
				ИмяПараметра,
				ИмяПроцедурыИлиФункции,
				ПредставлениеТипов(ОжидаемыеТипы), 
				?(ЗначениеСвойства <> Неопределено, ЗначениеСвойства, НСтр(""ru = 'Неопределено'"")),
				ТипЗнч(ЗначениеСвойства)));
		КонецЦикла;
	КонецЕсли;		
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Математические процедуры и функции.

// Выполняет пропорциональное распределение суммы в соответствии
// с заданными коэффициентами распределения.
//
// Параметры:
//  РаспределяемаяСумма - Число  - сумма, которую надо распределить, если сумма равна 0 - то возвращается Неопределено;
//                                 Если передана отрицательная - расчет по модулю и после инверсия знаков результата.
//  Коэффициенты        - Массив - коэффициенты распределения, должны быть положительны или отрицательными одновременно
//  Точность            - Число  - точность округления при распределении. Необязателен.
//
// Возвращаемое значение:
//  Массив - массив размерностью равный массиву коэффициентов, содержит
//           суммы в соответствии с весом коэффициента (из массива коэффициентов).
//           В случае, если распределить невозможно (кол-во коэффициентов = 0,
//           есть коэффициенты с отрицательным значением или суммарный вес коэффициентов = 0),
//           тогда будет возвращено Неопределено.
//
// Пример:
//
//	Коэффициенты = Новый Массив;
//	Коэффициенты.Добавить(1);
//	Коэффициенты.Добавить(2);
//	Результат = ОбщегоНазначенияКлиентСервер.РаспределитьСуммуПропорциональноКоэффициентам(1, Коэффициенты);
//	// Результат = [0.33, 0.67]
//
Функция РаспределитьСуммуПропорциональноКоэффициентам(Знач РаспределяемаяСумма, Знач Коэффициенты, Знач Точность = 2) Экспорт
	
	КоэффициентыАбсолютные = Новый Массив(Новый ФиксированныйМассив(Коэффициенты)); // cpy
	
	// Старое поведение при неуказанной сумме - для обратной совместимости.
	Если Не ЗначениеЗаполнено(РаспределяемаяСумма) Тогда 
		Возврат Неопределено;
	КонецЕсли;
	
	Если КоэффициентыАбсолютные.Количество() = 0 Тогда 
		// Недопустимо значение параметра Коэффициенты
		// Ожидалось: хотя бы один коэффициент будет задан.
		Возврат Неопределено;
	КонецЕсли;
	
	ИндексМаксимальногоКоэффициента = 0;
	МаксимальныйКоэффициент = 0;
	СуммаКоэффициентов = 0;
	КоэффициентыОтрицательны = (КоэффициентыАбсолютные[0] < 0);
	
	Для Индекс = 0 По КоэффициентыАбсолютные.Количество() - 1 Цикл
		Коэффициент = КоэффициентыАбсолютные[Индекс];
		
		Если КоэффициентыОтрицательны И Коэффициент > 0 Тогда 
			// Недопустимо значение параметра Коэффициенты
			// Ожидалось: все коэффициенты положительны или все отрицательны одновременно.
			Возврат Неопределено;
		КонецЕсли;
		
		Если Коэффициент < 0 Тогда 
			Коэффициент = -Коэффициент; // Abs(Коэффициент)
			КоэффициентыАбсолютные[Индекс] = Коэффициент; // move
		КонецЕсли;
		
		Если МаксимальныйКоэффициент < Коэффициент Тогда
			МаксимальныйКоэффициент = Коэффициент;
			ИндексМаксимальногоКоэффициента = Индекс;
		КонецЕсли;
		
		СуммаКоэффициентов = СуммаКоэффициентов + Коэффициент;
	КонецЦикла;
	
	Если СуммаКоэффициентов = 0 Тогда
		// Недопустимо значение параметра Коэффициенты
		// Ожидалось: хотя бы один коэффициент будет отличен от нуля.
		Возврат Неопределено;
	КонецЕсли;
	
	Результат = Новый Массив(КоэффициентыАбсолютные.Количество());
	
	ВыполнятьИнверсию = (РаспределяемаяСумма < 0);
	Если ВыполнятьИнверсию Тогда 
		РаспределяемаяСумма = -РаспределяемаяСумма; // Abs(РаспределяемаяСумма).
	КонецЕсли;
	
	РаспределеннаяСумма = 0;
	
	Для Индекс = 0 По КоэффициентыАбсолютные.Количество() - 1 Цикл
		Результат[Индекс] = Окр(РаспределяемаяСумма * КоэффициентыАбсолютные[Индекс] / СуммаКоэффициентов, Точность, 1);
		РаспределеннаяСумма = РаспределеннаяСумма + Результат[Индекс];
	КонецЦикла;
	
	СуммарнаяПогрешность = РаспределяемаяСумма - РаспределеннаяСумма;
	
	Если СуммарнаяПогрешность > 0 Тогда 
		
		// Погрешности округления отнесем на коэффициент с максимальным весом.
		Если Не РаспределеннаяСумма = РаспределяемаяСумма Тогда
			Результат[ИндексМаксимальногоКоэффициента] = Результат[ИндексМаксимальногоКоэффициента] + СуммарнаяПогрешность;
		КонецЕсли;
		
	ИначеЕсли СуммарнаяПогрешность < 0 Тогда 
		
		// Если распределили больше чем положено, размазываем погрешность по ближайшим максимальным весам.
		ЗначениеПогрешности = 1 / Pow(10, Точность);
		КоличествоЭлементовПогрешности = -СуммарнаяПогрешность / ЗначениеПогрешности;
		
		Для Сч = 1 По КоличествоЭлементовПогрешности Цикл 
			МаксимальныйКоэффициент = МаксимальноеЗначениеВМассиве(КоэффициентыАбсолютные);
			Индекс = КоэффициентыАбсолютные.Найти(МаксимальныйКоэффициент);
			Результат[Индекс] = Результат[Индекс] - ЗначениеПогрешности;
			КоэффициентыАбсолютные[Индекс] = 0;
		КонецЦикла;
		
	Иначе 
		// Если СуммарнаяПогрешность = 0, то все идеально.
	КонецЕсли;
	
	Если ВыполнятьИнверсию Тогда 
		Для Индекс = 0 По КоэффициентыАбсолютные.Количество() - 1 Цикл
			Результат[Индекс] = -Результат[Индекс];
		КонецЦикла;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы с внешними приложениями.

// Возвращает структуру параметров для см. процедуру ЗапуститьПрограмму.
//
// Возвращаемое значение:
//  ТекущийКаталог - Строка - Задает текущий каталог запускаемого приложения.
//  ДождатьсяЗавершения - Булево - Истина - дожидаться завершения запущенного приложения 
//      перед продолжением работы.
//  ПолучитьПотокВывода - Булево - Истина - результат, направленный в поток stdout,
//      если не указан ДождатьсяЗавершения - игнорируется.
//  ПолучитьПотокОшибок - Булево - Истина - ошибки, направленные в поток stderr,
//      если не указан ДождатьсяЗавершения - игнорируется.
//  ВыполнитьСНаивысшимиПравами - Булево - Истина - требуется запустить программу на исполнение 
//      с повышением привилегий системы:
//      - подтверждение UAC для Windows;
//      - интерактивным запросом c GUI sudo и перенаправлением
//      $DISPLAY и $XAUTHORITY текущего пользователя для Linux;
//      Не совместим с параметром ДождатьсяЗавершения. В MacOS игнорируется.
//  Кодировка - Строка - Код кодировки, устанавливаемый до выполнения пакетной операции.
//      В Linux и macOS игнорируется.
//
Функция ПараметрыЗапускаПрограммы() Экспорт
	
	Параметры = Новый Структура;
	Параметры.Вставить(""ТекущийКаталог"", """");
	Параметры.Вставить(""ДождатьсяЗавершения"", Ложь);
	Параметры.Вставить(""ПолучитьПотокВывода"", Ложь);
	Параметры.Вставить(""ПолучитьПотокОшибок"", Ложь);
	Параметры.Вставить(""ВыполнитьСНаивысшимиПравами"", Ложь); // RunWithElevatedPermissions.
	Параметры.Вставить(""Кодировка"", """");
	
	Возврат Параметры;
	
КонецФункции

// Запускает внешнюю программу в соответствии с параметрами запуска.
// Не доступно в веб-клиенте. 
//
// Параметры:
//  КомандаЗапуска - Строка, Массив - Командная строка для запуска программы.
//      Если Массив, то: первый элемент массива - путь к исполняемому приложению, остальные - передаваемые параметры,
//      массив соответствует тому, который получит вызываемая программа в argv.
//  ПараметрыЗапускаПрограммы - Структура - см. функцию ПараметрыЗапускаПрограммы.
//
// Возвращаемое значение:
//  Структура - Результат работы программы.
//      КодВозврата - Число  - код возврата программы.
//      ПотокВывода - Строка - результат работы программы, направленный в поток stdout.
//      ПотокОшибок - Строка - ошибки исполнения программы, направленные в поток stderr.
//
// Пример:
//	ОбщегоНазначенияКлиентСервер.ЗапуститьПрограмму(""calc"");
//	
//	ПараметрыЗапускаПрограммы = ОбщегоНазначенияКлиентСервер.ПараметрыЗапускаПрограммы();
//	ПараметрыЗапускаПрограммы.ВыполнитьСНаивысшимиПравами = Истина;
//	ОбщегоНазначенияКлиентСервер.ЗапуститьПрограмму(""C:\Program Files\1cv8\common\1cestart.exe"", 
//		ПараметрыЗапускаПрограммы);
//	
//	ПараметрыЗапускаПрограммы = ОбщегоНазначенияКлиентСервер.ПараметрыЗапускаПрограммы();
//	ПараметрыЗапускаПрограммы.ДождатьсяЗавершения = Истина;
//	Результат = ОбщегоНазначенияКлиентСервер.ЗапуститьПрограмму(""ping 127.0.0.1 -n 5"", ПараметрыЗапускаПрограммы);
//
Функция ЗапуститьПрограмму(Знач КомандаЗапуска, ПараметрыЗапускаПрограммы = Неопределено) Экспорт 
	
#Если ВебКлиент ИЛИ МобильныйКлиент Тогда
	ВызватьИсключение НСтр(""ru = 'Запуск программ недоступен в веб-клиенте.'"");
#Иначе
	
	СтрокаКоманды = БезопаснаяСтрокаКоманды(КомандаЗапуска);
	
	Если ПараметрыЗапускаПрограммы = Неопределено Тогда 
		ПараметрыЗапускаПрограммы = ПараметрыЗапускаПрограммы();
	КонецЕсли;
	
	ТекущийКаталог              = ПараметрыЗапускаПрограммы.ТекущийКаталог;
	ДождатьсяЗавершения         = ПараметрыЗапускаПрограммы.ДождатьсяЗавершения;
	ПолучитьПотокВывода         = ПараметрыЗапускаПрограммы.ПолучитьПотокВывода;
	ПолучитьПотокОшибок         = ПараметрыЗапускаПрограммы.ПолучитьПотокОшибок;
	ВыполнитьСНаивысшимиПравами = ПараметрыЗапускаПрограммы.ВыполнитьСНаивысшимиПравами;
	Кодировка                   = ПараметрыЗапускаПрограммы.Кодировка;
	
	Если ВыполнитьСНаивысшимиПравами Тогда 
#Если ВнешнееСоединение Тогда
		ВызватьИсключение 
			НСтр(""ru = 'Недопустимое значение параметра ПараметрыЗапускаПрограммы.ВыполнитьСНаивысшимиПравами.
			           |Повешение привилегий системы не доступно из внешнего соединения.'"");
#КонецЕсли
		
#Если Сервер Тогда
		ВызватьИсключение 
			НСтр(""ru = 'Недопустимое значение параметра ПараметрыЗапускаПрограммы.ВыполнитьСНаивысшимиПравами.
			           |Повешение привилегий системы не доступно на сервере.'"");
#КонецЕсли
		
	КонецЕсли;
	
	СистемнаяИнформация = Новый СистемнаяИнформация();
	Если (СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86) 
		Или (СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86_64) Тогда
	
		Если Не ПустаяСтрока(Кодировка) Тогда
			СтрокаКоманды = ""chcp "" + Кодировка + "" | "" + СтрокаКоманды;
		КонецЕсли;
	
	КонецЕсли;
	
	Если ДождатьсяЗавершения Тогда 
		
		Если ПолучитьПотокВывода Тогда 
			ФайлПотокаВывода = ПолучитьИмяВременногоФайла(""stdout.tmp"");
			СтрокаКоманды = СтрокаКоманды + "" > """""" + ФайлПотокаВывода + """""""";
		КонецЕсли;
		
		Если ПолучитьПотокОшибок Тогда 
			ФайлПотокаОшибок = ПолучитьИмяВременногоФайла(""stderr.tmp"");
			СтрокаКоманды = СтрокаКоманды + "" 2>"""""" + ФайлПотокаОшибок + """""""";
		КонецЕсли;
		
	КонецЕсли;
	
	КодВозврата = Неопределено;
	
	Если (СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86)
		Или (СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86_64) Тогда
		
		// Из-за запуска через shell перенаправление каталога требуется сделать командой.
		Если Не ПустаяСтрока(ТекущийКаталог) Тогда 
			СтрокаКоманды = ""cd /D """""" + ТекущийКаталог + """""" && "" + СтрокаКоманды;
		КонецЕсли;
		
		// Выполняется запуск через cmd.exe (для перенаправления stdout и stderr).
		СтрокаКоманды = ""cmd /S /C """" "" + СтрокаКоманды + "" """""";
		
#Если Сервер Тогда
		
		Если ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
			// В файловой информационной базе показывать окно консоли не следует и в серверном контексте.
			Оболочка = Новый COMОбъект(""Wscript.Shell"");
			КодВозврата = Оболочка.Run(СтрокаКоманды, 0, ДождатьсяЗавершения);
			Оболочка = Неопределено;
		Иначе 
			ЗапуститьПриложение(СтрокаКоманды,, ДождатьсяЗавершения, КодВозврата);
		КонецЕсли;
		
#Иначе
		
		Если ВыполнитьСНаивысшимиПравами Тогда
			
			Если ДождатьсяЗавершения Тогда
				ВызватьИсключение 
					НСтр(""ru = 'Недопустимо одновременно устанавливать параметры 
					           | - ПараметрыЗапускаПрограммы.ДождатьсяЗавершения и
					           | - ПараметрыЗапускаПрограммы.ВыполнитьСНаивысшимиПравами:
					           |Операционная система не позволяет отслеживать от имени пользователя процессы,
					           |запущенные администратором.'"");
			КонецЕсли;
			
			// После начала исполнения файла команды отследить статус процесса будет невозможно,
			// Потому удалять batch файл следует последней строкой команды в самом batch файле.
			// Асинхронно удалять нельзя, иначе может наступить коллизия, 
			// когда идет попытка удаления, а запуск еще не состоялся.
			
			ФайлКоманды = ПолучитьИмяВременногоФайла(""runas.bat"");
			ЗаписьКоманды = Новый ЗаписьТекста(ФайлКоманды, КодировкаТекста.OEM);
			ЗаписьКоманды.ЗаписатьСтроку(СтрокаКоманды);
			ЗаписьКоманды.ЗаписатьСтроку(""del /f /q """""" + ФайлКоманды + """""""");
			ЗаписьКоманды.Закрыть();
			
			Оболочка = Новый COMОбъект(""Shell.Application"");
			// Запуск с передачей глагола действия - повышения привилегий.
			Оболочка.ShellExecute(""cmd"", ""/c """""" + ФайлКоманды + """""""",, ""runas"", 0);
			Оболочка = Неопределено;
			
		Иначе 
			Оболочка = Новый COMОбъект(""Wscript.Shell"");
			КодВозврата = Оболочка.Run(СтрокаКоманды, 0, ДождатьсяЗавершения);
			Оболочка = Неопределено;
		КонецЕсли;
#КонецЕсли
		
	ИначеЕсли (СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Linux_x86) 
		Или (СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Linux_x86_64) Тогда
		
		Если ВыполнитьСНаивысшимиПравами Тогда
			
			ШаблонКоманды = ""pkexec env DISPLAY=[DISPLAY] XAUTHORITY=[XAUTHORITY] [СтрокаКоманды]"";
			
			ПараметрыШаблона = Новый Структура;
			ПараметрыШаблона.Вставить(""СтрокаКоманды"", СтрокаКоманды);
			
			ПараметрыЗапускаПодпрограммы = ПараметрыЗапускаПрограммы();
			ПараметрыЗапускаПодпрограммы.ДождатьсяЗавершения = Истина;
			ПараметрыЗапускаПодпрограммы.ПолучитьПотокВывода = Истина;
			
			Результат = ЗапуститьПрограмму(""echo $DISPLAY"", ПараметрыЗапускаПодпрограммы);
			ПараметрыШаблона.Вставить(""DISPLAY"", Результат.ПотокВывода);
			
			Результат = ЗапуститьПрограмму(""echo $XAUTHORITY"", ПараметрыЗапускаПодпрограммы);
			ПараметрыШаблона.Вставить(""XAUTHORITY"", Результат.ПотокВывода);
			
			СтрокаКоманды = СтроковыеФункцииКлиентСервер.ВставитьПараметрыВСтроку(ШаблонКоманды, ПараметрыШаблона);
			ДождатьсяЗавершения = Истина;
			
		КонецЕсли;
		
		ЗапуститьПриложение(СтрокаКоманды, ТекущийКаталог, ДождатьсяЗавершения, КодВозврата);
		
	Иначе
		
		// Для MacOS просто запускаем команду.
		// Параметр ПараметрыЗапускаПрограммы.ВыполнитьСНаивысшимиПравами игнорируется.
		ЗапуститьПриложение(СтрокаКоманды, ТекущийКаталог, ДождатьсяЗавершения, КодВозврата);
		
	КонецЕсли;
	
	// Переопределение возвращенного оболочной значения.
	Если КодВозврата = Неопределено Тогда 
		КодВозврата = 0;
	КонецЕсли;
	
	ПотокВывода = """";
	ПотокОшибок = """";
	
	Если ДождатьсяЗавершения Тогда 
		
		Если ПолучитьПотокВывода Тогда
			
			ФайлИнфо = Новый Файл(ФайлПотокаВывода);
			Если ФайлИнфо.Существует() Тогда 
				ЧтениеПотокаВывода = Новый ЧтениеТекста(ФайлПотокаВывода, КодировкаСтандартныхПотоков()); 
				ПотокВывода = ЧтениеПотокаВывода.Прочитать();
				ЧтениеПотокаВывода.Закрыть();
				УдалитьВременныйФайл(ФайлПотокаВывода);
			КонецЕсли;
			
			Если ПотокВывода = Неопределено Тогда 
				ПотокВывода = """";
			КонецЕсли;
			
		КонецЕсли;
		
		Если ПолучитьПотокОшибок Тогда 
			
			ФайлИнфо = Новый Файл(ФайлПотокаОшибок);
			Если ФайлИнфо.Существует() Тогда 
				ЧтениеПотокаОшибок = Новый ЧтениеТекста(ФайлПотокаОшибок, КодировкаСтандартныхПотоков());
				ПотокОшибок = ЧтениеПотокаОшибок.Прочитать();
				ЧтениеПотокаОшибок.Закрыть();
				УдалитьВременныйФайл(ФайлПотокаОшибок);
			КонецЕсли;
			
			Если ПотокОшибок = Неопределено Тогда 
				ПотокОшибок = """";
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Результат = Новый Структура;
	Результат.Вставить(""КодВозврата"", КодВозврата);
	Результат.Вставить(""ПотокВывода"", ПотокВывода);
	Результат.Вставить(""ПотокОшибок"", ПотокОшибок);
	
	Возврат Результат;
	
#КонецЕсли
	
КонецФункции

// Запускает диагностику сетевого ресурса.
// Не доступно в веб-клиенте.
// В модели сервиса функциональность ограничена получением описания ошибки.
//
// Параметры:
//  URL - Строка - адрес URL ресурса, диагностику которого надо выполнить.
//
// Возвращаемое значение:
//  Структура - Результат работы программы.
//      ОписаниеОшибки    - Строка - краткое описание ошибки.
//      ЖурналДиагностики - Строка - подробный журнал диагностики с техническими подробностями.
//
// Пример:
//	// Диагностика веб-сервиса адресного классификатора.
//	Результат = ОбщегоНазначенияКлиентСервер.ДиагностикаСоединения(""https://api.orgaddress.1c.ru/orgaddress/v1?wsdl"");
//	
//	ОписаниеОшибки    = Результат.ОписаниеОшибки;
//	ЖурналДиагностики = Результат.ЖурналДиагностики;
//
Функция ДиагностикаСоединения(URL) Экспорт
	
#Если ВебКлиент Тогда
	ВызватьИсключение НСтр(""ru = 'Выполнение диагностики соединения недоступно в веб-клиенте.'"");
#Иначе
	
	Описание = Новый Массив;
	Описание.Добавить(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр(""ru = 'При обращении по URL: %1'""), 
		URL));
	Описание.Добавить(ПредставлениеМестаДиагностики());
	
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
	Если ОбщегоНазначения.РазделениеВключено() Тогда
		Описание.Добавить(
			НСтр(""ru = 'Обратитесь к администратору.'""));
		
		ОписаниеОшибки = СтрСоединить(Описание, Символы.ПС);
		
		Результат = Новый Структура;
		Результат.Вставить(""ОписаниеОшибки"", ОписаниеОшибки);
		Результат.Вставить(""ЖурналДиагностики"", """");
		
		Возврат Результат;
	КонецЕсли;
#КонецЕсли
	
	Журнал = Новый Массив;
	Журнал.Добавить(
		НСтр(""ru = 'Журнал диагностики:
		           |Выполняется проверка доступности сервера.
		           |Описание диагностируемой ошибки см. в следующем сообщении журнала.'""));
	Журнал.Добавить();
	
	СоединениеЧерезПрокси = Ложь;
	
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
	Если ОбщегоНазначения.ПодсистемаСуществует(""СтандартныеПодсистемы.ПолучениеФайловИзИнтернета"") Тогда
		МодульПолучениеФайловИзИнтернетаКлиентСервер = 
			ОбщегоНазначения.ОбщийМодуль(""ПолучениеФайловИзИнтернетаКлиентСервер"");
		СостояниеНастроекПрокси = МодульПолучениеФайловИзИнтернетаКлиентСервер.СостояниеНастроекПрокси();
		
		СоединениеЧерезПрокси = СостояниеНастроекПрокси.СоединениеЧерезПрокси;
		
		Журнал.Добавить(СостояниеНастроекПрокси.Представление);
	КонецЕсли;
#Иначе
	Если ОбщегоНазначенияКлиент.ПодсистемаСуществует(""СтандартныеПодсистемы.ПолучениеФайловИзИнтернета"") Тогда
		МодульПолучениеФайловИзИнтернетаКлиентСервер = 
			ОбщегоНазначенияКлиент.ОбщийМодуль(""ПолучениеФайловИзИнтернетаКлиентСервер"");
		СостояниеНастроекПрокси = МодульПолучениеФайловИзИнтернетаКлиентСервер.СостояниеНастроекПрокси();
		
		СоединениеЧерезПрокси = СостояниеНастроекПрокси.СоединениеЧерезПрокси;
		
		Журнал.Добавить(СостояниеНастроекПрокси.Представление);
	КонецЕсли;
#КонецЕсли
	
	Если СоединениеЧерезПрокси Тогда 
		
		Описание.Добавить(
			НСтр(""ru = 'Диагностика соединения не выполнена, т.к. настроен прокси-сервер.
			           |Обратитесь к администратору.'""));
		
	Иначе 
		
		СтруктураСсылки = СтруктураURI(URL);
		АдресСервераРесурса = СтруктураСсылки.Хост;
		АдресСервераКонтрольнойПроверки = ""1c.com"";
		
		РезультатДоступностиРесурса = ПроверитьДоступностьСервера(АдресСервераРесурса);
		
		Журнал.Добавить();
		Журнал.Добавить(""1) "" + РезультатДоступностиРесурса.ЖурналДиагностики);
		
		Если РезультатДоступностиРесурса.Доступен Тогда 
			
			Описание.Добавить(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр(""ru = 'Выполнено обращение к несуществующему ресурсу на сервере %1
				           |или возникли неполадки на удаленном сервере.'""),
				АдресСервераРесурса));
			
		Иначе 
			
			РезультатКонтрольнойПроверки = ПроверитьДоступностьСервера(АдресСервераКонтрольнойПроверки);
			Журнал.Добавить(""2) "" + РезультатКонтрольнойПроверки.ЖурналДиагностики);
			
			Если Не РезультатКонтрольнойПроверки.Доступен Тогда
				
				Описание.Добавить(
					НСтр(""ru = 'Отсутствует доступ в сеть интернет по причине:
					           |- компьютер не подключен к интернету;
					           |- неполадки у интернет-провайдера;
					           |- подключение к интернету блокирует межсетевой экран, 
					           |  антивирусная программа или другое программное обеспечение.'""));
				
			Иначе 
				
				Описание.Добавить(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр(""ru = 'Сервер %1 не доступен по причине:
					           |- неполадки у интернет-провайдера;
					           |- подключение к серверу блокирует межсетевой экран, 
					           |  антивирусная программа или другое программное обеспечение;
					           |- сервер отключен или на техническом обслуживании.'""),
					АдресСервераРесурса));
				
				ЖурналТрассировки = ЖурналТрассировкиМаршрутаСервера(АдресСервераРесурса);
				Журнал.Добавить(""3) "" + ЖурналТрассировки);
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	ОписаниеОшибки = СтрСоединить(Описание, Символы.ПС);
	
	Журнал.Вставить(0);
	Журнал.Вставить(0, ОписаниеОшибки);
	
	ЖурналДиагностики = СтрСоединить(Журнал, Символы.ПС);
	
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
	ЗаписьЖурналаРегистрации(
		НСтр(""ru = 'Диагностика соединения'"", КодОсновногоЯзыка()),
		УровеньЖурналаРегистрации.Ошибка,,, ЖурналДиагностики);
#Иначе
	ЖурналРегистрацииКлиент.ДобавитьСообщениеДляЖурналаРегистрации(
		НСтр(""ru = 'Диагностика соединения'"", КодОсновногоЯзыка()),
		""Ошибка"", ЖурналДиагностики,, Истина);
#КонецЕсли
	
	Результат = Новый Структура;
	Результат.Вставить(""ОписаниеОшибки"", ОписаниеОшибки);
	Результат.Вставить(""ЖурналДиагностики"", ЖурналДиагностики);
	
	Возврат Результат;
	
#КонецЕсли
	
КонецФункции

// Создает объект описания защищенного соединения OpenSSL.
// Параметры:
//  СертификатКлиента - СертификатКлиентаФайл, 
//                      СертификатКлиентаWindows, 
//                      Неопределено - см ЗащищенноеСоединениеOpenSSL.
//  СертификатыУдостоверяющихЦентров - СертификатыУдостоверяющихЦентровФайл, 
//                                     СертификатыУдостоверяющихЦентровWindows, 
//                                     СертификатыУдостоверяющихЦентровLinux, 
//                                     СертификатыУдостоверяющихЦентровОС, 
//                                     Неопределено - см ЗащищенноеСоединениеOpenSSL.
//
// Возвращаемое значение:
//  ЗащищенноеСоединениеOpenSSL - описание защищенного соединения.
//
Функция НовоеЗащищенноеСоединение(СертификатКлиента = Неопределено, СертификатыУдостоверяющихЦентров = Неопределено) Экспорт
	
	Возврат Новый ЗащищенноеСоединениеOpenSSL(СертификатКлиента, СертификатыУдостоверяющихЦентров);
	
КонецФункции

#Область УстаревшиеПроцедурыИФункции

// Устарела. Следует использовать ОбщегоНазначенияКлиентСервер.РазностьМассивов
// Вычисляет разность массивов. Разностью массивов А и В является массив, содержащий
// все элементы массива А не существующие в массиве В.
//
// Параметры:
//  Массив - Массив - массив элементов, из которого необходимо выполнить вычитание;
//  МассивВычитания - Массив - массив элементов, который будет вычитаться.
// 
// Возвращаемое значение:
//  Массив - дополнение массива В до А.
//
Функция СократитьМассив(Массив, МассивВычитания) Экспорт
	
	Возврат РазностьМассивов(Массив, МассивВычитания);
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Выполняет поиск элемента в коллекции: списке значений или массиве.
//
Функция НайтиВСписке(Список, Элемент)
	
	Перем ЭлементВСписке;
	
	Если ТипЗнч(Список) = Тип(""СписокЗначений"") Тогда
		Если ТипЗнч(Элемент) = Тип(""ЭлементСпискаЗначений"") Тогда
			ЭлементВСписке = Список.НайтиПоЗначению(Элемент.Значение);
		Иначе
			ЭлементВСписке = Список.НайтиПоЗначению(Элемент);
		КонецЕсли;
	КонецЕсли;
	
	Если ТипЗнч(Список) = Тип(""Массив"") Тогда
		ЭлементВСписке = Список.Найти(Элемент);
	КонецЕсли;
	
	Возврат ЭлементВСписке;
	
КонецФункции

// Проверяет, что почтовый адрес не содержит символов обрамления
// если символы обрамления вставлены правильно убирает их.
Функция ПроверитьИПодготовитьПочтовыйАдрес(Знач ПолноеИмяАдресата, Знач ПочтовыйАдрес)
	
	НедопустимыйСимволВИмениАдресата = НСтр(""ru = 'Недопустимый символ в имени адресата.'"");
	НедопустимыйСимволВПочтовомАдресе = НСтр(""ru = 'Недопустимый символ в почтовом адресе.'"");
	СимволыОбрамления = ""<>[]"";
	
	ПочтовыйАдрес     = СокрЛП(ПочтовыйАдрес);
	ПолноеИмяАдресата = СокрЛП(ПолноеИмяАдресата);
	
	Если СтрНачинаетсяС(ПолноеИмяАдресата, ""<"") Тогда
		Если СтрЗаканчиваетсяНа(ПолноеИмяАдресата, "">"") Тогда
			ПолноеИмяАдресата = Сред(ПолноеИмяАдресата, 2, СтрДлина(ПолноеИмяАдресата)-2);
		Иначе
			ВызватьИсключение НедопустимыйСимволВИмениАдресата;
		КонецЕсли;
	ИначеЕсли СтрНачинаетсяС(ПолноеИмяАдресата, ""["") Тогда
		Если СтрЗаканчиваетсяНа(ПолноеИмяАдресата, ""]"") Тогда
			ПолноеИмяАдресата = Сред(ПолноеИмяАдресата, 2, СтрДлина(ПолноеИмяАдресата)-2);
		Иначе
			ВызватьИсключение НедопустимыйСимволВИмениАдресата;
		КонецЕсли;
	КонецЕсли;
	
	Если СтрНачинаетсяС(ПочтовыйАдрес, ""<"") Тогда
		Если СтрЗаканчиваетсяНа(ПочтовыйАдрес, "">"") Тогда
			ПочтовыйАдрес = Сред(ПочтовыйАдрес, 2, СтрДлина(ПочтовыйАдрес)-2);
		Иначе
			ВызватьИсключение НедопустимыйСимволВПочтовомАдресе;
		КонецЕсли;
	ИначеЕсли СтрНачинаетсяС(ПочтовыйАдрес, ""["") Тогда
		Если СтрЗаканчиваетсяНа(ПочтовыйАдрес, ""]"") Тогда
			ПочтовыйАдрес = Сред(ПочтовыйАдрес, 2, СтрДлина(ПочтовыйАдрес)-2);
		Иначе
			ВызватьИсключение НедопустимыйСимволВПочтовомАдресе;
		КонецЕсли;
	КонецЕсли;
	
	Для Индекс = 1 По СтрДлина(СимволыОбрамления) Цикл
		Если СтрНайти(ПолноеИмяАдресата, Сред(СимволыОбрамления, Индекс, 1)) <> 0
		 ИЛИ СтрНайти(ПочтовыйАдрес,     Сред(СимволыОбрамления, Индекс, 1)) <> 0 Тогда
			ВызватьИсключение НедопустимыйСимволВПочтовомАдресе;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Новый Структура(""Адрес, Представление"", ПочтовыйАдрес,ПолноеИмяАдресата);
	
КонецФункции

// Сдвигает маркер позиции пока встречается символ Символ
// возвращает номер позиции в строке, на которое установился маркер.
//
Функция ПропуститьПробелы(Знач Строка,
                          Знач ТекущийИндекс,
                          Знач ПропускаемыйСимвол)
	
	// Убираем лишние пробелы если они есть.
	Пока ТекущийИндекс < СтрДлина(Строка) Цикл
		Если Сред(Строка, ТекущийИндекс, 1) <> ПропускаемыйСимвол Тогда
			Возврат ТекущийИндекс;
		КонецЕсли;
		ТекущийИндекс = ТекущийИндекс + 1;
	КонецЦикла;
	
	Возврат ТекущийИндекс;
	
КонецФункции

Процедура НайтиРекурсивно(КоллекцияЭлементов, МассивЭлементов, СпособПоиска, ЗначениеПоиска)
	
	Для каждого ЭлементОтбора Из КоллекцияЭлементов Цикл
		
		Если ТипЗнч(ЭлементОтбора) = Тип(""ЭлементОтбораКомпоновкиДанных"") Тогда
			
			Если СпособПоиска = 1 Тогда
				Если ЭлементОтбора.ЛевоеЗначение = ЗначениеПоиска Тогда
					МассивЭлементов.Добавить(ЭлементОтбора);
				КонецЕсли;
			ИначеЕсли СпособПоиска = 2 Тогда
				Если ЭлементОтбора.Представление = ЗначениеПоиска Тогда
					МассивЭлементов.Добавить(ЭлементОтбора);
				КонецЕсли;
			КонецЕсли;
		Иначе
			
			НайтиРекурсивно(ЭлементОтбора.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);
			
			Если СпособПоиска = 2 И ЭлементОтбора.Представление = ЗначениеПоиска Тогда
				МассивЭлементов.Добавить(ЭлементОтбора);
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Функция ЗаменитьСимволыВСтрокеНаПробелы(Строка, ЗаменяемыеСимволы)
	Результат = Строка;
	Для Позиция = 1 По СтрДлина(Символы) Цикл
		Результат = СтрЗаменить(Результат, Сред(ЗаменяемыеСимволы, Позиция, 1), "" "");
	КонецЦикла;
	Возврат Результат;
КонецФункции

Функция ЕстьСимволыВНачалеВКонце(Строка, ПроверяемыеСимволы)
	Для Позиция = 1 По СтрДлина(ПроверяемыеСимволы) Цикл
		Символ = Сред(ПроверяемыеСимволы, Позиция, 1);
		СимволНайден = (Лев(Строка,1) = Символ) Или (Прав(Строка,1) = Символ);
		Если СимволНайден Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат Ложь;
КонецФункции

Функция СтрокаСодержитТолькоДопустимыеСимволы(Строка, ДопустимыеСимволы)
	МассивСимволов = Новый Массив;
	Для Позиция = 1 По СтрДлина(ДопустимыеСимволы) Цикл
		МассивСимволов.Добавить(Сред(ДопустимыеСимволы,Позиция,1));
	КонецЦикла;
	
	Для Позиция = 1 По СтрДлина(Строка) Цикл
		Если МассивСимволов.Найти(Сред(Строка, Позиция, 1)) = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
КонецФункции

Функция ЗначениеОжидаемогоТипа(Значение, ОжидаемыеТипы)
	ТипЗначения = ТипЗнч(Значение);
	Если ТипЗнч(ОжидаемыеТипы) = Тип(""ОписаниеТипов"") Тогда
		Возврат ОжидаемыеТипы.Типы().Найти(ТипЗначения) <> Неопределено;
	ИначеЕсли ТипЗнч(ОжидаемыеТипы) = Тип(""Тип"") Тогда
		Возврат ТипЗначения = ОжидаемыеТипы;
	ИначеЕсли ТипЗнч(ОжидаемыеТипы) = Тип(""Массив"") Или ТипЗнч(ОжидаемыеТипы) = Тип(""ФиксированныйМассив"") Тогда
		Возврат ОжидаемыеТипы.Найти(ТипЗначения) <> Неопределено;
	ИначеЕсли ТипЗнч(ОжидаемыеТипы) = Тип(""Соответствие"") Или ТипЗнч(ОжидаемыеТипы) = Тип(""ФиксированноеСоответствие"") Тогда
		Возврат ОжидаемыеТипы.Получить(ТипЗначения) <> Неопределено;
	КонецЕсли;
	Возврат Неопределено;
КонецФункции

Функция ПредставлениеТипов(ОжидаемыеТипы)
	Если ТипЗнч(ОжидаемыеТипы) = Тип(""Массив"") Тогда
		Результат = """";
		Индекс = 0;
		Для Каждого Тип Из ОжидаемыеТипы Цикл
			Если Не ПустаяСтрока(Результат) Тогда
				Результат = Результат + "", "";
			КонецЕсли;
			Результат = Результат + ПредставлениеТипа(Тип);
			Индекс = Индекс + 1;
			Если Индекс > 10 Тогда
				Результат = Результат + "",... ""
					+ СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр(""ru='(всего %1 типов)'""), ОжидаемыеТипы.Количество());
				Прервать;	
			КонецЕсли;	
		КонецЦикла;
		Возврат Результат;
	Иначе
		Возврат ПредставлениеТипа(ОжидаемыеТипы);
	КонецЕсли;
КонецФункции

Функция ПредставлениеТипа(Тип)
	Если Тип = Неопределено Тогда
		Возврат ""Неопределено"";
	ИначеЕсли ТипЗнч(Тип) = Тип(""ОписаниеТипов"") Тогда
		ТипСтрокой = Строка(Тип);
		Возврат ?(СтрДлина(ТипСтрокой) > 150, Лев(ТипСтрокой, 150) + ""..."" 
			+ СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр(""ru='(всего %1 типов)'""), Тип.Типы().Количество()), 
			ТипСтрокой);
	Иначе	
		ТипСтрокой = Строка(Тип);
		Возврат ?(СтрДлина(ТипСтрокой) > 150, Лев(ТипСтрокой, 150) + ""..."", ТипСтрокой);
	КонецЕсли;	
КонецФункции	

Функция МаксимальноеЗначениеВМассиве(Массив)
	
	МаксимальноеЗначение = 0;
	
	Для Индекс = 0 По Массив.Количество() - 1 Цикл
		Значение = Массив[Индекс];
		
		Если МаксимальноеЗначение < Значение Тогда
			МаксимальноеЗначение = Значение;
		КонецЕсли;
	КонецЦикла;
	
	Возврат МаксимальноеЗначение;
	
КонецФункции

Функция БезопаснаяСтрокаКоманды(КомандаЗапуска) Экспорт
	
	Результат = """";
	
	Если ТипЗнч(КомандаЗапуска) = Тип(""Строка"") Тогда 
		Если СодержитНебезопасныеДействия(КомандаЗапуска) Тогда 
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр(""ru = 'Недопустимая строка команды
				           |%1
				           |по причине:
				           |Строка команды не должна содержать символы: """"$"""", """"`"""", """"|"""", """";"""", """"&"""".'""),
				КомандаЗапуска);
		КонецЕсли;
		
		Результат = КомандаЗапуска;
	ИначеЕсли ТипЗнч(КомандаЗапуска) = Тип(""Массив"") Тогда
		Если КомандаЗапуска.Количество() > 0 Тогда 
			Если СодержитНебезопасныеДействия(КомандаЗапуска[0]) Тогда
				ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр(""ru = 'Недопустимая команда или путь к исполняемому файлу
				           |%1
				           |по причине:
				           |Команды не должна содержать символы: """"$"""", """"`"""", """"|"""", """";"""", """"&"""".'""),
				КомандаЗапуска[0]);
			КонецЕсли;
			Результат = МассивВСтрокуКоманды(КомандаЗапуска);
		Иначе
			ВызватьИсключение
				НСтр(""ru = 'Ожидался что в первый элемент КомандаЗапуска будет командой или путем к исполняемому файлу.'"");
		КонецЕсли;
	Иначе 
		ВызватьИсключение 
			НСтр(""ru = 'Ожидался что значение КомандаЗапуска будет <Строка> или <Массив>'"");
	КонецЕсли;
		
	Возврат Результат
	
КонецФункции

Функция СодержитНебезопасныеДействия(Знач СтрокаКоманды)
	
	СтрокаКоманды = СтрЗаменить(СтрокаКоманды, ""$DISPLAY"", """");
	СтрокаКоманды = СтрЗаменить(СтрокаКоманды, ""$XAUTHORITY"", """");
	
	Возврат СтрНайти(СтрокаКоманды, ""$"") <> 0
		Или СтрНайти(СтрокаКоманды, ""`"") <> 0
		Или СтрНайти(СтрокаКоманды, ""|"") <> 0
		Или СтрНайти(СтрокаКоманды, "";"") <> 0
		Или СтрНайти(СтрокаКоманды, ""&"") <> 0;
	
КонецФункции

Функция МассивВСтрокуКоманды(КомандаЗапуска)
	
	Результат = Новый Массив;
	НужныКавычки = Ложь;
	Для Каждого Аргумент Из КомандаЗапуска Цикл
		
		Если Результат.Количество() > 0 Тогда 
			Результат.Добавить("" "")
		КонецЕсли;
		
		НужныКавычки = Аргумент = Неопределено
			Или ПустаяСтрока(Аргумент)
			Или СтрНайти(Аргумент, "" "")
			Или СтрНайти(Аргумент, Символы.Таб)
			Или СтрНайти(Аргумент, ""&"")
			Или СтрНайти(Аргумент, ""("")
			Или СтрНайти(Аргумент, "")"")
			Или СтрНайти(Аргумент, ""["")
			Или СтрНайти(Аргумент, ""]"")
			Или СтрНайти(Аргумент, ""{"")
			Или СтрНайти(Аргумент, ""}"")
			Или СтрНайти(Аргумент, ""^"")
			Или СтрНайти(Аргумент, ""="")
			Или СтрНайти(Аргумент, "";"")
			Или СтрНайти(Аргумент, ""!"")
			Или СтрНайти(Аргумент, ""'"")
			Или СтрНайти(Аргумент, ""+"")
			Или СтрНайти(Аргумент, "","")
			Или СтрНайти(Аргумент, ""`"")
			Или СтрНайти(Аргумент, ""~"")
			Или СтрНайти(Аргумент, ""$"")
			Или СтрНайти(Аргумент, ""|"");
		
		Если НужныКавычки Тогда 
			Результат.Добавить("""""""");
		КонецЕсли;
		
		Результат.Добавить(СтрЗаменить(Аргумент, """""""", """"""""""""));
		
		Если НужныКавычки Тогда 
			Результат.Добавить("""""""");
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат СтрСоединить(Результат);
	
КонецФункции

Функция ТекстОшибкиПредопределенноеЗначениеНеНайдено(ПолноеИмяПредопределенного)
	
	Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр(""ru = 'Предопределенное значение """"%1"""" не найдено.'""), ПолноеИмяПредопределенного);
	
КонецФункции

#Если Не ВебКлиент Тогда

// Возвращает кодировку стандартных поток вывода и ошибок, используемую в текущей ОС.
//
// Возвращаемое значение:
//  КодировкаТекста - кодировка стандартных потоков вывода и ошибок.
//
Функция КодировкаСтандартныхПотоков()
	
	СистемнаяИнформация = Новый СистемнаяИнформация();
	Если (СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86) 
		Или (СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86_64) Тогда
		
		Кодировка = КодировкаТекста.OEM;
	Иначе
		Кодировка = КодировкаТекста.Системная;
	КонецЕсли;
	
	Возврат Кодировка;
	
КонецФункции

Процедура УдалитьВременныйФайл(ПолноеИмяФайла)
	
	Если ПустаяСтрока(ПолноеИмяФайла) Тогда
		Возврат;
	КонецЕсли;
		
	Попытка
		УдалитьФайлы(ПолноеИмяФайла);
	Исключение
#Если Сервер Тогда
		ЗаписьЖурналаРегистрации(НСтр(""ru = 'Базовая функциональность'"", КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Предупреждение,,, 
			СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр(""ru = 'Не удалось удалить временный файл
				           |%1 по причине: %2'""), 
				ПолноеИмяФайла, 
				КраткоеПредставлениеОшибки(ИнформацияОбОшибке())));
#КонецЕсли
	КонецПопытки;
	
КонецПроцедуры

Функция ПредставлениеМестаДиагностики()
	
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
	Если ОбщегоНазначения.РазделениеВключено() Тогда
		Возврат НСтр(""ru = 'Подключение проводится на сервере 1С:Предприятия в интернете.'"");
	Иначе 
		Если ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
			Если КлиентПодключенЧерезВебСервер() Тогда 
				Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр(""ru = 'Подключение проводится из файловой базы на веб-сервере <%1>.'""), ИмяКомпьютера());
			Иначе 
				Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр(""ru = 'Подключение проводится из файловой базы на компьютере <%1>.'""), ИмяКомпьютера());
			КонецЕсли;
		Иначе
			Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр(""ru = 'Подключение проводится на сервере 1С:Предприятие <%1>.'""), ИмяКомпьютера());
		КонецЕсли;
	КонецЕсли;
#Иначе 
	Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр(""ru = 'Подключение проводится на компьютере (клиенте) <%1>.'""), ИмяКомпьютера());
#КонецЕсли
	
КонецФункции

Функция ПроверитьДоступностьСервера(АдресСервера)
	
	ПараметрыЗапускаПрограммы = ПараметрыЗапускаПрограммы();
	ПараметрыЗапускаПрограммы.ДождатьсяЗавершения = Истина;
	ПараметрыЗапускаПрограммы.ПолучитьПотокВывода = Истина;
	ПараметрыЗапускаПрограммы.ПолучитьПотокОшибок = Истина;
	
	СистемнаяИнформация = Новый СистемнаяИнформация();
	ЭтоWindows = (СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86) 
		Или (СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86_64);
		
	Если ЭтоWindows Тогда
		ШаблонКоманды = ""ping %1 -n 2 -w 500"";
	Иначе
		ШаблонКоманды = ""ping -c 2 -w 500 %1"";
	КонецЕсли;
	
	СтрокаКоманды = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонКоманды, АдресСервера);
	
	Результат = ЗапуститьПрограмму(СтрокаКоманды, ПараметрыЗапускаПрограммы);
	
	// Разные операционные системы могут выводить ошибки в разные потоки:
	// - для Windows все всегда в потоке вывода;
	// - для Debian или RHEL ошибки падают в поток ошибок.
	ЖурналДоступности = Результат.ПотокВывода + Результат.ПотокОшибок;
	
	Если ЭтоWindows Тогда
		ФактНедоступности = (СтрНайти(ЖурналДоступности, ""Заданный узел недоступен"") > 0)
			Или (СтрНайти(ЖурналДоступности, ""Destination host unreachable"") > 0);
		
		БезПотерь = (СтрНайти(ЖурналДоступности, ""(0% потерь)"") > 0)
			Или (СтрНайти(ЖурналДоступности, ""(0% loss)"") > 0);
	Иначе 
		ФактНедоступности = (СтрНайти(ЖурналДоступности, ""Destination Host Unreachable"") > 0);
		БезПотерь = (СтрНайти(ЖурналДоступности, ""0% packet loss"") > 0)
	КонецЕсли;
	
	Доступен = Не ФактНедоступности И БезПотерь;
	СостояниеДоступности = ?(Доступен, НСтр(""ru = 'доступен'""), НСтр(""ru = 'не доступен'""));
	
	Журнал = Новый Массив;
	Журнал.Добавить(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр(""ru = 'Удаленный сервер %1 %2:'""), 
		АдресСервера, 
		СостояниеДоступности));
	
	Журнал.Добавить(""> "" + СтрокаКоманды);
	Журнал.Добавить(ЖурналДоступности);
	
	Возврат Новый Структура(""Доступен, ЖурналДиагностики"", Доступен, СтрСоединить(Журнал, Символы.ПС));
	
КонецФункции

Функция ЖурналТрассировкиМаршрутаСервера(АдресСервера)
	
	ПараметрыЗапускаПрограммы = ПараметрыЗапускаПрограммы();
	ПараметрыЗапускаПрограммы.ДождатьсяЗавершения = Истина;
	ПараметрыЗапускаПрограммы.ПолучитьПотокВывода = Истина;
	ПараметрыЗапускаПрограммы.ПолучитьПотокОшибок = Истина;
	
	СистемнаяИнформация = Новый СистемнаяИнформация();
	ЭтоWindows = (СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86) 
		Или (СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86_64);
	
	Если ЭтоWindows Тогда
		ШаблонКоманды = ""tracert -w 100 -h 15 %1"";
	Иначе 
		// Если вдруг пакет traceroute не установлен - в потоке вывода будет ошибка.
		// Т.к. результат все равно не разбирается, на поток вывода можно не обращать внимания.
		// По нему администратор поймет что ему надо доставить.
		ШаблонКоманды = ""traceroute -w 100 -m 100 %1"";
	КонецЕсли;
	
	СтрокаКоманды = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонКоманды, АдресСервера);
	
	Результат = ЗапуститьПрограмму(СтрокаКоманды, ПараметрыЗапускаПрограммы);
	
	Журнал = Новый Массив;
	Журнал.Добавить(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр(""ru = 'Трассировка маршрута к удаленному серверу %1:'""), АдресСервера));
	
	Журнал.Добавить(""> "" + СтрокаКоманды);
	Журнал.Добавить(Результат.ПотокВывода);
	Журнал.Добавить(Результат.ПотокОшибок);
	
	Возврат СтрСоединить(Журнал, Символы.ПС);
	
КонецФункции

#КонецЕсли

#КонецОбласти
"}
}
},
{11,
{"Табличный документ (печатные формы, ПФ)",1,0,"",""},
{0,
{"Вывод картинки (изображения) на печать, в макет (табличный документ)",0,0,"","//Вывод картинки (изображения) на печать, в макет (табличный документ)
//https://helpf.pro/faq/view/486.html

// 1-й вариант
//Как вывести картинку в табличный документ?

ТабДок = Новый ТабличныйДокумент; 
Макет = ОбработкаОбъект.ПолучитьМакет(""Макет""); 
ОбластьКартинки = Макет.ПолучитьОбласть(""ОбластьСКартинкой""); 
Картинка = Новый Картинка(ПутьККартинке); 

// Элемент управления ""Логотип"" входит в коллекцию картинок области. 
ОбластьКартинки.Рисунки.Логотип.Картинка = Картинка; 
ТабДок.Вывести(ОбластьКартинки); 

ТабДок.Показать(); 

// 2-й вариант
//Как вывести картинку в табличный документ без изменения макета?

Область = Макет.ПолучитьОбласть(""Шапка""); 
Рисунок = Область.Рисунки.Добавить(ТипРисункаТабличногоДокумента.Картинка); 
Рисунок.Верх = 5; 
Рисунок.Высота = 10; 
Рисунок.Ширина = 10; 
Рисунок.Лево = 5; 
Рисунок.Картинка = Новый Картинка(ПутьККартинке); 
Рисунок.РазмерКартинки = РазмерКартинки.РеальныйРазмер; 

ТабДок.Вывести(Область); 

//3-й вариант
//ПечатьОрганизации , добавляем в макет картинку с именем Картинка1 в самую нижнюю
//область с именем ОбластьПечатьОрганизации
ОбластьПечатьОрганизации = Макет.ПолучитьОбласть(""ПечатьОрганизации"");
Картинка= Новый Картинка(""C:\files\img\печатьОрганизации.gif"") ;
ОбластьПечатьОрганизации.Рисунки.Картинка1.Картинка = картинка;
ТабДок.Вывести(ОбластьПечатьОрганизации);

// 4-й вариант динамически
ОбластьПечатьОрганизации = Макет.ПолучитьОбласть(""ПечатьОрганизации"");
КартинкаПечатьОрганизации = ОбластьПечатьОрганизации.Рисунки.Добавить(ТипРисункаТабличногоДокумента.Картинка);
КартинкаПечатьОрганизации.Картинка = БиблиотекаКартинок.ОбщаяКартинка1;
КартинкаПечатьОрганизации.Верх = 0;
КартинкаПечатьОрганизации.Высота = 80;
КартинкаПечатьОрганизации.Ширина = 80;
КартинкаПечатьОрганизации.Лево = 50;
КартинкаПечатьОрганизации.ГраницаСверху = Ложь;
КартинкаПечатьОрганизации.ГраницаСлева = Ложь;
КартинкаПечатьОрганизации.ГраницаСправа = Ложь;
КартинкаПечатьОрганизации.ГраницаСнизу = Ложь;
КартинкаПечатьОрганизации.РазмерКартинки = РазмерКартинки.АвтоРазмер;
ТабДок.Вывести(ОбластьПечатьОрганизации);

//5-й вариант получение картинки из хранилища значений
// Выборка.Изображение - выборка из запроса, Изображение реквизит -хранил. значений  
Попытка
    Путь = КаталогВременныхФайлов()+ ""\1С_Картинка_""+Формат(ТекущаяДата(),""ДФ=yyyyMMddЧЧммсс"")+"".bmp"";
    КартинкаВПамяти = Выборка.Изображение.Получить();
    КартинкаВПамяти.Записать(Путь);
    ОбластьСостав.Рисунки.D1.Картинка = Новый Картинка(Путь);
Исключение
    ОбластьСостав.Рисунки.D1.Картинка = Новый Картинка;
КонецПопытки;"}
},
{0,
{"ДобавитьРисунок (изображение, картинку, факсимиле)",0,0,"","Функция ДобавитьРисунок(пТабличныйДокумент, пИмяОбласти, пКартинка, пЛево, пВерх, пВысота, пШирина)
	
	лРезультат = Неопределено;
	
	Область 	= пТабличныйДокумент.Области[пИмяОбласти]; 
	Рисунок 	= пТабличныйДокумент.Рисунки.Добавить(ТипРисункаТабличногоДокумента.Картинка);
	Рисунок.Картинка = пКартинка;
	Рисунок.Линия 	= Новый Линия(ТипЛинииРисункаТабличногоДокумента.НетЛинии); //Содержит тип линии рисунка
	Рисунок.Узор 	= ТипУзораТабличногоДокумента.БезУзора;
	Рисунок.Верх 	= пВерх; //Содержит положение верхней границы рисунка, отсчитываемое от верхней стороны табличного документа (в миллиметрах)
	Рисунок.Лево 	= пЛево; //Содержит положение левой границы рисунка, отсчитываемое от левой стороны табличного документа (в миллиметрах)
	Рисунок.Высота 	= пВысота; //Содержит высоту рисунка (в миллиметрах)
	Рисунок.Ширина 	= пШирина; //Содержит ширину рисунка (в миллиметрах).
	Рисунок.РазмерКартинки = РазмерКартинки.Пропорционально;
	
	Рисунок.Расположить(Область); //Если область по имени задана, то будут координаты и размер КАРТИНКИ, иначе впишет в область независимо от размера картинки
		
	Возврат лРезультат;
	
КонецФункции // ДобавитьРисунок()"}
},
{0,
{"ДобавитьРисунок в Область (изображение, картинку, факсимиле)",0,0,"","Функция ДобавитьРисунокВОбласть(пТабличныйДокумент, пОбласть, пКартинка, пЛево, пВерх, пВысота, пШирина)
	
	лРезультат = Неопределено;
	
	Область 	= пОбласть; 
	Рисунок 	= пТабличныйДокумент.Рисунки.Добавить(ТипРисункаТабличногоДокумента.Картинка);
	Рисунок.Картинка = пКартинка;
	Рисунок.Линия 	= Новый Линия(ТипЛинииРисункаТабличногоДокумента.НетЛинии); //Содержит тип линии рисунка
	Рисунок.Узор 	= ТипУзораТабличногоДокумента.БезУзора;
	Рисунок.Верх 	= пВерх; //Содержит положение верхней границы рисунка, отсчитываемое от верхней стороны табличного документа (в миллиметрах)
	Рисунок.Лево 	= пЛево; //Содержит положение левой границы рисунка, отсчитываемое от левой стороны табличного документа (в миллиметрах)
	Рисунок.Высота 	= пВысота; //Содержит высоту рисунка (в миллиметрах)
	Рисунок.Ширина 	= пШирина; //Содержит ширину рисунка (в миллиметрах).
	Рисунок.РазмерКартинки = РазмерКартинки.Пропорционально;
	
	Рисунок.Расположить(Область); //Если область по имени задана, то будут координаты и размер КАРТИНКИ, иначе впишет в область независимо от размера картинки
		
	Возврат лРезультат;
	
КонецФункции // ДобавитьРисунок()"}
},
{0,
{"Подпись в табличном дакументе печатной формы",0,0,"ТабДокПодпись","ОбластьПодпись<?""ВладелецПодписи""> 	= <?""Область"">.Рисунки.Добавить(ТипРисункаТабличногоДокумента.Картинка);
ОбластьПодпись<?""ВладелецПодписи"">.Картинка 	= БиблиотекаКартинок.<?""НазваниеИзображенияПодписи"">;
ОбластьПодпись<?""ВладелецПодписи"">.Линия 	= Новый Линия(ТипЛинииРисункаТабличногоДокумента.НетЛинии); //Содержит тип линии рисунка
ОбластьПодпись<?""ВладелецПодписи"">.Узор 	= ТипУзораТабличногоДокумента.БезУзора;
ОбластьПодпись<?""ВладелецПодписи"">.Верх 	= 0; //Содержит положение верхней границы рисунка, отсчитываемое от верхней стороны табличного документа (в миллиметрах)
ОбластьПодпись<?""ВладелецПодписи"">.Лево 	= 0; //Содержит положение левой границы рисунка, отсчитываемое от левой стороны табличного документа (в миллиметрах)
ОбластьПодпись<?""ВладелецПодписи"">.Высота 	= 20; //Содержит высоту рисунка (в миллиметрах)
ОбластьПодпись<?""ВладелецПодписи"">.Ширина 	= 40; //Содержит ширину рисунка (в миллиметрах).
ОбластьПодпись<?""ВладелецПодписи"">.РазмерКартинки 	= РазмерКартинки.АвтоРазмер;
"}
},
{0,
{"Доработка печатных форм (вывод реквизита в макет)",0,0,"","// <?""Выборка запроса для обхода""> - запрос с данными для вывода в ПФ
ТоварыВыгрузкаИзВыборки = <?""Выборка запроса для обхода"">.ВыгрузитьКолонку(""Номенклатура"");
Таблица<?""Таблица чего (напр, штрихкод, параметр)""> = ПолучитьТаблицу<?""Таблица чего (напр, штрихкод, параметр)"">(ТоварыВыгрузкаИзВыборки); // Функция получения новых своих данных для добавления

<?""Выборка запроса для обхода"">.Колонки.Добавить(""<?""Таблица чего (напр, штрихкод, параметр)"">"");

Если Таблица<?""Таблица чего (напр, штрихкод, параметр)""> <> Неопределено Тогда
	Для Каждого <?""Элемент выборки для обхода (Напр, СтрокаТовара)""> Из <?""Выборка запроса для обхода (Напр, ЗапросТовары)""> Цикл
		ПараметрыОтбора = Новый Структура;
		ПараметрыОтбора.Вставить(""Номенклатура"", <?""Элемент выборки для обхода (Напр, СтрокаТовара)"">.Товар);
		ПараметрыОтбора.Вставить(""ЕдиницаИзмеренияНаименование"", <?""Элемент выборки для обхода (Напр, СтрокаТовара)"">.ЕдиницаИзмерения); // <?""Элемент выборки для обхода (Напр, СтрокаТовара)"">.ЕдиницаИзмерения строкой
		
		НайденныеСтроки = Таблица<?""Таблица чего (напр, штрихкод, параметр)"">.НайтиСтроки(ПараметрыОтбора);
		
		РезделительЭлементов = "", "";
		РезделительДлина = СтрДлина(РезделительЭлементов);
		Если ЗначениеЗаполнено(НайденныеСтроки) Тогда
			<?""Таблица чего (напр, штрихкод, параметр)"">Строка = """";
			
			Для каждого ЭлМассив Из НайденныеСтроки Цикл
				<?""Таблица чего (напр, штрихкод, параметр)"">Строка = <?""Таблица чего (напр, штрихкод, параметр)"">Строка + СокрЛП(ЭлМассив.<?""Таблица чего (напр, штрихкод, параметр)"">) + РезделительЭлементов;
			КонецЦикла;
			
			<?""Таблица чего (напр, штрихкод, параметр)"">Строка = Сред(<?""Таблица чего (напр, штрихкод, параметр)"">Строка, 1, СтрДлина(<?""Таблица чего (напр, штрихкод, параметр)"">Строка) - РезделительДлина); // Убираем последний разделитель
			
			<?""Элемент выборки для обхода (Напр, СтрокаТовара)"">.<?""Таблица чего (напр, штрихкод, параметр)""> = <?""Таблица чего (напр, штрихкод, параметр)"">Строка;
			
		КонецЕсли;
	КонецЦикла;
КонецЕсли;

// Далее в цикле построчной обработки товаров
Если Таблица<?""Таблица чего (напр, штрихкод, параметр)""> <> Неопределено Тогда
	ОбластьМакета.Параметры.<?""Таблица чего (напр, штрихкод, параметр)""> = Строчка.<?""Таблица чего (напр, штрихкод, параметр)"">;
КонецЕсли;

Функция ПолучитьТаблицу<?""Таблица чего (напр, штрихкод, параметр)"">(СписокНоменклатуры)
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	""ВЫБРАТЬ
	|	ШтрихкодыНоменклатуры.Штрихкод КАК Штрихкод,
	|	ШтрихкодыНоменклатуры.ЕдиницаИзмерения КАК ЕдиницаИзмерения,
	|	ШтрихкодыНоменклатуры.Номенклатура
	|ИЗ
	|	РегистрСведений.ШтрихкодыНоменклатуры КАК ШтрихкодыНоменклатуры
	|ГДЕ
	|	ШтрихкодыНоменклатуры.Номенклатура В (&Номенклатура)"";
	
	Запрос.УстановитьПараметр(""Номенклатура"", СписокНоменклатуры); // В запросе важно наличие ""ГДЕ Элемент В (&Номенклатура)""
	
	РезультатЗапроса = Запрос.Выполнить();
	
	ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		Возврат РезультатЗапроса.Выгрузить();
	КонецЕсли; 
	
КонецФункции
"}
},
{0,
{"ОбластьМакета.Параметры.Заполнить",0,0,"","ОбластьМакета = Макет.ПолучитьОбласть(""Шапка"");

лДанныеЗаполнения = Новый Структура();
лДанныеЗаполнения.Вставить("""", );

ОбластьМакета.Параметры.Заполнить(лДанныеЗаполнения);

ТабличныйДокумент.Вывести(ОбластьМакета);"}
},
{0,
{"АдресОбластьМакета (для вывода картинки в область, но в целом для многого)",0,0,"","//Функция АдресОбластьМакета
//-------------------------------------------------------------------------
//Параметры:
//		пТабличныйДокумент 	- ТабДок 	- описание
//		пОбласть 	- Область 	- Область из которой блать значения номера строки, колонки. Относительно которой получать область. Типа точка отсчёта
//		пСтрокаБазовая 	- Число 	- Число смещения области относительно строки пОбласть 
//		пКолонкаБазовая 	- Число 	- Число смещения области относительно колонки пОбласть
//		пСтрокаСтрого 	- Число 	- Если не ноль, то будет присвоено строго это значение. Для задания масштаба высоты
//		пКолонкаСтрого 	- Число 	- Если не ноль, то будет присвоено строго это значение. Для задания масштаба ширины
//Возвращаемое значение:
//		Область 	- Область для вставки картинки относительно заданной области
//-------------------------------------------------------------------------
//Фигня в том, что если выводить картинку (через Рисунок.Расположить(Область)) 
//в просто область, полученную через 
//ОбластьПодвалСчета 	= ТабличныйДокумент.Области[""ПодвалСчета""];
//То будет выведено по значениям свойств КАРТИНКИ Лево и Право.
//Но если передать область полученную через, то подцепит место области, но кривовато
//ОбластьПодвалСчета 	= ТабличныйДокумент.Область(ЛСтрока, ЛКолонка, ПСтрока, ПКолонка);
//Аккуратно надо с пСтрокаСтрого, пКолонкаСтрого. Т.к. они привязаны к колонкам,
//и если кто-то добавит новую, то всё может ощутимо сместиться/измениться.
//В целом все значения подбираются эмпирически на относительных значениях 
//расположения области через пОбласть.Верх, пОбласть.Низ
//-------------------------------------------------------------------------
//автор: КучеровРМ 11.01.2019
Функция АдресОбластьМакета(пТабличныйДокумент, пОбласть, пСтрокаБазовая = 0, пКолонкаБазовая = 0, пСтрокаСтрого = 0, пКолонкаСтрого = 0)
	
	ОбластьКоордПрям = """";
	
	ЛСтрока 	= пОбласть.Верх + 1 + пСтрокаБазовая;
	ЛКолонка 	= пОбласть.Лево + 1 + пКолонкаБазовая;
	
	Если ЗначениеЗаполнено(пСтрокаСтрого) Тогда
		ПСтрока 	= пСтрокаСтрого;
	Иначе
		ПСтрока 	= пОбласть.Низ + 1 + пСтрокаБазовая;
	КонецЕсли; 
	
	Если ЗначениеЗаполнено(пКолонкаСтрого) Тогда
		ПКолонка 	= пКолонкаСтрого;
	Иначе
		Высота 		= ПСтрока - ЛСтрока;
		ПКолонка 	= Высота + пКолонкаБазовая;
	КонецЕсли;
	
	ОбластьКоордПрям 	= пТабличныйДокумент.Область(ЛСтрока, ЛКолонка, ПСтрока, ПКолонка);
	
	Возврат ОбластьКоордПрям;
	
КонецФункции // АдресОбластьМакета()"}
},
{0,
{"АвтоМасштаб",0,0,"","ТабличныйДокумент.АвтоМасштаб = Истина; //Если не помещается на лист, то будет подогнан"}
},
{0,
{"Добавить картинку/факсимиле универсально",0,0,"","//+++ АйТи Кучеров Р.М. 11.01.2019 ТЗ № ИС00-008594 >> e1cib/data/Документ.ЗаданиеНаРаботу?ref=b78532336337376211e9090986673c87

Функция ВывестиФаксимиле(пТабличныйДокумент, пЗаказКлиента, пОбластьДляВывода = Неопределено, пИмяОбластиДляВывода = ""Подвал"")
	
	лРезультат = Ложь;
	
	Организация   = пЗаказКлиента.Организация;
	
	ФайлКартинки = Неопределено;
	Запрос = Новый Запрос;
	Запрос.Текст =
	""ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 2
	|	ОрганизацииПрисоединенныеФайлы.Ссылка КАК ФайлКартинки
	|ИЗ
	|	Справочник.ОрганизацииПрисоединенныеФайлы КАК ОрганизацииПрисоединенныеФайлы
	|ГДЕ
	|	ОрганизацииПрисоединенныеФайлы.ВладелецФайла = &Организация
	|	И (ОрганизацииПрисоединенныеФайлы.Наименование = """"Динамика_Подпись""""
	|			ИЛИ ОрганизацииПрисоединенныеФайлы.Наименование = """"Динамика_Печать"""")"";
	
	Запрос.УстановитьПараметр(""Организация"",Организация);
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		ВыборкаФайлКартинки = Выборка.ФайлКартинки;
		Если ВыборкаФайлКартинки.Наименование = ""Динамика_Подпись"" Тогда
			ФайлКартинкиПодпись = Выборка.ФайлКартинки;
		ИначеЕсли ВыборкаФайлКартинки.Наименование = ""Динамика_Печать"" Тогда
			ФайлКартинкиПечать = Выборка.ФайлКартинки;
		КонецЕсли; 
	КонецЦикла;
	
	Если пОбластьДляВывода = Неопределено И НЕ ПустаяСтрока(пИмяОбластиДляВывода) Тогда
		пОбластьДляВывода 	= пТабличныйДокумент.Области[пИмяОбластиДляВывода];	
	КонецЕсли; 
	
	//ФайлКартинкиПодпись
	Если ЗначениеЗаполнено(ФайлКартинкиПодпись) Тогда
		Картинка = ПолучитьКартинку(РаботаСФайлами.ДвоичныеДанныеФайла(ФайлКартинкиПодпись));
		
		Если ЗначениеЗаполнено(Картинка) Тогда
			РисунокРазмер = 40; //Но при выводе в область это не повлияет
			ОбластьКоордПрям = АдресОбластьМакета(пТабличныйДокумент, пОбластьДляВывода, -3, 10,, 15);
			ДобавитьРисунокВОбласть(пТабличныйДокумент, ОбластьКоордПрям, Картинка, 100, 2, РисунокРазмер, РисунокРазмер);
		КонецЕсли;
		лРезультат = Истина;
	КонецЕсли;
	
	//ФайлКартинкиПечать
	Если ЗначениеЗаполнено(ФайлКартинкиПечать) Тогда
		Картинка = ПолучитьКартинку(РаботаСФайлами.ДвоичныеДанныеФайла(ФайлКартинкиПечать));
		
		Если ЗначениеЗаполнено(Картинка) Тогда
			РисунокРазмер = 40; //Но при выводе в область это не повлияет
			ОбластьКоордПрям = АдресОбластьМакета(пТабличныйДокумент, пОбластьДляВывода, 0, 17,, 24);
			ДобавитьРисунокВОбласть(пТабличныйДокумент, ОбластьКоордПрям, Картинка, 100, 2, РисунокРазмер, РисунокРазмер);
		КонецЕсли;
		лРезультат = Истина;
	КонецЕсли;
	
	Возврат лРезультат;
	
КонецФункции // ВывестиФаксимиле()

Функция ПолучитьКартинку(ДвоичныеДанныеФайла)
	
	лРезультат = Неопределено;
	
	Если ТипЗнч(ДвоичныеДанныеФайла) = Тип(""Картинка"") Тогда
		Картинка = ДвоичныеДанныеФайла;
	ИначеЕсли ТипЗнч(ДвоичныеДанныеФайла) = Тип(""ДвоичныеДанные"") Тогда
		Картинка = Новый Картинка(ДвоичныеДанныеФайла);
	Иначе
		Картинка = Новый Картинка;
	КонецЕсли;
	
	лРезультат = Картинка;
	
	Возврат лРезультат;
	
КонецФункции // ПолучитьКартинку()

//Функция АдресОбластьМакета
//-------------------------------------------------------------------------
//Параметры:
//		пТабличныйДокумент 	- ТабДок 	- описание
//		пОбласть 	- Область 	- Область из которой блать значения номера строки, колонки. Относительно которой получать область. Типа точка отсчёта
//		пСтрокаБазовая 	- Число 	- Число смещения области относительно строки пОбласть 
//		пКолонкаБазовая 	- Число 	- Число смещения области относительно колонки пОбласть
//		пСтрокаСтрого 	- Число 	- Если не ноль, то будет присвоено строго это значение. Для задания масштаба высоты
//		пКолонкаСтрого 	- Число 	- Если не ноль, то будет присвоено строго это значение. Для задания масштаба ширины
//Возвращаемое значение:
//		Область 	- Область относительно заданной области
//-------------------------------------------------------------------------
//Фигня в том, что если выводить картинку (через Рисунок.Расположить(Область)) 
//в просто область, полученную через 
//ОбластьПодвалСчета 	= ТабличныйДокумент.Области[""ПодвалСчета""];
//То будет выведено по значениям свойств КАРТИНКИ Лево и Право.
//Но если передать область полученную через, то подцепит место области, но кривовато
//ОбластьПодвалСчета 	= ТабличныйДокумент.Область(ЛСтрока, ЛКолонка, ПСтрока, ПКолонка);
//-------------------------------------------------------------------------
//автор: КучеровРМ 11.01.2019 
Функция АдресОбластьМакета(пТабличныйДокумент, пОбласть, пСтрокаБазовая = 0, пКолонкаБазовая = 0, пСтрокаСтрого = 0, пКолонкаСтрого = 0)
	
	ОбластьКоордПрям = """";
	
	ЛСтрока 	= пОбласть.Верх + 1 + пСтрокаБазовая;
	ЛКолонка 	= пОбласть.Лево + 1 + пКолонкаБазовая;
	
	Если ЗначениеЗаполнено(пСтрокаСтрого) Тогда
		ПСтрока 	= пСтрокаСтрого;
	Иначе
		ПСтрока 	= пОбласть.Низ + 1 + пСтрокаБазовая;
	КонецЕсли; 
	
	Если ЗначениеЗаполнено(пКолонкаСтрого) Тогда
		ПКолонка 	= пКолонкаСтрого;
	Иначе
		Высота 		= ПСтрока - ЛСтрока;
		ПКолонка 	= Высота + пКолонкаБазовая;
	КонецЕсли;
	
	ОбластьКоордПрям 	= пТабличныйДокумент.Область(ЛСтрока, ЛКолонка, ПСтрока, ПКолонка);
	
	Возврат ОбластьКоордПрям;
	
КонецФункции // АдресОбластьМакета()

Функция ДобавитьРисунокВОбласть(пТабличныйДокумент, пОбласть, пКартинка, пЛево = 0, пВерх = 0, пВысота = 0, пШирина = 0, РасположитьРисунок = Ложь)
	
	лРезультат = Неопределено;
	
	Область 	= пОбласть; 
	Рисунок 	= пТабличныйДокумент.Рисунки.Добавить(ТипРисункаТабличногоДокумента.Картинка);
	Рисунок.Картинка = пКартинка;
	Рисунок.Линия 	= Новый Линия(ТипЛинииРисункаТабличногоДокумента.НетЛинии); //Содержит тип линии рисунка
	Рисунок.Узор 	= ТипУзораТабличногоДокумента.БезУзора;
	Рисунок.Верх 	= пВерх; //Содержит положение верхней границы рисунка, отсчитываемое от верхней стороны табличного документа (в миллиметрах)
	Рисунок.Лево 	= пЛево; //Содержит положение левой границы рисунка, отсчитываемое от левой стороны табличного документа (в миллиметрах)
	Рисунок.Высота 	= пВысота; //Содержит высоту рисунка (в миллиметрах)
	Рисунок.Ширина 	= пШирина; //Содержит ширину рисунка (в миллиметрах).
	Рисунок.РазмерКартинки = РазмерКартинки.Пропорционально;
	
	Если РасположитьРисунок Тогда
		Рисунок.Расположить(Область);	
	КонецЕсли; 
		
	Возврат лРезультат;
	
КонецФункции // ДобавитьРисунокВОбласть()
 
//--- АйТи Кучеров Р.М. 11.01.2019 ТЗ № ИС00-008594 ч.2 >> e1cib/data/Документ.ЗаданиеНаРаботу?ref=b78532336337376211e9090986673c87
"}
},
{0,
{"Добавить Картинку",0,0,"","//+++ АйТи Кучеров Р.М. 15.01.2019 ТЗ № ИС00-008594 >> e1cib/data/Документ.ЗаданиеНаРаботу?ref=b78532336337376211e9090986673c87
//Было:ФормированиеПечатныхФорм.ВывестиФаксимилеВТабличныйДокумент(Макет, Область, ДанныеПечати.Организация, ПараметрыПечати);
ОтображатьФаксимиле = Ложь;
Если ПараметрыПечати <> Неопределено И ПараметрыПечати.Свойство(""ОтображатьФаксимиле"") Тогда
	ОтображатьФаксимиле = ПараметрыПечати.ОтображатьФаксимиле;
КонецЕсли;

Если ОтображатьФаксимиле Тогда
	//Макет из этой внешней обработки
	МакетОбработки 	= ПолучитьМакет(""ПФ_MXL_СчетНаОплату""); 
	Область 		= МакетОбработки.ПолучитьОбласть(""ПодвалСчета"");
Иначе
	Область 		= Макет.ПолучитьОбласть(""ПодвалСчета"");
КонецЕсли;

Если ОтображатьФаксимиле Тогда
	ФайлКартинки = Неопределено;
	Запрос = Новый Запрос;
	Запрос.Текст =
	""ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 2
	|	ОрганизацииПрисоединенныеФайлы.Ссылка КАК ФайлКартинки
	|ИЗ
	|	Справочник.ОрганизацииПрисоединенныеФайлы КАК ОрганизацииПрисоединенныеФайлы
	|ГДЕ
	|	ОрганизацииПрисоединенныеФайлы.ВладелецФайла = &Организация
	|	И (ОрганизацииПрисоединенныеФайлы.Наименование = """"Динамика_Подпись""""
	|			ИЛИ ОрганизацииПрисоединенныеФайлы.Наименование = """"Динамика_Печать"""")"";
	
	Запрос.УстановитьПараметр(""Организация"", ДанныеПечати.Организация);
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		ВыборкаФайлКартинки = Выборка.ФайлКартинки;
		Если ВыборкаФайлКартинки.Наименование = ""Динамика_Подпись"" Тогда
			ФайлКартинкиПодпись = Выборка.ФайлКартинки;
		ИначеЕсли ВыборкаФайлКартинки.Наименование = ""Динамика_Печать"" Тогда
			ФайлКартинкиПечать = Выборка.ФайлКартинки;
		КонецЕсли; 
	КонецЦикла;
	
	//ФайлКартинкиПодпись
	Если ЗначениеЗаполнено(ФайлКартинкиПодпись) Тогда
		Картинка = ПолучитьКартинку(РаботаСФайлами.ДвоичныеДанныеФайла(ФайлКартинкиПодпись));
		
		Если ЗначениеЗаполнено(Картинка) Тогда
			Область.Рисунки.РуководительПодпись.Картинка = Картинка;
		КонецЕсли;
	КонецЕсли;
	
	//ФайлКартинкиПечать
	Если ЗначениеЗаполнено(ФайлКартинкиПечать) Тогда
		Картинка = ПолучитьКартинку(РаботаСФайлами.ДвоичныеДанныеФайла(ФайлКартинкиПечать));
		
		Если ЗначениеЗаполнено(Картинка) Тогда
			Область.Рисунки.Печать.Картинка = Картинка;
		КонецЕсли;
	КонецЕсли;
КонецЕсли;
// Вывести подписи
//Область = Макет.ПолучитьОбласть(""ПодвалСчета"");
//--- АйТи Кучеров Р.М. 15.01.2019 ТЗ № ИС00-008594 >> e1cib/data/Документ.ЗаданиеНаРаботу?ref=b78532336337376211e9090986673c87
"}
},
{5,
{"Табличный документ в Таблицу значений",1,0,"",""},
{0,
{"ТД в ТЗ (построчно)",0,0,"","// Вариант 1
// По переданному табличному документу возвращает таблицу значений, 
// при условии что в первой строке таблицы - идентификаторы колонок 
// Автор : dimoff
Функция ПолучитьТЗИзМакета(ТабДок, КолонкаИндекса = 1) Экспорт
	
	ТаблицаДанных = Новый ТаблицаЗначений;
	НомерКолонки = 0;
	Пока Истина Цикл
		НомерКолонки = НомерКолонки + 1;
		ИмяКолонки = ТабДок.Область(1, НомерКолонки).Текст;
		Если ПустаяСтрока(ИмяКолонки) Тогда
			Прервать;
		КонецЕсли;        
		ТаблицаДанных.Колонки.Добавить(ИмяКолонки);
	КонецЦикла;
	
	СчетчикКолонок = НомерКолонки - 1;
	
	НомерСтроки = 1; ФлагПрерывания = Ложь;
	Пока Истина Цикл
		НомерСтроки = НомерСтроки + 1;
		Стр = ТаблицаДанных.Добавить();
		
		Для А = 1 ПО СчетчикКолонок Цикл
			ТекстКолонки = ТабДок.Область(НомерСтроки, А).Текст;
			Если ПустаяСтрока(ТекстКолонки) Тогда
				Если А = КолонкаИндекса Тогда
					Флагпрерывания = Истина;
					ТаблицаДанных.Удалить(Стр);
				КонецЕсли;
			Иначе
				Стр[А - 1] = ТекстКолонки
			КонецЕсли;
			
			Если Флагпрерывания Тогда
				Прервать
			КонецЕсли;
		КонецЦикла;
		
		Если Флагпрерывания Тогда
			Прервать
		КонецЕсли;
	КонецЦикла;
	
	Возврат ТаблицаДанных
КонецФункции

// Варинат 2
//Функция загружает весь макет, табличный документ в таблицу значений
//Первая строка содержит подписи колонок (должны быть правильные идентификаторы)
//Пустые строки (состоящией из пробелов, переводов строки и т.п.) заменяет на Неопределено
//Если в ячейке есть значение, в ячейку таблицы значений попадает именно это значение
//Автор : Гений1С
Функция обМакетВТаблицуЗначений(Макет) Экспорт
	Перем ТЗ;
	ТЗ=Новый ТаблицаЗначений();
	#Если Клиент Тогда
		//Считываем колонки
		Для Стр=1 По Макет.ВысотаТаблицы Цикл
			Если Стр>1 Тогда
				ТекСтр=ТЗ.Добавить();
			КонецЕсли;
			ПустаяСтрока=истина;
			Для Кол=1 По Макет.ШиринаТаблицы Цикл
				Яч=Макет.Область(Стр, Кол);
				Если Яч.СодержитЗначение Тогда
					Зн=Яч.Значение;
				Иначе
					Зн=Яч.Текст;
				КонецЕсли;
				Если ТипЗнч(Зн)=Тип(""Строка"") И ПустаяСтрока(Зн) Тогда
					Зн=Неопределено;
				КонецЕсли;
				
				//Добавляем колонку
				Если Стр=1 Тогда
					ТЗ.Колонки.Добавить(Зн);
				Иначе
					ТекСтр[Кол-1]=Зн;
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
	#КонецЕсли
	Возврат ТЗ;
КонецФункции    "}
},
{0,
{"ТД в ТЗ 2 (построчно)",0,0,"","// Преобразует табличный документ в таблицу значений
// Первый ряд - имена колонок
// Все колонки с типом ""Строка""
Функция ТабДокВТаблицуЗначений(ТабДок) Экспорт
	ТЧ = Новый ТаблицаЗначений;
	
	ТекущийРяд = 1;
	ТекущаяКолонка = 1;
	
	СписокКолонок = Новый СписокЗначений;
	Область = ТабДок.ПолучитьОбласть(""R"" + ТекущийРяд);
	Пока Истина Цикл
		ИмяКолонки = Область.Область(""R1C"" + ТекущаяКолонка).Текст;
		ИмяКолонкиМетаданных = ПолучитьДопустимоеИмяДляМетаданных(ИмяКолонки);
		Если НЕ ПустаяСтрока(ИмяКолонки) Тогда
			СписокКолонок.Добавить(ИмяКолонкиМетаданных, ИмяКолонки);
		Иначе
			Прервать;
		КонецЕсли;
		ТекущаяКолонка = ТекущаяКолонка + 1;
	КонецЦикла;
	
	ВсегоКолонок = СписокКолонок.Количество();
	Если ВсегоКолонок = 0 Тогда
		Возврат неопределено;
	КонецЕсли;
	
	КС = Новый КвалификаторыСтроки(50);
	МассивТипов = Новый Массив;
	МассивТипов.Добавить(Тип(""Строка""));
	ОписаниеСтроки = Новый ОписаниеТипов(МассивТипов,,,,КС);
	
	СтруктураСтроки = Новый Структура;
	Для Каждого Колонка ИЗ СписокКолонок Цикл
		ТЧ.Колонки.Добавить(Колонка.Значение, ОписаниеСтроки, Колонка.Представление);
		СтруктураСтроки.Вставить(Колонка.Значение, """");
	КонецЦикла;
	
	// Перебор строк
	
	ЕстьСтрокаСДанными = Истина;
	Пока ЕстьСтрокаСДанными Цикл
		ТекущийРяд = ТекущийРяд + 1;
		Область = ТабДок.ПолучитьОбласть(""R"" + ТекущийРяд);
		
		ПустыхЗначений = 0;
		Для ИНД = 1 ПО ВсегоКолонок Цикл
			ЗначениеКолонки = СокрЛП(Область.Область(""R1C"" + ИНД).Текст);
			Если ПустаяСтрока(ЗначениеКолонки) Тогда
				ПустыхЗначений = ПустыхЗначений + 1;
			КонецЕсли;
			СтруктураСтроки[СписокКолонок[ИНД-1].Значение] = ЗначениеКолонки;
		КонецЦикла;
		Если ПустыхЗначений >= ВсегоКолонок Тогда
			ЕстьСтрокаСДанными = Ложь;
			Прервать;
		КонецЕсли;
		НоваяСтрока = ТЧ.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтруктураСтроки);
	КонецЦикла;
	Возврат ТЧ;    
КонецФункции

Функция ПолучитьДопустимоеИмяДляМетаданных(СтрокаВхода) Экспорт
	СтрокаВхода = СокрЛП(СтрокаВхода);
	СтрокаВхода = ТРег(СтрокаВхода);
	СтрокаВхода = СтрЗаменить(СтрокаВхода, "" "", """");
	СтрокаВхода = СтрЗаменить(СтрокаВхода, """""""", """");
	НедопустимыеСимволы = "".,/\|!№%;:?*()-=+'`~"";
	Для ИНД = 1 ПО СтрДлина(НедопустимыеСимволы) Цикл
		СимволЗамены = Сред(НедопустимыеСимволы, ИНД, 1);
		СтрокаВхода = СтрЗаменить(СтрокаВхода, СимволЗамены, """");
	КонецЦикла;
	Возврат СтрокаВхода;        
КонецФункции
"}
},
{0,
{"ТД в ТЗ 3 (построчно)",0,0,"","Функция ТабличныйДокументВТаблицуЗначений(ТабДок)
	
	ТаблицаДанныеДокумента = Новый ТаблицаЗначений();
	
	Для СчетчикКолонок = 1 По ТабДок.ШиринаТаблицы Цикл
		
		ИмяКолонки = ""_"" + СчетчикКолонок;
		ТаблицаДанныеДокумента.Колонки.Добавить(ИмяКолонки);
		
		Для СчетчикСтрок = 1 По ТабДок.ВысотаТаблицы Цикл
			
			ИндексСтроки = СчетчикСтрок - 1;
			
			Если СчетчикКолонок = 1 Тогда
				СтрокаТаблицы = ТаблицаДанныеДокумента.Добавить();
			Иначе
				СтрокаТаблицы = ТаблицаДанныеДокумента[ИндексСтроки];
			КонецЕсли;
			
			ТекущаяЯчейка = ТабДок.Область(СчетчикСтрок, СчетчикКолонок);
			ЗначениеЯчейки = ТекущаяЯчейка.Текст;
			
			СтрокаТаблицы[ИмяКолонки] = ЗначениеЯчейки;
			
		КонецЦикла
	КонецЦикла;
	Возврат ТаблицаДанныеДокумента;
	
КонецФункции
| Подробнее: http://www.advanter.net/preobrazovanie-tablichnogo-dokumenta-v-tablicu-znachenij-perebor/"}
},
{0,
{"ТД в ТЗ (через ПостроительОтчета)",0,0,"","&НаСервере
Функция ПреобразоватьТабличныйДокументВТаблицуЗначений(ТабДокумент)
	
	ПоследняяСтрока 	= ТабДокумент.ВысотаТаблицы;
	ПоследняяКолонка 	= ТабДокумент.ШиринаТаблицы;
	ОбластьЯчеек 		= ТабДокумент.Область(1, 1, ПоследняяСтрока, ПоследняяКолонка); 
	// Создаем описание источника данных на основании области ячеек табличного документа.
	ИсточникДанных 		= Новый ОписаниеИсточникаДанных(ОбластьЯчеек);  
	// Создаем объект для интеллектуального построения отчетов,
	// указываем источник данных и выполняем построение отчета.
	ПостроительОтчета 	= Новый ПостроительОтчета; 
	ПостроительОтчета.ИсточникДанных 	= ИсточникДанных;
	ПостроительОтчета.Выполнить();
	// Результат выгружаем в таблицу значений.
	ТабЗначений 		= ПостроительОтчета.Результат.Выгрузить();
	
	Возврат ТабЗначений;
	
КонецФункции"}
},
{0,
{"Область ТД в ТЗ  (через ПостроительОтчета)",0,0,"","//Создать Таблицу значений из области Табличного документа

//Из макета будет выгружена область с именем ""ОбластьДанных"". По умолчанию первая строка области будет названием колонок ТЗ.
//Отмечу, что источником в построителе запроса является не Табличный документ, а Область Табличного документа.

Функция ПолучитьТЗИзМакета(ИмяМакета)
	МакетСправочника 	= ПолучитьМакет(ИмяМакета);
	ОбластьДанныхМакета = МакетСправочника.ПолучитьОбласть(""ОбластьДанных"");
	ТЗ 	= ПолучитьТаблицуИзОбластиМакета(ОбластьДанныхМакета.Область(1,1, ОбластьДанныхМакета.ВысотаТаблицы, ОбластьДанныхМакета.ШиринаТаблицы));
КонецФункции
//////////////////////////////////////////////////
Функция ПолучитьТаблицуИзОбластиМакета(ОбластьМакета)
	Построитель 	= Новый ПостроительЗапроса;
	ИсточникДанных 	= Новый ОписаниеИсточникаДанных(ОбластьМакета);
	Построитель.ИсточникДанных 	= ИсточникДанных;
	Построитель.Выполнить();
	ТабЗначений 	= Построитель.Результат.Выгрузить();
	Возврат ТабЗначений;
КонецФункции"}
}
}
},
{3,
{"Производительность",1,0,"",""},
{0,
{"ОценкаПроизводительностиКлиентСервер (устарело)",0,0,"","// Устарела. Будет удалена в следующей редакции библиотеки.
// Необходимо использовать
//		на сервере - ОценкаПроизводительности.НачатьЗамерВремени.
//		на клиенте - ОценкаПроизводительностиКлиент.НачатьЗамерВремени.
ОценкаПроизводительностиКлиентСервер.НачатьЗамерВремени(КлючеваяОперация);"}
},
{0,
{"ОценкаПроизводительности.НачатьЗамерВремени (Сервер)",0,0,"НЗВС","лЗамерВремениНачало 	= ОценкаПроизводительности.НачатьЗамерВремени(); //Начало типового замера времени на Сервере



ОценкаПроизводительности.ЗакончитьЗамерВремени(""<?""Ключевая операция (вроде слитно или с заглавными первыми буквами слов)"">"", лЗамерВремениНачало, , """"); //Конец типового замера времени на Сервере"}
},
{0,
{"ОценкаПроизводительностиКлиент.НачатьЗамерВремени (Клиент)",0,0,"НЗВК","ОценкаПроизводительностиКлиент.НачатьЗамерВремени(Истина, ""<?""Ключевая операция (вроде слитно или с заглавными первыми буквами слов)"">"");"}
}
},
{1,
{"Система взаимодействия (типовое)",1,0,"",""},
{0,
{"ОтправитьСообщениеАссистенту",0,0,"","// Процедура ОтправитьСообщениеАссистенту
//
// Параметры:
//  Ссылка	 		 - Ссылка 					- Ссылка на тот объект, в обсуждения которого нужно отправить сообщение 
//  Заголовок		 - Строка 					- Заголовок обсуждения 					
//  Текст			 - Строка 					- Текст сообщения
//  Получатель 		 - Справочник.Пользователи  - пользователь, которому нужно отправить сообщение
// 
//автор: Тюрин Н.А. 17.05.2019
Процедура ОтправитьСообщениеАссистенту(Ссылка, Заголовок, Текст, Получатель) Экспорт
	
	НавСсылка = ПолучитьНавигационнуюСсылку(Ссылка);
	
	УстановитьПривилегированныйРежим(Истина);
	
	ОтборОбсуждений = Новый ОтборОбсужденийСистемыВзаимодействия();
	ОтборОбсуждений.КонтекстноеОбсуждение = Истина;
	
	КонтекстОбсуждения = Новый КонтекстОбсужденияСистемыВзаимодействия(НавСсылка);
	ОтборОбсуждений.КонтекстОбсуждения = КонтекстОбсуждения;
	
	Обсуждения = СистемаВзаимодействия.ПолучитьОбсуждения(ОтборОбсуждений);
	
	Если Обсуждения.Количество() = 0 Тогда
		НовоеОбсуждение = СистемаВзаимодействия.СоздатьОбсуждение();
		НовоеОбсуждение.Заголовок = Заголовок;
		НовоеОбсуждение.КонтекстОбсуждения = КонтекстОбсуждения;
		НовоеОбсуждение.Записать();
		
		Идентификатор = НовоеОбсуждение.Идентификатор;
	Иначе
		Идентификатор = Обсуждения[0].Идентификатор;		
	КонецЕсли;
	
	Если Идентификатор <> Неопределено Тогда
		
		НовоеСообщение = СистемаВзаимодействия.СоздатьСообщение(Идентификатор);
		ПользовательИБ = ПользователиИнформационнойБазы.НайтиПоУникальномуИдентификатору(Получатель.ИдентификаторПользователяИБ);
		ПользовательСВ = СистемаВзаимодействия.ПолучитьИдентификаторПользователя(ПользовательИБ.УникальныйИдентификатор);
		Дуся = СистемаВзаимодействия.ПолучитьИдентификаторПользователя(Новый УникальныйИдентификатор(""9de7fcc9-9c1c-4bb1-9727-0e4ef1746469""));
		
		НовоеСообщение.Автор = Дуся;
		ПользователиИнформационнойБазы.ПолучитьПользователей();
		НовоеСообщение.Получатели.Добавить(ПользовательСВ);
		НовоеСообщение.Дата = ТекущаяДата();
		НовоеСообщение.Данные = НавСсылка;
		НовоеСообщение.Текст = Текст;
		НовоеСообщение.Записать();
	КонецЕсли;
		
	УстановитьПривилегированныйРежим(Ложь);
	
КонецПроцедуры"}
}
},
{1,
{"БСП",1,0,"",""},
{0,
{"Файлы",0,0,"","Простой запуск программ

ФайловаяСистема.ЗапуститьПрограмму(""calc"");

Сбор команды запуска и получение потока вывода stdout

ПараметрыЗапускаПрограммы = ФайловаяСистема.ПараметрыЗапускаПрограммы();
ПараметрыЗапускаПрограммы.ДождатьсяЗавершения = Истина;
ПараметрыЗапускаПрограммы.ПолучитьПотокВывода = Истина;

КомандаЗапуска = Новый Массив;
КомандаЗапуска.Добавить(""ping"");
КомандаЗапуска.Добавить(""127.0.0.1"");
КомандаЗапуска.Добавить(""-n"");
КомандаЗапуска.Добавить(5);

Результат = ФайловаяСистема.ЗапуститьПрограмму(КомандаЗапуска, ПараметрыЗапускаПрограммы);

ОбщегоНазначений.СообщитьПользователю(Результат.ПотокВывода);

Поместить выбранный на клиенте файл во временное хранилище

Оповещение = Новый ОписаниеОповещения(""ПослеЗагрузкиФайла"", ЭтотОбъект);
ПараметрыЗагрузки = ФайловаяСистемаКлиент.ПараметрыЗагрузкиФайла();
ПараметрыЗагрузки.ИдентификаторФормы = УникальныйИдентификатор;
ФайловаяСистемаКлиент.ЗагрузитьФайл(Оповещение, ПараметрыЗагрузки);

Сохранить файл на клиенте из временного хранилища

Оповещение = Новый ОписаниеОповещения(""ПослеСохраненияФайла"", ЭтотОбъект);
ФайловаяСистемаКлиент.СохранитьФайл(Оповещение, АдресВоВременномХранилище, ""МойФайл.файл"");

Открывает файл для просмотра или редактирования c диска клиента

ФайловаяСистемаКлиент.ОткрытьФайл(КаталогДокументов + ""МойФайл.файл"")

Открывает файл для просмотра или редактирования c временного хранилища

ФайловаяСистемаКлиент.ОткрытьФайл(АдресВоВременномХранилище, , ""МойФайл.файл"");

Открывает проводник c позиционирование курсора на файле.

ФайловаяСистемаКлиент.ОткрытьПроводник(""C:\Program Files\1cv8\common\1cestart.exe"")
ФайловаяСистемаКлиент.ОткрытьПроводник(""/home/"")

Открывает навигационную ссылку в программе, которая ассоциирована с протоколом навигационной ссылки.

ФайловаяСистемаКлиент.ОткрытьНавигационнуюСсылку(""e1cib/navigationpoint/startpage""); // начальная страница.
ФайловаяСистемаКлиент.ОткрытьНавигационнуюСсылку(""v8help://1cv8/QueryLanguageFullTextSearchInData"");
ФайловаяСистемаКлиент.ОткрытьНавигационнуюСсылку(""https://1c.ru"");
ФайловаяСистемаКлиент.ОткрытьНавигационнуюСсылку(""mailto:help@1c.ru"");
ФайловаяСистемаКлиент.ОткрытьНавигационнуюСсылку(""skype:echo123?call"");

Показывает диалог выбора каталога.

Оповещение = Новый ОписаниеОповещения(""ПослеВыбораКаталога"", ЭтотОбъект);
ФайловаяСистемаКлиент.ВыбратьКаталог(Оповещение);

Ну и немножко о внешних компонентах

Оповещение = Новый ОписаниеОповещения(""ПослеПодключенияКомпоненты"", ЭтотОбъект)
ОбщегоНазначенияКлиент.ПодключитьКомпонентуИзМакета(Оповещение, ""CryptS"", ""Обработка.ЗаявлениеНаВыпускНовогоКвалифицированногоСертификата.Макет.КомпонентаОбмена"");"}
}
},
{3,
{"Случайности (ГСЧ,  временные файлы-каталоги)",1,0,"",""},
{8,
{"ГСЧ",1,0,"",""},
{0,
{"ГСЧ",0,0,"ГСЧ","лГСЧ 				= Новый ГенераторСлучайныхЧисел();
лСлучайноеЧисло 	= лГСЧ.СлучайноеЧисло(0, 1);"}
},
{0,
{"Случайная строка",0,0,"","Функция ПолучитьСлучайнуюСтроку(пГСЧ = Неопределено, лКолСимволов = 1)
	
	Если пГСЧ = Неопределено Тогда
		лГСЧ 	= Новый ГенераторСлучайныхЧисел();
	Иначе
		лГСЧ 	= пГСЧ;
	КонецЕсли; 
	
	лСлучайнаяСтрока = """";
	Для Сч = 1 По лКолСимволов Цикл
		
		лСлучЧисло = лГСЧ.СлучайноеЧисло(0, 2) ;
		
		Если лСлучЧисло = 0 Тогда
			лСлучайнаяСтрока 	= лСлучайнаяСтрока + Символ(лГСЧ.СлучайноеЧисло(32, 126)); // Символ 32 - пробел, цифры, знаки, англ буквы
		ИначеЕсли лСлучЧисло = 1 Тогда
			лСлучайнаяСтрока 	= лСлучайнаяСтрока + Символ(лГСЧ.СлучайноеЧисло(1073, 1103)); // строчная кириллица
		Иначе
			лСлучайнаяСтрока 	= лСлучайнаяСтрока + Символ(лГСЧ.СлучайноеЧисло(1040, 1072)); // прописная кириллица
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат лСлучайнаяСтрока;
	
КонецФункции // ПолучитьСлучайнуюСтроку()"}
},
{0,
{"Случайная строка по шаблону",0,0,"","лГСЧ 	= Новый ГенераторСлучайныхЧисел(); 
лШаблон = ""фыв"";

RegExp 				= Новый COMОбъект(""VBScript.RegExp""); //Для 1C v 7.x: CreateObject(""VBScript.RegExp"") 
RegExp.IgnoreCase 	= Истина; //Игнорировать регистр 
RegExp.Global 		= Истина; //Поиск всех вхождений шаблона 
RegExp.MultiLine 	= Истина; //Многострочный режим 
RegExp.Pattern 		= лШаблон;

лСлучайнаяСтрока 	= """";
лЦиклов 			= 0;
Пока НЕ RegExp.Test(лСлучайнаяСтрока) И лЦиклов < 100000 Цикл
	
	лСлучайнаяСтрока 	= """";
	
	Для Сч = 1 По 10 Цикл
		
		лСлучЧисло 	= лГСЧ.СлучайноеЧисло(0, 2) ;
		
		Если лСлучЧисло = 0 Тогда
			лСлучайнаяСтрока 	= лСлучайнаяСтрока + Символ(лГСЧ.СлучайноеЧисло(33, 126)); // цифры, знаки, англ буквы
		ИначеЕсли лСлучЧисло = 1 Тогда
			лСлучайнаяСтрока 	= лСлучайнаяСтрока + Символ(лГСЧ.СлучайноеЧисло(1073, 1103)); // строчная кириллица
		Иначе
			лСлучайнаяСтрока 	= лСлучайнаяСтрока + Символ(лГСЧ.СлучайноеЧисло(1040, 1072)); // прописная кириллица
		КонецЕсли;
		
	КонецЦикла;
	
	лЦиклов 	= лЦиклов + 1;
	
КонецЦикла; 

Сообщить(лСлучайнаяСтрока);"}
},
{0,
{"Случайный пароль",0,0,"","Пароль = """";
ГСЧ = Новый ГенераторСлучайныхЧисел(Число(Формат(ТекущаяДата(), ""ДФ=yyyyMMddHHmmss"")));
МинимальнаяДлинаПаролейПользователей = ПолучитьМинимальнуюДлинуПаролейПользователей();
Если МинимальнаяДлинаПаролейПользователей = 0 Тогда
	МинимальнаяДлинаПаролейПользователей = 7;
КонецЕсли;    
Сч = 0;
Пока СтрДлина(Пароль) < МинимальнаяДлинаПаролейПользователей Цикл        
	Сч = Сч + 1;
	Если Сч <= 5 Тогда
		Пароль = Пароль + Символ(ГСЧ.СлучайноеЧисло(48, 57)); // цифры
	ИначеЕсли Сч = 6 Тогда
		Пароль = Пароль + Символ(ГСЧ.СлучайноеЧисло(1073, 1103)); // строчная кириллица
	ИначеЕсли Сч = 7 Тогда
		Пароль = Пароль + Символ(ГСЧ.СлучайноеЧисло(1040, 1072)); // прописная кириллица
	КонецЕсли;            
КонецЦикла;
"}
},
{0,
{"Варианты применения",0,0,"","Известный афоризм математика ORNL Роберта Кавью: «генерация случайных чисел слишком важна, чтобы оставлять её на волю случая».

Заполнение набора тестовых данных 
Генерация ШК 
Генерация коротких уникальных УИ 
Выборочный контроль сотрудников 
Расчет риска методом Монте-Карло 
Определение интервалов обращения к сервисам 
Одноразовые пароли 
Выбор аттестационных вопросов 
Азартные игры 
Эмуляция отчетности 
Розыгрыши 
Ключи шифрования 
Формирование недостающих документов 
Моделирование деятельности 
Генерация паролей 
Распределение накладных по водителям 
Моделирование отчетности 
Выбор исполнителя 
Выбор анекдота 
Диверсификация текстов 
Выбор клиентов для акций 
Выбор товаров для акций 
Розыгрыш премий 
Выбор товаров для стимулирования продаж 
Имитация ошибок и искажений информации 
Магический шар 
Криптография 
"}
},
{0,
{"ГСЧ без дубликатов",0,0,"","Массив 	= Новый Массив();
Для н = 1 по 20 Цикл
	
	Найден = Истина;
	Пока Найден Цикл
		ГСЧ 	= Новый ГенераторСлучайныхЧисел(ТекущаяУниверсальнаяДатаВМиллисекундах());
		Код 	= """";
		
		Для у = 1 по 10 Цикл
			
			Число 	= ГСЧ.СлучайноеЧисло(0, 9);
			Код 	= Код + Формат(Число,""ЧЦ=1; ЧН=0; ЧВН=; ЧГ=0"");
			
		КонецЦикла;
		
		Результат 	= Массив.Найти(Код);
		Если Результат = Неопределено Тогда
			Найден 	= Ложь;
			Массив.Добавить(Код);
		КонецЕсли; 
		
	КонецЦикла;
	
	Сообщить(Код);
	
КонецЦикла;    "}
},
{0,
{"Выбрать случайный элемент ТЧ",0,0,"ГСЧТ[абл]","лГСЧ 				= Новый ГенераторСлучайныхЧисел(); 
лСлучайноеЧисло 	= лГСЧ.СлучайноеЧисло(0, <?""Имя таблицы (слитно)"">.Количество() - 1); 

л<?""Имя таблицы (слитно)"">СлучЭлем 			= <?""Имя таблицы (слитно)"">[лСлучайноеЧисло].Наименование;"}
},
{0,
{"Выбрать случайный элемент массива",0,0,"ГСЧМ[асс]","лГСЧ 				= Новый ГенераторСлучайныхЧисел(); 
лСлучайноеЧисло 	= лГСЧ.СлучайноеЧисло(0, <?""Имя массива (слитно)"">.ВГраница()); 

л<?""Имя массива (слитно)"">СлучЭлем 			= <?""Имя массива (слитно)"">[лСлучайноеЧисло];"}
}
},
{0,
{"ПолучитьИмяВременногоФайла",0,0,"ПИВФ","ПолучитьИмяВременногоФайла"}
},
{0,
{"Случайное имя файла",0,0,"","лКаталогДляВыгрузкиФайла 	= ""C:\"";
лСлучИмя 	= СтрЗаменить(Строка(Новый УникальныйИдентификатор()), ""-"", """"); 	
лИмяФайла 	= лКаталогДляВыгрузкиФайла + лСлучИмя + "".txt"";

Попытка
	УдалитьФайлы(лИмяФайла);
Исключение
	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ОписаниеОшибки());
КонецПопытки;"}
}
},
{1,
{"Описание типов",1,0,"",""},
{0,
{"ОписаниеТипов Строка",0,0,"ОТСтр","Строка<?""Количество символов""> 	= Новый ОписаниеТипов(""Строка"", , Новый КвалификаторыСтроки(<?""Количество символов"">));"}
}
},
{5,
{"Доработки, правки (TODO, FIXME)",1,0,"",""},
{0,
{"Инфо (""Visual Studio Code"" и ""Todo Tree"")",0,0,"","Установить редактор ""Visual Studio Code"" и в нём поставить расширение ""Todo Tree"" - оно будет показывать текст по тегам TODO и FIXME."}
},
{0,
{"Доработки, TODO",0,0,"/тд","//TODO [АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy"">]: <?>"}
},
{0,
{"Доработки, TODO (русский ввод)",0,0,"/дор[абот]","//TODO [АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy"">]: <?>"}
},
{0,
{"Правки, FIXME",0,0,"/фм","//FIXME [АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy"">]: <?>"}
},
{0,
{"Правки, FIXME (русский ввод)",0,0,"/прав[к]","//FIXME [АйТи КучеровРМ <?"""", ДатаВремя, ""ДФ=dd.MM.yyyy"">]: <?>"}
}
},
{3,
{"OneScript (код 1С) через Visual Code Studio",1,0,"",""},
{0,
{"Файл отладки launch.json (должен лежать рядом с запускаемыми файлами *.os)",0,0,"","{
    // Используйте IntelliSense, чтобы узнать о возможных атрибутах.
    // Наведите указатель мыши, чтобы просмотреть описания существующих атрибутов.
    // Для получения дополнительной информации посетите: https://go.microsoft.com/fwlink/?linkid=830387
    ""version"": ""0.2.0"",
    ""configurations"": [
        {
            ""name"": ""Отладка 1Script"",
            ""type"": ""oscript"",
            ""request"": ""launch"",
            ""program"": ""${file}"",
            ""args"": [],
            ""cwd"": ""${workspaceRoot}"",
            ""runtimeExecutable"": null,
            ""debugPort"": 2801,
            ""protocol"": ""internal""
        }
    ]
}"}
},
{0,
{"Аргументы в launch.json (пример)",0,0,"","Аргумент может быть таким:
""args"": [
	""${file}"",
	""Аргумент1"",
	""Аргумент2""
],
"}
},
{0,
{"Расширения (Language 1C (BSL), OneScript)",0,0,"","//https://github.com/1c-syntax/vsc-language-1c-bsl/wiki/%D0%97%D0%B0%D0%BF%D1%83%D1%81%D0%BA-%D1%81%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D0%B2-.os-.bsl-%D1%81-%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E-OneScript
Language 1C (BSL) 	- Поддержка языка 1С:Предприятие 8 (BSL) в VSC

//https://marketplace.visualstudio.com/items?itemName=EvilBeaver.oscript-debug
OneScript Debug 	- Сервер отладки 1Script"}
}
},
{6,
{"PowerShell",1,0,"",""},
{0,
{"Работа с JSON-объектами в Powershell",0,0,"","Работа с JSON-объектами в Powershell
Википедия определяет JSON как

текстовый формат обмена данными, основанный на JavaScript… формат считается языконезависимым и может использоваться практически с любым языком программирования.

Если говорить более конкретно, то JSON позволяет описывать объекты, на подобие того как это делает xml, но намного проще.

По сути JSON-объекты представляют собой хеш-таблицу, допускающую вложенность.


Возьмём пример всё из той же Википедии:

Следующий пример показывает JSON-представление объекта, описывающего человека. В объекте есть строковые поля имени и фамилии, объект, описывающий адрес, и массив, содержащий список телефонов.

{
   ""firstName"": ""Иван"",
   ""lastName"": ""Иванов"",
   ""address"": {
       ""streetAddress"": ""Московское ш., 101, кв.101"",
       ""city"": ""Ленинград"",
       ""postalCode"": 101101
   },
   ""phoneNumbers"": [
       ""812 123-1234"",
       ""916 123-4567""
   ]
}
Для работы с JSON-объектами в Powershell начиная с версии 3.0 предусмотрены специальные командлеты:

PS C:\> Get-Command '*json'

CommandType    Name                              ModuleName
-----------    ----                              ----------
Cmdlet         ConvertFrom-Json                  Microsoft.PowerShell.Utility
Cmdlet         ConvertTo-Json                    Microsoft.PowerShell.Utility
Для создания JSON-объекта его описание в определённом формате нужно поместить в here-string (многострочную текстовую переменную). Звучит страшно, но самом деле всё просто: берём описание нашего объекта выше, помещаем его между символами @” и “@ (это и есть here-string) и скармливаем всё это командлету ConvertFrom-Json, который конвертирует JSON-отформатированные строки в объект:

$User = @""
{
   ""firstName"": ""Иван"",
   ""lastName"": ""Иванов"",
   ""address"": {
       ""streetAddress"": ""Московское ш., 101, кв.101"",
       ""city"": ""Ленинград"",
       ""postalCode"": 101101
   },
   ""phoneNumbers"": [
       ""812 123-1234"",
       ""916 123-4567""
   ]
}
""@ | ConvertFrom-Json
Вот и всё! Объект создан. Теперь можно обращаться к отдельным свойствам объекта любой вложенности:

PS C:\> $User.firstName
Иван
PS C:\> $User.address.city
Ленинград
PS C:\> $User.phoneNumbers[0]
812 123-1234
При помощи JSON-формата очень удобно сохранять в одном объекте информацию, полученную с разных объектов и разных типов. Рассмотрим ещё один пример:

$json = @""
{
  ""ServerName""        : ""$env:ComputerName"",
  ""UserName""          : ""$env:UserName"",
  ""ComputerInfo""      :
  {
    ""Manufacturer"": ""$((Get-WmiObject Win32_ComputerSystem).Manufacturer)"",
    ""Architecture"": ""$((Get-wmiObject Win32_OperatingSystem).OSArchitecture)"",
    ""SerialNumber"": ""$((Get-wmiObject Win32_OperatingSystem).SerialNumber)""
  },
  ""CollectionDate""    : ""$(Get-Date)""
 }
""@

$Info = ConvertFrom-Json -InputObject $json

Из созданного объекта достаём, интересующие свойства:

PS C:\> $Info.ServerName
SERVER
PS C:\> $Info.UserName
admin
PS C:\> $Info.ComputerInfo.Manufacturer
System manufacturer
PS C:\> $Info.CollectionDate
07/02/2014 15:05:00
PS C:\> $Info.ComputerInfo.Architecture
64-bit

 

Если же необходимо из готового объекта сделать JSON-форматированную строку следует использовать командлет ConvertTo-Json. Например:

$File = Get-ChildItem C:\Windows\System32\calc.exe
$File.VersionInfo | ConvertTo-Json
В результате получаем:

{
    ""Comments"":  """",
    ""CompanyName"":  ""Microsoft Corporation"",
    ""FileBuildPart"":  7600,
    ""FileDescription"":  ""Калькулятор Windows"",
    ""FileMajorPart"":  6,
    ""FileMinorPart"":  1,
    ""FileName"":  ""C:\\Windows\\System32\\calc.exe"",
    ""FilePrivatePart"":  16385,
    ""FileVersion"":  ""6.1.7600.16385 (win7_rtm.090713-1255)"",
    ""InternalName"":  ""CALC"",
    ""IsDebug"":  false,
    ""IsPatched"":  false,
    ""IsPrivateBuild"":  false,
    ""IsPreRelease"":  false,
    ""IsSpecialBuild"":  false,
    ""Language"":  ""Русский (Россия)"",
    ""LegalCopyright"":  ""© Корпорация Майкрософт. Все права защищены."",
    ""LegalTrademarks"":  """",
    ""OriginalFilename"":  ""CALC.EXE.MUI"",
    ""PrivateBuild"":  """",
    ""ProductBuildPart"":  7600,
    ""ProductMajorPart"":  6,
    ""ProductMinorPart"":  1,
    ""ProductName"":  ""Операционная система Microsoft® Windows®"",
    ""ProductPrivatePart"":  16385,
    ""ProductVersion"":  ""6.1.7600.16385"",
    ""SpecialBuild"":  """"
}

После создания JSON-строки, её можно легко отправить другому приложению. Наиболее частое  использование JSON – пересылка данных от сервера к браузеру. Обычно данные доставляются с помощью AJAX, который позволяет обмениваться данными между браузером и сервером без перезагрузки страницы.

JSON прост для понимания и использования, является очень гибким инструментом для передачи данных между приложениями (или даже компьютерами), а также подходит для сохранения и вывода различной информации."}
},
{0,
{"Получить производительность компьютера",0,0,"","$CpuLogFile = 'C:\Log\LogCPU_' + (Get-Date -Format ""yyyy-MM-dd"") + '.txt'
while (1) {
    $DateTime = (Get-Date -Format ""dd.MM.yyyy HH:mm:ss"")
    $DateTime >> $CpuLogFile
    $DateTime
    
    $CpuLoadAverage = (Get-WmiObject win32_processor | Measure-Object -property LoadPercentage -Average | Select Average ).Average
    
    $ProcessorStats = Get-WmiObject win32_processor
    $ComputerCpu = $ProcessorStats.LoadPercentage
    $ComputerCpu = ""{0:N2}"" -f $ComputerCpu
    # Lets create a re-usable WMI method for memory stats
    $OperatingSystem = Get-WmiObject win32_OperatingSystem
    # Lets grab the free memory
    $FreeMemory = $OperatingSystem.FreePhysicalMemory
    # Lets grab the total memory
    $TotalMemory = $OperatingSystem.TotalVisibleMemorySize
    # Lets do some math for percent
    $MemoryUsed = ($FreeMemory/ $TotalMemory) * 100
    $PercentMemoryUsed = ""{0:N2}"" -f $MemoryUsed

    # usedDiskSpaceDrives
    $usedDiskSpaceDrives = ''
    $driveLetters = Get-WmiObject Win32_Volume | select DriveLetter
    foreach ($driveLetter in $driveLetters)
    {
        $drive = Get-WmiObject Win32_Volume | where {$_.DriveLetter -eq $driveLetter.DriveLetter}
        
        $usedDiskSpace = $drive.Capacity - $drive.FreeSpace
        $usedDiskSpacePct = [math]::Round(($usedDiskSpace / $drive.Capacity) * 100,1)
        $usedDiskSpacePct = ""{0:N2}"" -f $usedDiskSpacePct
        $usedDiskSpaceDrives = $usedDiskSpaceDrives + $drive.Caption + '=' + $usedDiskSpacePct + '#'
    }

    # Lets throw them into an object for outputting
    $objHostInfo = New-Object System.Object
    $objHostInfo | Add-Member -MemberType NoteProperty -Name Name -Value $computer
    $objHostInfo | Add-Member -MemberType NoteProperty -Name CPULoadPercent -Value $ComputerCpu
    $objHostInfo | Add-Member -MemberType NoteProperty -Name CpuLoadAverage -Value $CpuLoadAverage
    $objHostInfo | Add-Member -MemberType NoteProperty -Name MemoryUsedPercent -Value $PercentMemoryUsed
    $objHostInfo | Add-Member -MemberType NoteProperty -Name usedDiskSpaceDrives -Value $usedDiskSpaceDrives

    $objHostInfoStr = 'ComputerCpu=' + $ComputerCpu + ';CpuLoadAverage=' + $CpuLoadAverage + ';PercentMemoryUsed=' + $PercentMemoryUsed + ';usedDiskSpaceDrives=' + $usedDiskSpaceDrives
    $objHostInfoStr >> $CpuLogFile
    $objHostInfoStr
    # Lets dump our info into an array
    #$objHostInfo >> $CpuLogFile

    #'CPU LoadPercentage Average    ' + $CpuLoad >> $CpuLogFile
    $Process = Get-Process | Sort-Object CPU -desc | Select-Object -first 5
    $Process >> $CpuLogFile
    $Process
    
    ''
    
    sleep 10
}
"}
},
{0,
{"Список самых: загрузка памяти компьютера (Top Memory Usage using)",0,0,"","Get Top Memory Usage using Powershell

$scripthost = Read-Host ""Enter the Hostname of the Computer you would like to check Memory Statistics for""
""""
""""
""===========CPU - Top 10 Utilization List===========""
gwmi -computername $scripthost Win32_PerfFormattedData_PerfProc_Process| sort PercentProcessorTime -desc | select Name,PercentProcessorTime | Select -First 10 | ft -auto
""===========Memory - Top 10 Utilization List===========""
gwmi -computername $scripthost Win32_Process | Sort WorkingSetSize -Descending | Select Name,CommandLine,@{n=""Private Memory(mb)"";Expression = {[math]::round(($_.WorkingSetSize / 1mb), 2)}} | Select -First 10 | Out-String   
#gwmi -computername $scripthost Win32_Process | Sort WorkingSetSize -Descending | Select Name,CommandLine,@{n=""Private Memory(mb)"";e={$_.WorkingSetSize/1mb}} | Select -First 10 | Out-String
#$fields = ""Name"",@{label = ""Memory (MB)""; Expression = {[math]::round(($_.ws / 1mb), 2)}; Align = ""Right""}; 

""===========Server Memory Information===========""
$fieldPercentage = @{Name = ""Memory Percentage in Use (%)""; Expression = { “{0:N2}” -f ((($_.TotalVisibleMemorySize - $_.FreePhysicalMemory)*100)/ $_.TotalVisibleMemorySize)}};     
$fieldfreeram = @{label = ""Available Physical Memory (MB)""; Expression = {[math]::round(($_.FreePhysicalMemory / 1kb), 2)}}; 
$fieldtotalram = @{label = ""Total Physical Memory (MB)""; Expression = {[math]::round(($_.TotalVisibleMemorySize / 1kb), 2)}}; 
$fieldfreeVram = @{label = ""Available Virtual Memory (MB)""; Expression = {[math]::round(($_.FreeVirtualMemory / 1kb), 2)}}; 
$fieldtotalVram = @{label = ""Total Virtual Memory (MB)""; Expression = {[math]::round(($_.TotalVirtualMemorySize /1kb), 2)}}; 
$memtotal = Get-WmiObject -Class win32_OperatingSystem -ComputerName $scripthost; 
$memtotal | Format-List $fieldPercentage,$fieldfreeram,$fieldtotalram,$fieldfreeVram,$fieldtotalVram;

+++
get-wmiobject WIN32_PROCESS | Sort-Object -Property ws -Descending|select -first 10|Select processname, @{Name=""Mem Usage(MB)"";Expression={[math]::round($_.ws / 1mb)}},@{Name=""ProcessID"";Expression={[String]$_.ProcessID}},@{Name=""UserID"";Expression={$_.getowner().user}}

++
get-process -computername $tag1 | Group-Object -Property ProcessName | 
    Format-Table Name, @{n='Mem (KB)';e={'{0:N0}' -f (($_.Group|Measure-Object WorkingSet -Sum).Sum / 1KB)};a='right'} -AutoSize
	
"}
},
{0,
{"Получить сетевую активность полученных и отправленных байтов (network activity bytes send and receive)",0,0,"","ms windows network activity bytes send and receive in command line

+++
In Powershell:

$computer 	= ""LocalHost""
$namespace 	= ""root\CIMV2""
$Tcpip_NI 	= Get-WmiObject -class Win32_PerfRawData_Tcpip_NetworkInterface -computername $computer -namespace $namespace
$Tcpip_NI | Select BytesReceivedPersec,BytesSentPersec,BytesTotalPersec

In cmd line using just wmic:

wmic path Win32_PerfRawData_Tcpip_NetworkInterface Get BytesReceivedPersec,BytesSentPersec,BytesTotalPersec

++
$ifIndex 	= Get-WmiObject -Class win32_ip4routetable | where {$_.destination -eq ""0.0.0.0""} | select -ExpandProperty InterfaceIndex
$ifIndex 	= ""InterfaceIndex="" + $ifIndex
$nic_name 	= Get-WmiObject -Class win32_networkadapterconfiguration -Filter $ifIndex | select -ExpandProperty Description
$nic 		= [System.Net.NetworkInformation.Networkinterface]::GetAllNetworkInterfaces() | where {($_.description -eq $nic_name) -and ($_.operationalstatus -eq ""up"")}
$stats 		= $nic.GetIPv4Statistics()
$bytesSent 	= $stats.BytesSent
$bytesReceived = $stats.BytesReceived

+
[System.Net.NetworkInformation.NetworkInterface]::GetAllNetworkInterfaces() | ForEach-Object {$_.GetIPv4Statistics()}

Информация о устройстве
PowerShell snippet to detect ethernet network speed in Windows
An easy to use PowerShell snippet to detect ethernet network speed in Windows Server (Core & Nano including) is:

wmic NIC where ""NetEnabled='true'"" get ""Name,Speed""
This prints out the name of the interface and configured speed, like:

PS C:\Users\janr> wmic NIC where ""NetEnabled='true'"" get ""Name,Speed""
Name                                    Speed
Broadcom NetXtreme Gigabit Ethernet #2  1000000000
You can also easily get the network adapter’s MAC address using:

wmic NIC where ""NetEnabled='true'"" get MACAddress
Did you know you can list all Hyper-V virtual machines MAC addresses easily with PowerShell?

That was easy, now wasn’t it?!  Of course you can also use PowerShell’s Get-NetAdapter cmdlet. The Get-NetAdapter cmdlet gets the basic network adapter properties, like:

PS C:\> (Get-NetAdapter -Name Ethernet).LinkSpeed
1 Gbps
You can lookup the available interfaces and its names with (Get-NetAdapter).Name"}
},
{0,
{"Сохранить и прочитать файл в 1С через PowerShell (WScript.Shell, Run)",0,0,"","ObjShell 		= Новый COMОбъект(""WScript.Shell"");
ПутьКФайлу 		= ПолучитьИмяВременногоФайла(""txt"");
Script 			= ПолучитьСкриптPowerShell(ПутьКФайлу);
ObjScriptRun 	= ObjShell.Run(""Powershell.exe -windowstyle hidden -Executionpolicy Bypass -nologo -noninteractive -comand "" + Script, 0, True);

ТекстовыйФайл.Прочитать(ПутьКФайлу);
лРезультатПроцессы 	= ТекстовыйФайл.ПолучитьТекст();

Файл 		= Новый Файл(ПутьКФайлу);
Если Файл.Существует() Тогда
	УдалитьФайлы(ПутьКФайлу);
КонецЕсли;"}
},
{2,
{"IP",1,0,"",""},
{0,
{"""пингуется"" ли указанный IP (через winmgmts, Win32_PingStatus, vbs)",0,0,"","Вариант №1: 
// Функция Avaible проверяет ""пингуется"" ли указанный IP
Function Avaible(IP) Export
	Try
		ServicesSet = GetCOMObject(""winmgmts:{impersonationLevel=impersonate}"");
		Items = ServicesSet.ExecQuery(""SELECT StatusCode from Win32_PingStatus WHERE address = '"" + IP + ""' AND Timeout=3"");
	Except
		Return Undefined;
	EndTry;
	For Each Item In Items Do
		If Item.StatusCode = 0 Then
			Return True;
		Else
			Return False;
		EndIf;
	EndDo;
EndFunction // Avaible()

Вариант №2: 
Function Avaible_2(IP) Export
	scrptCtrl = New COMObject(""MSScriptControl.ScriptControl"");
	scrptCtrl.language = ""vbscript"";
	scrptCtrl.addcode(""
	|Function Avaible()
	|Set objWMIService = GetObject(""""winmgmts:{impersonationLevel=impersonate}"""")
	|Set objPing = objWMIService.ExecQuery(""""select * from Win32_PingStatus where address = '"" + IP + ""'"""")
	|For Each objStatus in objPing
	|If IsNull(objStatus.StatusCode) Or objStatus.StatusCode <> 0 Then
	|   Avaible = 0
	|Else
	|   Avaible = 1
	|End If
	|Next
	|End function
	|"");
	Return ScrptCtrl.Run(""Avaible"");
EndFunction // Avaible_2()"}
},
{0,
{"IP (через winmgmts, Win32_NetworkAdapterConfiguration)",0,0,"","strComputer = "".""; 
objWMIService = ПолучитьCOMОбъект(""winmgmts:\\"" + strComputer + ""\root\CIMV2""); 
colItems = objWMIService.ExecQuery(""Select * from Win32_NetworkAdapterConfiguration Where IPEnabled=TRUE"",,48); 
Для Каждого objItem Из colItems Цикл 
	Сообщить(""----------------------------------- ""); 
	Сообщить(""Win32_NetworkAdapterConfiguration""); 
	Сообщить(""----------------------------------- ""); 
	Для Каждого Стр Из objItem.IPAddress Цикл 
		Сообщить(""IPAddress: "" + Стр); 
	КонецЦикла; 
КонецЦикла; "}
}
}
},
{8,
{"Директивы расширения (Перед, Вместо, После, ИзменениеИКонтроль)",1,0,"",""},
{0,
{"Директива расширения",0,0,"расш[ирение]","&<?"""", ВыборВарианта, ""Перед"", ""Перед"", ""Вместо"", ""Вместо"", ""После"", ""После"", ""ИзменениеИКонтроль"", ""ИзменениеИКонтроль"">(""<?""Название метода"">"")"}
},
{0,
{"Директива расширения Перед",0,0,"расшПе[ре]","&Перед(""<?""Название метода"">"")"}
},
{0,
{"Директива расширения Перед",0,0,"расшПо[сле]","&После(""<?""Название метода"">"")"}
},
{0,
{"Директива расширения Вместо",0,0,"расшВ[мес]","&Вместо(""<?""Название метода"">"")"}
},
{0,
{"Директива расширения ИзменениеИКонтроль",0,0,"расшИ[зм]","&ИзменениеИКонтроль(""<?""Название метода"">"")"}
},
{0,
{"Директива расширения Удаление",0,0,"расшУдал[ит]","#Удаление
<?>
#КонецУдаления"}
},
{0,
{"Директива расширения Вставка",0,0,"расшВст[авит]","#Вставка
<?>
#КонецВставки"}
},
{0,
{"Директива расширения Заменить",0,0,"расшЗам[ен]","#Удаление

#КонецУдаления
#Вставка
<?>
#КонецВставки"}
}
},
{10,
{"Шифрование",1,0,"",""},
{0,
{"Шифрование в 1С (большая статья)",0,0,"","Шифрование в 1С
При выборе метода шифрования необходимо исходить из правила - «Если стоимость взлома алгоритма выше, чем стоимость зашифрованных данных, вы,
скорее всего, в безопасности»
Брюс Шнайер. 
НЕМНОГО ТЕОРИИ
Существует два метода шифрования:

Симметричное шифрование - использует один и тот же ключ и для шифрования, и для дешифрования. Основная проблема этого метода заключается в том, что если вы хотите передать зашифрованное сообщение, то должны передать и ключ, который можно при передаче скомпрометировать.

Асимметричное шифрование - использует два разных ключа: один для шифрования (который также называется открытым), другой для дешифрования (называется
закрытым). Этот метод лишен недостатка предыдущего. Открытый ключ можно передать по открытым каналам.

Электронная цифровая подпись (ЭЦП) – это разновидность асимметричного шифрования, когда документ подписывается закрытым ключом, а достоверность документа проверяется открытым.
Хотя в реальности это выглядит несколько сложнее. Хэш-функцией создается хэш документа, который и подписывается закрытым ключом. Далее, эта подпись добавляется к документу.
При проверке подписи, хэш-функцией создается хэш проверяемого документа. Подпись, присоединенная при подписи, дешифруется открытым ключом. Сравниваются два хэша, если они равны, то все в порядке.

Сертификат безопасности – если упростить до предела, сертификат безопасности и является тем самым открытым ключом с дополнительной информацией. Обычно,
сертификаты располагаются в базах данных центров сертификации, которые и формируют из открытого ключа, сертификат. Эти центры отвечают за достоверность сертификатов.
На практике, если вы получили документ, подписанный ЭЦП, и хотите проверить подлинность подписи, необходимо проверить сертификат в центре сертификации и, если он действительно принадлежит отправителю и не просрочен, проверить целостность документа.
При отправке шифрованного сообщения, получаете сертификат получателя в центре, зашифруете сообщение открытым ключом из сертификата и отправляете получателю.
Поскольку создание сертификата и размещение в базе данных дело платное, можно создать временный сертификат. Это сертификат, который не удостоверен в центре сертификации, и его достоверность не может быть подтверждена кроме как вашим словом.
Каждая локальная машина под управлением любой ОС имеет свою локальную базу сертификатов. В Windows для просмотра сертификатов достаточно запустить консоль управления набрав в командной строке certmgr.msc, в Linux можно использовать апплет шифрования оболочки, хотя там возможностей больше.
Обычно сертификаты попадают в эту базу автоматически, когда используется шифрованное соединение вроде SSL, VPN и др., однако временный сертификат необходимо добавлять в ручную.

Криптопровайдер – из названия понятно, что это набор программных средств управляющих всем, что связанно с криптографией. Создание сертификатов, проверка сертификатов в центрах сертификации, шифрование, дешифрование и пр.

МЕТОДЫ ШИФРОВАНИЯ
В 1С возможны три варианта с помощью которых можно шифровать данные:

Шифрование методом встроенного объекта «МенеджерКриптографии».
Шифрование с использованием внешних компонент.
Шифрование непосредственно в 1С.
ШИФРОВАНИЕ МЕТОДОМ ВСТРОЕННОГО ОБЪЕКТА «МенеджерКриптографии».
Этот метод достаточно подробно описан в Синтакс-Помощнике. Поэтому я опишу только последовательность работы с ним.
Создаем объект МенеджерКриптографии.


Где ""Microsoft Enhanced Cryptographic Provider v1.0"" и есть тот самый криптопровайдер, а ""1"" тип который можно посмотреть в реестре.


Дальше еще проще, получаем из менеджера криптографии, хранилище сертификатов. Из хранилища получаем нужный сертификат.
При выборе сертификата лучше использовать серийный номер, так как он короче отпечатка, меньше вероятность ошибки. Поиск по наименованию субъекта необходимо делать с осторожностью, так как при создании нескольких сертификатов одним владельцем, наименования субъекта могут быть одинаковыми.
После того как сертификат получен, зашифровываем, дешифровываем, подписываем, проверяем подпись, в общем делаем все что необходимо.
В интернете имеются реализации, когда сертификат записывают в регистр, а оттуда извлекают их при необходимости. Проблема заключается в том, что все сертификаты имеют срок действия, и к тому же они могут быть перевыпущены в любой момент, в случае, когда закрытые ключи утеряны или скомпрометированы. Эти изменения придется отслеживать вручную.

ШИФРОВАНИЕ С ИСПОЛЬЗОВАНИЕМ ВНЕШНИХ КОМПОНЕНТ
Использование внешних компонент зависит от опыта и прихоти программиста. Есть множество бесплатных и платных реализаций.
Каждая из таких реализаций предусматривает наличие собственных методов управления ключами и алгоритмами шифрования, поэтому описывать хотя бы некоторые из них не имеет никакого смысла, так как каждый выберет реализацию по душе.
В качестве единственного примера реализации предлагаю статью «Шифрование
и защита информации в 1С:Предприятие 7.7/8.0/8.1/8.2», так как она использует широко распространённую платформу .Net Framework, в которой можно реализовать шифрование множеством алгоритмов.

ШИФРОВАНИЕ НЕПОСРЕДСТВЕННО В 1С
Чаще всего, бывают случаи, когда «танцы с бубнами» вокруг сертификатов абсолютно не нужны. Никто не будет заморачиваться покупкой сертификатов, а создание и отслеживание временных сертификатов, только добавляет «головной боли» программисту. К тому же необходимо всего лишь передать ведомость по зарплате в филиал или в документообороте создать персональную служебную записку.
Для этого можно реализовать достаточно надежный для этих целей алгоритм шифрования на встроенном языке.
Основными ограничениями в этом случае являются отсутствие в 1С методов для работы с двоичными данными и производительность платформы.
Обойти ограничения отсутствия методов двоичного счисления можно применив для работы алгоритма обычную десятичную математику.
С производительностью, к сожалению, ничего сделать нельзя. Все попытки существенно увеличить производительность при шифровании и дешифровании не привели к успеху, натыкаясь на ограничения платформы.

RSA для 1С
С теорией алгоритма RSA можно познакомиться здесь.
Основываясь именно на этом материале был реализован программный код состоящий всего из шести небольших функций.

// Функция проверяет является ли проверяемое число простым.
// Тест простоты (Перебор делителей).
// Параметры:
// 	- натуральное число.
// Возврат:
// 	- ИСТИНА - если число является простым.
&НаСервере
Функция ТестПростоты(ЧислоДляПроверки)
	Индекс = 2;
	Признак = 0;
	Пока ((Индекс * Индекс)  1) Цикл 
		ЦелаяЧасть = Цел(ЧислоДляПроверки/Индекс);
		Если (ЧислоДляПроверки/Индекс - ЦелаяЧасть) = 0 Тогда 
			Признак = 1;
		КонецЕсли;
		Индекс = Индекс + 1;
	КонецЦикла;
	Если Признак = 1 Тогда
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли;
КонецФункции
// Функция возвращает случайное простое число в заданном диапазоне.
// Параметры:
// 	- НижнийДиапазон - нижняя граница диапазона;
// 	- ВерхнийДиапазон - верхняя граница диапазона.
// Возврат:
// 	- случайное простое число.
&НаСервере
Функция ПолучитьПростоеЧисло(НижнийДиапазон, ВерхнийДиапазон, ЧислоИнициации)
	ГСЧ = Новый ГенераторСлучайныхЧисел(ЧислоИнициации);
	СлучайноеЧисло = ГСЧ.СлучайноеЧисло(НижнийДиапазон, ВерхнийДиапазон);
	Пока Не ТестПростоты(СлучайноеЧисло) Цикл 
		СлучайноеЧисло = ГСЧ.СлучайноеЧисло(НижнийДиапазон, ВерхнийДиапазон);
	КонецЦикла;
	ЧислоИнициации = ГСЧ.СлучайноеЧисло(НижнийДиапазон, ВерхнийДиапазон);
	Возврат СлучайноеЧисло;
КонецФункции
// Функция вычисляет взаимно простое число к заданному значению (Алгоритм Евклида).
// Параметры:
// 	- ЧислоОснова - число являющееся основой для поиска взаимно простых чисел.
// 	- ЧислоПоиска - число от которого начинается поиск взаимно простого числа.
// Возврат:
// 	- структура с взаимно простым числом и обратное число по модулю.
&НаСервере
Функция ПолучитьВзаимноПростыеЧисла(ЧислоОснова, ЧислоПоиска) 
	СтруктураВозврата = Новый Структура;
	Пока ЧислоПоиска  0 Цикл
			Частное = Делимое/Делитель;
			Остаток = Делимое - Делитель * Цел(Частное);
			Альфа = АльфаМинус2 - Цел(Частное) * АльфаМинус1;
			Вита = ВитаМинус2 - Цел(Частное) * ВитаМинус1;
			Если Остаток > 0 Тогда
				Делимое = Делитель;
				Делитель = Остаток;
			Иначе
				НаибольшийОбщийДелитель = Делитель;
			КонецЕсли;
			АльфаМинус2 = АльфаМинус1;
			АльфаМинус1 = Альфа;
			ВитаМинус2 = ВитаМинус1;
			ВитаМинус1 = Вита;
		КонецЦикла;
		Если НаибольшийОбщийДелитель = 1 И ВитаМинус2 > 0 Тогда //  
			СтруктураВозврата.Вставить(""НОД"", ЧислоПоиска);
			СтруктураВозврата.Вставить(""Вита"", ВитаМинус2);
			Возврат СтруктураВозврата;
		КонецЕсли;
		ЧислоПоиска = ЧислоПоиска + 1;
	КонецЦикла;
	Возврат ПолучитьВзаимноПростыеЧисла(ЧислоОснова, Цел(ЧислоПоиска/2));
КонецФункции
// Функция формирует закрытый и открытый ключ.
// Возврат:
// 	- структура с набором ключей, открытый-(e, n) и закрытый-(d, n).
&НаСервере
Функция СформироватьКлючи() Экспорт
	// Управление разрядностью ключа
	ВерхняяГраница = 100;
	НижняяГраница = 32;
	ЧислоИнициации = (Год(ТекущаяДата()) + Месяц(ТекущаяДата()) + День(ТекущаяДата()))*(Час(ТекущаяДата())+Минута(ТекущаяДата())+Секунда(ТекущаяДата()));
	// p
	ЧастьПи = ПолучитьПростоеЧисло(НижняяГраница, ВерхняяГраница, ЧислоИнициации);
	// q
	ЧастьКью = ЧастьПи;
	Пока ЧастьКью = ЧастьПи Цикл
		ЧастьКью = ПолучитьПростоеЧисло(НижняяГраница, ВерхняяГраница, ЧислоИнициации);
	КонецЦикла;
	// n
	ЧастьЭн = ЧастьПи * ЧастьКью;
	// Вычисляем функцию Эйлера.
	ЗначениеЭйлера = (ЧастьПи - 1) * (ЧастьКью - 1);
	// Вычисляем случайное взаимно простое чисело.
	ГСЧ = Новый ГенераторСлучайныхЧисел(ЗначениеЭйлера);
	СлучайноеЧисло = ГСЧ.СлучайноеЧисло(1, ЗначениеЭйлера);
	// e, d
	СтруктураЗначений = ПолучитьВзаимноПростыеЧисла(ЗначениеЭйлера, СлучайноеЧисло);
	ЧастьЕ = СтруктураЗначений.НОД;
	ЧастьД = СтруктураЗначений.Вита;
	// Собираем готовые ключи
	СтруктураВозврата = Новый Структура;
	СтруктураКлюча = Новый Структура;
	СтруктураКлюча.Вставить(""ЧастьЕ"", ЧастьЕ);
	СтруктураКлюча.Вставить(""ЧастьЭн"", ЧастьЭн);
	СтруктураВозврата.Вставить(""ОткрытыйКлюч"", ЗначениеВСтрокуВнутр(СтруктураКлюча));
	СтруктураКлюча = Новый Структура;
	СтруктураКлюча.Вставить(""ЧастьЭн"", ЧастьЭн);
	СтруктураКлюча.Вставить(""ЧастьД"", ЧастьД);
	СтруктураВозврата.Вставить(""ЗакрытыйКлюч"", ЗначениеВСтрокуВнутр(СтруктураКлюча));
	Возврат СтруктураВозврата;
КонецФункции
// Функция шифрует текст с использованием открытого ключа.
// Параметры:
// 	- текст подлежащий шифрованию;
// 	- открытый ключ.
// Возврат:
// 	- шифротекст в виде строки чисел через "";"".
&НаСервере
Функция Шифрование(ШифруемыйТекст, ОткрытыйКлюч) Экспорт
	СтрокаВозврата = """";
	СтруктураКлюча = ЗначениеИзСтрокиВнутр(ОткрытыйКлюч);
	Для Индекс = 1 По СтрДлина(ШифруемыйТекст) Цикл
		Код = КодСимвола(ШифруемыйТекст, Индекс);
		Степень = Pow(Код, СтруктураКлюча.ЧастьЕ);
		Шифрокод = Степень - СтруктураКлюча.ЧастьЭн * Цел(Степень / СтруктураКлюча.ЧастьЭн);
		СтрокаВозврата = СтрокаВозврата + Шифрокод + "";""
	КонецЦикла;
	Возврат СтрокаВозврата;
КонецФункции
// Функция дешифрует текст с использованием закрытого ключа.
// Параметры:
// 	- шифротекст;
// 	- закрытый ключ.
// Возврат:
// 	- дешифрованный текст.
&НаСервере
Функция Дешифрование(Шифротекст, ЗакрытыйКлюч) Экспорт
	СтрокаВозврата = """";
	СтруктураКлюча = ЗначениеИзСтрокиВнутр(ЗакрытыйКлюч);
	СтрШифрокод = """";
	Для Индекс = 1 По СтрДлина(Шифротекст) Цикл
		Если Сред(Шифротекст, Индекс, 1) = "";"" Тогда 
			Шифрокод = Число(СтрШифрокод);
			Степень = Pow(Шифрокод, СтруктураКлюча.ЧастьД);
			Код = Степень - СтруктураКлюча.ЧастьЭн * Цел(Степень / СтруктураКлюча.ЧастьЭн);
			СтрокаВозврата = СтрокаВозврата + Символ(Код);
			СтрШифрокод = """";
		Иначе 
			Если Не Сред(Шифротекст, Индекс, 1) = "" "" Тогда
				СтрШифрокод = СтрШифрокод + Сред(Шифротекст, Индекс, 1);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Возврат СтрокаВозврата;
КонецФункции
Функции расположены в модуле объекта обработки «ОбменСообщениями» из демонстрационного примера |File: demo.zip - Hash: MD5 - 63AF4F485464C863D6B626BAEC44C6C0|.
Демонстрационный пример представляет из себя средство обмена сообщениями между пользователями 1С.


Открытые ключи и содержания сообщений хранятся в базе данных, а закрытые, локально у пользователей. При этом содержание сообщений хранится в регистре в зашифрованном виде.


Алгоритм RSA был разработан еще в 1977 г. В 2003 г. Ади Шамир и Эран Тромер разработали схему устройства TWIRL, которое при стоимости $ 10 000 может дешифровать 512-битный ключ за 10 минут, а при стоимости $ 10 000 000 – 1024-битный ключ меньше, чем за год.
Однако этот алгоритм используется и до настоящего времени с рекомендуемой длинной ключа 2048 бит.
В нашем же случае используется ключ примерно в 14 бит, увеличить длину ключа можно увеличив период диапазона.

// Управление разрядностью ключа
ВерхняяГраница = 100;
НижняяГраница = 32;
Однако значительное увеличение, резко замедляет процесс шифрования и дешифрования."}
},
{0,
{"Симметричное шифрование в 1С",0,0,"","Симметричное шифрование в 1С
Наверно, многие из разработчиков когда-нибудь сталкивались с необходимостью зашифровать данные в 1С. Однажды и я столкнулся с этой проблемой. В сети предлагается множество способов организации шифрования сторонними методами, я же хотел бы рассмотреть шифрование встроенными методами.

В данной статье рассматривается шифрование строк. Разбираемые алгоритмы применимы к любым значениям, которые возможно преобразовать в строку и обратно. Например, таблицу значений можно преобразовать в строку методом ЗначениеВСтрокуВнутр и методом ЗначениеИзСтрокиВнутр получить обратно таблицу значений.

В 1С есть два встроенных варианта использования шифрования:

1. Использование электронной подписи (асимметричное шифрование) имеет сложный механизм применения - в настоящей статье не рассматривается.

2. Использование запароленного zip-архива (симметричное шифрование) - рассматривается в настоящей статье.

Для анализа использования алгоритма приведу примеры универсальных функций, выполняющих шифрование и дешифровку данных (функции выполняются на сервере):

Функция ПолучитьЗашифрованныеДанные(ДанныеШифрования,КлючШифрования,ИдентификаторДанных = ""0"") Экспорт
    
    Попытка
        
        Путь = КаталогВременныхФайлов()+""\""+ИдентификаторДанных;
        ПутьФайла = Путь+"".txt"";
        ПутьАрхива = Путь+"".zip"";
        ЗаписьТекста = Новый ЗаписьТекста(ПутьФайла);
        ЗаписьТекста.Записать(ДанныеШифрования);
        ЗаписьТекста.Закрыть();
        ЗаписьАрхива = Новый ЗаписьZipФайла(ПутьАрхива,КлючШифрования,,,,МетодШифрованияZIP.AES256);
        ЗаписьАрхива.Добавить(ПутьФайла);
        ЗаписьАрхива.Записать();
        ДвоичныеДанные = Новый ДвоичныеДанные(ПутьАрхива);
        ХранилищеДанных = Новый ХранилищеЗначения(ДвоичныеДанные,Новый СжатиеДанных(9));
        УдалитьФайлы(ПутьФайла);
        УдалитьФайлы(ПутьАрхива);
        Возврат ХранилищеДанных;
        
    Исключение
        Возврат Неопределено;
    КонецПопытки; 

КонецФункции

Функция ПолучитьРасшифрованныеДанные(ХранилищеДанных,КлючШифрования,ИдентификаторДанных = ""0"") Экспорт
    
    Попытка
        КаталогСохранения = КаталогВременныхФайлов();
        Путь = КаталогСохранения+""\""+ИдентификаторДанных;
        ПутьАрхива = Путь+"".zip"";
        ХранилищеДанных.Получить().Записать(ПутьАрхива);
        ЧтениеАрхива = Новый ЧтениеZipФайла(ПутьАрхива,КлючШифрования);
        ЭлементАрхива = ЧтениеАрхива.Элементы[0];
        ЧтениеАрхива.Извлечь(ЭлементАрхива,КаталогСохранения);
        ЧтениеАрхива.Закрыть();
        ПутьФайла = КаталогСохранения+""\""+ЭлементАрхива.Имя;
        ЧтениеТекста = Новый ЧтениеТекста(ПутьФайла);
        Данные = ЧтениеТекста.Прочитать();
        ЧтениеТекста.Закрыть();
        УдалитьФайлы(ПутьАрхива);
        УдалитьФайлы(ПутьФайла);
        Возврат Данные;
        
    Исключение
        Возврат Неопределено;
    КонецПопытки; 

КонецФункции

 
Функция ПолучитьЗашифрованныеДанные возвращает хранилище значения с зашифрованными двоичными данными.

Параметры функции:

ДанныеШифрования - Строка для зашифровки;

КлючШифрования - Ключ симметричного шифрования (пароль zip-архива);

ИдентификаторДанных - Строка - Произвольное идентификационное значение (необязательный параметр)

Механизм шифрования заключается в следующей последовательности действий:

Шифруемая строка записывается в текстовый файл
Текстовый файл помещается в архив с паролем (метод шифрования можно выбрать, в данном случае используется AES-256)
Записанный архив в зашифрованном виде переводится в двоичные данные
Двоичные данные помещаются в хранилище значения, которое возвращается функцией (в дальнейшем, хранилище значения можно поместить в реквизит какого-либо объекта или регистра и хранить в СУБД до появления необходимости в расшифровке)
Созданные файлы удаляются
Функция ПолучитьРасшифрованныеДанные возвращает расшифрованное строковое значение.

Параметры функции:

ХранилищеДанных -Хранилище значения с зашифрованными данными (значение возвращенное функцией ПолучитьЗашифрованныеДанные);

КлючШифрования - Ключ сииметричного шифрования (пароль zip-архива; такой же, как для функции ПолучитьЗашифрованныеДанные);

ИдентификаторДанных - Строка - Произвольное идентификационное значение (необязательный параметр)

Механизм дешифрования заключается в следующей последовательности действий:

Из зашифрованного хранилища значения извлекаются двоичные данные
Двоичные данные записываются в файл (это должен быть зашифрованный zip-архив)
Из zip-архива извлекается текстовый файл с расшифрованным строковым значением
Из текстового файла считывается расшифрованное строковое значение, которое возвращается данной функцией
Созданные файлы удаляются
Изложил свой опыт работы с симметричным шифрованием в 1С.

Надеюсь, будет кому-нибудь полезен."}
},
{0,
{"SHA256 (через MSScriptControl.ScriptControl, JScript)",0,0,"","// Сформируем финансовый токен
ХэшФинансовогоТокена = ""123"";
// Получим хэш финансового токена
ScrptCtrl 			= Новый COMОбъект(""MSScriptControl.ScriptControl"");
ScrptCtrl.Language 	= ""JScript""; 
ScrptCtrl.AddCode(""Текст"");
ХэшФинансовогоТокена 	= ScrptCtrl.Eval(""SHA256('"" + ХэшФинансовогоТокена + ""')"");"}
},
{0,
{"ХешированиеДанных",0,0,"","Хеширование 	= Новый ХешированиеДанных(ХешФункция.SHA256);
Хеширование.Добавить(masterToken + str(operationNum) + usedMethod + login);
financeToken 	= Строка(Хеширование.ХешСумма);"}
},
{0,
{"Шифрование строковых данных. Менеджер криптографии",0,0,"","Шифрование строковых данных. Менеджер криптографии.
Просмотр криптопровайдеров ОС Windows. Инициализация менеджера криптографии.
Шифрование строковых данных с помощью CAPICOM.EnvelopedData
Шифрование строковых данных с помощью CAPICOM.EncryptedData

Шифрование - обратимое преобразование некой информации с целью сокрытия от неавторизованных лиц и, в это же время, предоставление, авторизованным пользователям доступа к ней. Главная задача шифрования - это соблюдение конфиденциальности передаваемой информации.

Методы шифрования:
Симметричное шифрование - использует один и тот же ключ и для зашифрования, и для расшифрования;
Асимметричное шифрование - использует два разных ключа: один для зашифрования (который также называется открытым), другой для расшифрования (называется закрытым).
Объект МенеджерКриптографии платформы 1С позволяет шифровать данные, используя симметричное шифрование, так как криптопровайдеры ОС Windows используют данный вид шифрования (RC2, RC4).

Создание временного сертификата

Для использования шифрования необходимо иметь сертификат. Создание сертификата описано в статье Создание временного сертификата для использования во время разработки. Сертификат необходимо создавать с параметром -sky exchange, иначе расшифрование сообщения будет завершаться ошибкой ""Модуль криптографии не поддерживает установку пароля к закрытому ключу"".

1. Ошибка установки пароля к закрытому ключу
Так же желательно создавать сертификат с параметром -sp, который позволит задать имя криптопровайдера для сертификата, например, ""Microsoft Strong Cryptographic Provider"", так как для инициализации объекта МенеджерКриптографии требуется в конструкторе указывать имя криптопровайдера (имя модуля провайдера).

Пример создания временного сертификата для тестирования шифрования в 1С:
makecert.exe -r -pe -n CN=""www.example.com"" -ss my -sr currentuser
-sky exchange -sp ""Microsoft Strong Cryptographic Provider""


2. Создание временного сертификата
Внимание: пароль на контейнер закрытого ключа при создании сертификата в данном случае не устанавливается!

Реализация шифрования

Функция шифрования строковых данных:
// Функция выполняет шифрование строковых данных.
//
// Параметры
//  СтроковыеДанные  - Строка - данные для шифрования;
//  Отпечаток  - Строка - отпечаток сертификата закодированный в Base64;
//  ИмяКП  - Строка - имя модкля криптографии;
//  ТипКП  - Строка - Тип модуля криптографии.
//
// Возвращаемое значение:
//   Строка   - зашифрованный данные формата PKCS#7 закодированные в Base64.
//
&НаКлиенте
Функция ЗашифроватьСтроку(СтроковыеДанные, Отпечаток, ИмяКП, ТипКП)
 
 ИмяВременногоФайла = ПолучитьИмяВременногоФайла();
 ЗаписьТекста = Новый ЗаписьТекста(ИмяВременногоФайла, ""CESU-8"");
 ЗаписьТекста.Записать(СтроковыеДанные);
 ЗаписьТекста.Закрыть();

 МенеджерКриптографии = Новый МенеджерКриптографии(ИмяКП, """", ТипКП);
 ХранилищеСертификатов = МенеджерКриптографии.ПолучитьХранилищеСертификатов(
  ТипХранилищаСертификатовКриптографии.ПерсональныеСертификаты,
  РасположениеХранилищаСертификатовКриптографии.ДанныеПользователяОС);
 Сертификат = ХранилищеСертификатов.НайтиПоОтпечатку(Base64Значение(Отпечаток));
 
 ЗашифрованныеДанные = МенеджерКриптографии.Зашифровать(ИмяВременногоФайла, Сертификат);
 
 УдалитьФайлы(ИмяВременногоФайла);
 
 Возврат Base64Строка(ЗашифрованныеДанные);

КонецФункции // ЗашифроватьСтроку()


В данной функции строковые данные записываются в файл в кодировке CESU-8, т.е. UTF-8 без BOM. Инициализируется менеджер криптографии и по отпечатку происходит поиск сертификата в хранилище сертификатов текущего пользователя в ветке Личное.

3. Личные сертификаты текущего пользователя
Далее происходит шифрование строковых данных, используя найденный сертификат, тем самым, расшифрование сможет произвести тот пользователь, который имеет доступ к закрытому ключу этого сертификата. Результатом шифрования являются двоичные данные, которые кодируются в строку Base64. Двоичные данные имеют формат PKCS#7.

Функция расшифрования строковых данных:
// Функция выполняет расшифровку строковых данных.
//
// Параметры
//  ЗашифрованныеДанные  - Строка - зашифрованный данные формата PKCS#7 закодированные в Base64;
//  Отпечаток  - Строка - отпечаток сертификата закодированный в Base64;
//  ПарольЗакрытогоКлюча  - Строка - пароль к контейнеру закрытого ключа;
//  ИмяКП  - Строка - имя модкля криптографии;
//  ТипКП  - Строка - Тип модуля криптографии.
//
// Возвращаемое значение:
//   Строка   - расшифрованные строковые данные.
//
&НаКлиенте
Функция РасшифроватьСтроку(ЗашифрованныеДанные, Отпечаток, ПарольЗакрытогоКлюча, ИмяКП, ТипКП)

 МенеджерКриптографии = Новый МенеджерКриптографии(ИмяКП, """", ТипКП); 
 МенеджерКриптографии.ПарольДоступаКЗакрытомуКлючу = ПарольЗакрытогоКлюча;
 
 РасшифрованныеДанные = МенеджерКриптографии.Расшифровать(Base64Значение(ЗашифрованныеДанные));
 
 ИмяВременногоФайла = ПолучитьИмяВременногоФайла();
 РасшифрованныеДанные.Записать(ИмяВременногоФайла); 
 ЧтениеТекста = Новый ЧтениеТекста(ИмяВременногоФайла, ""CESU-8"");
 СтрокаДанных = ЧтениеТекста.Прочитать();
 ЧтениеТекста.Закрыть();
 
 УдалитьФайлы(ИмяВременногоФайла);
 
 Возврат СтрокаДанных;

КонецФункции // РасшифроватьСтроку()


В данной функции инициализируется менеджер криптографии и указывается пароль к контейнеру закрытого ключа. Далее происходит расшифровка зашифрованных данных. Результатом расшифрования являются двоичные данные, которые записываются в файл с кодировкой CESU-8 и считываются из него.

Скачать обработку шифрования/расшифрования строковых данных можно по этой ссылке.

Пример работы обработки:

4. Шифрование и расшифрование сообщения
На рисунке 4 поле ""Пароль"" пустое, так как при создании временного сертификата мы не указывали пароль на контейнер закрытого ключа."}
},
{0,
{"Шифрование строковых данных с помощью CAPICOM.EncryptedData",0,0,"","Шифрование строковых данных с помощью CAPICOM.EncryptedData
Шифрование строковых данных. Менеджер криптографии.
Просмотр криптопровайдеров ОС Windows. Инициализация менеджера криптографии.
Шифрование строковых данных с помощью CAPICOM.EnvelopedData

Шифрование с помощью объекта EncryptedData библиотеки CAPICOM является самым простым в реализации, так как в данном случае не требует сертификатов и всего что с ними связано в отличии от объекта EnvelopedData и объекта МенеджераКриптографии языка 1С.

EncryptedData - объект, который предоставляет разработчику свойства и методы для шифрования/дешифрования некой информации с использованием секретного ключа. Этот объект поддерживает следующие симметричные алгоритмы: RC2, RC4, DES, 3DES. Общая схема симметричного шифрования:

1. Симметричное шифрование
Методы объекта:
Decrypt - выполняет дешифрование данных, используя секретный ключ;
Encrypt - выполняет шифрование данных, с применением секретного ключа;
SetSecret - устанавливает секретный ключ.
Свойства объекта:
Algorithm - алгоритм. используемый для шифрования/дешифрования;
Content - содержит данные для шифрования либо дешифрованные данные.

Функция шифрования:
// Функция выполняет шифрование строковых данных.
//
// Параметры
//  СтроковыеДанные  - Строка - данные для шифрования;
//  СекретныйКлюч  - Строка - ключ, при помощи которого производится дешифрование;
//
// Возвращаемое значение:
//   Строка   - зашифрованный данные закодированные в Base64.
//
Функция ЗашифроватьСтроку(Знач СтроковыеДанные, СекретныйКлюч)
 
 // Константы.
 ECAPICOM_ENCRYPTION_KEY_LENGTH_MAXIMUM = 0; // Максимальная длина ключа.
 CAPICOM_ENCRYPTION_ALGORITHM_RC4 = 1;  // Симметричный алгоритм шифрования RC4.
 CAPICOM_ENCODE_BASE64 = 0;     // Результат шифрование вернуть в формате Base64.
 
 // Инициализируем объект EncryptedData, задач длину ключа, алгоритм и данные для шифрования.
 EncryptedData = Новый COMОбъект(""CAPICOM.EncryptedData"");
 EncryptedData.Algorithm.KeyLength = ECAPICOM_ENCRYPTION_KEY_LENGTH_MAXIMUM;
 EncryptedData.Algorithm.Name = CAPICOM_ENCRYPTION_ALGORITHM_RC4;
 EncryptedData.Content = СтроковыеДанные; // нет времени кодировать в UTF-8.
 
 // Установим секретный ключ.
 EncryptedData.SetSecret(СекретныйКлюч);
 
 // Шифруем данные.
 Возврат EncryptedData.Encrypt(CAPICOM_ENCODE_BASE64);

КонецФункции // ЗашифроватьСтроку()

Функция дешифрования:
// Функция выполняет расшифровку строковых данных.
//
// Параметры
//  ЗашифрованныеДанные  - Строка - зашифрованный данные закодированные в Base64;
// СекретныйКлюч  - Строка - ключ, которым производилось шифрование.
//
// Возвращаемое значение:
//   Строка   - расшифрованные строковые данные.
//
Функция РасшифроватьСтроку(Знач ЗашифрованныеДанные, СекретныйКлюч)
 
 // Инициализируем объект EnvelopedData и выполняем дешифрацию.
 EncryptedData = Новый COMОбъект(""CAPICOM.EncryptedData"");
 EncryptedData.SetSecret(СекретныйКлюч);
 EncryptedData.Decrypt(ЗашифрованныеДанные);
 
 Возврат EncryptedData.Content;

КонецФункции // РасшифроватьСтроку()

Обработку можно скачать по этой ссылке.

2. Пример работы обработки
Как устанавливается библиотека CAPICOM и почему не стоит ею злоупотреблять описано в статье Вычисление хэш-сумм MD, SHA при помощи CAPICOM."}
},
{0,
{"Вычисление хэш-сумм MD, SHA при помощи CAPICOM",0,0,"","Вычисление хэш-сумм MD, SHA при помощи CAPICOM
Вычисление хэш-суммы по алгоритму SHA-512
Вычисление хэш-суммы по алгоритму MD5
Вычисление хэш-суммы по алгоритму ГОСТ Р 34.11-94

Установка CAPICOM

Компания Microsoft не советует использовать библиотеку CAPICOM, но без её COM-объектов обойтись трудно. Первым делом необходимо скачать Platform SDK CAPICOM. Этот пакет содержит свободно распространяемые файлы компоненты CAPICOM 2.1.0.1 и примеры её использования. CAPICOM можно использовать для электронной подписи данных и её проверки, хэширования данных, шифрования и расшифровки данных и т.д. После запуска скачанного пакета мастер установки произведет копирование файлов компоненты в указанную папку. В папке ...\Microsoft CAPICOM 2.1.0.2 SDK\Lib\X86 находится файл CAPICOM.dll который нужно зарегистрировать в системе, для этого запустите командную строку от имени администратор и выполните команду regsvr32 CAPICOM.dll:

Регистрация библиотеки CAPICOM
На этом установка закончена, можно приступать к использованию COM-объектов библиотеки CAPICOM в конфигурации :)

Реализация вычисления хэш-суммы

После регистрации библиотеки capicom.dll становится доступен COM-объект HashedData, у которого ProgID = CAPICOM.HashedData.1. Этот объект имеет метод Hash, в который будем передавать строку, и два свойства. Через свойство Algorithm указываем алгоритм вычисления хэш-суммы, а через свойство Value будем получать результат вызова метода Hash. Перед передачей строки в метод Hash производим приведение строки к кодировке UTF-8.

Список поддерживаемых алгоритмов и их значения (Algorithm):
SHA1 - CAPICOM_HASH_ALGORITHM_SHA1 (0);
MD2 - CAPICOM_HASH_ALGORITHM_MD2 (1);
MD4 - CAPICOM_HASH_ALGORITHM_MD4 (2);
MD5 - CAPICOM_HASH_ALGORITHM_MD5 (3);
SHA-256 - CAPICOM_HASH_ALGORITHM_SHA_256 (4);
SHA-384 - CAPICOM_HASH_ALGORITHM_SHA_384 (5);
SHA-512 - CAPICOM_HASH_ALGORITHM_SHA_512 (6).
Функция вычисления хэш-суммы на языке 1С:
// Функция вычисляет хэш-сумму по алгоритмам SHA и MD.
//
// Параметры
//  Строка  - Строка - исходная строка;
// Алгоритм - Число - алгоритм, по которому вычисляется хэш-сумма.
//
// Возвращаемое значение:
//   Строка   - хэш-сумма в виде N-символьной строке в шестнадцатеричном формате.
//
&НаСервереБезКонтекста
Функция ВычислитьХэшСумму(Строка, Алгоритм) Экспорт
 
 HashedData = Новый COMОбъект(""CAPICOM.HashedData.1"");
 // Указываем алгоритм хэширования.
 HashedData.Algorithm = Алгоритм;
 // Передаем данные, строку кодируем в последовательность байтов UTF-8.
 UTF8Encoding = Новый COMОбъект(""System.Text.UTF8Encoding"");
 HashedData.Hash(UTF8Encoding.GetBytes_4(Строка));
 
 // Возвращаем вычисленную хэш-сумму.
 Возврат HashedData.Value;

КонецФункции // ВычислитьХэшСумму()


Результат работы функции:

Хэш-сумма по алгоритму MD5 от значения 123
Хэш-сумма представляется в видет N-символьной строки в шестнадцатеричном виде.
Обработку можно скачать по этой ссылке.

Минус данной реализации таков: Microsoft  уходит от поддержки библиотеки CAPICOM и требуется установка данной библиотеки (если код будет выполняться на сервере, то у становка требуется только на машине, где установлен сервер 1С:Предприятие)"}
},
{0,
{"Обработка по шифрованию и расшифровке строковых полей справочников модифицированным методом Виженера",0,0,"","Обработка по шифрованию и расшифровке строковых полей справочников модифицированным методом Виженера - реализация без внешних компонент, без com-объектов, чистый 1С.
Хочу поделиться примером реализации обработки по шифрованию/расшифровке произвольных текстовых полей справочников. Требования перед разработкой я поставил следующие:

Должен быть реализован функционал шифрования и расшифровки по паролю;
Зашифрованные данные должны храниться в полях исходных данных, т.е. длина зашифрованного текста должна быть равной длине исходного текста, дополнительных таблиц быть не должно;
Список полей для шифрования/расшифровки должен быть настраиваемым и не зависеть от конфигурации;
Шифрование должно выполняться средствами платформы 1С без внешних компонент, com-объектов и т.д., чтобы исключить зависимость от ОС;
Решений на Инфостарте по шифрованию/расшифровки строк огромное множество (Защита и шифрование) - практически на любой вкус. Приведу наиболее интересные (на мой субъективный взгляд):

Подсистема шифрования данных + пример реализации: решение Keystore для хранения паролей;
Симметричное шифрование в 1С;
Шифрование текста, хеш сумма;
Хеширование данных с ключом по алгоритму SHA-1 штатными средствами 1С;
 Шифратор и дешифратор текста и файлов для 1С; 
Однако, найти публикацию, отвечающую всем моим требованиям, так и не удалось. Из-за наличия требования №2 (о не превышении длиной зашифрованного текста длины исходного текста), в качестве метода шифрования был выбран шифр Виженера.
Да, по современным стандартам данный шифр является ненадежным и поддается взлому. Поэтому, чтобы повысить время на дешифровку текста, в базовый алгоритм были внесены следующие улучшения:

Ключ для шифрования формируется на основании пароля, длина ключа шифрования равна длине шифруемого текста;
Код каждого символа ключа шифрования равен коду соответсвующего символа пароля, смещенного на псевдо случайную величину А;
Псевдо случайная величина А зависит от максимального кода среди символов пароля и длины кодируемой строки;
Код каждого символа зашифрованной строки равен сумме кода соответствующего символа исходной строки, кода соответствующего символа ключа шифрования и псевдо-случайной величины В;
Псевдо случайная величина В зависит от максимального кода среди символов ключа шифрования и длины кодируемой строки;
 Для генерации псевдо случайных величин использовался встроенный объект платформы ""ГенераторСлучайныхЧисел"". Ниже приведны основные функции обработки:

Функция ПолучитьМаксимальныйКодСимволаСтроки - получает максимальный код символа в переданной строке : 
Функция ПолучитьМаксимальныйКодСимволаСтроки(СтрокаАнализа)
	
	ДлинаСтрокиАнализа = СтрДлина(СтрокаАнализа);
	
	МаксимальныйКодСимвола = 0;
	
	Для Счетчик = 1 По ДлинаСтрокиАнализа Цикл
				
		КодТекущегоСимвола = КодСимвола(СтрокаАнализа, Счетчик);
		
		Если КодТекущегоСимвола > МаксимальныйКодСимвола Тогда
			
			МаксимальныйКодСимвола = КодТекущегоСимвола;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат МаксимальныйКодСимвола;
	
КонецФункции
Функция ПолучитьКлючШифрования - получает по паролю ключ шифрования с учетом псевдо случайного смещения:
Функция ПолучитьКлючШифрования(лПароль, ДлинаКодируемойСтроки)
	
	лПароль_Длина 	= СтрДлина(лПароль);
	КлючШифрования	= """";
	
	ЧислоДляИнциализацииГенератораСлучаныхЧисел = ПолучитьМаксимальныйКодСимволаСтроки(лПароль_Длина);
	
	ЧислоДляИнциализацииГенератораСлучаныхЧисел = ЧислоДляИнциализацииГенератораСлучаныхЧисел + ДлинаКодируемойСтроки;
	
	ГенераторСлучаныхЧисел = Новый ГенераторСлучайныхЧисел(ЧислоДляИнциализацииГенератораСлучаныхЧисел);
	
	СчетчикПоПаролю = Неопределено;
	
	Для Счетчик = 1 По ДлинаКодируемойСтроки Цикл
		
		Если (СчетчикПоПаролю = Неопределено) ИЛИ (СчетчикПоПаролю > лПароль_Длина) Тогда
			
			СчетчикПоПаролю = 1;
				
		КонецЕсли;
		
		СлучайноеСмещение = ГенераторСлучаныхЧисел.СлучайноеЧисло(1, ЧислоДляИнциализацииГенератораСлучаныхЧисел);
				
		СимволПароля = Сред(лПароль, СчетчикПоПаролю, 1);
		
		КлючШифрования = КлючШифрования + Символ(КодСимвола(СимволПароля) + СлучайноеСмещение);
		
		СчетчикПоПаролю = СчетчикПоПаролю + 1;
		
	КонецЦикла;
	
	Возврат КлючШифрования;
	
КонецФункции
Функция ЗашифроватьСтроку - шифрует строку шифром Виженера по ключу шифрования с учетом псевдо случайного смещения:
Функция ЗашифроватьСтроку(КодируемаяСтрока, КлючШифрования)
	
	ДлинаКодируемойСтроки = СтрДлина(КодируемаяСтрока);
	
	ЧислоДляИнциализацииГенератораСлучаныхЧисел = ПолучитьМаксимальныйКодСимволаСтроки(КлючШифрования);
	
	ЧислоДляИнциализацииГенератораСлучаныхЧисел = ЧислоДляИнциализацииГенератораСлучаныхЧисел + ДлинаКодируемойСтроки;
	
	ГенераторСлучаныхЧисел = Новый ГенераторСлучайныхЧисел(ЧислоДляИнциализацииГенератораСлучаныхЧисел);
	
	ЗакодированнаяСтрока = """";
	
	Для Счетчик = 1 ПО ДлинаКодируемойСтроки Цикл
		
		КодСимволаИсходнойСтроки 	= КодСимвола(КодируемаяСтрока, Счетчик);
		КодСимволаКлючаШифрования 	= КодСимвола(КлючШифрования, Счетчик);		
		СлучайнаяСоставляющая 		= ГенераторСлучаныхЧисел.СлучайноеЧисло(1, ЧислоДляИнциализацииГенератораСлучаныхЧисел);
		
		КодЗакодированныгоСимвола = КодСимволаИсходнойСтроки + КодСимволаКлючаШифрования + СлучайнаяСоставляющая;
		
		ЗакодированнаяСтрока = ЗакодированнаяСтрока + Символ(КодЗакодированныгоСимвола);
		
	КонецЦикла;
	
	Возврат ЗакодированнаяСтрока;
	
КонецФункции
Функция РасшифроватьСтроку - расшифровывает строку по ключу шифрования с учетом псевдо случайного смещения:
Функция РасшифроватьСтроку(КодируемаяСтрока, КлючШифрования)
	
	ДлинаКодируемойСтроки = СтрДлина(КодируемаяСтрока);
	
	ЧислоДляИнциализацииГенератораСлучаныхЧисел = ПолучитьМаксимальныйКодСимволаСтроки(КлючШифрования);
	
	ЧислоДляИнциализацииГенератораСлучаныхЧисел = ЧислоДляИнциализацииГенератораСлучаныхЧисел + ДлинаКодируемойСтроки;
	
	ГенераторСлучаныхЧисел = Новый ГенераторСлучайныхЧисел(ЧислоДляИнциализацииГенератораСлучаныхЧисел);
	
	ЗакодированнаяСтрока = """";
	
	Для Счетчик = 1 ПО ДлинаКодируемойСтроки Цикл
		
		КодСимволаКлючаШифрования 	= КодСимвола(КлючШифрования, Счетчик);			
		КодЗакодированныгоСимвола 	= КодСимвола(КодируемаяСтрока, Счетчик);
		СлучайнаяСоставляющая 		= ГенераторСлучаныхЧисел.СлучайноеЧисло(1, ЧислоДляИнциализацииГенератораСлучаныхЧисел);
		
		КодСимволаИсходнойСтроки = КодЗакодированныгоСимвола - КодСимволаКлючаШифрования - СлучайнаяСоставляющая;
		
		ЗакодированнаяСтрока = ЗакодированнаяСтрока + Символ(КодСимволаИсходнойСтроки);
		
	КонецЦикла;
	
	Возврат ЗакодированнаяСтрока;
	
КонецФункции
Функция ЗашифроватьРасшифроватьПолеОбъекта - получает ключ шифрования по паролю и шифрует или расшифровывает строку в зависимости от входных параметров:
Процедура ЗашифроватьРасшифроватьПолеОбъекта(ЗначениеРеквизита, Пароль, ЗаписатьЭлемент, ЭтоШифрование)
	
	Если НЕ ПустаяСтрока(ЗначениеРеквизита) Тогда
		
		КлючШифрования = ПолучитьКлючШифрования(Пароль, СтрДлина(ЗначениеРеквизита));
		
		Если ЭтоШифрование Тогда
			
			ЗначениеРеквизита = ЗашифроватьСтроку(ЗначениеРеквизита, КлючШифрования);
			
		Иначе
			
			ЗначениеРеквизита = РасшифроватьСтроку(ЗначениеРеквизита, КлючШифрования);
			
		КонецЕсли;
			
		Если НЕ ЗаписатьЭлемент Тогда
			
			ЗаписатьЭлемент = ИСТИНА;
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры
Фактическая реализация алгоритма в виде обработки в приложенном файле. Интерфейс обработки интуитивно понятен. Для выполнения шифрования (или расшифровки) необходимо выполнить несколько простых шагов: 

Выбрать поля данных в базе для обработки (при нажатии на гиперссылку с надписью ""Обработать:"" открывается отдельная форма с деревом справочников конфигурации со всеми текстовыми реквизитами и табличными частями с текстовыми реквизитами;
Ввести пароль;
Ввести подтверждение пароля;
Нажать кнопку ""Зашифровать"" или ""Расшифровать"" в зависимости от требуемого действия. 
В качестве примера работы алгоритма приложены скриншоты со справочником ""Страны"" до шифрования и после шифрования.  На этом все, спасибо за внимание, надеюсь, кому-нибудь пригодится."}
},
{0,
{"JS (через window.crypto.getRandomValues)",0,0,"","var array = new Uint32Array(10);
window.crypto.getRandomValues(array);

console.log(""Your lucky numbers:"");
for (var i = 0; i < array.length; i++) {
    console.log(array[i]);
}"}
},
{3,
{"Base64",1,0,"",""},
{0,
{"Через ПолучитьИмяВременногоФайла",0,0,"","//		Encoded 	- ДвоичныеДанные 	- Зашифрованный текс 
//		Кодировка 	- Строка 	- Кодировка: ANSI OEM UTF16 UTF8 Системная
Процедура Decode(Encoded, Кодировка)
	
	ДвДанные = Base64Значение(Encoded);
	Если ДвДанные = Неопределено Тогда
		Предупреждение(""Ошибка формата Base64"");
		Возврат;
	КонецЕсли;
	
	ВременныйФайл 	= ПолучитьИмяВременногоФайла();
	ДвДанные.Записать(ВременныйФайл);
	
	КодировкаФайла 	= Кодировка;
	КодировкаФайла 	= КодировкаТекста[Кодировка];
		
	Чтение 		= Новый ЧтениеТекста(ВременныйФайл, КодировкаФайла);
	Decoded 	= Чтение.Прочитать();
	Чтение.Закрыть();
	УдалитьФайлы(ВременныйФайл);
	
КонецПроцедуры

&НаКлиенте
Процедура Encode(Команда)
	
	КодировкаФайла 	= Кодировка;
	
	КодировкаФайла 	= КодировкаТекста[Кодировка];
	
	ВременныйФайл 	= ПолучитьИмяВременногоФайла();
	
	Запись 		= Новый ЗаписьТекста(ВременныйФайл, КодировкаФайла);
	Запись.Записать(Decoded);
	Запись.Закрыть();
	
	ДвДанные 	= Новый ДвоичныеДанные(ВременныйФайл);
	Encoded 	= Base64Строка(ДвДанные);
	
	УдалитьФайлы(ВременныйФайл);
	
КонецПроцедуры"}
},
{0,
{"Через ПотокВПамяти",0,0,"КодСтр","Функция КодироватьСтрокуBase64(пОбычнаяСтрока)
	
	СтрокаКодирования 	= пОбычнаяСтрока;
	
	ПотокВПамяти 	= Новый ПотокВПамяти();
	ЗаписьДанных 	= Новый ЗаписьДанных(ПотокВПамяти);
	ЗаписьДанных.ЗаписатьСтроку(СтрокаКодирования);
	
	ДД 				= ПотокВпамяти.ЗакрытьИПолучитьДвоичныеДанные();
	лРезультат 		= Base64Строка(ДД);
	
	Возврат лРезультат;
	
КонецФункции // КодироватьСтрокуBase64
 
Функция ДекодироватьСтрокуBase64(пСтрокаBase64)
	
	ДД1 			= Base64Значение(Строка);
	ЧтениеДанных 	= Новый ЧтениеДанных(ДД1);
	СтрокаРаскодированная 	= ЧтениеДанных.ПрочитатьСтроку();
	ЧтениеДанных.Закрыть();
	
	Возврат лРезультат;
	
КонецФункции // ДекодироватьСтрокуBase64
"}
},
{0,
{"Что-то ещё",0,0,"","&НаСервере
Функция Преобразовать64(Строка64 = неопределено, Массив64 = неопределено)
	Таб64 = Новый ТаблицаЗначений;
	Таб64.Колонки.Добавить(""Код"");
	Таб64.Колонки.Добавить(""Символ"");
	Нпп = 0;
	Для Код = КодСимвола(""A"") По КодСимвола(""Z"") Цикл
		стр = Таб64.Добавить();
		стр.Код = Нпп;
		стр.Символ = Символ(Код);
		Нпп = Нпп + 1;
	КонецЦикла;
	Для Код = КодСимвола(""a"") По КодСимвола(""z"") Цикл
		стр = Таб64.Добавить();
		стр.Код = Нпп;
		стр.Символ = Символ(Код);
		Нпп = Нпп + 1;
	КонецЦикла;
	стр = Таб64.Добавить();
	стр.Код = Нпп;
	стр.Символ = ""0"";
	Нпп = Нпп + 1;
	Для Код = 1 По 9 Цикл
		стр = Таб64.Добавить();
		стр.Код = Нпп;
		стр.Символ = Формат(Код,""ЧЦ=1; ЧДЦ=0"");
		Нпп = Нпп + 1;
	КонецЦикла;
	стр = Таб64.Добавить();
	стр.Код = Нпп;
	стр.Символ = ""+"";
	Нпп = Нпп + 1;
	стр = Таб64.Добавить();
	стр.Код = Нпп;
	стр.Символ = ""/"";
	
	Если Массив64 = неопределено Тогда 
		Если Строка64 = неопределено Тогда
			Сообщить(""неверный вызов функции"");
			Возврат неопределено;
		КонецЕсли;
		//Уберем переносы строк
		Строка64 = СтрЗаменить(Строка64, Символ(10), """");
		Строка64 = СтрЗаменить(Строка64, Символ(13), """");
		
		//преобразовываем строку в массив
		Если СтрДлина(Строка64) % 4 <> 0 Тогда
			Сообщить(""длина строки на входе должна быть кратна 4""); 
			Сообщить(СтрДлина(Строка64)); 
			Возврат неопределено;
		КонецЕсли;
		Кол4 = Цел(СтрДлина(Строка64) / 4);
		РазмерМ = Кол4 * 3;
		Если Прав(Строка64, 2) = ""=="" Тогда
			РазмерМ = РазмерМ - 2;
		ИначеЕсли Прав(Строка64, 1) = ""="" Тогда
			РазмерМ = РазмерМ - 1;
		КонецЕсли;            
		Массив64 = Новый Массив(РазмерМ);
		Для А = 1 По Кол4 Цикл
			Число3 = 0;
			Для Б = 1 По 4 Цикл
				Буква1 = Сред(Строка64, (А-1)*4 + Б, 1);    
				Если Буква1 = ""="" Тогда
					Код4 = 0;
				Иначе
					стрН = Таб64.Найти(Буква1, ""Символ"");
					Если стрН = Неопределено Тогда
						Сообщить(""ошибка при поиске ""+ КодСимвола(Буква1));    
					Иначе 
						Код4 = стрН.Код;
					КонецЕсли;
				КонецЕсли;
				Число3 = Число3 * 64 + Код4;
			КонецЦикла;
			Ост = Число3 % 256;
			Индекс = (А-1)*3 + 2;
			Если Индекс <= РазмерМ - 1 Тогда
				Массив64[Индекс] = Ост;
			КонецЕсли;
			Число3 = (Число3 - Ост) / 256;
			Ост = Число3 % 256;
			Индекс = (А-1)*3 + 1;
			Если Индекс <= РазмерМ - 1 Тогда
				Массив64[Индекс] = Ост;
			КонецЕсли;
			Число3 = (Число3 - Ост) / 256;
			Ост = Число3 % 256;
			Массив64[(А-1)*3 + 0] = Ост;
		КонецЦикла;
		Возврат Массив64;
	Иначе //Преобразовываем массив в строку
		Строка64 = """";
		Кол3 = Цел(Массив64.Количество() / 3);
		Если Массив64.Количество() % 3 <> 0 Тогда
			Кол3 = Кол3 + 1;
		КонецЕсли;
		Для А = 1 По Кол3 Цикл
			Число3 = Массив64[(А-1)*3];    
			Если (А-1)*3+1 <= Массив64.ВГраница() Тогда
				Код3 = Массив64[(А-1)*3+1];
			Иначе
				Код3 = 0;
			КонецЕсли;
			Число3 = Число3*256 + Код3;
			Если (А-1)*3+2 <= Массив64.ВГраница() Тогда
				Код3 = Массив64[(А-1)*3+2];
			Иначе
				Код3 = 0;
			КонецЕсли;
			Число3 = Число3*256 + Код3;
			
			Ост4 = Число3 % 64;
			Число3 = (Число3 - Ост4) / 64;
			Ост3 = Число3 % 64;
			Число3 = (Число3 - Ост3) / 64;
			Ост2 = Число3 % 64;
			Число3 = (Число3 - Ост2) / 64;
			Ост1 = Число3 % 64;
			Число3 = (Число3 - Ост1) / 64;
			стрН = Таб64.Найти(Ост1, ""Код"");
			Если стрН = неопределено Тогда
				Сообщить(""Ошибка при поиске"");
			Иначе
				Строка64 = Строка64 + стрН.Символ;
			КонецЕсли;
			стрН = Таб64.Найти(Ост2, ""Код"");
			Если стрН = неопределено Тогда
				Сообщить(""Ошибка при поиске"");
			Иначе
				Строка64 = Строка64 + стрН.Символ;
			КонецЕсли;
			стрН = Таб64.Найти(Ост3, ""Код"");
			Если стрН = неопределено Тогда
				Сообщить(""Ошибка при поиске"");
			Иначе
				Строка64 = Строка64 + стрН.Символ;
			КонецЕсли;
			стрН = Таб64.Найти(Ост4, ""Код"");
			Если стрН = неопределено Тогда
				Сообщить(""Ошибка при поиске"");
			Иначе
				Строка64 = Строка64 + стрН.Символ;
			КонецЕсли;
		КонецЦикла;
		//Если количество символов не делится на 3, то на конце должны быть
		//знаки ""=""
		Если Массив64.Количество() % 3 = 1 Тогда
			Строка64 = Лев(Строка64, СтрДлина(Строка64)-2)+ ""=="";    
		ИначеЕсли Массив64.Количество() % 3 = 2 Тогда
			Строка64 = Лев(Строка64, СтрДлина(Строка64)-1)+ ""="";    
		КонецЕсли;
		Возврат Строка64;
	КонецЕсли;
КонецФункции"}
}
}
},
{11,
{"HTML",1,0,"",""},
{0,
{"ПолучитьБлокиПоКлассу",0,0,"","Функция ПолучитьБлокиПоКлассу(Документ, Класс)
   
    МассивБлоков = Новый Массив;
   
    СписокЭлементов = Документ.ПолучитьЭлементыПоИмени(""div"");
    Для Каждого Элемент Из СписокЭлементов Цикл
        АтрибутКласс = Элемент.ПолучитьАтрибут(""class"");
        Если АтрибутКласс<>Неопределено Тогда
            Если АтрибутКласс=Класс Тогда
                МассивБлоков.Добавить(Элемент);
            КонецЕсли;
        КонецЕсли;
    КонецЦикла;
   
    Возврат МассивБлоков;
   
КонецФункции"}
},
{0,
{"ЧтениеHtml Пример",0,0,"","//возвращает первый тэг, у которого атрибут class равен ""content""
Чтение = Новый ЧтениеHtml;
Чтение.УстановитьСтроку(ДанныеТекущейСтраницы, ""UTF8"");
Построитель = Новый ПостроительDOM;
Документ = Построитель.Прочитать(Чтение);

Блоки = ПолучитьБлокиПоКлассу(Документ, ""content"");
Если Блоки.Количество()=0 Тогда
    Возврат Неопределено;
Иначе
    Возврат Блоки[0];
КонецЕсли;
"}
},
{0,
{"Пример большой 1",0,0,"","https://infostart.ru/public/88106/
В этой статье я постараюсь описать процесс парсинга сайтов средствами 1С с примером. Это статья не является инструкцией к применению, а лишь демонстрирует возможности 1С. Что мы имеем? 1. Сайт в интернете, на котором располагается список товаров. В моем случае – это интернет магазин салона «Связной» 2. Понимание основ сайтостроения… хотя бы знание HTML тегов 3. Умение кодить в 1С 8 Все вышеперечисленные пункты в арсенале? Тогда читаем далее
Заметка 2018 года: Это очень плохой способ парсинга. Даже не помню были тогда в 1С те средства, которыми можно парсить или нет. Хороший способ есть тут

Для начала парсинга стоит определиться с тем что мы хотим спарсить и какая у нас будет иерархия. В моем случае это - категория сотовых телефонов. Верхний уровень иерархии будет - производители. Почему именно так? Потому что я так захотел. Вы же вправе использовать любую иерархию. Далее нам будут интересны такие поля как: Наименование, Цена, Картинка и Описание... ну и пожалуй захватим операционную систему, чтобы пример получился более наглядным.

Создаем внешнюю обработку. Те, кто не знают как это сделать - дальше могут не читать
Создаем форму обработки с командной панелью снизу и сверху (они могут быть полезными)
Размещаем на ней Панель и обзываем первую страницу ""СамСайт""
Кладем на страницу ""СамСайт"" ПолеHTMLДокумента и обзываем его к примеру ""Сайт""
Переименовываем кнопку ""Выполнить"", которая находится на нижней панели в ""Загрузить сайт""
Описываем процедуру нажатия на эту кнопку так:
ЭлементыФормы.Сайт.Перейти(""http://www.svyaznoy.ru/catalog/phone/224""); //Категория с мобильными телефонами
Проверяем работу нашей обработки. У меня появился сайт связного. А у Вас?

Дальше сложнее. Все еще хочешь парсить сайты? Тогда читай.

Сам парсинг сайта заключается в обходе всех элементов загруженной страницы, выдергивания необходимой информации и запихивания их в табличную часть. Для этого:

Создадим табличную часть ""Производители"" с реквизитами ""Отметка"" (Булево), ""Наименование"" (Строка 100) и ""Ссылка"" (Строка 300).
Добавляем еще одну страницу на панели и обзываем ее ""Производители""
Размещаем на этой странице одноименную табличную часть
Добавляем на нижней панели кнопку ""Заполнить производителей"" с кодом:
Для Каждого Стр из ЭлементыФормы.Сайт.Документ.body.all Цикл
    Если Стр.tagName = ""H1"" и Стр.innerText = ""Производители"" Тогда
        Для Каждого опСтр из Стр.nextSibling.children Цикл
            новСтр = Производители.Добавить();
            новСтр.Наименование = опСтр.innerText;
            новСтр.Ссылка = опСтр.firstChild.href;
        КонецЦикла;
        Возврат;
    КонецЕсли;
КонецЦикла;
   Здесь напрашиваются небольшие пояснения:
   tagName - имя HTML тега в HTML документе
   nextSubling - следующий элемент HTML документа от текущего
   children - список дочерних элементов
   firstChild - первый дочерний элемент от текущего

Проверяем. При проверке важно находиться на странице ""СамСайт"", чтобы заполнять производителей

Производители заполнены. Теперь к самим телефонам

Создаем табличную часть ""Товары"" с реквизитами ""Производитель"" (Строка 100), ""Наименование"" (Строка 100), ""Цена"" (Число 10,2), ""Картинка"" (Строка 300), ""Описание"" (Строка Неограниченная), ""ОС"" (строка 100), ""Ссылка"" (Строка,300)
Добавляем еще одну страницу на панели и обзываем ее ""Товары""
Размещаем на этой странице одноименную табличную часть
Добавляем на нижней панели кнопку ""Заполнить товары"" с кодом:
Для Каждого Стр из Производители Цикл
    //Если отметку сняли - то не трогаем этого производителя
    Если Не Стр.Отметка Тогда
        Продолжить;
    КонецЕсли;
    Форма = ПолучитьФорму(""ФормаТоваров"");
    Форма.ЭлементыФормы.Сайт.Перейти(Стр.Ссылка);
    Форма.ТекущийПроизводитель = Стр;
    Форма.ОткрытьМодально();
КонецЦикла;
Создаем форму обработки ""ФормаТоваров""
Кладем на ""ФормаТоваров"" ПолеHTMLДокумента и называем его ""Сайт""
На событие ДкументСформирован у ПоляHTMLДокумента пишем код:
Если ЭлементыФормы.Сайт.Документ.body.all.length>1 Тогда
    ГрузимТовары();
КонецЕсли;
Создаем переменную в модуле формы
Перем ТекущийПроизводитель Экспорт;
Создаем процедуру ГрузимТовары():
Процедура ГрузимТовары()
    Для Каждого Стр из ЭлементыФормы.Сайт.Документ.body.all Цикл
        Если Стр.className = ""ct_desc cleared"" Тогда
            новСтр = Товары.Добавить();
            Для Каждого опСтр из Стр.children Цикл
                Если опСтр.className = ""pic_and_comp"" Тогда
                    новСтр.Картинка = СтрЗаменить(Сред(опСтр.firstChild.style.backgroundImage,5),"")"","""")
                КонецЕсли;
                Если опСтр.className = ""name"" Тогда
                    новСтр.Наименование = опСтр.innerText;
                    новСтр.Ссылка = опСтр.firstChild.href;
                КонецЕсли;
                Если опСтр.className = ""price"" Тогда
                    новСтр.Цена = Число(СтрЗаменить(СтрЗаменить(опСтр.innerText,""-"",""""),"" "",""""));
                КонецЕсли;
                Если опСтр.className = ""desc"" Тогда
                    новСтр.Описание = опСтр.innerText;//опСтр.innerHTML - если нужно вместе с тегами
                КонецЕсли;
            КонецЦикла;
        КонецЕсли;
    КонецЦикла;
    Закрыть();
КонецПроцедуры
Проверяем. Все работает.
Дело осталось за ""операционной системой"" и еще надо загрузить картинки. Давайте по порядку. Чтобы получить ""ОС"" нам надо открыть этот товар и считать ""ОС"" оттуда. Для этого делаем следующее:

Добавляем на нижней панели кнопку ""Доп Инфо"" с кодом:
Для Каждого Стр из Товары Цикл
    Форма = ПолучитьФорму(""ФормаДопИнфо"");
    Форма.ЭлементыФормы.Сайт.Перейти(Стр.Ссылка);
    Форма.ТекущийТовар = Стр;
    Форма.ОткрытьМодально();
КонецЦикла;
Создаем форму обработки ""ФормаДопИнфо""
Кладем на ""ФормаДопИнфо"" ПолеHTMLДокумента и называем его ""Сайт""
На событие ДкументСформирован у ПоляHTMLДокумента пишем код:
Если ЭлементыФормы.Сайт.Документ.body.all.length>1 Тогда
    ГрузимДопИнфо();
КонецЕсли;
Создаем переменную в модуле формы
Перем ТекущийТовар Экспорт;
Создаем процедуру ГрузимДопИнфо():
Процедура ГрузимДопИнфо();
    Для Каждого Стр из ЭлементыФормы.Сайт.Документ.body.all Цикл
        Если Стр.className = ""card_spec"" Тогда
            Для Каждого опСтр из Стр.children Цикл
                Если Найти(опСтр.innerText,""Операционная система:"") Тогда
                    ТекущийТовар.ОС = СокрЛП(СтрЗаменить(опСтр.innerText,""Операционная система:"",""""));
                КонецЕсли;
            КонецЦикла;
        КонецЕсли;
    КонецЦикла;
    Закрыть();
КонецПроцедуры
Проверяем и переходим к последнему пункту

Заметили как похожи две последние инструкции? То-то же. Стремился к универсальности. Ну и наконец последний этап - сохраним все изображения к примеру на диск ""С"" в папку ""Svyaznoy"". Поехали:

Добавляем на нижней панели кнопку ""Сохранить Картинки"" с кодом:
Для Каждого Стр из Товары Цикл
    путьСамФайл = Лев(Стр.Картинка,Найти(Стр.Картинка,"".jpg/"") + 3);
    самФайл = СтрЗаменить(СтрЗаменить(ПутьСамФайл,""http://static.svyaznoy.ru/upload/iblock/"",""""),""/"","""");
    Стр.Картинка = СохранитьКартинкуСайта(""C:\Svyaznoy"",ПутьСамФайл,СамФайл);
КонецЦикла;
Добавляем функцию СохранитьКартинкуСайта:
Функция СохранитьКартинкуСайта(КаталогСохранения,КартинкаНаСайте,КартинкаУНас)
    ИмяФайлаКартинки = КаталогСохранения + ""\"" + КартинкаУНас;
    ГетЗапрос = Новый COMОбъект(""WinHttp.WinHttpRequest.5.1"");
    ГетЗапрос.SetTimeouts(10000, 10000, 10000, 10000);
    БазовыйУРЛ = КартинкаНаСайте;
    Хидер1 = ""Content-Type"";
    Хидер2 = ""image/jpg""; // Тип рисунка.
    ГетЗапрос.Open(""GET"", БазовыйУРЛ, False); // Синхронный режим.
    ГетЗапрос.setRequestHeader(Хидер1, Хидер2);
    ГетЗапрос.Send();
    СтатусОтправки = ГетЗапрос.status;
    Если СтатусОтправки <> 200 Тогда
        Сообщить(""Ошибка отправки запроса на: ""
                 + КартинкаНаСайте);
        Возврат """";
    КонецЕсли;       

    Стрим = Новый COMОбъект(""ADODB.Stream"");
    Стрим.Mode = 3;
    Стрим.Type = 1;
    Стрим.Open();
    Стрим.Write(ГетЗапрос.responseBody);

    Стрим.SaveToFile(ИмяФайлаКартинки, 2);
    Стрим.Close();
    Возврат ИмяФайлаКартинки;
КонецФункции
На этом наша эпопея с парсингом закончена. Это всего лишь пример того, как это можно сделать. Приложив сюда немного своего кода - можно сделать парсер для любого сайта.

Имея парсер 1С - я могу спарсить все, кроме этого парсера. Имея два парсера 1С - я могу спарсить все :)"}
},
{0,
{"Пример большой 2",0,0,"","Данная статья показывает пример парсинга одного конкретного сайта со своей структурой, на основе которого можно понять суть, методы и без особых проблем парсить другие сайты.
Здесь описано: подключение к серверу, сохранение html-страницы на диск, загрузка и цикличный обход ее структуры, рекурсивный парсинг, загрузка картинок по ссылке на диск.
Задача: научиться парсить сайт на конкретном примере

Будем парсить сайт brass.ru - крупного поставщика фурнитуры

Способ парсинга аналогичен тому, что указан в публикации //infostart.ru/public/88106/ , но имеет другой подход.

Далее следует большое полотно текста вперемешку с кодом, если нет желания читать – внизу можно скачать обработку и сразу разбираться в коде – он прокомментирован.

Следует сразу понять, что не существует универсальных парсеров сайтов, подходящих для всех. Большинство сайтов различаются своей структурой, поэтому для каждого из них существует свой алгоритм вытаскивания информации.

Поехали!

Парсить будем не с помощью элемента ДокументHTML на форме, а с помощью ЧтениеHTML (класс для загрузки html-документа) и ПостроительDOM (класс, загружающий в себя всю структуру и информацию документа). Суть этого метода заключается в том, что нам нужно подключиться к серверу, получить необходимую нам html-страницу (только html-код) и разобрать ее, а не загружать всё содержимое страницы на форму и потом рендерить его.

Практический любой сайт строится таким образом, что он состоит из блоков, которые содержат другие блоки, которые содержат другие блоки и так может повторяться огромное количество раз. Поэтому нам придется заранее узнать имена элементов, которые содержат необходимые нам данные.

Я использовал для этого Google Chrome.

Теоритическая часть

1. Парсим каталоги

Начнем собирать данные. Заходим в каталог товаров, клацаем правой клавишей на список товаров -> Показать код элемента. Видим, что список подкаталогов содержится в элементе TABLE с классом navCatalog, глядим на ссылки на подкаталоги – они представляют из себя элементы A. Это значит, что нам нужно найти элемент TABLE с классом navCatalog и получить из него все элементы A. Если мы перейдем в первый каталог, то увидим, что там есть еще каталоги – это не проблема, ведь эта страница подчиняется все тем же правилам, а наша процедура парсинга каталогов будет рекурсивна.

2. Парсим список товаров

Переходим в следующий подкаталог и, наконец, видим наши товары. Они, конечно, распределены по страницам, но, добавив в ссылку «?SHOWALL_1=1», мы сможем посмотреть весь список товаров из этого каталога. Смотрим код элемента, и видим, что все товары так же заключены в элементе TABLE, но уже с классом catalog. Этот элемент содержит в себе блоки TD с классом item – это и есть блоки с нашими товарами. В каждом из них содержится по два блока DIV с именами img и name – они содержат изображение и имя (ссылку на товар), соответственно. Все, с этой страницы мы вытянули все, что нам было нужно.

3. Парсим страницу товара

Все, что нам осталось найти – ссылка на картинку большого разрешения и описание товара. Переходим на страницу товара, все тем же способом видим, в каком блоке находится картинка (блок DIV класса big) и описание (блок DIV класса text). Все, осталась только техническая часть.

Техническая часть

Данный сайт устроен таким образом, что все товары распределены по каталогам и основная информация с картинками располагается только на страничке товара. Структура похожа на сайт связного (возможно, они на одной платформе). В таком случае, последовательность наших действий:

Парсим страничку каталога верхнего уровня и получаем список остальных каталогов;
Рекурсивно парсим страницы каталогов на подкаталоги;
Парсим подкаталоги нижнего уровня на список товаров;
Парсим страницу каждого товара для получения информации о нем.
На каждом шаге нам нужно будет запоминать информацию с предыдущего, поэтому мы создадим две табличные части – одну для запоминания всех каталогов, содержащих товары, вторую – для запоминания товаров.

Создадим обработку. Добавим реквизиты:

- Сервер (будем хранить адрес нашего сайта);

- КаталогЗагрузки (путь к папке на диске, в которую будут загружаться временные файлы).

Добавим на форму табличную часть «СписокКаталогов» с реквизитами

- Раздел (для хранения имени каталога);

- СсылкаНаСтраницу (для хранения ссылки на каталог).

Будем грузить артикул, наименование, описание и большую картинку.

Добавим на форму табличную часть «Товары» с реквизитами:

- Артикул;

- Наименование;

- Описание;

- СсылкаНаКартинку (будем хранить ссылку на маленькую картинку);

- СсылкаНаТовар (будем хранить ссылку на страницу товара);

- ПутьКФайлу (будем хранить путь к картинке, которую загрузили на диск).

Все реквизиты должны быть типа строка неограниченной длины. Можно добавить реквизит-пометку для обозначения тех строк, которые нам нужно будет загрузить.

Собственно, реквизитов нам больше не нужно, приступим к написанию кода.

В комментариях дали ссылку на отлично расписанный способ получить страницу (я использую его же, но очень худо)

Первым делом грузим и парсим страницу основного каталога – brass.ru/catalog/.

 При открытии формы нам следует запомнить сервер, с которого будем загружать страницы – www.brass.ru (адрес должен выглядеть именно так), каталог на диске. Так же откроем соединение с сервером.

Перем Соединение;
Процедура ПередОткрытием(Отказ, СтандартнаяОбработка)
    Сервер = ""www.brass.ru"";
    КаталогЗагрузки = ""C:/1c82/brass"";
    Соединение = Новый HTTPСоединение(Сервер);
КонецПроцедуры
Так же нам обязательно нужно создать в этом каталоге еще три других, в них будут загружаться временные файлы:

- ""/catalog/""
- ""/temp/""
- ""/img/""

Что бы понять, что будет происходить далее, нужно обязательно при запуске кода смотреть, что из себя прадставляют полученные нами структуры (табличцы значений) ДокументХТМЛ, ЭлементыTABLE, ЭлементыTD и прочие подобные - сразу все встанет на свои места.

Обозначим процедуру (сразу с параметрами, т.к. она будет рекурсивно парсить все каталоги).

Процедура ПропарситьКаталог(Каталог = """", Раздел = """")
    ЧтениеХТМЛ = Новый ЧтениеHTML; 
    ПостроительДОМ = Новый ПостроительDOM;
    //Генерируем имя файла на диске, в который запишется страница сайта
    ИмяФайла = КаталогЗагрузки + ""/catalog/"" + СтрЗаменить(Каталог, ""/"", ""_"") + "".html""; 
    //Загружаем нужную нам страницу в каталог
    Соединение.Получить(Каталог, ИмяФайла);
    //Начинаем чтение нашего файла
    ЧтениеХТМЛ.ОткрытьФайл(ИмяФайла, ""UTF-8""); 
    //Загружаем всю структуру документа в DOM
    ДокументХТМЛ = ПостроительДОМ.Прочитать(ЧтениеХТМЛ);
    
    //Получаем все элементы TABLE
    ЭлементыTABLE = ДокументХТМЛ.ПолучитьЭлементыПоИмени(""TABLE"");
    //Находим в них нужный нам блок, содержащий ссылки на подкаталоги
    Для Каждого ЭлементTABLE из ЭлементыTABLE Цикл
    ОбработкаПрерыванияПользователя();
        Если ЭлементTABLE.ИмяКласса = ""navCatalog"" Тогда
            //Нашли, собираем из него все ссылки (элементы А)
            ЭлементыA = ЭлементTABLE.ПолучитьЭлементыПоИмени(""A"");
            Если ЭлементыA.Количество() > 0 Тогда
                //Начинаем парсить каждую найденную ссылку как каталог этой же процедурой рекурсивно
                Для Каждого ЭлементA из ЭлементыA Цикл
                    ПропарситьКаталог(ЭлементA.Гиперссылка, Раздел + "" / "" + ЭлементA.ТекстовоеСодержимое);
                КонецЦикла;
            Иначе
                //Если ссылок не найдено, значит подкаталогов нет и это конечный подкаталог
                //Добавляем его в нашу табличную часть
                НоваяСтрока = СписокКаталогов.Добавить();
                НоваяСтрока.Раздел = Раздел;
                НоваяСтрока.СсылкаНаСтраницу = Каталог;    
            КонецЕсли;    
        КонецЕсли;
    КонецЦикла;
КонецПроцедуры
Лепим на форму кнопку - при ее нажатии у нас загрузятся все каталоги и заполнится табличная часть каталогов, в событие при нажатии вставляем следующее:

ПропарситьКаталог(""/catalog/"", ""Каталог"");
Поздарвляю, теперь наша обработка может распарсить все каталоги сайта и загрузить их в табличную часть. Нужно нам это для того, что бы при выборе каждого каталога мы могли бы загрузить его содержимое. 

Далее создадим кнопку для загрузки товаров в соответствующую табличную часть и пропишем ей следующий код:

Товары.Очистить();

ЧтениеХТМЛ = Новый ЧтениеHTML(); 
ПостроительДОМ = Новый ПостроительDOM;
//Добавляем к адресу ссылки обозначение, которое позволит нам получить полный список товаров выбранного каталога, а не постранично    
АдресСайта = ЭлементыФормы.СписокКаталогов.ТекущиеДанные.СсылкаНаСтраницу + ""?SHOWALL_1=1"";
//Загружаем страницу с товарами
Соединение.Получить(АдресСайта, КаталогЗагрузки + ""/site.html"");
//Начинаем чтение нашего файла
ЧтениеХТМЛ.ОткрытьФайл(КаталогЗагрузки + ""/site.html"", ""UTF-8""); 
//Загружаем всю структуру документа в DOM
ДокументХТМЛ = ПостроительДОМ.Прочитать(ЧтениеХТМЛ); 

//Получаем все элементы TABLE
ЭлементыTABLE = ДокументХТМЛ.ПолучитьЭлементыПоИмени(""TABLE"");

Для Каждого ЭлементTABLE из ЭлементыTABLE Цикл
    //Находим блок, содержащий все товары
    Если ЭлементTABLE.ИмяКласса = ""catalog"" Тогда
        //Теперь получаем все блоки TD, входящие в блок TABLE класса catalog
        ЭлементыTD = ЭлементTABLE.ПолучитьЭлементыПоИмени(""TD"");
        Для Каждого ЭлементTD из ЭлементыTD Цикл
            //Находим блок каждого товара
            Если ЭлементTD.ИмяКласса = ""item"" Тогда
                //Теперь получаем все блоки DIV, входящие в блок TD класса item
                ЭлементыDIV = ЭлементTD.ПолучитьЭлементыПоИмени(""DIV"");
                //Мы знаем, что в каждом таком блоке лежат еще два блока с картинкой и ссылкой на страницу товара
                Если ЭлементыDIV.Количество() = 2 тогда
                    НоваяСтрока = Товары.Добавить();
                    //Добавили новую строку в табличную часть товары, переходим к её заполнению
                    Для Каждого ЭлементDIV из ЭлементыDIV Цикл
                        //Нашли блок с картинкой маленького разрешения
                        Если ЭлементDIV.ИмяКласса = ""img"" Тогда
                            //Т.к. в этом блоке есть еще один блок, а в нем еще один, то мы можем спокойно обращаться к ним через ПервыйДочерний
                            //Таким образом мы спускаемся вниз по дереву структуры до нужных нам данных
                            НоваяСтрока.СсылкаНаТовар = ЭлементDIV.ПервыйДочерний.Гиперссылка;
                            Если НЕ ЭлементDIV.ПервыйДочерний.ПервыйДочерний = Неопределено Тогда
                                НоваяСтрока.СсылкаНаКартинку = ЭлементDIV.ПервыйДочерний.ПервыйДочерний.Источник;
                            КонецЕсли;
                        КонецЕсли;
                        //Нашли блок с именем товара
                        Если ЭлементDIV.ИмяКласса = ""name"" Тогда
                            //Получаем текстовое содержимое - артикул и наименование в одной строке! Не беда.
                            ПолученнаяСтрока = ЭлементDIV.ТекстовоеСодержимое;
                            //Артикул состоит из цифр и латинских символов, разберем строку по этому принципу
                            Н = 1;
                            Пока Н  1000 Тогда
                                    Прервать;
                                КонецЕсли;
                                Н = Н + 1;
                            КонецЦикла;
                            
                            Артикул = Лев(ПолученнаяСтрока, Н - 1);
                            Если СтрДлина(Артикул) > 0 Тогда
                                Наименование = Прав(ПолученнаяСтрока, СтрДлина(ПолученнаяСтрока) - Н);
                            Иначе
                                Наименование = Прав(ПолученнаяСтрока, СтрДлина(ПолученнаяСтрока) - Н + 1);
                            КонецЕсли;
                            
                            НоваяСтрока.Артикул = Артикул;
                            НоваяСтрока.Наименование = Наименование;
                        КонецЕсли;
                    КонецЦикла;    
                КонецЕсли;
            КонецЕсли;
        КонецЦикла;
    КонецЕсли;
КонецЦикла;
Поздравляю, теперь наша обработка может загрузить все товары из выбранного в первой табличной части каталога!

Следующим шагом создаем кнопку для загрузки дополнительной информации (картинки большого разрешения и описания) путем парсинга страницы товара:

ЧтениеХТМЛ = Новый ЧтениеHTML(); 
ПостроительДОМ = Новый ПостроительDOM;

//Т.к. ссылки на страницы с товарами у нас уже есть в табличной части, то мы просто загружаем и парсим их страницы
Для Каждого Строка из Товары Цикл
    Если Строка.Пометка Тогда
        //Код аналогичен предыдущим этапам, поэтому комментарии излишни
        ИмяФайла = КаталогЗагрузки + ""/temp/site_"" + Строка.НомерСтроки +"".html"";
        Соединение.Получить(Строка.СсылкаНаТовар, ИмяФайла);
        ЧтениеХТМЛ.ОткрытьФайл(ИмяФайла, ""UTF-8"");
        ДокументХТМЛ = ПостроительДОМ.Прочитать(ЧтениеХТМЛ); 
        //Получаем все блоки DIV
        ЭлементыDIV = ДокументХТМЛ.ПолучитьЭлементыПоИмени(""DIV"");
        Для Каждого ЭлементDIV из ЭлементыDIV Цикл
            //Находим интересующий нас блок с картинкой большого разрешения
            Если ЭлементDIV.ИмяКласса = ""big"" Тогда
                Если НЕ ЭлементDIV.ПервыйДочерний = Неопределено Тогда
                    Строка.СсылкаНаКартинку = ЭлементDIV.ПервыйДочерний.Источник;    
                КонецЕсли; 
            КонецЕсли;
            //Находим интересующий нас блок с описанием товара
            Если ЭлементDIV.ИмяКласса = ""text"" Тогда
                //В строке содержатся лишние символы, поэтому просто обрежем их
                ПолученнаяСтрока = ЭлементDIV.ТекстовоеСодержимое;    
                Н = 1;
                Пока Н  1000 Тогда
                        Прервать;
                    КонецЕсли;
                    Н = Н + 1;
                КонецЦикла;
                
                Строка.Описание = Прав(ПолученнаяСтрока, СтрДлина(ПолученнаяСтрока) - Н + 1);
            КонецЕсли;
        КонецЦикла;    
    КонецЕсли;
КонецЦикла;

Отмечаем галочками несколько товаров, жмем кнопку и видим, как загружается описание и ссылка на картинку заменяется новой. 

По сути, текстовые данные мы получили, задача выполнена, но осталось еще загрузка картинок - это будет бонусом и без комментариев кода. Или другой, более эффективный способ сохранения картинки от Поручика

Для этого создадим функцию для загрузки картинки, которая вернет нам путь к ней:

Функция ЗагрузитьКартинку(КаталогСохранения, СсылкаНаКартинку, ИмяКартинки)
    ИмяФайлаКартинки = """";
    Попытка
        ИмяФайлаКартинки = КаталогСохранения + ИмяКартинки;
        Request = Новый COMОбъект(""WinHttp.WinHttpRequest.5.1"");
        Request.SetTimeouts(10000, 10000, 10000, 10000);
        Header1 = ""Content-Type"";
        Header2 = ""image/jpg"";
        Request.Open(""GET"", ""http://"" + СсылкаНаКартинку, False);
        Request.setRequestHeader(Header1, Header1);
        Request.Send();
        СтатусОтправки = Request.status;
        Если СтатусОтправки <> 200 Тогда
            Сообщить(""Ошибка отправки запроса на: "" + СсылкаНаКартинку);
            Возврат """";
        КонецЕсли;        

        Stream = Новый COMОбъект(""ADODB.Stream"");
        Stream.Mode = 3;
        Stream.Type = 1;
        Stream.Open();
        Stream.Write(Request.responseBody);

        Stream.SaveToFile(ИмяФайлаКартинки, 2);
        Stream.Close();
    Исключение
    КонецПопытки;
    Возврат ИмяФайлаКартинки;
КонецФункции

+ нам нужно для всех помеченных строк записать путь к файлу в соответствующее поле. Для это можем в процедуру загрузки дополнительной информации (предыдущая) в обходе строк табличной части добавить следующую строку:

Строка.ПутьКФайлу = ЗагрузитьКартинку(КаталогЗагрузки + ""/img/"", Сервер + Строка.СсылкаНаКартинку, ЗаменитьСимволы(Строка.Артикул) + "".jpg"");
Имена картинок формируются из артикулов, а артикулы могут содержать неприемлимые знаки, избавимся от них функцией ЗаменитьСимволы, которая у нас использована в предыдущем отрывке кода:

Функция ЗаменитьСимволы(мСтрока)
    Строка = СтрЗаменить(мСтрока, """", """");
    Н = 1;
    ДС = СтрДлина(Строка) - 1;
    Пока Н  90) И (КодСимвола(Строка, Н) < 48 ИЛИ КодСимвола(Строка, Н) > 57) И (КодСимвола(Строка, Н) < 97 ИЛИ КодСимвола(Строка, Н) > 122) Тогда
            Строка = СтрЗаменить(Строка, Сред(Строка, Н, 1), ""-"");
        КонецЕсли;
        Н = Н + 1;
    КонецЦикла;
    
    Возврат Строка;
КонецФункции

Алилуя! У нас есть артикул, наименование, описание и картинка в большом разрешении! Осталось только перенести эти данные в номенклатуру, но если вы дошли до этого момента, то, надеюсь, вы это сможете сделать сами.

В заключение лишь скажу, что есть и другие способы парсинга сайта, но этот для меня показался простейшим и эффективным. Здесь достаточно знать структуру сайта и менять лишь алгоритм перебора данных ПостроителяDOM."}
},
{0,
{"Элемент.Документ.documentElement.innerHTML",0,0,"","Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
       ПолеСтраницыРеквизит = ""Internet.yandex.ru"";
КонецПроцедуры
&НаКлиенте
Процедура ПолеСтраницыДокументСформирован(Элемент)
       СтрокаП = Элемент.Документ.documentElement.innerHTML;
КонецПроцедуры"}
},
{0,
{"myOnError",0,0,"","</head> 
    <script type=""text/javascript"">
        window.onerror = myOnError;
        function myOnError(msg, url, lno) {return true}
    </script>    
...
<body>"}
},
{0,
{"ПолучитьТекст и УстановитьТекст",0,0,""," пТекстНовостиHTML = ЭлементыФормы.ТекстНовостиHTML.ПолучитьТекст();    
 ПроверитьБлокировкуДокумента();                                        
 ЭлементыФормы.ТекстНовостиHTML.УстановитьТекст(пТекстНовостиHTML);"}
},
{0,
{"Как получить текст из html",0,0,"","1С 8.x : Как получить текст из html?
Один мой хороший клиент использует встроенный в 1С почтовый клиент.

До этого все работало хорошо, но недавно из-за установки нового банк-клиента на компьютере обновили Internet Explorer до 11 версии - стала появляться ошибка:



Поле объекта не обнаружено innerText

Пришлось немного доработать типовую функцию получения текста из html:

Код 1C v 8.х
 Функция ПреобразоватьТекстИзХТМЛФорматаВПростой(ТекстВФорматеХТМЛ) Экспорт
	Попытка
		НовыйHTMLДокумент = Новый COMОбъект(""HtmlFile"");
		НовыйHTMLДокумент.open(""text/html"");
		НовыйHTMLДокумент.write(ТекстВФорматеХТМЛ);
		НовыйHTMLДокумент.close();
		
		Возврат СтрЗаменить(НовыйHTMLДокумент.all.item(0).innerText, Символ(13), """");
	Исключение	
		Построитель = Новый ПостроительDOM;
		ЧтениеHTML = Новый ЧтениеHTML;
		ЧтениеHTML.УстановитьСтроку(ТекстВФорматеХТМЛ);
		ДокументHTML = Построитель.Прочитать(ЧтениеHTML);
		
		Возврат СокрЛП(ДокументHTML.Тело.ТекстовоеСодержимое);
	КонецПопытки;
КонецФункции   
еще функции пример получения:

Код 1C v 8.х
 // Процедура изменяет признак формат текста письма (Текст, HТМЛ),
// и при этом конвертирует сам текст.
//
// Параметры:
//  ЭУHTML,ЭУТекст - Элементы управления формы, соответственно поле HTML и поле Текст
//  Кнопка - выбранная кнопка ее текст ""Простой текст"" или ""HTML"" новый вид текста письма
//  либо текст кнопки если пометку кнопки менять не требуется, соответственно 
//  вопрос о потере форматирования задаваться не будет
// Возвращаемое значение:
//  Булево, признак выполнения изменения формата
//
Функция удИзменитьФорматТекста(ЭУHTML,ЭУТекст, Кнопка) Экспорт
    Если ТипЗнч(Кнопка) = Тип(""Строка"") Тогда
        НовыйВидТекстаПисьма = Кнопка;
        ЕстьКнопка = Ложь;
    Иначе
        Если Кнопка.Пометка Тогда 
            Возврат Ложь; 
        КонецЕсли;
        НовыйВидТекстаПисьма = Кнопка.Текст;        
        ЕстьКнопка = Истина;
    КонецЕсли;     
        
    Если Найти(НовыйВидТекстаПисьма,""Простой текст"") > 0 Тогда          
        ИсходныйТекст = ЭУHTML.ПолучитьТекст();
        НачалоBODY = Найти(ИсходныйТекст, ""<BODY>"");
        КонецBODY  = Найти(ИсходныйТекст, ""</BODY>"");
        Если ЕстьКнопка и (НачалоBODY > 0 И КонецBODY > 0 И (НачалоBODY + 6) < КонецBODY) Тогда
            СтрокаВопроса = ""Будет потеряно форматирование текста. Продолжить?"";
            ОтветНаВопрос = Вопрос(СтрокаВопроса, РежимДиалогаВопрос.ДаНет, , КодВозвратаДиалога.Нет);
            Если ОтветНаВопрос <> КодВозвратаДиалога.Да Тогда                
                Возврат Ложь;
            КонецЕсли;
        КонецЕсли;
        ФорматТекста = ЭУHTML.Документ.all.item(0).innerText;             
        ЭУТекст.Значение =  СтрЗаменить(ФорматТекста, Символ(13), """");
        ЭУТекст.Видимость = Истина;
        ЭУHTML.Видимость = Ложь;
        ЭУHTML.УстановитьТекст("""");                        
    Иначе
        ФорматХТМЛ = СтрЗаменить(ЭУТекст.Значение, Символы.ПС, ""<BR>"");
    
        ЭУHTML.УстановитьТекст(ФорматХТМЛ);
        ЭУHTML.Видимость = Истина;
        ЭУТекст.Видимость = Ложь;
    КонецЕсли; 
    
    Если ЕстьКнопка Тогда
        Кнопка.Пометка = Истина;         
    КонецЕсли;   
    Возврат Истина;                     


КонецФункции // обИзменитьФорматТекста()   "}
},
{0,
{"ЧтениеHTML через ОткрытьФайл (получит вроде только текст, без тегов)",0,0,"","лАдрес 			= ""http://gran-it.net/updateset.php"";
ЧтениеHTML 		= Новый ЧтениеHTML;
ЧтениеHTML.ОткрытьФайл(лАдрес, ""utf-8"");
ПостроительDOM 	= Новый ПостроительDOM;
ДокументDOM 	= ПостроительDOM.Прочитать(ЧтениеHTML);

Если ДокументDOM.Тело = Неопределено Тогда // Ответ не получен
	Сообщить(""Оу"");
Иначе // Получили ответ
	ТекстСтраницы    = ДокументDOM.Тело.ТекстовоеСодержимое;
КонецЕсли;"}
},
{0,
{"Загрузкить текст страницы (загрузит с HTML тегами)",0,0,"","лАдрес 			= ""http://gran-it.net/updateset.php"";

HTTPСоединение 	= Новый HTTPСоединение(""forum.mista.ru"");
HTTPЗапрос 		= Новый HTTPЗапрос(""/topic.php?id=751707"");
ВременныйФайл 	= ПолучитьИмяВременногоФайла();
HTTPОтвет 		= HTTPСоединение.Получить(HTTPЗапрос);
КодСостояния 	= HTTPОтвет.КодСостояния;
responseText 	= HTTPОтвет.ПолучитьТелоКакСтроку();
Сообщить(responseText);"}
},
{0,
{"Парсер сайта на 1С",0,0,"","Парсер сайта на 1С
https://helpf.pro/faq/view/1435.html

В этой статье я постараюсь описать процесс парсинга сайтов средствами 1С с примером.
Это статья не является инструкцией к применению, а лишь демонстрирует возможности 1С.

Что мы имеем?
1. Сайт в интернете, на котором располагается список товаров. В моем случае – это интернет магазин салона «Связной»
2. Понимание основ сайтостроения… хотя бы знание HTML тегов
3. Умение кодить в 1С 8

Для начала парсинга стоит определиться с тем что мы хотим спарсить и какая у нас будет иерархия. В моем случае это категория сотовых телефонов. Верхний уровень иерархии будет производители. Почему именно так? Потомы что я так захотел. Вы же вправе использовать любую иерархию.

Далее нам будут интересны такие поля как: Наименование, Цена, Картинка и Описание... ну и пожалую захватим операционную систему, чтобы пример получился более наглядным.

1. Создаем внешнюю обработку. Те, кто не знают как это сделать - дальше могут не читать
2. Создаем форму обработки с командной панелью снизу и сверху (они могут быть полезными)
3. Размещаем на ней Панель и обзываем первую страницу ""СамСайт""
4. Кладем на страницу ""СамСайт"" ПолеHTMLДокумента и обзываем его к примеру ""Сайт""
5. Переименовываем кнопку ""Выполнить"", которая находится на нижней панели в ""Загрузить сайт""
6. Описываем процедуру нажатия на эту кнопку так:
Код 1C v 8.х
   ЭлементыФормы.Сайт.Перейти(""http://www.svyaznoy.ru/catalog/phone/224""); //Категория с мобильными телефонами   

7. Проверяем работу нашей обработки. У меня появился сайт связного. А у Вас?

Дальше сложнее. Все еще хочешь парсить сайты? Тогда читай:

Сам парсинг сайта заключается в обходе всех элементов загруженной страницы, выдергивания необходимой информации и запихивания их в табличную часть. Для этого:
1. Создадим табличную часть ""Производители"" с реквизитами ""Отметка"" (Булево), ""Наименование"" (Строка 100) и ""Ссылка"" (Строка 300).
2. Добавляем еще одну страницу на панели и обзываем ее ""Производители""
3. Размещаем на этой странице одноименную табличную часть
4. Добавляем на нижней панели кнопку ""Заполнить производителей"" с кодом:
Код 1C v 8.х
        Для Каждого Стр из ЭлементыФормы.Сайт.Документ.body.all Цикл
              Если Стр.tagName = ""H1"" и Стр.innerText = ""Производители"" Тогда
                  Для Каждого опСтр из Стр.nextSibling.children Цикл
                      новСтр = Производители.Добавить();
                      новСтр.Наименование = опСтр.innerText;
                      новСтр.Ссылка = опСтр.firstChild.href;
                  КонецЦикла;
                  Возврат;
              КонецЕсли;
          КонецЦикла;   


Здесь напрашиваются небольшие пояснения:
tagName - имя HTML тега в HTML документе
nextSubling - следующий элемент HTML документа от текущего
children - список дочерних элементов
firstChild - первый дочерний элемент от текущего
5. Проверям. При проверке важно, находиться на странице ""СамСайт"", чтобы заполнять производителей

Производители заполнены. Теперь к самим телефонам

1. Создаем табличную часть ""Товары"" с реквизитами ""Производитель"" (Строка 100), ""Наименование"" (Строка 100), ""Цена"" (Число 10,2), ""Картинка"" (Строка 300), ""Описание"" (Строка Неограниченная), ""ОС"" (строка 100), ""Ссылка"" (Строка,300)
2. Добавляем еще одну страницу на панели и обзываем ее ""Товары""
3. Размещаем на этой странице одноименную табличную часть
4. Добавляем на нижней панели кнопку ""Заполнить товары"" с кодом:
Код 1C v 8.х
       Для Каждого Стр из Производители Цикл
          //Если отметку сняли - то не трогаем этого производителя
          Если Не Стр.Отметка Тогда
              Продолжить;
          КонецЕсли;
          Форма = ПолучитьФорму(""ФормаТоваров"");
          Форма.ЭлементыФормы.Сайт.Перейти(Стр.Ссылка);
          Форма.ТекущийПроизводитель = Стр;
          Форма.ОткрытьМодально();
      КонецЦикла;   


5. Создаем форму обработки ""ФормаТоваров""
6. Кладем на ""ФормаТоваров"" ПолеHTMLДокумента и называем его ""Сайт""
7. На событие ДкументСформирован у ПоляHTMLДокумента пишем код:
Код 1C v 8.х
  Если ЭлементыФормы.Сайт.Документ.body.all.length>1 Тогда
          ГрузимТовары();
      КонецЕсли;   


8. Создаем переменную в модуле формы
перем ТекущийПроизводитель Экспорт;
9. Создаем процедуру ГрузимТовары():
Код 1C v 8.х
       Процедура ГрузимТовары()
          Для Каждого Стр из ЭлементыФормы.Сайт.Документ.body.all Цикл
              Если Стр.className = ""ct_desc cleared"" Тогда
                  новСтр = Товары.Добавить();
                  Для Каждого опСтр из Стр.children Цикл
                      Если опСтр.className = ""pic_and_comp"" Тогда
                          новСтр.Картинка = СтрЗаменить(Сред(опСтр.firstChild.style.backgroundImage,5),"")"","""")
                      КонецЕсли;
                      Если опСтр.className = ""name"" Тогда
                          новСтр.Наименование = опСтр.innerText;
                          новСтр.Ссылка = опСтр.firstChild.href;
                      КонецЕсли;
                      Если опСтр.className = ""price"" Тогда
                          новСтр.Цена = Число(СтрЗаменить(СтрЗаменить(опСтр.innerText,""-"",""""),"" "",""""));
                      КонецЕсли;
                      Если опСтр.className = ""desc"" Тогда
                          новСтр.Описание = опСтр.innerText;//опСтр.innerHTML - если нужно вместе с тегами 

                      КонецЕсли;
                  КонецЦикла;

              КонецЕсли;

          КонецЦикла;
          Закрыть();
      КонецПроцедуры   


10. Проверям. Все работает.

Дело осталось за ""операционной системой"" и еще надо загрузить картинки. Давайте по порядку. Чтобы получить ""ОС"" нам надо открыть этот товар и считать ""ОС"" оттуда. Для этого делаем следующее:

1. Добавляем на нижней панели кнопку ""Доп Инфо"" с кодом:
Код 1C v 8.х
 Для Каждого Стр из Товары Цикл
          Форма = ПолучитьФорму(""ФормаДопИнфо"");
          Форма.ЭлементыФормы.Сайт.Перейти(Стр.Ссылка);
          Форма.ТекущийТовар = Стр;
          Форма.ОткрытьМодально();
      КонецЦикла;   


2. Создаем форму обработки ""ФормаДопИнфо""
3. Кладем на ""ФормаДопИнфо"" ПолеHTMLДокумента и называем его ""Сайт""
4. На событие ДкументСформирован у ПоляHTMLДокумента пишем код:
Код 1C v 8.х
   Если ЭлементыФормы.Сайт.Документ.body.all.length>1 Тогда
          ГрузимДопИнфо();
      КонецЕсли;   


5. Создаем переменную в модуле формы
перем ТекущийТовар Экспорт;
6. Создаем процедуру ГрузимДопИнфо():
Код 1C v 8.х
       Процедура ГрузимДопИнфо();
          Для Каждого Стр из ЭлементыФормы.Сайт.Документ.body.all Цикл
              Если Стр.className = ""card_spec"" Тогда
                  Для Каждого опСтр из Стр.children Цикл
                      Если Найти(опСтр.innerText,""Операционная система:"") Тогда
                          ТекущийТовар.ОС = СокрЛП(СтрЗаменить(опСтр.innerText,""Операционная система:"",""""));
                      КонецЕсли;
                  КонецЦикла;
              КонецЕсли;
          КонецЦикла;
          Закрыть();
      КонецПроцедуры   


7. Проверяем и переходим к последнему пункту

Заметили как похожи две последние инструкции? То-то же. Стремился к универсальности. Ну и наконец последний этап - Сохраним все изображения к примеру на диск ""С"" в папку ""связной"". Поехали

1. Добавляем на нижней панели кнопку ""Сохранить Картинки"" с кодом:
Код 1C v 8.х
       Для Каждого Стр из Товары Цикл
              путьСамФайл = Лев(Стр.Картинка,Найти(Стр.Картинка,"".jpg/"") + 3);
              самФайл = СтрЗаменить(СтрЗаменить(ПутьСамФайл,""http://static.svyaznoy.ru/upload/iblock/"",""""),""/"","""");
              Стр.Картинка = СохранитьКартинкуСайта(""C:\Svyaznoy"",ПутьСамФайл,СамФайл);
          КонецЦикла;   


2. Добавляем функцию СохранитьКартинкуСайта:
Код 1C v 8.х
       Функция СохранитьКартинкуСайта(КаталогСохранения,КартинкаНаСайте,КартинкаУНас)
              ИмяФайлаКартинки = КаталогСохранения + ""\"" + КартинкаУНас;
              ГетЗапрос = Новый COMОбъект(""WinHttp.WinHttpRequest.5.1"");
              ГетЗапрос.SetTimeouts(10000, 10000, 10000, 10000);
              БазовыйУРЛ = КартинкаНаСайте;
              Хидер1 = ""Content-Type"";
              Хидер2 = ""image/jpg""; // Тип рисунка.
              ГетЗапрос.Open(""GET"", БазовыйУРЛ, False); // Синхронный режим.
              ГетЗапрос.setRequestHeader(Хидер1, Хидер2);
              ГетЗапрос.Send();
              СтатусОтправки = ГетЗапрос.status;
              Если СтатусОтправки <> 200 Тогда
                  Сообщить(""Ошибка отправки запроса на: ""
                      + КартинкаНаСайте);
                  Возврат """";
              КонецЕсли;        

              Стрим = Новый COMОбъект(""ADODB.Stream"");
              Стрим.Mode = 3;
              Стрим.Type = 1;
              Стрим.Open();
              Стрим.Write(ГетЗапрос.responseBody);

              Стрим.SaveToFile(ИмяФайлаКартинки, 2);
              Стрим.Close();
              Возврат ИмяФайлаКартинки;
      КонецФункции   


На этом наша эпопея с парсингом закончена. Это всего лишь пример того, как это можно сделать. Приложив сюда немного своего кода - можно сделать парсер для любого сайта. Скачивать файлы может только зарегистрированный пользователь! 
Имея парсер 1С - я могу спарсить все, кроме этого парсера. Имя два парсера 1С - я могу спарсить все )
Автор: opx"}
}
},
{5,
{"Расширение языков программирования (COMОбъект, MSScriptControl: JavaScript, JScript,  VBscript)",1,0,"",""},
{2,
{"JavaScript",1,0,"",""},
{0,
{"Математические функции в JavaScript",0,0,"","Математические функции в JavaScript
Чтобы работать с математикой в JavaScript, вам достаточно иметь понятия о таких вещах как функция, операнд и оператор. Этот список начинается с таких вещей как сортировка, округление и генерация случайных значений..
 Admin » 21.07.2017, 10:17 » Категория: WEB-Разработка / HTML, CSS, PHP, JScript

Математика в JavaScript
Математика в JavaScript
Наличие чисел и числовых данных позволяет вам каким-либо образом работать с языком. Но помимо работы с арифметическими операторами в JavaScript, математические конструкции могут быть сложной задачей для новичков. По этой причине, нужно концентрироваться не на синтаксисе, а на общих математических функциях, этот список начинается с таких вещей как сортировка, округление и генерация случайных значений, этого достаточно, прежде чем углубляться в детали.

Работа со случайными числами
Случайные числа часто требуются в JavaScript, к примеру, для отрисовки звезд, разбросанных по ночному небу. Но есть много различных видов случайностей, и в зависимости от логики и потребностей вашего приложения вам может понадобиться один из них.

Основной случай
Самая простая форма случайности - это функция Math.random(), встроенная в JavaScript.

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
Math.random() // 0.19401081069372594
Math.random() всегда возвращает число с плавающей точкой между 0 и 1. С технической точки зрения число, возвращаемое при помощи Math.random() может быть 0, но никогда не будет равно 1.

Если вы часто используйте Math.random(), используйте свою собственную функцию в сценариях:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
function getRandom() {
 return Math.random();
}
Проблема, конечно, в том, что данная функция всегда будет создавать случайное число в пределах весьма ограниченного диапазона, далее мы постараемся рассмотреть некоторые рекомендации предназначенные для решения этой проблемы.

Случайное число в интервале [min, max)
Расширение такой функциональности требует немного математики:

Случайное число с плавающей точкой:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
function getRandomFloat(min, max) {
 return Math.random() * (max - min) + min;
}

getRandomFloat(11, 101)
// 75.31898734299466
Целочисленное случайное число:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
function getRandomInt(min, max) {
 return Math.floor(Math.random() * (max - min)) + min;
}

getRandomInt(10, 20)
// 12
Случайное число в интервале [min, max]:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
function getRandomInRange(min, max) {
 return Math.floor(Math.random() * (max - min + 1)) + min;
}

getRandomInRange(1, 10)
// 7
Булевские случайные величины (true/false)
Если вы хотите простую случайность 0 или 1, представляющую подбрасывание монеты:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
function coinToss() {
 return Math.floor(Math.random() * 2);
}

coinToss();
// 0
Если вам нужно получить true или false:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
function coinToss() {
 return (Math.floor(Math.random() * 2) === 0);
}

coinToss();
// true
Или же:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
function coinToss() {
   return Math.random()<.5;
}

coinToss();
// true
Если вы хотите связать конкретные слова со сторонами монеты (да / нет, верх / низ и т.д.):

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
function coinFlip() {
 return (Math.floor(Math.random() * 2) === 0) ? ""up"" : ""down"";
}

coinFlip();
// up
Случайные величины с исключениями
Для ограниченного диапазона целых чисел необходимо создать массив чисел, которые вы хотели бы извлечь и в дальнейшем выбрать случайным образом из этого массива:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
let numPool = [ 1, 3, 5, 7, 9, 10 ],
rand = numPool[Math.floor(Math.random() * numPool.length)];
Можно также использовать массив чисел, которые вы хотите исключить, и приготовить пустой массив, в котором будет содержаться результат фильтрации из первого массива во второй:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
let numPool = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
let excludePool = [ 3, 4 ];
let filteredPool = [];
Затем в цикле прогоняем массив numPool, если выпавшее число существует и находится в массиве excludePool, помещаем результат в filteredPool:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
for (let i = 0; i < numPool.length; i++) {
 if (excludePool.indexOf(numPool[i]) === -1) {
 filteredPool.push(numPool[i]);
 }
}
И, наконец, получаем случайные числа из массива filteredPool:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
let rand = filteredPool[Math.floor(Math.random() * filteredPool.length)];
Случайные величины без повторений
Для небольшого набора чисел необходимо создать массив, заполненный элементами, далее перетасуйте их в случайном порядке, поместите результат в новый массив, а затем вытаскивайте по одному:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
let numPool = [ 13, 21, 36, 14, 27, 10 ];
   
function shuffle(numPool) {

 for(
 let j, x, i = numPool.length; i; 
 j = parseInt(Math.random() * i), 
 x = numPool[--i], 
 numPool[i] = numPool[j], 
 numPool[j] = x
 );

 return numPool;
};

let randomResult = shuffle(numPool);
while( randomResult.length > 0 ) {
 console.log( randomResult.pop() );
}
Для получения более широкого диапазона чисел, создайте и заполните массив случайными числами, исключая любые, которые были ранее сгенерированы:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
let numReserve = []
while (numReserve.length < 12) {
 let randomNumber = Math.ceil(Math.random() * 1000);
 let found = false;
 for (let i = 0; i < numReserve.length; i++) {
 if (numReserve[i] === randomNumber){ 
 found = true;
 break;
 }
 }
 if (!found) { numReserve[numReserve.length]=randomNumber; }
}
В приведенном выше коде numReserve заполняется 12ю случайными числами от 0 до 1000.

Криптографические случайные величины
К сожалению, ни один из выше методов не создает число с достаточной хаотичностью для криптографически защищенных функций (Math.random() не является достаточной функцией, которая генерирует случайные числа). Поэтому, мы можем использовать Web Cryptography API путем создания typedArray:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
let cryptoStor = new Uint16Array(8);
В этом случае мы создаем массив с восемью различными слотами, каждый из которых содержит беззнаковое 16-разрядное целое число. Существуют и другие варианты Int8Array, Uint8Array, int16Array, Int32Array и Uint32Array.

Затем, необходимо заполнить массив случайными числами определенного типа:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
window.crypto.getRandomValues(cryptoStor);
// [43484, 57947, 46691, 49849, 24272, 11827, 28203, 17423]
Ко всему прочему, Web Cryptography API имеет хорошую поддержку в современных браузерах.

Округления
Очень часто вычисления в JavaScript дают не совсем те результаты, которые мы хотим. Разумеется, мы можем делать с числами что угодно - округлять в большую или меньшую сторону, устанавливать диапазоны, отсекать ненужные числа до определенного количества знаков после запятой, все зависит от того, что вы хотите сделать в дальнейшем с этим числом.

Зачем необходимо округление?
Одним из любопытных аспектов JavaScript является то, что он на самом деле не хранит целые числа, мы сразу же работаем с числами с плавающей точкой. Это, в сочетании с тем фактом, что многие дробные значения не могут быть выражены конечным числом знаков после запятой, в JavaScript мы можем получить такие результаты:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
0.1 * 0.2;
> 0.020000000000000004

0.3 - 0.1
> 0.19999999999999998
Для практических целей эта неточность не имеет никакого значения, в нашем случае мы говорим об ошибке в квинтиллионных долях, однако, кого-то это может разочаровать. Мы можем получить несколько странный результат и при работе с числами, которые представляют собой значения валют, процентов или размеров файла. Для того, чтобы исправить эти неточности, нам как раз и необходимо уметь округлять результаты, при этом достаточно установить десятичную точность.

Округление чисел имеет практическое применение, мы можем манипулировать числом в некотором диапазоне, например, хотим округлить значение до ближайшего целого числа, а не работать только с десятичной частью.

Округление десятичных чисел
Для того, чтобы отсечь десятичное число, используйте toFixed или метод toPrecision. Оба они принимают единственный аргумент, который определяет, соответственно, сколько значащих цифр (т.е. общее количество цифр, используемых в числе) или знаков после запятой (количество после десятичной точки) должен включать в себя результат:

Если аргумент не определен для toFixed(), то по умолчанию он будет равен нулю, что означает 0 знаков после запятой, аргумент имеет максимальное значение, равное 20.
Если аргумент не задан для toPrecision, число остается нетронутым

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
let randNum = 6.25;
randNum.toFixed();
// ""6""
КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
Math.PI.toPrecision(1);
// ""3""
КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
randNum = 87.335;
randNum.toFixed(2);
// ""87.33""
КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
randNum = 87.337;
randNum.toPrecision(3);
// ""87.3""
Оба метода toFixed() и toPrecision() возвращают строковое представление результата, а не число. Это означает, что при суммировании округленного значения с randNum будет произведена конкатенация строк, а не сумма чисел:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
let randNum = 6.25;
let rounded = randNum.toFixed(); // ""6""
console.log(randNum + rounded);
// ""6.256""
Если вы хотите, чтобы результат имел числовой тип данных, то вам необходимо будет применить parseFloat:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
let randNum = 6.25;
let rounded = parseFloat(randNum.toFixed(1));
console.log(rounded);
// 6.3
Обратите внимание, что значения 5 округлены, за исключением редких случаев.

Методы toFixed() и toPrecision() являются полезными, ибо они могут не только отсекать дробную часть, но и дополнять знаки после запятой, что удобно при работе с валютой:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
let wholeNum = 1
let dollarsCents = wholeNum.toFixed(2);
console.log(dollarsCents);
// ""1.00""
Стоить обратите внимание, что toPrecision будет давать результат в экспоненциальной записи, если число целых чисел больше, чем сам сама точность:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
let num = 123.435
num.toPrecision(2);
// ""1.2e+2""
Как избежать ошибок округления с десятичными числами
В некоторых случаях, toFixed и toPrecision округляет значение 5 в меньшую сторону, а в большую:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
let numTest = 1.005;
numTest.toFixed(2);
// ""1.00""
Результат расчета выше должен был быть 1.01, а не 1. Если вы хотите избежать подобную ошибку, мы можем использовать решение, предложенное Jack L Moore, которое использует экспоненциальные числа для расчета:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
function round(value, decimals) {
 return Number(Math.round(value+'e'+decimals)+'e-'+decimals);
}
Теперь:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
round(1.005,2);
// 1.01
Машинное эпсилон округление
Альтернативный метод округления десятичных чисел был введен в ES6. Машинное эпсилон округление обеспечивает разумный предел погрешности при сравнении двух чисел с плавающей точкой. Без округления, сравнения могут дать результаты, подобные следующим:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
0.1 + 0.2 === 0.3
// false
Мы используем Math.EPSILON в нашей функции для получения корректного сравнения:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
function epsEqu(x, y) {
 return Math.abs(x - y) < Number.EPSILON * Math.max(Math.abs(x), Math.abs(y));
}
Функция принимает два аргумента: первый - текущий расчет, второй - ожидаемый результат. Она возвращает сравнение двух:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
epsEqu(0.1 + 0.2, 0.3)
// true
Все современные браузеры уже поддерживают ES6 математические функции, но если вы хотите получить поддержку в таких браузерах, как IE 11, используйте polyfills.

Отсечение дробной части
Все методы, представленные выше умеют округлять до десятичных чисел. Для того, чтобы просто отсечь число до двух знаков после запятой, необходимо сначала умножить его на 100, а затем полученный результат уже разделить на 100:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
function truncated(num) {
 return Math.trunc(num * 100) / 100;
}

truncated(3.1416)
// 3.14
Если вы хотите приспособить метод под любое количество знаков после запятой, вы можете воспользоваться двойным побитовым отрицанием:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
function truncated(num, decimalPlaces) { 
 let numPowerConverter = Math.pow(10, decimalPlaces); 
 return ~~(num * numPowerConverter)/numPowerConverter;
}
Теперь:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
let randInt = 35.874993;
truncated(randInt,3);
// 35.874
Округление до ближайшего числа
Для того, чтобы округлить десятичное число до ближайшего числа в большую или в меньшую сторону, в зависимости от того, к чему мы ближе всего, используйте Math.round():

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
Math.round(4.3)
// 4

Math.round(4.5)
// 5
Обратите внимание, что «половина значения», 0.5 округляется в большую сторону по правилам математики.

Округление к меньшему до ближайшего целого числа
Если вы хотите всегда округлять в меньшую сторону, используйте Math.floor:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
Math.floor(42.23);
// 42

Math.floor(36.93);
// 36
Обратите внимание, что округление в меньшую сторону работает для всех чисел, в том числе и для отрицательных. Представьте небоскреб с бесконечным количеством этажей, в том числе с этажами нижнего уровня (представляющий отрицательные числа). Если вы находитесь в лифте на нижним уровнем между 2 и 3 (что представляет собой значение -2.5), Math.floor доставит вас до -3:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
Math.floor(-2.5);
// -3
Но если вы хотите избежать подобной ситуации, используйте Math.trunc(), поддерживаемый во всех современных браузерах (кроме IE / Edge):

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
Math.trunc(-41.43);
// -41
На MDN вы найдете polyfill, который обеспечит поддержку Math.trunc в браузерах и IE / Edge.

Округление к большему до ближайшего целого числа
С другой стороны, если вам нужно всегда округлять в большую сторону, используйте Math.ceil(). Опять же, вспоминаем бесконечный лифт: Math.ceil всегда будет идти «вверх», независимо от того, является ли число отрицательное или нет:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
Math.ceil(42.23);
// 43

Math.ceil(36.93);
// 37

Math.ceil(-36.93);
// -36
Округление до большего/меньшего необходимого числа
Если мы хотим, чтобы округлить до ближайшего числа, кратного 5, самый простой способ создать функцию, которая делит число на 5, округляет его, а затем умножает его на ту же сумму:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
function roundTo5(num) {
 return Math.round(num/5)*5;
}
Теперь:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
roundTo5(11);
// 10
Если вы хотите округлять до кратных своему значению, мы использовать более общую функцию, передавая в нее начальное значение и кратное:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
function roundToMultiple(num, multiple) {
 return Math.round(num/multiple)*multiple;
}
Теперь:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
let initialNumber = 11;
let multiple = 10;
roundToMultiple(initialNumber, multiple);
// 10;
Фиксирование числа в диапазоне
Есть много случаев, когда мы хотим получить значение х, лежащее в пределах диапазона. Например, нам может понадобиться значение от 1 до 100, но при этом мы получили значение 123. Для того, чтобы исправить это, мы можем использовать минимальное (возвращает наименьшее из набора чисел) и максимальное (возвращает наибольшее из любого множества чисел). В нашем примере, диапазон от 1 до 100:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
let lowBound = 1;
let highBound = 100;
let numInput = 123;
let clamped = Math.max(lowBound, Math.min(numInput, highBound));
console.log(clamped);
// 100;
Опять же, мы можем переиспользовать операцию и обернуть все это в функцию, воспользуемся решением предложенное Daniel X. Moore:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
Number.prototype.clamp = function(min, max) {
 return Math.min(Math.max(this, min), max);
};
Теперь:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
numInput.clamp(lowBound, highBound);
// 100;
Гауссово округление
Гауссово округление, также известное как банковское округлением, заключается в том, что округление для этого случая происходит к ближайшему четному. Этот метод округления работает без статистической погрешности. Лучшее решение было предложено Tim Down:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
function gaussRound(num, decimalPlaces) {
 let d = decimalPlaces || 0,
 m = Math.pow(10, d),
 n = +(d ? num * m : num).toFixed(8),
 i = Math.floor(n), f = n - i,
 e = 1e-8,
 r = (f > 0.5 - e && f < 0.5 + e) ?
      ((i % 2 == 0) ? i : i + 1) : Math.round(n);
 return d ? r / m : r;
}
Теперь:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
gaussRound(2.5)
// 2

gaussRound(3.5)
// 4

gaussRound(2.57,1)
// 2.6
Десятичный знак в CSS:
Так как JavaScript часто используется для создания позиционного преобразования HTML-элементов, вы можете задаться вопросом, что произойдет, если мы cгенерируем десятичные значения для наших элементов:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
#box { width: 63.667731993px; }
Хорошая новость заключается в том, что современные браузеры будут учитывать десятичные значения в блочной модели, в том числе в процентных или пиксельных единицах измерения.

Сортировка
Очень часто нам приходится сортировать какие-либо элементы, например, у нас есть массив игровых рекордов, при этом они должны быть организованы по убыванию ранга игроков. К сожалению, стандартный метод sort() имеет некоторые удивительные ограничения: он хорошо работает с часто употребляемыми английскими словами, но сразу же ломается при встрече с числами, уникальными символами или словами в верхнем регистре.

Сортировка в алфавитном порядке
Казалось бы, сортировки массива по алфавиту должна быть простейшей задачей:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
let fruit = [""butternut squash"", ""apricot"", ""cantaloupe""];
fruit.sort();

// ""apricot"", ""butternut squash"", ""cantaloupe""]
Тем не менее мы сталкиваемся с проблемой, как только один из элементов находится в верхнем регистре:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
let fruit = [""butternut squash"", ""apricot"", ""Cantalope""];
fruit.sort();

// ""Cantaloupe"", ""apricot"", ""butternut squash""]
Это связано с тем, что, по умолчанию, сортировщик сравнивает первый символ представленный в Unicode. Unicode - это уникальный код для любого символа, независимо от платформы, независимо от программы, независимо от языка. Например, если смотреть по кодовой таблице символ «a» имеет значение U+0061 (в шестнадцатеричной системе 0x61), в то время как символ «C» имеет код U+0043 (0x43), который идет раньше в Unicode-таблице, чем символ «a».

Чтобы отсортировать массив, который может содержать смешанные регистры первых букв, нам необходимо либо преобразовать все элементы временно в нижний регистру, или определить свой порядок сортировки при помощи метода localeCompare() c некоторыми аргументами. Как правило, для такого случая, лучше сразу создать функцию для многократного использования:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
function alphaSort(arr) {
 arr.sort(function (a, b) {
 return a.localeCompare(b, 'en', {'sensitivity': 'base'});
 });
}

let fruit = [""butternut squash"", ""apricot"", ""Cantaloupe""];
alphaSort(fruit)

// [""apricot"", ""butternut squash"", ""Cantaloupe""]
Если вы хотите получить массив отсортированный в обратный алфавитном порядке, просто поменяйте позициями а и b в функции:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
function alphaSort(arr) {
 arr.sort(function (a, b) {
 return b.localeCompare(a, 'en', {'sensitivity': 'base'});
 });
}

let fruit = [""butternut squash"", ""apricot"", ""Cantaloupe""];
alphaSort(fruit)

// [""Cantaloupe"", ""butternut squash"", ""apricot""]
Тут стоит обратить внимание, что localeCompare используется с аргументами, еще надо помнить, что он поддерживается IE11+, для более старых версий IE, мы можем использовать его без аргументов, и в нижнем регистре:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
function caseSort(arr) {
 arr.sort(function (a, b) {
 return a.toLowerCase().localeCompare(b.toLowerCase());
 });
}

let fruit = [""butternut squash"", ""apricot"", ""Cantaloupe""];
caseSort(fruit)

// [""apricot"", ""butternut squash"", ""Cantaloupe""]
Числовая сортировка
С некоторыми числовыми массивами сортировка работает просто идеально, но в какой-то момент результат может быть непредсказуемым:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
let highScores = [11, 57, 10, 16, 32, 100];
highScores.sort();

// [10, 100, 11, 16, 32, 57]
Дело в том, что метод sort() производит лексикографическую сравнение: а это означает, что числа будут преобразованы в строку и сравнения будут снова проводиться путем сопоставления первого символа этой строки в порядке символов Unicode-таблицы. Поэтому нам снова необходимо определить свой порядок сортировки:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
let highScores = [11, 57, 10, 16, 32, 100];
highScores.sort( function(a,b) { return a - b; } ); 

// [10, 11, 16, 32, 57, 100]
Опять же, для сортировки чисел в обратном порядке, поменяйте позициями a и b в функции.

Сортировка JSON-подобной структуры
И наконец, если у нас есть JSON-подобная структура данных:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
let scores = [
 {
 ""name"": ""Daniel"",
 ""score"": 21768
 },
 {
 ""name"": ""Michael"",
 ""score"": 33579
 },
 {
 ""name"": ""Alison"",
 ""score"": 38395
 }
];
В ES6+, вы можете использовать стрелочные функции:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
scores.sort((a, b) => b.score - a.score));
Для старых браузеров, не имеющих такую поддержку:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
scores.sort(function(a, b) { return a.score - b.score });
Как видите, сортировка в JavaScript это довольно не очевидная вещь, я надеюсь, что эти примеры облегчат как-нибудь жизнь.

Работа со степенными функциями
Возведение в степень - операция, первоначально определяемая как результат многократного умножения натурального числа на себя, квадратный корень из числа a - число, дающее a при возведении в квадрат. Этими функциями мы могли пользоваться постоянно в повседневной жизни на уроках математики, в том числе при вычислении площадей, объемов или даже при физическом моделировании.

В JavaScript степенная функция представлена как Math.pow(), в новом стандарте ES7 был представлен новый оператор возведения в степень - « * * «.

Возведение в степень
Для того, чтобы возвести число в n-ую степень, используйте функцию Math.pow(), где первый аргумент это число, которое будет возведено в степень, второй аргумент это показатель степени:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
Math.pow(3,2)
// 9
Такая форма записи означает 3 в квадрате, или 3 × 3, что приводит к результату 9. Можно привести еще пример, конечно:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
Math.pow(5,3);
// 125
То есть, 5 в кубе, или 5 × 5 × 5, равно 125.

ECMAScript 7 - это следующая версия JavaScript, в принципе, мы можем использовать новый предложенный оператор возведения в степень - * *, такая форма записи может быть более наглядной:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
3 ** 2 
// 9
На данный момент поддержка этого оператора довольно ограниченная, поэтому его не рекомендуется использовать.

Степенная функция может пригодиться в самых разных ситуациях.
Простой пример, вычисление количества секунд в часе: Math.pow (60,2).

Квадратный и кубический корень
Math.sqrt() и Math.cbrt() противоположны функции Math.pow(). Как мы помним, квадратный корень из числа a - число, дающее a при возведении в квадрат.

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
Math.sqrt(9)
// 3
В тоже время кубический корень из числа a - число, дающее a при возведении в куб.

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
Math.cbrt(125)
// 5
Math.cbrt() был введен в спецификацию JavaScript совсем недавно, и поэтому поддерживается только в современных браузерах: Chrome 38+, Firefox и Opera 25+ и Safari 7.1+. Вы заметите, что Internet Explorer отсутствует в этом списке, однако на MDN вы найдете полифилл.

Примеры
Конечно, мы можем использовать и не целые значения в одной из этих функций:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
Math.pow(1.25, 2);
// 1.5625

Math.cbrt(56.57)
// 3.8387991760286138
Обратите внимание, что это вполне себе работает и при использовании отрицательных значениях аргументов:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
Math.pow(-5,2)
// 25

Math.pow(10,-2)
// 0.01
Тем не менее, для квадратного корня это не будет работать:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
Math.sqrt(-9)
// NaN
Из математического анализа мы знаем, что под мнимым числом понимают квадратные корни из отрицательных чисел. И это может привести нас к еще одной технике работы с комплексными числами, но это уже другая история.

Вы можете использовать дробные значения в Math.pow(), чтобы найти квадратные и кубические корни чисел. Квадратный корень использует показатель 0.5:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
Math.pow(5, 0.5); // = Math.sqrt(5) = 5 ** (1/2)
// 2.23606797749979
Однако, из-за капризов с плавающей точкой, вы не можете точно предположить правильный результат:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
Math.pow(2.23606797749979,2)
// 5.000000000000001
В таких ситуациях, вы вам придется прибегать к отсечению знаков у числа или округление до какого-либо значения.

Некоторые, по непонятным причинам в JavaScript путают функцию Math.pow() с Math.exp(), которая является экспоненциальной функцией для чисел, в целом. Примечание: в английском языке «показатель степени» переводится как «exponent», поэтому это скорее относится к англоговорящим, хотя существуют и альтернативные названия показателя степени, такие как index, power.

Математические константы
Работа с математикой в JavaScript облегчается за счет ряда встроенных констант. Эти константы являются свойствами объекта Math. Стоит обратить внимание, что константы пишутся в верхнем регистре, а не CamelCase нотации.

Math.PI
Число Пи - математическая константа, равная отношению длины окружности к длине ее диаметра. Старое название - лудольфово число. Пи - иррациональное число, то есть его значение не может быть точно выражено в виде дроби m/n, где m и n - целые числа. Следовательно, его десятичное представление никогда не заканчивается и не является периодическим. На бумаге популярно использовать его короткую форму записи - 3.14159.

Ваш браузер не может хранить бесконечное число, так что JavaScript округляет число Пи до такого значения 3,141592653589793, что более чем достаточно для большинства задач.

Хотя это число наиболее распространено в задачах на нахождении длин, площади окружности, число Пи также используется в вероятности, статистики, инженерных и естественных науках: это как универсальная константа.

Math.SQRT2
Квадратный корень из числа 2 - положительное вещественное число, которое при умножении само на себя дает число 2. Геометрически корень из 2 можно представить как длину диагонали квадрата со стороной 1 (это следует из теоремы Пифагора). Это было первое известное в истории математики иррациональное число. JavaScript округляет это число до такого значения 1.4142135623730951. (Из-за ошибок округления в JavaScript: Math.SQRT2 * Math.SQRT2 не равно 2).

Math.SQRT1_2
Квадратный корень из 0.5 - это единица, деленная на корень квадратный из 2. И опять же, это иррациональное число.

Простейшими преобразованиями на бумаге мы можем записать это так:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
 √(1/2) = √1 / √2 = 1 / √2 = √2 / 2
Но из-за проблем с плавающей точкой, мы можем получить такой результат:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
Math.SQRT1_2 === Math.sqrt(1/2)
// true

Math.sqrt(2) / 2 === Math.sqrt(1/2)
// true

1 / Math.sqrt(2) === Math.sqrt(1/2)
// false
Math.E
Как ни странно, в математике константа е всегда записывалась в нижнем регистре, в JavaScript же это число используют в верхнем регистре. Число e - основание натурального логарифма, математическая константа, иррациональное и трансцендентное число. Иногда число e называют числом Эйлера или числом Непера. JavaScript округляет его как 2,718281828459045. Число e играет важную роль в дифференциальном и интегральном исчислении, а также во многих других разделах математики.

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
Math.pow(Math.E,1)
// 2.718281828459045

Math.pow(Math.E,2)
// 7.3890560989306495

Math.pow(Math.E,3)
// 20.085536923187664
Натуральный логарифм
Натуральный логарифм - это логарифм по основанию e, где e - иррациональная константа, равная приблизительно 2,718281828. Натуральный логарифм числа x - это показатель степени, в которую нужно возвести число e, чтобы получить x. Math.log(х) - это натуральный из x по основанию e.

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
Math.log(-1); // NaN, out of range
Math.log(0); // -Infinity
Math.log(1); // 0
Math.log(10); // 2.302585092994046
Если вам нужно получить логарифм из y по основанию x:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
function getBaseLog(x, y) {
 return Math.log(y) / Math.log(x);
}

getBaseLog(1/5, 5) 
// -1
Однако, из-за особенностей округления чисел с плавающей точкой, ответ получается не всегда точный и только близок к правильному значению:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
 getBaseLog(10, 1000)
// 2.9999999999999996
Math.LN2
Свойство Math.LN2 представляет натуральный логарифм из 2 равный 0.6931471805599453.

Math.LN10
Свойство Math.LN10 представляет натуральный логарифм из 10 равный 2.302585092994046

Math.LOG2E
Свойство Math.LOG2E представляет двоичный логарифм из e равный 1.4426950408889634

Math.LOG10E
Свойство Math.LOG10E представляет десятичный логарифм из e равный 0.4342944819032518

Math.abs, parseInt, parseFloat
Работа с числами в JavaScript может быть куда более сложной, чем кажется. Полученные значения не всегда попадают внутрь ожидаемых диапазонов, иногда результат может оказаться вовсе не тем, что мы ожидали.

Math.abs()
Метод Math.abs() возвращает абсолютное значение числа, что напоминает нам аналогичную математическую функцию модуля числа a.

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
let newVal = -57.64;
Math.abs(newVal);

// 57.64
Math.abs(0) всегда возвращает нуль, но если поставить знак минус перед функцией -Math.abs(NUM) мы всегда будем отрицательное значение.

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
-Math.abs(0);
// -0
parseInt()
Мы знаем, что JavaScript понимает, что «15» это строка, а не число и, например, при разборе CSS-свойств средствами JavaScript, или получив какое-либо значение из неподготовленного массива, наши результаты могут получиться непредсказуемыми. Мы могли получить на вход строку представленную как «17px», и для нас это не является редкостью. Вопрос заключается в том, как преобразовать эту строку в фактическое значение и использовать его в дальнейших расчетах.

Синтаксис: parseInt(string, radix);

Функция parseInt преобразует первый переданный ей аргумент в строковый тип, интерпретирует его и возвращает целое число или значение NaN. Результат (если не NaN) является целым числом и представляет собой первый аргумент (string), рассматривающийся как число в указанной системе счисления (radix). Например, основание 10 указывает на преобразование из десятичного числа, 8 - восьмеричного, 16 - шестнадцатеричного и так далее. Если основание больше 10, то для обозначения цифр больше 9 используются буквы. Например, для шестнадцатеричных чисел (основание 16) используются буквы от A до F.

Рассмотрим пример работы с CSS-свойствами, где, условно говоря, мы можем получить такое значение:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
let elem = document.body;
let centerPoint = window.getComputedStyle(elem).transformOrigin;
// ""454px 2087.19px""
Мы можем разделить значения по пробелам:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
let centers = centerPoint.split("" "");
// [""454px"", ""2087.19px""]
Однако, каждый элемент все еще есть строка, мы можем избавиться от этого применив нашу функцию:

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
let centerX = parseInt(centers[0], 10);
// 454

let centerY = parseInt(centers[1], 10);
// 2087
Как видите, вторым аргументом мы указываем систему счисления, в которую будет преобразовано число, этот параметр необязательный, но его рекомендуется использовать, в случае, если вы не знаете какая строка поступит на вход.

parseFloat()
Из примера выше, вы наверное заметили, что parseInt отбрасывает дробную часть. В нашем случае, parseFloat умеет работать с числами с плавающей точкой. Опять же, это может быть полезным при разборе CSS и других задачах, особенно при работе с плавающей точкой в процентах.

Синтаксис: parseFloat(string)

КОД: ВЫДЕЛИТЬ ВСЁ РАЗВЕРНУТЬ
let FP = ""33.33333%"";
console.log(parseFloat(FP));

// 33.33333
Обратите внимание, что в синтаксисе parseFloat нет второго аргумента.

Мы понимаем, что parseInt() и parseFloat() являются чрезвычайно полезными функциями, важно учитывать, что и тут не обойтись без ошибок, поэтому необходимо проверять диапазон ожидаемых значений и в конечном счете анализировать результат, чтобы гарантировать, что полученные значения верны."}
},
{0,
{"Случайные числа массивом (JScript)",0,0,"","Функция ВызватьJScript(Число1, Число2)
	
	Попытка
		ОбъектSC 			= Новый COMОбъект(""MSScriptControl.ScriptControl"");
		ОбъектSC.Language 	= ""JScript"";
	Исключение
		Сообщить(""Объект не создан: "" + ОписаниеОшибки());
		Возврат Неопределено;
	КонецПопытки;
	
	СтрокаJS = ""function RandArr(){var array = new Array(10);
	|for (var i = 0; i < array.length; i++) {
	|    array[i] = Math.random();
	|} return array}"";
	
	
	ОбъектSC.AddCode(СтрокаJS); 
	СтрокаВызоваФункции 	= ""RandArr();"";
	Результат 	= ОбъектSC.Eval(СтрокаВызоваФункции);
	
	Возврат Результат;
	
КонецФункции

Сообщить(""123"");
Р = ВызватьJScript(1,2);
Для каждого м Из Р Цикл
	Сообщить(м);
КонецЦикла;
"}
}
},
{2,
{"Python",1,0,"",""},
{0,
{"MSScriptControl, Python Script Engine (ENG)",0,0,"","Follow these steps carefully

Go to Activestate and get [ActivePython 2.5.7][1] MSI installer.
I had DLL hell problems with 2.6.x
Install in your Windows machine
once install is complete open Command Prompt and go to

C:\Python25\lib\site-packages\win32comext\axscript\client

execute \>  python pyscript.py you should see message Registered: Python

Go to ms office excel and open worksheet

Go to Tools > Macros > Visual Basic Editor
Add a reference to the Microsoft Script control ![alt text][2]
Add a new User Form. In the UserForm add a CommandButton
Switch to the code editor and Insert the following code

Dim WithEvents PyScript As MSScriptControl.ScriptControl

Private Sub CommandButton1_Click()
   If PyScript Is Nothing Then
       Set PyScript = New MSScriptControl.ScriptControl
       PyScript.Language = ""python""
       PyScript.AddObject ""Sheet"", Workbooks(1).Sheets(1)
       PyScript.AllowUI = True
   End If
   PyScript.ExecuteStatement ""Sheet.cells(1,1).value='Hello'""
End Sub
Execute. Enjoy and expand as necessary"}
},
{0,
{"MSScriptControl, Python Script Engine",0,0,"","Python Script Engine не создан в MSScriptControl
Я пытаюсь использовать Python из Excel 2003 с помощью MSScriptControl. Я выполнил все необходимые шаги, как указано в различных темах здесь и в других местах, например:

Установка ActivePython
Добавление ссылки «MSScriptControl 1.0» в VBA в Excel
Регистрация Python, запустив скрипт C: \ Python27 \ Lib \ site-packages \ win32comext \ axscript \ client \ pyscript.py
но я не могу заставить свой код работать на одном ПК (во время работы над другим, где я выполнял те же шаги, что и выше).

Работа с многоэлементными формулами excel на python
Нужна помощь в создании XML из Excel
Pandas dataframe и кодировка символов при чтении файла excel
Чтение определенных столбцов из excel для python
Фильтровать данные Excel на основе выбора диапазона дат на пандах
Вот код в VBA:

Global sc As New MSScriptControl.ScriptControl Public Function calibrate() sc.Language = ""python"" sc.ExecuteStatement (""import SABRSolver"") End Function 
когда я выполняю функцию, она останавливается на sc.Language говоря мне, что «Механизм сценария для указанного языка не может быть создан (Ошибка 380)»

Это действительно сводит меня с ума, поскольку, как сказано, он работает на других машинах с одинаковой настройкой."}
}
},
{0,
{"MSScriptControl.ScriptControl, JScript",0,0,"","Функция ВызватьJScript(Число1, Число2)
	
	Попытка
		лОбъектSC 			= Новый COMОбъект(""MSScriptControl.ScriptControl"");
		лОбъектSC.Language 	= ""JScript"";
	Исключение
		Сообщить(""Объект не создан: "" + ОписаниеОшибки());
		Возврат Неопределено;
	КонецПопытки;
	
	лСтрокаJS = ""function Summa(a, b)
	|{
	|	var c = a + b;
	|	return c;
	|}"";
	
	//лСтрокаJS = ""function Summa(){var array = new Uint32Array(10);
	//|window.crypto.getRandomValues(array);
	//|for (var i = 0; i < array.length; i++) {
	//|    return (array[i]);
	//|}"";
	
	лОбъектSC.AddCode(лСтрокаJS); 
	лСтрокаВызоваМетода 	= ""Summa("" + Число1 + "", "" + Число2 + "");""; //TODO [АйТи КучеровРМ 25.07.2019]: Формировать строку параметров автоматически на основе массива 
	Результат 				= лОбъектSC.Eval(лСтрокаВызоваМетода);	
	
	Возврат Результат;
	
КонецФункции "}
},
{0,
{"MSScriptControl.ScriptControl, VBscript",0,0,"","Функция ВызватьVBscript(Число1, Число2)
	
	Попытка
		лОбъектSC 			= Новый COMОбъект(""MSScriptControl.ScriptControl"");
		лОбъектSC.Language 	= ""VBscript"";
	Исключение
		Сообщить(""Объект не создан: "" + ОписаниеОшибки());
		Возврат Неопределено;
	КонецПопытки;
	
	//лСтрокаJS = ""function Summa(a, b)
	//|{
	//|	var c = a + b;
	//|	return c;
	//|}"";
	
	//лОбъектSC.AddCode(лСтрокаJS); //В примере не использовался
	лСтрокаВызоваМетода 	= ""Asc("""""" + Число1 + """""")"";
	Результат 				= лОбъектSC.Eval(лСтрокаВызоваМетода);	
	
	Возврат Результат;
	
КонецФункции "}
},
{0,
{"Передача массива из 1С в VBscript через COM (MSScriptControl.ScriptControl, VBscript)",0,0,"","Скрипт 			= Новый COMОбъект(""MSScriptControl.ScriptControl"");
Скрипт.Language = ""VBscript"";
Текст 	= ""
|Function TestF(Arr, test)
|    test = Arr(0)
|End Function"";


Массив 	= Новый COMSafeArray(""VT_VARIANT"", 2);
Массив.SetValue(0, 23);

Test 	= 0;
Скрипт.AddCode(Текст);
й		= Скрипт.Run(""TestF"", Массив, Test);
Сообщить(Test);

Еще можно так: 

Массив1 = Новый Массив;
// заполнение массива Массив1 значениями

// ...
Размер 	= Новый Массив;
Размер.Добавить(2);
Размер.Добавить(3);
Массив2 = Новый COMSafeArray(Массив1, ""VT_I4"", Размер);
Массив3 = Новый COMSafeArray(Массив2);"}
}
},
{1,
{"Ubuntu (UNIX)",1,0,"",""},
{5,
{"Команды в терминале (Terminal command line) (файлы для запуска формата *.sh)",1,0,"",""},
{0,
{"Сделать типовой скриншот (через Terminal (Ctrl + Alt + T)) (gnome-screenshot -d xx to delay the action)",0,0,"","gnome-screenshot -d 10

Периодически:
while true; do gnome-screenshot -d 10; done

Для прерывания надо нажать: ""Ctrl + z""."}
},
{0,
{"Открыть сайт",0,0,"","firefox http://www.youtube.com

Или (для запуска из файла под пользователем, чтобы всё нормально с правами, иначе там жесть, даже под root сложно запуститься):
/usr/bin/firefox http://www.youtube.com

Если вызывается из файла *.sh, то надо ткрыть права файлу: на запуск, и поместить в группу администраторов (adm).
"}
},
{0,
{"Скриншот через scrot",0,0,"","sudo apt-get install scrot

while true; do scrot -d int  'filename.jpg|png' -e 'mv $f /file/path/to/store/screenshots'; done
	
while true; do scrot -d 5 '%Y-%m-%d-%H:%M:%S.png' -e 'mv $f ~/Pictures/'; done
	
Для прерывания надо нажать: ""Ctrl + z"".	"}
},
{0,
{"Прервывание выполнения кода (вечных циклов): ""Ctrl + z""",0,0,"","Для прерывания надо нажать в терминале: ""Ctrl + z""."}
},
{0,
{"Дата",0,0,"","echo ""Time is:""
date"}
}
}
},
{0,
{"РегистрСведений_Отбор",0,0,"РСОт[бор]","лНаборЗаписей 	= РегистрыСведений.ИмяРегистра.СоздатьНаборЗаписей(); //Подготавливает пустой контейнер в оперативной памяти, структура которого соответствует структуре регистра в БД
лНаборЗаписей.Отбор.Регистратор.Установить(Значение); //В этот контейнер нужно помещать только те записи, поле ""Регистратор"" которых соответствует значению ""Значение""
лНаборЗаписей.Прочитать(); //Указывается, что необходимо выполнить чтение данных из БД в соответствии с теми условиями которые наложены на контейнер
"}
},
{0,
{"ОбъектДляПередачиНаСервер",0,0,"ОДП[НС]","лОбъектДляПередачиНаСервер 	= Объект;"}
},
{0,
{"ПрогрессБар (Состояние)",0,0,"","&НаКлиенте
Процедура Прогрессор(пСообщение, пВсего, пТекущ)
	
	Если пВсего > 0 Тогда
		лПроцент 	= Цел(пТекущ / пВсего * 100);
		
		Если лПроцент > Цел((пТекущ - 1) / пВсего * 100) Тогда
			лТекстСообщения 	= пСообщение + "": "" + Формат(лПроцент, ""Ч(0)2"") + ""% "" + СтрЗаменить(Формат("""", ""С"" + Мин(99, лПроцент)), "" "", ""l"") + СтрЗаменить(Формат("""", ""С"" + Мин(99, 99 - лПроцент)), "" "", ""'"") + ""l"";
			Состояние(лТекстСообщения, лПроцент, ""Ожидайте""); // Сюда по ситуации можно выводить анекдоты :)
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Пример использования
Для ин = 1 По 100000 Цикл
	Если ин % 10 = 0 Тогда // Чтобы вызывать не каждый шаг, а с периодичностью, чтобы не нагружать
		Прогрессор(""Тест"", 100000, ин);
	КонецЕсли;
КонецЦикла;"}
},
{0,
{"ВыбратьФайл (картинку)",0,0,"","&НаКлиенте
Процедура ВыбратьФайл(Команда)
	
	ОбъектКартинка 		= Новый Картинка;
	
	ДиалогВыбораФайла 	= Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Открытие);
	ДиалогВыбораФайла.Фильтр				= ОбъектКартинка.ФильтрИменФайлов();
	ДиалогВыбораФайла.МножественныйВыбор	= Ложь;
	ДиалогВыбораФайла.Заголовок				= ""Выбор картинки"";
	ДиалогВыбораФайла.ПроверятьСуществованиеФайла = Истина;
	
	Если ДиалогВыбораФайла.Выбрать() Тогда
		// Отображение картинки
		ДвоичныеДанные	= Новый ДвоичныеДанные(ДиалогВыбораФайла.ПолноеИмяФайла);
		АдресХранилища	= ПоместитьВоВременноеХранилище(ДвоичныеДанные, ЭтотОбъект.ИдентификаторВладельца);
		//АдресХранилища - реквизит типа Строка на форме в котором можно посмотреть изображение. Ввид элемента - Поле картинки
		
		// Параметры
		Файл 	= Новый Файл(ДиалогВыбораФайла.ПолноеИмяФайла);
		Имя 	= Файл.ИмяБезРасширения;
		
		ЭтотОбъект.Модифицированность 	= Истина;
		ЭтотОбъект.ОбновитьОтображениеДанных();
	КонецЕсли;
	
КонецПроцедуры"}
},
{0,
{"ОбработкаПрерыванияПользователя",0,0,"ОПП","ОбработкаПрерыванияПользователя(); // для прерывания работы встроенного языка при нажатии пользователем клавиши Ctrl+Break"}
},
{0,
{"ПолучитьЗначенияРеквизитов",0,0,"","// Возвращает структуру, содержащую значения реквизитов прочитанные из информационной базы
// по ссылке на объект.
// 
//  Если доступа к одному из реквизитов нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Параметры:
//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
//  ИменаРеквизитов - Строка или Структура - если Строка, то имена реквизитов, 
//               перечисленные через запятую, в формате требований к свойствам структуры.
//               Например, ""Код, Наименование, Родитель"".
//               Если Структура, то в качестве ключа передается псевдоним поля для
//               возвращаемой структуры с результатом, а в качестве значения (опционально) 
//               - фактическое имя поля в таблице. 
//               Если значение не определено, то имя поля берется из ключа.
// 
// Возвращаемое значение:
//  Структура    - содержит список свойств, как список имен в строке
//                 ИменаРеквизитов, со значениям реквизитов, прочитанных
//                 из информационной базы.
// 
Функция ПолучитьЗначенияРеквизитов(Ссылка, ИменаРеквизитов) Экспорт // Из ОбщегоНазначения
	
	Если ТипЗнч(ИменаРеквизитов) = Тип(""Структура"") Тогда
		СтруктураРеквизитов = ИменаРеквизитов;
	ИначеЕсли ТипЗнч(ИменаРеквизитов) = Тип(""Строка"") Тогда
		СтруктураРеквизитов = Новый Структура(ИменаРеквизитов);;
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр(""ru = 'Неверный тип второго параметра ИменаИлиСтруктураРеквизитов: %1'""), 
		Строка(ТипЗнч(ИменаРеквизитов)));
	КонецЕсли;
	
	ТекстПолей = """";
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		ИмяПоля   = ?(ЗначениеЗаполнено(КлючИЗначение.Значение), СокрЛП(КлючИЗначение.Значение), СокрЛП(КлючИЗначение.Ключ));
		Псевдоним = СокрЛП(КлючИЗначение.Ключ);
		ТекстПолей  = ТекстПолей + ?(ПустаяСтрока(ТекстПолей), """", "","") + ""
		|	"" + ИмяПоля + "" КАК "" + Псевдоним;
	КонецЦикла;
	
	Запрос = Новый Запрос(
	""ВЫБРАТЬ
	|"" + ТекстПолей + ""
	|ИЗ
	|	"" + Ссылка.Метаданные().ПолноеИмя() + "" КАК ПсевдонимЗаданнойТаблицы
	|ГДЕ
	|	ПсевдонимЗаданнойТаблицы.Ссылка = &Ссылка
	|"");
	Запрос.УстановитьПараметр(""Ссылка"", Ссылка);
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	
	Результат = Новый Структура;
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		Результат.Вставить(КлючИЗначение.Ключ);
	КонецЦикла;
	ЗаполнитьЗначенияСвойств(Результат, Выборка);
	
	Возврат Результат;
КонецФункции"}
},
{0,
{"ПолучитьЗначенияРеквизитов типовое",0,0,"","ОбщегоНазначения.ЗначениеРеквизитаОбъекта(СсылкаНаОбъект, ИменаРеквизитов);"}
},
{0,
{"ОпределитьТипОбъекта",0,0,"","// возвращает подробное описание типа объекта
Функция ОпределитьТипОбъекта(Объект)
	
	Строка 	= """" + Объект.Тип;
	Если Строка = ""Строка"" Тогда
		Строка 	= Строка + "", "" + ?(Объект.Тип.КвалификаторыСтроки.Длина = 0, ""Неограниченная"", Объект.Тип.КвалификаторыСтроки.Длина);    
	ИначеЕсли Строка = ""Число"" Тогда
		Строка 	= Строка + "", "" + Объект.Тип.КвалификаторыЧисла.Разрядность + ""."" +
		Объект.Тип.КвалификаторыЧисла.РазрядностьДробнойЧасти;
	ИначеЕсли Не ЗначениеЗаполнено(Строка) Тогда
		Строка 	= """";
	КонецЕсли;    
	
	Возврат Строка;
	
КонецФункции"}
},
{0,
{"ОбновитьФорму через ОбработкаОповещения",0,0,"","Процедура ОбработкаОповещения(ИмяСобытия, Параметр, Источник)
	
	Если ИмяСобытия = ""<?""Имя документа (слитно)"">ОбновитьФормуДокумента"" Тогда 
		ЭтотОбъект.Прочитать(); // Для УФ: ЭтаФорма.Прочитать(); Ещё есть: ЭтаФорма.ОбновитьОтображениеДанных();
		Если ЭтаФорма.Открыта() Тогда
			ЭтаФорма.Обновить(); 
		Иначе
			ЭтаФорма.Открыть();
		КонецЕсли; 
	КонецЕсли;
	
КонецПроцедуры;

Оповестить(""<?""Имя документа (слитно)"">ОбновитьФормуДокумента""); // Перечитать форму"}
},
{0,
{"Программно выполнить процедуры и обработ. событий формы (УФ)",0,0,"","МассивСсылок = ПолучитьМассивСсылокНаВидыЦен();

Для Каждого Строка Из МассивСсылок Цикл
	
	ПараметрыОткрытия 	= Новый Структура(""Ключ"", Строка);
	ФормаОбъекта 		= ПолучитьФорму(""Справочник.ВидыЦен.Форма.ФормаЭлемента"", ПараметрыОткрытия);
	
	ФормаОбъекта.Открыть(); 	// открыли
	ФормаОбъекта.Записать();	// записали
	ФормаОбъекта.Закрыть(); 	// закрыли 
	
КонецЦикла;"}
},
{0,
{"ПолучитьРеквизитМетаданныхОбъекта",0,0,"","Функция ПолучитьРеквизитМетаданныхОбъекта(Объект1С, ИмяРеквизита) Экспорт
	
	Возврат Объект1С.Метаданные()[ИмяРеквизита];
	
КонецФункции
"}
},
{0,
{"Получить макет Объекта формы",0,0,"","&НаСервере
Функция ПолучитьМакетОбъекта(пИмяМакета)
	
	рфОбъектЗначение 	= РеквизитФормыВЗначение(""Объект"");
	лМакет 				= рфОбъектЗначение.ПолучитьМакет(пИмяМакета);
	
	Возврат лМакет;
	
КонецФункции // ПолучитьМакетОбъекта()"}
},
{0,
{"Номер строки итеративно",0,0,"","НомерСтроки 	= ?(НомерСтроки = Неопределено, 0, НомерСтроки + 1); //При повторном использовании в другом месте надо будет обнулить значение, помни"}
},
{0,
{"Картинку из макета в HTML поле",0,0,"","ДвоичныеДанные 	= ПолучитьМакетОбъекта(""Макет""); // В макет загружена картинка
// РеквизитФормыВЗначение(""Объект"").ПолучитьМакет(ИмяМакета)
АдресВХ 		= ПоместитьВоВременноеХранилище(Новый Картинка(ДвоичныеДанные)); 
ТекстРезультата = ""
|<HTML><HEAD>
|<META content=""""text/html; charset=utf-8"""" http-equiv=Content-Type>
|<META name=GENERATOR content=""""MSHTML 11.00.9600.17631""""></HEAD>
|<BODY>тест<img src="" + АдресВХ + ""></BODY></HTML>"";"}
},
{0,
{"Сообщить с разделителем",0,0,"","Сообщить(""<?""Вид разделителя"", ВыборВарианта, ""--------"", ""---------------------------------------------"", ""____"", ""_____________________________________________"", ""===="", ""============================================="", ""******"", ""*********************************************"", ""////"", ""/////////////////////////////////////////////"">"", 	СтатусСообщения.БезСтатуса);
"}
},
{0,
{"ЭтоДокумент",0,0,"","ЭтоДокумент 	= Метаданные.Документы.Содержит(ДокументОбъект.Метаданные());"}
},
{0,
{"КаталогВыгрузки",0,0,"","Если ПустаяСтрока(КаталогВыгрузки) Тогда
	ГСЧ 	= Новый ГенераторСлучайныхЧисел();
	КаталогВыгрузки 	= КаталогВременныхФайлов() + Строка(ГСЧ.СлучайноеЧисло()) + ""\"";
Иначе
	КаталогВыгрузки 	= ОсновныеПараметры.КаталогВыгрузки;
	ПоследнийСимвол 	= Прав(КаталогВыгрузки, 1);
	Если НЕ ПоследнийСимвол = ""\"" Тогда
		КаталогВыгрузки = КаталогВыгрузки + ""\"";
	КонецЕсли;
КонецЕсли;"}
},
{0,
{"ОпределитьКонтекст",0,0,"","Функция ОпределитьКонтекст() Экспорт
	
	#Если ВнешнееСоединение Тогда
		Возврат ""Внешнее соединение"";
	#КонецЕсли
	
	// Клиентов много.
	#Если Клиент Тогда
		#Если МобильноеПриложениеКлиент Тогда
			Возврат ""Мобильное приложение (клиент)"";
		#КонецЕсли
		#Если ВебКлиент Тогда
			Возврат ""Веб-клиент""; 
		#КонецЕсли
		#Если ТонкийКлиент Тогда
			Возврат ""Тонкий клиент"";
		#КонецЕсли
		#Если ТолстыйКлиентУправляемоеПриложение Тогда
			Возврат ""Толстый клиент (управляемоеПриложение)"";
		#КонецЕсли
		#Если ТолстыйКлиентОбычноеПриложение Тогда
			Возврат ""Толстый клиент (обычноеПриложение)"";
		#КонецЕсли
	#КонецЕсли
	
	#Если Сервер Тогда
		#Если МобильноеПриложениеСервер Тогда
			Возврат ""Мобильное приложение (сервер)"";
		#КонецЕсли
		// Так как 1С:Предприятие поддерживает два варианта работы (файловый и клиент-серверный),
		// то отработаем каждый из вариантов.
		Если Лев(СтрокаСоединенияИнформационнойБазы(), 4) = ""File"" Тогда
			// Виртуальный сервер используется в файловом варианте.
			Возврат ""Виртуальный сервер""
		Иначе
			// Реальный сервер используется в клиент-серверном варианте.
			Возврат ""Реальный сервер"";
		КонецЕсли;
	#КонецЕсли
	
КонецФункции"}
},
{0,
{"Команда открытия списка регистра с отбором",0,0,"","// Команда
&НаКлиенте
Процедура ОбработкаКоманды(ПараметрКоманды, ПараметрыВыполненияКоманды)

	ПараметрыФормы = Новый Структура;
	ПараметрыФормы.Вставить(""<?""Имя Элемента Для Отбора (Слитно)"">"", ПараметрКоманды);

	ОткрытьФорму(""РегистрСведений.ИмяРегистра.ФормаСписка"", ПараметрыФормы, ПараметрыВыполненияКоманды.Источник, ПараметрыВыполненияКоманды.Уникальность, ПараметрыВыполненияКоманды.Окно);

КонецПроцедуры

// В форме списка

//Удаляет элемент отбора динамического списка
//
//Параметры:
//Список  - обрабатываемый динамический список,
//ИмяПоля - имя поля компоновки, отбор по которому нужно удалить
//
Процедура УдалитьЭлементОтбораСписка(Список, ИмяПоля)
	
	ЭлементыОтбора = Список.Отбор.Элементы;
	ПолеКомпоновки = Новый ПолеКомпоновкиДанных(ИмяПоля);
	Для Каждого ЭлементОтбора Из ЭлементыОтбора Цикл
		Если ТипЗнч(ЭлементОтбора) = Тип(""ЭлементОтбораКомпоновкиДанных"")
			И ЭлементОтбора.ЛевоеЗначение = ПолеКомпоновки Тогда
			ЭлементыОтбора.Удалить(ЭлементОтбора);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры // УдалитьЭлементОтбораСписка()

//Устанавливает элемент отбор динамического списка
//
//Параметры:
//Список			- обрабатываемый динамический список,
//ИмяПоля			- имя поля компоновки, отбор по которому нужно установить,
//ВидСравнения		- вид сравнения отбора, по умолчанию - Равно,
//ПравоеЗначение 	- значение отбора
//
Процедура УстановитьЭлементОтбораСписка(Список, ИмяПоля, ПравоеЗначение, ВидСравнения = Неопределено)
	
	ЭлементОтбора = Список.Отбор.Элементы.Добавить(Тип(""ЭлементОтбораКомпоновкиДанных""));
	ЭлементОтбора.ЛевоеЗначение    = Новый ПолеКомпоновкиДанных(ИмяПоля);
	ЭлементОтбора.ВидСравнения     = ?(ВидСравнения = Неопределено, ВидСравненияКомпоновкиДанных.Равно, ВидСравнения);
	ЭлементОтбора.Использование    = Истина;
	ЭлементОтбора.ПравоеЗначение   = ПравоеЗначение;
	ЭлементОтбора.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный;
	
КонецПроцедуры // УстановитьЭлементОтбораСписка()

//Изменяет элемент отбора динамического списка
//
//Параметры:
//Список         - обрабатываемый динамический список,
//ИмяПоля        - имя поля компоновки, отбор по которому нужно установить,
//ВидСравнения   - вид сравнения отбора, по умолчанию - Равно,
//ПравоеЗначение - значение отбора,
//Установить     - признак необходимости установить отбор
//
Процедура ИзменитьЭлементОтбораСписка(Список, ИмяПоля, ПравоеЗначение = Неопределено, Установить = Ложь, ВидСравнения = Неопределено)
	
	УдалитьЭлементОтбораСписка(Список, ИмяПоля);
	
	Если Установить Тогда
		УстановитьЭлементОтбораСписка(Список, ИмяПоля, ПравоеЗначение, ВидСравнения);
	КонецЕсли;
	
КонецПроцедуры // ИзменитьЭлементОтбораСписка()

&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	
	Если Параметры.Свойство(""<?""Имя Элемента Для Отбора (Слитно)"">"") Тогда
		ИзменитьЭлементОтбораСписка(Список, ""<?""Имя Элемента Для Отбора (Слитно)"">"", Параметры.<?""Имя Элемента Для Отбора (Слитно)"">, Истина);
		Элементы.<?""Имя Элемента Для Отбора (Слитно)"">.Видимость = Ложь;
	КонецЕсли;

КонецПроцедуры
"}
},
{0,
{"Открыть форму созданного но незаписанного",0,0,"","&НаКлиенте
Процедура СоздатьНовыйОбъект()
	
	ФормаОбъекта    = ПолучитьФорму(""Документ.ЗаказПокупателя.Форма.ФормаДокумента"");
	// Или справочник
	ФормаОбъекта    = ПолучитьФорму(""Справочник.Партнеры.Форма.ФормаЭлемента"");
	
	ДанныеФормы     = ФормаОбъекта.Объект;
	СоздатьНовыйОбъектНаСервере(ДанныеФормы);
	
	КопироватьДанныеФормы(ДанныеФормы, ФормаОбъекта.Объект);  
	ФормаОбъекта.Открыть();
	
КонецПроцедуры

&НаСервереБезКонтекста
Процедура СоздатьНовыйОбъектНаСервере(НовыйОбъект)
	НовыйОбъект.Дата    = ТекущаяДата();
	// Другой произвольный алгоритм
КонецПроцедуры"}
},
{0,
{"Убрать префикс и лидирующие нули",0,0,"","// Типовой ПрефиксацияОбъектовКлиентСервер.ПолучитьНомерНаПечать(РеквизитыДокумента.НомерСмены);
Функция ОбработатьНомерДокумента(ВходящийНомер)
	
	НомерБезПрефикса = Объект.ВходящийНомер; 
	Пока Найти(НомерБезПрефикса, ""0"") <> 1 Цикл
		НомерБезПрефикса = Сред(НомерБезПрефикса, 2); //удаляет лидирующие ненули
	КонецЦикла;
	
	НомерБезНулей = НомерБезПрефикса;
	Пока Найти(НомерБезНулей, ""0"") = 1 Цикл
		НомерБезНулей = Сред(НомерБезНулей, 2); //удаляет лидирующие нули
	КонецЦикла;
	
	Возврат НомерБезНулей;
	
КонецФункции"}
},
{0,
{"Значение Реквизита Типовое",0,0,"","ЗначениеРеквизита = УправлениеСвойствами.ЗначениеСвойства(ДокОбъект, ""МойРеквизит""); 

// В бсп 2.4 это методы УправлениеСвойствами.ЗначениеСвойства() и УправлениеСвойствами.ЗначенияСвойств(), УправлениеСвойствами.ПолучитьЗначенияСвойств() — устаревший методо
// УправлениеСвойствами.ЗаполнитьДополнительныеРеквизитыВФорме(ЭтотОбъект);

// ОМ -\ УправлениеСвойствами

// Возвращает значение дополнительного свойства объекта.
//
// Параметры:
//  Объект   - ЛюбаяСсылка - ссылка на объект, например, СправочникСсылка.Номенклатура,
//                           ДокументСсылка.ЗаказПокупателя, ...
//  Свойство - ПланВидовХарактеристикСсылка.ДополнительныеРеквизитыИСведения - ссылка на
//                           дополнительный реквизит, значение которого нужно получить.
//           - Строка - Имя дополнительного свойства.
//
// Возвращаемое значение:
//  Произвольный - любое значение, допустимое для свойства.
//
Функция ЗначениеСвойства(Объект, Свойство) Экспорт
	ПолучатьРеквизиты = УправлениеСвойствамиСлужебный.ЭтоОбъектМетаданныхСДополнительнымиРеквизитами(Объект.Метаданные());
	
	Результат = ЗначенияСвойств(Объект, ПолучатьРеквизиты, Истина, Свойство);
	Если Результат.Количество() = 1 Тогда
		Возврат Результат[0].Значение;
	КонецЕсли;
КонецФункции "}
},
{0,
{"Занят ли файл",0,0,"","Попытка
	ДД 	= Новый ДвоичныеДанные(ИмяФайла);
Исключение
	Сообщить(""Файл занят другим приложением!"");
КонецПопытки;"}
},
{0,
{"Горячие, или быстрые кнопки для пользователя 1С 8.3",0,0,"","Горячие, или быстрые кнопки для пользователя 1С 8.3	
	
Сочетания клавиш для документов	
Кнопка по умолчанию (нажатие вместо клика мышкой)	Ctrl + Enter
Выбор поля (альтернатива мыши)	F4
Прямой обход полей	Tab
Обратный обход полей	Shift + Tab
Сочетания клавиш для справочников 1С 8.3	
Новый элемент	Ins
Новая группа	Ctrl + F9
Изменить элемент	Shift + Enter
Просмотр элемента или группы	Alt + Д + Р
Копировать элемент или группу	F9
Пометить элемент/Снять пометку	Del
История значения	F5
Найти в дереве	Alt + Д + А
Перенести в другую группу	Ctrl + F5
Подчиненный справочник	Alt + Д + Ч
Горящие клавиши для программиста 1С	
Глобальные действия	
Создать новый документ	Ctrl + N
Открыть существующий документ	Ctrl + O
Активизировать поле поиска в командной панели	Ctrl + D
Открыть “Глобальный поиск по текстам”	Ctrl + Shift + F
Открыть “Результаты глобального поиска по текстам”	Ctrl + Shift + H
Запустить 1С:Предприятие без отладки	Ctrl + F5
Открыть окно “Конфигурация”	Ctrl + Shift + С
Обновить конфигурацию БД	F7
Открыть “Шаблоны текста”	Ctrl + Shift + T
Открыть встроенный “Калькулятор” системы 1С Предприятие 8.2	Ctrl + F2
Открыть “Свойства”	Alt + EnterCtrl + E
Открыть “Дополнительно”	Shift + Alt + Enter
Открыть “Служебные сообщения”	Ctrl + Alt + O
Закрыть “Служебные сообщения”	Ctrl + Shift + Z
Очистить служебные сообщения	Ctrl + Alt + Z
Открыть “Справку”	F1
Открыть “Содержание справки”	Shift + F1
Открыть “Индекс справки”	Shift + Alt + F1
Открыть “Поиск по справке”	Ctrl + Alt + F1
Открыть “Синтаксис-Помощник	Ctrl + Shift + F1
Поиск по индексу в “Синтаксис-Помощнике”	Ctrl + F1
Общие действия	
Удалить	Del
Добавить	Ins
Сохранить активный документ	Ctrl + S
Печать активного документа	Ctrl + P
Печать на текущий принтер	Ctrl + Shift + P
Копировать в буфер обмена	Ctrl + C Ctrl + Ins
Вырезать в буфер обмена	Ctrl + X Shift + Del
Вставить из буфера обмена	Ctrl + V Shift + Ins
Добавить к буферу обмена	Shift + Num+
Вычесть из буфера обмена	Shift + Num-
Выделить все	Ctrl + A
Отменить последнее действие	Ctrl + Z Alt + BackSpace
Вернуть отмененное действие	Ctrl + Y Shift + Alt + BackSpace
Найти	Ctrl + F
Найти следующий	F3
Найти следующий выделенный	Ctrl + F3
Найти предыдущий	Shift + F3
Найти предыдущий выделенный	Ctrl + Shift + F3
Заменить	Ctrl + H
Найти в дереве	Ctrl + T
Следующий элемент в результатах поиска и окне сообщений	F8
Предыдущий элемент в результатах поиска и окне сообщений	Shift + F8
Развернуть (узел дерева, группу табличного документа, группировку модуля)	Ctrl + Num+
Свернуть (узел дерева, группу табличного документа, группировку модуля)	Ctrl + Num-
Развернуть (узел дерева, группу табличного документа, группировку модуля) и все подчиненные	Ctrl + Alt + Num+
Свернуть (узел дерева, группу табличного документа, группировку модуля) и все подчиненные	Ctrl + Alt + Num-
Развернуть (все узлы дерева, группы табличного документа, группировки модуля)	Ctrl + Shift + Num+
Свернуть (все узлы дерева, группы табличного документа, группировки модуля)	Ctrl + Shift + Num-
Следующая страница	Ctrl + PgDn Ctrl + Alt + F
Предыдущая страница	Ctrl + PgUp Ctrl + Alt + B
Включить/выключить жирность	Ctrl + B
Включить/выключить курсив	Ctrl + I
Включить/выключить подчеркивание	Ctrl + U
Переход к предыдущей главе справки	Alt + Left
Переход к следующей главе справки	Alt + Right
Управление окнами	
Закрыть активное окно, модальный диалог или приложение	Alt + F4
Закрыть активное обычное окно	Ctrl + F4
Закрыть активное окно (кроме обычных)	Shift + Esc
Активизировать следующее обычное окно	Ctrl + Tab Ctrl + F6
Активизировать предыдущее обычное окно	Ctrl + Shift + Tab Ctrl + Shift + F6
Активизировать следующую секцию окна	F6
Активизировать предыдущую секцию окна	Shift + F6
Вызвать системное меню приложения или модального диалога	Alt + Space
Вызвать системное меню окна (кроме модальных диалогов)	Alt + Hyphen(-) Alt + Num-
Вызвать главное меню	Alt F10
Вызвать контекстное меню	Shift + F10
Переход по истории активности окон	
Переместиться назад	Ctrl + “-”
Переместиться вперед	Ctrl + Shift + “-”
Вернуть активность обычному окну	Esc
Форма	
Перейти к следующему элементу формы/выполнить действие кнопки по умолчанию	Enter
Выполнить действие кнопки по умолчанию	Ctrl + Enter
Перейти к следующему элементу формы	Tab
Вернуться к предыдущему элементу формы	Shift + Tab
Активизировать командную панель, связанную с активным элементом управления/формой	Alt + F10
Открыть “Список элементов управления формы”	Ctrl + Shift + L
Перемещение по элементам управления, объединенным в одну группу	Up, Down, Left, Right
Работа со списком и деревом	
Открыть	F2
Обновить	Ctrl + Shift + R
Скопировать	F9
Новая группа	Ctrl + F9
Удалить строку	Shift + Del
Перемещение строки вверх	Ctrl + Shift + Up
Перемещение строки вниз	Ctrl + Shift + Down
Перенести элемент в другую группу	Ctrl + Shift + M
Перейти на уровень вниз с одновременным раскрытием группы	Ctrl + Down
Перейти на уровень вверх (к “родителю”)	Ctrl + Up
Закончить редактирование	Shift + F2
Развернуть узел дерева	Num+ Ctrl + Num+
Свернуть узел дерева	Num- Ctrl + Num-
Развернуть узел дерева и все подчиненные	Num* Ctrl + Alt + Num+
Свернуть узел дерева и все подчиненные	Ctrl + Alt + Num-
Развернуть все узлы дерева (выполняется в любом месте дерева)	Ctrl + Shift + Num+
Свернуть все узлы дерева (выполняется в любом месте дерева)	Ctrl + Shift + Num-
Изменение флажка	Пробел
Поле ввода	
Переключить режим вставки/замены	Ins
Кнопка выбора	F4
Кнопка открытия	Ctrl + Shift + F4
Очистить поле	Shift + F4
Удалить символ слева от курсора	BackSpace
Удалить символ справа от курсора	Del
Удалить слово слева от курсора	Ctrl + BackSpace
Удалить слово справа от курсора	Ctrl + Del
Перейти в начало строки	Home
Перейти в конец строки	End
Поле картинки	
Увеличить масштаб	Num+
Уменьшить масштаб	Num-
Прокрутить	Up, Down, Left, Right
Прокрутить на размер окна вверх	Page Up
Прокрутить на размер окна вниз	Page Down
Прокрутить на размер окна влево	Alt + PgUp
Прокрутить на размер окна вправо	Alt + PgDn
Редактор управляемых форм	
Переключиться на закладку “Форма”	Alt + 1
Переключиться на закладку “Модуль”	Alt + 2
Переключиться на закладку “Форма” и активизировать закладку “Элементы”	Alt + 3
Переключиться на закладку “Форма” и активизировать закладку “Реквизиты”	Alt + 4
Переключиться на закладку “Форма” и активизировать закладку “Команды”	Alt + 5
Переключиться на закладку “Форма” и активизировать закладку “Командный интерфейс”	Alt + 6
Переключиться на закладку “Форма” и активизировать закладку “Параметры”	Alt + 7
Переключиться на закладку “Форма” и активизировать окно предварительного просмотра формы	Alt + 8
Редактор форм	
Протестировать форму	Ctrl + R
Переместить элемент управления	Up, Down, Left, Right
Копировать элемент управления	Ctrl + (Up, Down, Left, Right)
Копировать элемент управления с инверсией выравнивания по сетке	Ctrl + Alt + (Up, Down, Left, Right)
Изменить размер элемента управления	Shift + (Up, Down, Left, Right)
Изменить размер элемента управления с инверсией выравнивания по сетке	Shift + Alt + (Up, Down, Left, Right)
Инверсия использования сетки	Alt + (Up, Down, Left, Right)
Открыть окно “Привязка границ для элемента…”	Ctrl + Shift + S
Начало редактирования	F2
Редактор табличных документов	
Перейти к ячейке	Ctrl + G
Перемещение по ячейкам	Up, Down, Left, Right
Перемещение по ячейкам к следующей заполненной или пустой	Ctrl + (Up, Down, Left, Right)
Перемещение по ячейкам к следующей заполненной или пустой с выделением ячеек	Ctrl + Shift + (Up, Down, Left, Right)
Выделение ячеек	Shift + (Up, Down, Left, Right)
Выделение ячеек от текущей до начала строки	Shift + Home
Выделение ячеек от текущей до конца строки	Shift + End
Выделение строк	Alt + Shift + (Up, Down)
Выделение строк до следующей заполненной или пустой ячейки	Ctrl + Alt + Shift + (Up, Down)
Выделение колонок	Alt + Shift + (Left, Right)
Выделение колонок до следующей заполненной или пустой ячейки	Ctrl + Alt + Shift + (Left, Right)
Выделение ячеек от текущей до начала документа	Ctrl + Shift + Home
Выделение ячеек от текущей до конца документа	Ctrl + Shift + End
Прокрутить на страницу вверх	PgUp
Прокрутить на страницу вниз	PgDn
Прокрутить на страницу влево	Alt + PgUp
Прокрутить на страницу вправо	Alt + PgDn
Перейти к редактированию содержимого ячейки	Enter
Переключение режима редактирования/ввода в ячейке	F2
Перейти в начало строки	Home
Перейти в конец строки	End
Перейти в начало текста	Ctrl + Home
Перейти в конец текста	Ctrl + End
Установка имени текущей области	Ctrl + Shift + N
Редактор текстовых документов и модулей	
Переключить режим вставки/замены	Ins
Перейти в начало строки	Home
Перейти в конец строки	End
Выделить до начала строки	Shift + Home
Выделить до конца строки	Shift + End
Перейти в начало текста	Ctrl + Home
Перейти в конец текста	Ctrl + End
Выделить до начала текста	Ctrl + Shift + Home
Выделить до конца текста	Ctrl + Shift + End
Прокрутить на одну строку вверх	Ctrl + Up
Прокрутить на одну строку вниз	Ctrl + Down
Перейти к началу предшествующего слова	Ctrl + Left
Перейти к началу следующего слова	Ctrl + Right
Выделить слово	Ctrl + W
Выделить предшествующее слово	Ctrl + Shift + Left
Выделить следующее слово	Ctrl + Shift + Right
Прокрутить на страницу вверх	PgUp
Прокрутить на страницу вниз	PgDn
Выделить предыдущую страницу текста	Shift + PgUp
Выделить следующую страницу текста	Shift + PgDn
Снять выделение	Esc
Перейти к строке	Ctrl + G
Удалить символ слева от курсора	BackSpace
Удалить символ справа от курсора	Del
Удалить слово слева от курсора	Ctrl + BackSpace
Удалить слово справа от курсора	Ctrl + Del
Установить/снять закладку	Alt + F2
Следующая закладка	F2
Предыдущая закладка	Shift + F2
Удалить текущую строку	Ctrl + L
Форматировать блок	Shift + Alt + F
Добавить комментарий	Ctrl + Num/
Удалить комментарий	Ctrl + Shift + Num/
Сдвинуть блок вправо	Tab
Сдвинуть блок влево	Shift + Tab
Синтаксический контроль	Ctrl + F7
Процедуры и функции модуля	Ctrl + Alt + P
Перейти к объявлению процедуры или переменной	F12
Контекстная подсказка	Ctrl + Пробел
Свернуть группу (курсор может быть в любом месте группы)	Ctrl + Num —
Развернуть группу (курсор может быть в любом месте группы)	Ctrl + Num +
Свернуть все группы	Ctrl + Shift + Num —
Развернуть все группы	Ctrl + Shift + Num +
Обновить группировки	Ctrl+ Shift + R
Активизация шаблона	Ctrl + Q
Перейти по операторным скобкам назад	Ctrl + [
Перейти по операторным скобкам вперед	Ctrl + ]
Перейти по операторным скобкам назад с выделением текста	Ctrl + Shift + [
Перейти по операторным скобкам вперед с выделением текста	Ctrl + Shift + ]
Отладчик	
Начать/продолжить отладку	F5
Перезапуск приложения для отладки	Ctrl + Shift + F5
Прекратить отладку	Shift + F5
Шагнуть в	F11
Шагнуть через	F10
Шагнуть из	Shift + F11
Идти до курсора	Shift + F10
Установить/снять точку останова	F9
Отключить/включить точку останова	Ctrl + Shift + F9
Список точек останова	Alt + F9
Вычислить выражение	Shift + F9
Открыть табло	Ctrl + Alt + W
Открыть стек вызовов	Ctrl + Alt + C
Редактор картинок	
Переключение картинка/коллекция	Ctrl + K
Параметры картинки/коллекции	Shift + Alt + P
Отразить слева направо	Ctrl + H
Отразить сверху вниз	Ctrl + Shift + H
Выделение прямоугольником	Shift + Alt + S
Масштаб	Ctrl + M
Ластик	Ctrl + Shift + E
Заливка	Ctrl + Shift + F
Карандаш	Ctrl + Shift + I
Кисть	Ctrl + Shift + B
Линия	Ctrl + Shift + L
Кривая	Shift + Alt + С
Аэрограф	Ctrl + Shift + A
Текст	Shift + Alt + T
Увеличение масштаба	Ctrl + Num+
Уменьшение масштаба	Ctrl + Num-
Палитра свойств	
Сохранить свойства	Enter
Восстановить значения свойства	Esc
Раскрыть категорию свойств	Num+
Закрыть категорию свойств	Num-
Перейти в начало палитры	Home
Перейти в конец палитры	End
Перейти к предыдущему свойству	Up
Перейти к следующему свойству	Down
Прокрутить на страницу вверх	PgUp
Прокрутить на страницу вниз	PgDn
Перейти к предыдущей категории	Ctrl + PgUp
Перейти к следующей категории	Ctrl + PgDn
Редактор карты маршрута	
Перейти на следующий элемент карты	Tab
Перейти на предыдущий элемент карты	Shift + Tab
Уменьшить ширину элемента карты	Shift + (Left)
Увеличить ширину элемента карты	Shift + (Right)
Уменьшить высоту элемента карты	Shift + (Up)
Увеличить высоту элемента карты	Shift + (Down)
Перемещение выделенного варианта вверх (только при выделенном варианте в элементе “Выбор варианта”)	Ctrl + (Up)
Перемещение выделенного варианта вниз (только при выделенном варианте в элементе “Выбор варианта”)	Ctrl + (Down)
Поиск	Ctrl + F
Найти следующий	F3
Найти предыдущий	Shift + F3
Замена	Ctrl + H
Конфигурация	
Открыть конфигурацию	Alt + К + Enter
Поиск во всех текстах	Alt + К + Т
Объединение конфигураций	Alt + К + О
Загрузить измененную конфигурацию	Alt + K + З
Конвертирование данных	Alt + К + Е
Администрирование	
Пользователи	Alt + А + П
Сохранить данные	Alt + А + Х
Восстановить данные	Alt + А + В
Выгрузить данные	Alt + А + Ы
Загрузить данные	Alt + А + Г
Настройка журнала регистрации	Alt + А + Н
Распределенная ИБ	Alt + А + Р
Управление	Alt + А + Р + У
Автообмен	Alt + А + Р + А
Действия	
Открыть в отладчике	Alt + Д + Т
Синтаксический контроль запросов	Alt + Д + К
Синтаксический контроль	Alt + Д + И
Процедуры и функции модуля	Alt + Д + Р
Файл	
Новый	Ctrl + N
Открыть	Ctrl + O
Сохранить	Ctrl + S
Печать	Ctrl + P
Сравнить файлы	Alt + Ф + Р
Закрыть	Alt + Ф + З
Просмотр	Alt + Ф + Р + Р + Enter
Параметры страницы	Alt + Ф + М
Работа с закладками	
Предыдущая закладка	Shift + F2
Закладка	Alt + F2
Следующая закладка	F2
Работа с блоком	
Форматировать	Ctrl + Shift +F
Сдвинуть вправо	Tab
Сдвинуть влево	Shift + Tab
Добавить комментарий	Ctrl + Num /
Удалить комментарий	Ctrl + Shift + Num /
Окна	
Закрыть окно	Ctrl + F4
Следующее окно	Ctrl + Shift + F6
Предыдущее окно	Ctrl + F6
Каскадом	Alt + О + К
Закрыть окно сообщений	Ctrl + Shift + z
Следующая страница	Ctrl + Alt + F
Предыдущая страница	Ctrl + Alt + B
Разделить окно	Alt + О + Р
Поиск и замена	
Заменить	Ctrl + Shift + F3
Искать	Ctrl + F3
Повторить поиск	F3
Искать назад	Alt + F3
Искать вперед	Shift + F3
Переход к строке	Ctrl + Shift + L
Сервис	
Калькулятор	Ctrl + F2
Синтаксис помощник	Alt + С + С
Настройка шаблонов	Alt + С + Н
Временная блокировка	Alt + С + В
Запуск предприятия	F11
Запуск отладчика	F12
Помощь	
Помощь	F1
Содержание	Shift + F1
Поиск в Синтаксис-Помощнике	Ctrl + F1
О программе	Alt + П + О
Общие	
Свойства	Alt + Enter
Выход	Alt + F4
Предприятие	
Документ	
Кнопка по умолчанию	Ctrl + Enter
Выбор поля (альтернатива мыши)	F4
Прямой обход полей	Tab
Обратный обход полей	Shift + Tab
Справочник Действия	
Новый элемент	Ins
Новая группа	Ctrl + F9
Изменить элемент	Shift + Enter
Просмотр элемента или группы	Alt + Д + Р
Копировать элемент или группу	F9
Пометить элемент/Снять пометку	Del
История значения	F5
Найти в дереве	Alt + Д + А
Перенести в другую группу	Ctrl + F5
Подчиненный справочник	Alt + Д + Ч
Сортировка	
Сортировка справочника по коду	Ctrl + 1
Сортировка справочника по наименованию	Ctrl + 2
Сортировка справочника по реквизиту	Ctrl + 3
На уровень вверх	Ctrl + стрелка вверх
На уровень вниз	Ctrl + стрелка вниз
"}
},
{0,
{"Загрузить дополнительные реквизиты номенклатуры",0,0,"","//Загрузить дополнительные реквизиты номенклатуры (http://mikuslas.ru/dop_rekvizity)

//Обработкой ЗагрузкаДанныхИзТабличногоДокумента - УФ

//Откроем событие «При записи объекта» и добавим туда код:

Объект.ДополнительныеРеквизиты.Очистить(); // Предварительно удаляем все доп. реквизиты. Если не нужно - закомментировать.

ДопСвойства = Новый Соответствие;
ДопСвойства.Вставить(""11"", 91); // Наименование свойства, номер ячейки
ДопСвойства.Вставить(""АКЦИЯ"", 92);
ДопСвойства.Вставить(""Размер,мм"", 93);
ДопСвойства.Вставить(""Формат"", 94);

Для Каждого ЭлементДопСвойства Из ДопСвойства Цикл

	//ИмяСвойства = ЭлементДопСвойства.Ключ + "" ("" + """"""Общие"""""" + "")""; // Это если риквизит Общий
	ИмяСвойства = ЭлементДопСвойства.Ключ + "" ("" + Объект.ВидНоменклатуры + "")"";
	
    ТекСвойство = ПланыВидовХарактеристик.ДополнительныеРеквизитыИСведения.НайтиПоНаименованию(ИмяСвойства, Ложь);
	ТекЗначениеДляСвойства = ТекстыЯчеек[ЭлементДопСвойства.Значение];
	//ТекЗначение = ТекЗначениеДляСвойства; // Это если нужно само значение из ячейки, т.е. простого типа
    ТекЗначение = Справочники.ЗначенияСвойствОбъектов.НайтиПоНаименованию(ТекЗначениеДляСвойства, Ложь);
	
	Если Не ЗначениеЗаполнено(ТекСвойство) Тогда
        Сообщить(""Не удалось найти свойство: """""" + ИмяСвойства + """""""");
        Продолжить;
    КонецЕсли;
    Если Не ЗначениеЗаполнено(ТекЗначение) Тогда
        Сообщить(""Создаем новое значение """""" + ТекстыЯчеек[ЭлементДопСвойства.Значение] + """""" для свойства """""" + ТекСвойство + """""""");
        НовоеЗначение = Справочники.ЗначенияСвойствОбъектов.СоздатьЭлемент();
        НовоеЗначение.Владелец = ТекСвойство;
        НовоеЗначение.Наименование = ТекстыЯчеек[ЭлементДопСвойства.Значение];
        НовоеЗначение.Записать();
        ТекЗначение = НовоеЗначение.Ссылка;
    КонецЕсли;

    МассивСтрок = Объект.ДополнительныеРеквизиты.НайтиСтроки(Новый Структура(""Свойство"", ТекСвойство));
    Если МассивСтрок.Количество() = 0 Тогда
        ДопРеквизит = Объект.ДополнительныеРеквизиты.Добавить();
    Иначе
        ДопРеквизит = МассивСтрок[0];
    КонецЕсли;
    ДопРеквизит.Свойство = ТекСвойство;
    ДопРеквизит.Значение = ТекЗначение;

КонецЦикла;

Объект.Записать();

//В соответствие «ДопСвойста» нужно вставить столько записей, сколько требуется загрузить дополнительных реквизитов. В качестве ключа указываем текстовое наименование дополнительного реквизита, а в качестве значения - номе строки табличного документа, где это значение храниться."}
},
{0,
{"Загрузить дополнительные реквизиты номенклатуры для Общие",0,0,"","//Загрузить дополнительные реквизиты номенклатуры (http://mikuslas.ru/dop_rekvizity)

//Обработкой ЗагрузкаДанныхИзТабличногоДокумента - УФ

//Откроем событие «При записи объекта» и добавим туда код:

//Объект.ДополнительныеРеквизиты.Очистить(); // Предварительно удаляем все доп. реквизиты. Если не нужно - закомментировать.

ДопСвойства = Новый Соответствие;
ДопСвойства.Вставить(""Цена для сайта"", 2); // Наименование свойства, номер ячейки

Для Каждого ЭлементДопСвойства Из ДопСвойства Цикл
	
	//ИмяСвойства 			= ЭлементДопСвойства.Ключ + "" ("" + """"""Общие"""""" + "")""; // Это если риквизит Общий
	ИмяСвойства 			= ЭлементДопСвойства.Ключ + "" ("" + Объект.ВидНоменклатуры + "")""; 
	
	ТекСвойство 			= ПланыВидовХарактеристик.ДополнительныеРеквизитыИСведения.НайтиПоНаименованию(ИмяСвойства, Ложь);
	ТекЗначениеДляСвойства 	= ТекстыЯчеек[ЭлементДопСвойства.Значение];
	//ТекЗначение 			= ТекЗначениеДляСвойства; // Это если нужно само значение из ячейки, т.е. простого типа
	ТекЗначение 			= Справочники.ЗначенияСвойствОбъектов.НайтиПоНаименованию(ТекЗначениеДляСвойства, Ложь);
	
	Если Не ЗначениеЗаполнено(ТекСвойство) Тогда
		Сообщить(""Не удалось найти свойство: """""" + ИмяСвойства + """""""");
		Продолжить;
	КонецЕсли;
	
	МассивСтрок = Объект.ДополнительныеРеквизиты.НайтиСтроки(Новый Структура(""Свойство"", ТекСвойство));
	Если МассивСтрок.Количество() = 0 Тогда
		ДопРеквизит = Объект.ДополнительныеРеквизиты.Добавить();
	Иначе
		ДопРеквизит = МассивСтрок[0];
	КонецЕсли;
	ДопРеквизит.Свойство 	= ТекСвойство;
	ДопРеквизит.Значение 	= ТекЗначение;
	
КонецЦикла;

//Объект.Записать();
"}
},
{0,
{"Лог",0,0,"","//Процедура сообщения и логирования 
//-------------------------------------------------------------------------
//Параметры:
//		пСобытие 	- Строка 	- Сообщение для выдачи или записи
//		ОсновныеПараметры 	- Структура 	- ВИмяФайлаЛога
//-------------------------------------------------------------------------
//автор: КучеровРМ 06.11.2018 (тактично позаимствована из модуля Битрикс)
Процедура СообщитьПодробно(пСобытие, ОсновныеПараметры = Неопределено, Логирование = Истина, ЗаписьВЖурналРегистрации = Ложь) Экспорт
	
	#Если Клиент Тогда
		Сообщить(пСобытие);
	#КонецЕсли
	
	Если ЗаписьВЖурналРегистрации Тогда
		ЗаписьЖурналаРегистрации(""АйТи_Логирование"", УровеньЖурналаРегистрации.Информация,,, пСобытие);
	КонецЕсли;
	
	Если Логирование И ОсновныеПараметры <> Неопределено Тогда
		
		Если ОсновныеПараметры.ИмяФайлаЛога <> """" Тогда
			
			Попытка
				
				Текст = Новый ЗаписьТекста(ОсновныеПараметры.ИмяФайлаЛога, КодировкаТекста.ANSI,, Истина);
				Текст.ЗаписатьСтроку(Строка(ТекущаяДата()) + ""--"" + пСобытие);
				Текст.Закрыть();	
				
			Исключение
				Сообщить(""Ошибка: "" + ОписаниеОшибки(), СтатусСообщения.Важное);
			КонецПопытки; 
			
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

СообщитьПодробно(""Не удалось записать договор контрагента. "" + ОписаниеОшибки(), ПараметрыОбмена);"}
},
{0,
{"RunFileFromCMD",0,0,"","'Window - параметры запуска окна:
'0 Hides the window and activates another window.
'1 Activates and displays a window. If the window is minimized or maximized, the system restores it to its original size and position. An application should specify this flag when displaying the window for the first time.
'2 Activates the window and displays it as a minimized window.
'3 Activates the window and displays it as a maximized window.
'4 Displays a window in its most recent size and position. The active window remains active.
'5 Activates the window and displays it in its current size and position.
'6 Minimizes the specified window and activates the next top-level window in the Z order.
'7 Displays the window as a minimized window. The active window remains active.
'8 Displays the window in its current state. The active window remains active.
'9 Activates and displays the window. If the window is minimized or maximized, the system restores it to its original size and position. An application should specify this flag when restoring a minimized window.
'10 Sets the show-state based on the state of the program that started the application.

'Флаг ожидания завершения приложение. 0- без ожидания завершения. 1 — ожидать завершение выполнения.

Процедура RunFileFromCMD(ЗапускаемаяПрограмма, Аргументы = """", ЗапускаемыйФайл = """", ДописатьВКонец = """", ВидОкна = 1, ОжиданиеЗавершения = 1)
	
	WshShell = Новый COMОбъект(""Wscript.Shell"");
    
    Команда = """""""" + ЗапускаемаяПрограмма + """""""";
    Если НЕ ПустаяСтрока(ЗапускаемыйФайл) Then
        Команда = Команда + "" "" + """""""" + ЗапускаемыйФайл + """""""";
    КонецЕсли;
    Если НЕ ПустаяСтрока(Аргументы) Тогда
        Команда = Команда + "" """""" + Аргументы + """""""";
    КонецЕсли;    
    Если НЕ ПустаяСтрока(ДописатьВКонец) Тогда
        Команда = Команда + "" "" + ДописатьВКонец;
    КонецЕсли;
    
    WshShell.Run(Команда, ВидОкна, ОжиданиеЗавершения);
	
КонецПроцедуры

&НаКлиенте
Функция ExecFileFromCMD(ЗапускаемаяПрограмма, Аргументы = """", ЗапускаемыйФайл = """", ДописатьВКонец = """")
	
	WshShell = Новый COMОбъект(""Wscript.Shell"");
    
    Команда = """""""" + ЗапускаемаяПрограмма + """""""";
    Если НЕ ПустаяСтрока(ЗапускаемыйФайл) Тогда
        Команда = Команда + "" "" + """""""" + ЗапускаемыйФайл + """""""";
    КонецЕсли;
    Если НЕ ПустаяСтрока(Аргументы) Тогда
        Команда = Команда + "" """""" + Аргументы + """""""";
    КонецЕсли;
    Если НЕ ПустаяСтрока(ДописатьВКонец) Тогда
        Команда = Команда + "" "" + ДописатьВКонец;
    КонецЕсли;
    
    WshExec = WshShell.Exec(Команда);
    
    InStream = WshExec.StdIn;
    //InStream.WriteLine(""cd D:"");
    Возврат WshExec.StdOut.ReadAll(); // Прочитать весь текст из командного окна
    
КонецФункции

Пример:
ПутьПриложения 			= ""C:\Users\Python\Python35\python.exe"";
ПутьЗапускаемогоФайла 	= ""D:\Disk_D\CODING\python\Run Matlab Function\Run myFunction.py"";
Аргументы 				= ""5.1"";
    
ExecFileFromCMD(ПутьПриложения, Аргументы, ПутьЗапускаемогоФайла);
"}
},
{0,
{"РольДоступна",0,0,"РольД[оступна]","РольДоступна(""<?""Имя роли (Слитно)"">"")"}
},
{0,
{"ПраваДоступны",0,0,"РольД[оступна]","Для каждого Роль Из Метаданные.Роли Цикл
	
	лПравоИмя 	= ""Администрирование"";
	Если ПравоДоступа(лИмяПрава, Метаданные, Роль) Тогда
		Сообщить(""'"" + Роль + ""' имеет право: "" + лПравоИмя);
	КонецЕсли;
	
КонецЦикла;"}
},
{0,
{"СтруктураПараметров",0,0,"СтруктПарам[етров]","лСтруктураПараметров<?""Дописать имя в конец (слитно)""> 	= Новый Структура();
лСтруктураПараметров<?""Дописать имя в конец (слитно)"">.Вставить(""Параметр""	, Неопределено);"}
},
{0,
{"СтруктураПараметров Функция",0,0,"СтруктПарамФ[ункция]","лПараметры<?""Имя параметров (Слитно)""> = СтруктураПараметров<?""Имя параметров (Слитно)"">();

Функция СтруктураПараметров<?""Имя параметров (Слитно)"">()
	
	лСтруктураПараметров<?""Имя параметров (Слитно)""> = Новый Структура;
	
	лСтруктураПараметров<?""Имя параметров (Слитно)"">.Вставить(""Параметр""	, Неопределено);
	
	Возврат лСтруктураПараметров<?""Имя параметров (Слитно)"">;
	
КонецФункции // СтруктураПараметров<?""Имя параметров (Слитно)"">()"}
},
{0,
{"СтруктураПараметров в переменную",0,0,"СтруктП[араметр]","<?""Имя параметра (слитно)""> 	= лСтруктураПараметров.<?""Имя параметра (слитно)"">;
<?>"}
},
{0,
{"СтруктураПараметров.Вставить",0,0,"СтруктПарамВ[ставить]","лСтруктураПараметров.Вставить(""<?""Имя параметра (слитно)"">""		, 	СтрокаТаблицы.<?""Имя параметра (слитно)"">);"}
},
{0,
{"РежимЗаписиДокумента",0,0,"РЗД","РежимЗаписиДокумента.Проведение"}
},
{0,
{"ПолучитьКомментарийКода",0,0,"","//Функция получает ""рабочий"" комментарий для вставки в код
//-------------------------------------------------------------------------
//Параметры:
//		ФИО 	- Строка или элемент справочника 	- Полное ФИО
//		ДокументНомер 	- Строка 	- Номер документа, если надо задать вручную
//		ДокументДата 	- Строка 	- Дата документа, если надо задать вручную
//		Префикс 	- Строка 	- Что будет после ""//+++ "", в целом краткое название фирмы
//Возвращаемое значение:
//		Строка 	- ""Рабочий"" комментарий 
//-------------------------------------------------------------------------
//автор: КучеровРМ 19.11.2018 
&НаКлиенте
Функция ПолучитьКомментарийКода(ФИО, ДокументНомер = """", ДокументДата = """", Префикс = ""АйТи"") Экспорт
	
	Если ЗначениеЗаполнено(ФИО) Тогда
		ИсполнительЗадачиФИО 	= ?(ТипЗнч(ФИО) <> Тип(""Строка""), Строка(ФИО), ФИО);
		
		ФИОФизическогоЛица 		= ФизическиеЛицаКлиентСервер.ЧастиИмени(СокрЛП(ИсполнительЗадачиФИО)); // разбиваем на части    
		ИсполнительЗадачи 		= ФизическиеЛицаКлиентСервер.ФамилияИнициалы(ФИОФизическогоЛица);
	Иначе
		ИсполнительЗадачи = """";
	КонецЕсли; 
	
	ФорматДаты 				= ""ДФ=dd.MM.yyyy"";
	
	ТекДата 				= Формат(ТекущаяДата(), ФорматДаты);
	
	ТипЗнчДокументДата = ТипЗнч(ДокументДата);
	Если ТипЗнчДокументДата <> Тип(""Строка"") Тогда
		ДокументДата = Формат(ДокументДата, ФорматДаты);
	КонецЕсли; 
	
	ТелоКомментария 	= ИсполнительЗадачи + "" "" + ТекДата + "" ТЗ № "" + ДокументНомер + ?(НЕ ПустаяСтрока(ДокументДата), "" от "" + ДокументДата, """");
	КомментарийКода 	= ""//+++ "" + Префикс + "" "" + ТелоКомментария + ""
	|	
	|//--- "" + Префикс + "" "" + ТелоКомментария;
	
	Возврат КомментарийКода;
	
КонецФункции // ПолучитьКомментарийКода()"}
},
{0,
{"Префиксы имен переменных в программных модулях",0,0,"","Предлагается система префиксов для именования переменных при написании программ на 1С. 
https://infostart.ru/public/99748/

Префиксы имен переменных в программных модулях

Правила именования переменных при разработке конфигураций на платформе 1С:Предприятие 7.7.

Префикс отделяется от основного имени переменной символом «_» для лучшей читаемости программы.
Гл_ - глобальная переменная, процедура или функция. Описана в глобальном модуле с ключевым словом ЭКСПОРТ.
м_ 	- переменная, описанная явно или неявно в текущем программном модуле. Рекомендуется всегда явно описывать переменные модуля в начале текста модуля с помощью оператора Перем.
л_ 	- переменная, описанная явно или неявно в текущей процедуре или функции. Рекомендуется никогда явно не описывать локальные переменные процедур и функций, а создавать их с помощью оператора присваивания, например: л_НомерСтроки=0.
п_ 	- параметр текущей процедуры или функции.
рд_ - реквизит диалога. Описан в форме диалога.
яч_ - ячейка таблицы в режиме ввода данных. Определена в таблице. Может использоваться в тексте программы в качестве переменных. Является первичной ячейкой и/или группой соседних ячеек, объединенных командой ""объединить ячейки"". Представляет собой единую неделимую единицу ввода и/или отображения информации в таблице.
от_ - область таблицы. Определена в таблице. Представляет собой группу ячеек таблицы. Используется, как правило, для форматирования ячеек области.
Отсутствие префикса означает, что переменная является реквизитом того объекта (справочника, документа, …), модулем которого является фрагмент программы. Как следствие, в модулях отчетов и обработок, в том числе и внешних, не должны встречаться переменные без префикса.

Правила именования переменных при разработке конфигураций на платформе 1С:Предприятие 8.

Гл_ 	- глобальная переменная, процедура или функция для основного режима работы конфигурации. Описана в модуле приложения с ключевым словом ЭКСПОРТ.
ГлВС_ 	- глобальная переменная, процедура или функция для работы конфигурации в режиме внешнего соединения. Описана в модуле внешнего соединения с ключевым словом ЭКСПОРТ.
м_ 		- (переменная модуля) переменная, описанная явно или неявно в текущем программном модуле. Рекомендуется всегда явно описывать переменные модуля в начале текста модуля с помощью оператора Перем.
л_ 		- переменная, описанная явно или неявно в текущей процедуре или функции. Рекомендуется никогда явно не описывать локальные переменные процедур и функций, а создавать их с помощью оператора присваивания, например: л_НомерСтроки=0. 
п_ 		- параметр текущей процедуры или функции.
рф_ 	- реквизит формы. Определен как реквизит формы (на закладке «Реквизиты»).
Отсутствие префикса означает, что переменная является реквизитом того объекта (справочника, документа, …), модулем которого является фрагмент программы. Как следствие, в модулях отчетов и обработок, в том числе и внешних, не должны встречаться переменные без префикса.

Комментарий.
Давно пользуюсь этой системой и уже не могу с ней расстаться.
Природа префиксов - ""по месту рождения"" переменной. Префикс отлично дополняет смысл, который можно узнать из имени переменной. Потому что всегда полезно знать, является переменная локальной или объявлена в модуле или это параметр процедуры (функции) или вообще является реквизитом объекта, к которому модуль относится. Когда писал на 7.7 до этой системы,был у меня случай (и потом еще пара случаев, когда другим помогал), когда объявлена переменная в модуле формы и с таким же именем реквизит диалога на форме. Первый раз очень трудно такую ошибку найти. 
При использовании префиксов такое просто невозможно.
Когда ко мне обращались за помощью в поиске ошибки и показывают модуль без префиксов, я часто говорю: ""префиксов нет, поэтому и не работает"". И на самом деле ошибка находится сама, стоит только расставить префиксы в модуле. Ну не все ошибки, конечно, а те, которые не позволяли двигаться дальше.

Для 8-ки практически все то же самое, что и для 7.7. Только в 8 реквизит диалога отделен от данных, поэтому префикса ""рд_"" нет. Обращение к элементам формы возможно только через свойство формы ""ЭлементыФормы"", так что префикс не нужен, и так ни с чем не спутаешь. Зато в форме могут быть реквизиты (которые определены на закладке формы ""реквизиты""). Для них префикс ""рф_"".
Еще пока не пришлось пользоваться префиксами ""Гл_"" и ""ГлВС_"" - для этого надо конфигурацию с нуля писать.

Хотел еще суффиксы ввести, ""Ссылка"" и ""Объект"". Но не прижились: писать долго, и хотя для смысла они очень полезны, но острой проблемы нет. Поэтому я их использую, но только в случаях, когда это необходимо, поэтому в систему для обязательного применения они не записаны. Но требуются они довольно часто, потому что все-таки важно понимать, переменная ""л_Контрагент"", например, является ""л_КонтрагентСсылка"" или ""л_КонтрагентОбъект"".

8-ка правда немного мешает применению этой системе. В 8-ке помощник ввода текстов гораздо мощнее, чем в 7.7. Например, при вставке предопределенных процедур модуля мы получаем заголовок процедуры вместе с параметрами, которые, к сожалению моему, без префиксов «п_». И ставить их мне иногда лень, Поэтому в текстах моих можно встретить небольшие процедуры без префиксов, если очень тороплюсь. Но в большинстве случаев все-таки меняю. И чем больше и сложнее текст процедуры, тем больше важно поставить префиксы у параметров.

Сейчас и разработчики 1С стали использовать префикс ""м"" в переменных модулей, правда без подчеркивания. На мой вкус с подчеркиванием лучше. Но все равно, когда читаешь текст какой-нибудь процедуры (функции) и сразу не понимаешь, локальная это переменная, параметр процедуры (функции) или реквизит объекта у меня возникает раздражение. Ну если уж пришли к префиксу ""м_"", то дальше просто просятся префиксы ""п_"" и ""л_"", с моей точки зрения, конечно."}
},
{0,
{"Префиксы имен переменных в программных модулях Дописан",0,0,"","Предлагается система префиксов для именования переменных при написании программ на 1С. 
https://infostart.ru/public/99748/

Префиксы имен переменных в программных модулях

Правила именования переменных при разработке конфигураций на платформе 1С:Предприятие 7.7.

Префикс отделяется от основного имени переменной символом «_» для лучшей читаемости программы.
Гл_ - глобальная переменная, процедура или функция. Описана в глобальном модуле с ключевым словом ЭКСПОРТ.
м_ 	- переменная, описанная явно или неявно в текущем программном модуле. Рекомендуется всегда явно описывать переменные модуля в начале текста модуля с помощью оператора Перем.
л_ 	- переменная, описанная явно или неявно в текущей процедуре или функции. Рекомендуется никогда явно не описывать локальные переменные процедур и функций, а создавать их с помощью оператора присваивания, например: л_НомерСтроки=0.
п_ 	- параметр текущей процедуры или функции.
рд_ - реквизит диалога. Описан в форме диалога.
яч_ - ячейка таблицы в режиме ввода данных. Определена в таблице. Может использоваться в тексте программы в качестве переменных. Является первичной ячейкой и/или группой соседних ячеек, объединенных командой ""объединить ячейки"". Представляет собой единую неделимую единицу ввода и/или отображения информации в таблице.
от_ - область таблицы. Определена в таблице. Представляет собой группу ячеек таблицы. Используется, как правило, для форматирования ячеек области.
Отсутствие префикса означает, что переменная является реквизитом того объекта (справочника, документа, …), модулем которого является фрагмент программы. Как следствие, в модулях отчетов и обработок, в том числе и внешних, не должны встречаться переменные без префикса.

Правила именования переменных при разработке конфигураций на платформе 1С:Предприятие 8.

Гл_ 	- глобальная переменная, процедура или функция для основного режима работы конфигурации. Описана в модуле приложения с ключевым словом ЭКСПОРТ.
ГлВС_ 	- глобальная переменная, процедура или функция для работы конфигурации в режиме внешнего соединения. Описана в модуле внешнего соединения с ключевым словом ЭКСПОРТ.
м_ 		- (переменная модуля) переменная, описанная явно или неявно в текущем программном модуле. Рекомендуется всегда явно описывать переменные модуля в начале текста модуля с помощью оператора Перем.
л_ 		- переменная, описанная явно или неявно в текущей процедуре или функции. Рекомендуется никогда явно не описывать локальные переменные процедур и функций, а создавать их с помощью оператора присваивания, например: л_НомерСтроки=0. 
п_ 		- параметр текущей процедуры или функции.
рф_ 	- реквизит формы. Определен как реквизит формы (на закладке «Реквизиты»).
Отсутствие префикса означает, что переменная является реквизитом того объекта (справочника, документа, …), модулем которого является фрагмент программы. Как следствие, в модулях отчетов и обработок, в том числе и внешних, не должны встречаться переменные без префикса.

Далее приписывается тип переменной сразу после первой, вида:
лс_ 	- Локальная Строка
лм_ 	- Массива
лМвт_ 	- МенеджерВременныхТаблиц
лСтр_ 	- Структура
лТз_ 	- ТаблицаЗначений
лРз_ 	- РезультатЗапроса

мм_ 	- Массив


Комментарий.
Давно пользуюсь этой системой и уже не могу с ней расстаться.
Природа префиксов - ""по месту рождения"" переменной. Префикс отлично дополняет смысл, который можно узнать из имени переменной. Потому что всегда полезно знать, является переменная локальной или объявлена в модуле или это параметр процедуры (функции) или вообще является реквизитом объекта, к которому модуль относится. Когда писал на 7.7 до этой системы,был у меня случай (и потом еще пара случаев, когда другим помогал), когда объявлена переменная в модуле формы и с таким же именем реквизит диалога на форме. Первый раз очень трудно такую ошибку найти. 
При использовании префиксов такое просто невозможно.
Когда ко мне обращались за помощью в поиске ошибки и показывают модуль без префиксов, я часто говорю: ""префиксов нет, поэтому и не работает"". И на самом деле ошибка находится сама, стоит только расставить префиксы в модуле. Ну не все ошибки, конечно, а те, которые не позволяли двигаться дальше.

Для 8-ки практически все то же самое, что и для 7.7. Только в 8 реквизит диалога отделен от данных, поэтому префикса ""рд_"" нет. Обращение к элементам формы возможно только через свойство формы ""ЭлементыФормы"", так что префикс не нужен, и так ни с чем не спутаешь. Зато в форме могут быть реквизиты (которые определены на закладке формы ""реквизиты""). Для них префикс ""рф_"".
Еще пока не пришлось пользоваться префиксами ""Гл_"" и ""ГлВС_"" - для этого надо конфигурацию с нуля писать.

Хотел еще суффиксы ввести, ""Ссылка"" и ""Объект"". Но не прижились: писать долго, и хотя для смысла они очень полезны, но острой проблемы нет. Поэтому я их использую, но только в случаях, когда это необходимо, поэтому в систему для обязательного применения они не записаны. Но требуются они довольно часто, потому что все-таки важно понимать, переменная ""л_Контрагент"", например, является ""л_КонтрагентСсылка"" или ""л_КонтрагентОбъект"".

8-ка правда немного мешает применению этой системе. В 8-ке помощник ввода текстов гораздо мощнее, чем в 7.7. Например, при вставке предопределенных процедур модуля мы получаем заголовок процедуры вместе с параметрами, которые, к сожалению моему, без префиксов «п_». И ставить их мне иногда лень, Поэтому в текстах моих можно встретить небольшие процедуры без префиксов, если очень тороплюсь. Но в большинстве случаев все-таки меняю. И чем больше и сложнее текст процедуры, тем больше важно поставить префиксы у параметров.

Сейчас и разработчики 1С стали использовать префикс ""м"" в переменных модулей, правда без подчеркивания. На мой вкус с подчеркиванием лучше. Но все равно, когда читаешь текст какой-нибудь процедуры (функции) и сразу не понимаешь, локальная это переменная, параметр процедуры (функции) или реквизит объекта у меня возникает раздражение. Ну если уж пришли к префиксу ""м_"", то дальше просто просятся префиксы ""п_"" и ""л_"", с моей точки зрения, конечно."}
},
{0,
{"Форма подбора",0,0,"","
////////////////////////////////////////////////////////////////////////////////
// ФормаДокумента 

&НаКлиенте
Процедура РезультатПодбор(Команда)
	
	ОписаниеОбработчикаВыбора = Новый ОписаниеОповещения(""ОбработкаПодбора"", ЭтотОбъект);
	//ПараметрыПодбора = Новый Структура(""ВидимостьФинансовойЦели,ВидимостьКоличестваИЦены,ДатаОтбора,ВалютаКошелька,ДатаОперации,КошелекОперации,СтрокаПоиска"",
	//ВидимостьФинансовойЦели, ВидимостьКоличестваИЦены, , ВалютаКошелька, Объект.Дата, Объект.КошелекДолг, """");
	ПараметрыПодбора = Неопределено;
	ОткрытьФорму(""Обработка.ФормыПодборов.Форма.ПодборРезультата"", ПараметрыПодбора, ЭтаФорма, Объект.Ссылка, ,, ОписаниеОбработчикаВыбора); 
	
КонецПроцедуры

&НаКлиенте
Процедура ОбработкаПодбора(РезультатПодбора, ДополнительныеПараметры) Экспорт

	Если НЕ ТипЗнч(РезультатПодбора) = Тип(""Структура"")
		ИЛИ НЕ РезультатПодбора.Свойство(""АдресТаблицыВыбора"") Тогда
		Возврат;
	КонецЕсли; 
	
	ДобавитьВРезультатСтрокиНаСервере(РезультатПодбора);

КонецПроцедуры

&НаСервере
Процедура ДобавитьВРезультатСтрокиНаСервере(РезультатПодбора)

	ТаблицаПодбора = ПолучитьИзВременногоХранилища(РезультатПодбора.АдресТаблицыВыбора);
	Для Каждого СтрокаПодбора Из ТаблицаПодбора Цикл
		Если ЗначениеЗаполнено(СтрокаПодбора.ИмяРезультата) Тогда
			СтрокаРасхода 				= Объект.Результат.Добавить();
			СтрокаРасхода.ИмяРезультата = СтрокаПодбора.ИмяРезультата;
			СтрокаРасхода.Параметр      = СтрокаПодбора.Параметр;
			СтрокаРасхода.Значение   	= СтрокаПодбора.Значение;
		КонецЕсли; 
	КонецЦикла; 

КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ФормаПодбора 

&НаКлиенте
Процедура ПеренестиВЗапись(Команда)
	
	Закрыть(ПодготовитьРезультатКПереносуВЗапись(ВладелецФормы.УникальныйИдентификатор));
	
КонецПроцедуры

&НаСервере
Функция ПодготовитьРезультатКПереносуВЗапись(ИДВладельца)

	АдресТаблицы = ПоместитьВоВременноеХранилище(Результаты.Выгрузить(), ИДВладельца);
	Результат = Новый Структура(""АдресТаблицыВыбора"", АдресТаблицы);
	
	Возврат Результат;

КонецФункции


&НаКлиенте
Процедура СписокИсторииВыбор(Элемент, ВыбраннаяСтрока, Поле, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	
	ВыборСтрокиСпискаИстории();
	
КонецПроцедуры

Процедура ДобавитьРезультатВСписок(СтруктураВыбора)

	НоваяСтрока 				= Результаты.Добавить();
	НоваяСтрока.ИмяРезультата 	= СтруктураВыбора.ИмяРезультата;
	НоваяСтрока.Параметр        = СтруктураВыбора.Параметр;
	НоваяСтрока.Значение        = СтруктураВыбора.Значение;
	
	Элементы.ФормаПеренестиВЗапись.Доступность = Результаты.Количество() > 0;

КонецПроцедуры

&НаКлиенте
Процедура ВыборСтрокиСпискаИстории()

	ТекущаяСтрока = Элементы.СписокИстории.ТекущиеДанные;
	Если ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	
	ПараметрВыбора = Новый Структура(""ИмяРезультата, Параметр, Значение"", 
		ТекущаяСтрока.ИмяРезультата, ТекущаяСтрока.Параметр, ТекущаяСтрока.Значение);
	
	ДобавитьРезультатВСписок(ПараметрВыбора);

КонецПроцедуры

"}
},
{0,
{"ПолучитСсылкуНового",0,0,"","&НаСервереБезКонтекста
Функция <?""Имя элемента (слитно)"">ПолучитСсылкуНового()
	
	КлючУникальности 	= Новый УникальныйИдентификатор;
	НоваяСсылка 		= Документы.<?""Имя элемента (слитно)"">.ПолучитьСсылку(КлючУникальности);
	
	Возврат НоваяСсылка;
	
КонецФункции // <?""Имя элемента (слитно)"">ПолучитСсылкуНового()"}
},
{0,
{"Получучить область макета и вывести ее в табличный документ",0,0,"","ОбластьМакета<?""Имя области (слитно)""> 	= Макет.ПолучитьОбласть(""<?""Имя области (слитно)"">"");
ТабличныйДокумент.Вывести(ОбластьМакета<?""Имя области (слитно)"">);"}
},
{0,
{"Получить текст файла картинки",0,0,"","//Получить текст файла картинки? Хочу записать его в xml, чтобы вся инфа была в xml
//Вот кусок кода как в base64 вывести без внешних файлов (очень удобно для импорта любой программой) 
ВыбранноеИзображение 						= Новый Картинка(ИмяВременногоФайла, Ложь);
ЭлементыФормы.ПолеКартинки1.Картинка 		= ВыбранноеИзображение;
ЭлементыФормы.ПолеКартинки1.Масштабировать 	= Истина;
ЭлементыФормы.Надпись1.Значение 			= Строка(Выборка.ФизЛицо);
ЗаписьXML.ЗаписатьАтрибут(""img"", Base64Строка(Картинка.ПолучитьДвоичныеДанные()));"}
},
{0,
{"Контакты (КИ). Заполнение на форме типовое",0,0,"","Если Объект.АйТи_ПотреблениеПоСделке Тогда
	ДополнительныеПараметрыКИ = УправлениеКонтактнойИнформацией.ПараметрыКонтактнойИнформацией();
	ДополнительныеПараметрыКИ.Вставить(""ИмяЭлементаДляРазмещения"", ""ГруппаКонтактнаяИнформация"");
	ДополнительныеПараметрыКИ.Вставить(""ПоложениеЗаголовкаКИ"", ПоложениеЗаголовкаЭлементаФормы.Лево);
	ДополнительныеПараметрыКИ.Вставить(""ОтложеннаяИнициализация"", Истина);
	УправлениеКонтактнойИнформацией.ПриСозданииНаСервере(ЭтаФорма, Объект.АйТи_КонтактноеЛицо, ДополнительныеПараметрыКИ);
КонецЕсли;"}
},
{0,
{"ЗЗ (ЗначениеЗаполнено) с учетом мутабельных",0,0,"","// Определяет заполнено ли переданное значение
//
// Параметры: 
//  Значение - Неопределено - Значение, заполнение которого надо проверить
//
// Возвращаемое значение:
//  Булево - Истина, если значение заполнено, иначе ложь.
//
Функция обЗначениеЗаполнено(Значение) Экспорт

	Результат = Ложь;
	
	Попытка
		Результат = ЗначениеЗаполнено(Значение)	
	Исключение // Мутабельные типы (Объекты)
		Результат = Ложь
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции // обЗначениеЗаполнено()"}
},
{0,
{"РежимЗаписиДокумента.Проведение (РЗД)",0,0,"РЗД","РежимЗаписиДокумента.Проведение"}
},
{0,
{"Список.Отбор ",0,0,"","ГруппаОтбора 			= Список.Отбор.Элементы.Добавить(Тип(""ГруппаЭлементовОтбораКомпоновкиДанных""));
ГруппаОтбора.ТипГруппы 	= ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИЛИ;

ЭлементОтбора 					= Список.Отбор.Элементы.Добавить(Тип(""ЭлементОтбораКомпоновкиДанных""));
ЭлементОтбора.Родитель 			= ГруппаОтбора;
ЭлементОтбора.ЛевоеЗначение 	= Новый ПолеКомпоновкиДанных(""Объект"");
ЭлементОтбора.ВидСравнения 		= ВидСравненияКомпоновкиДанных.Равно;
ЭлементОтбора.Использование 	= Истина;
ЭлементОтбора.ПравоеЗначение 	= Объект.Ссылка;"}
},
{0,
{"ПолучитьРодителя (справочник)",0,0,"","Функция ПолучитьРодителя(пСправочникСсылка)
	
	лСправочникСсылка 	= пСправочникСсылка;
	Пока НЕ лСправочникСсылка.Родитель.Пустая() Цикл
		лСправочникСсылка 	= лСправочникСсылка.Родитель;	
	КонецЦикла;
	
	Возврат лСправочникСсылка;
	
КонецФункции
"}
},
{0,
{"ПометкаУдаления",0,0,"","&НаКлиенте
Процедура АйТи_УстановитьСнятьПометкуУдаленияПосле(Команда)
	
	УстановитьСнятьПометкуУдаления(Объект.СтатьяБазыЗнаний) 
	
КонецПроцедуры

&НаКлиенте
Процедура УстановитьСнятьПометкуУдаления(пСсылка, пЗначение = Неопределено)
	
	Если ЗначениеЗаполнено(пСсылка) Тогда
		Если пЗначение = Неопределено Тогда
			лОбъектПометкаУдаления 	= ПолучитьПометкуУдаленияНаСервере(пСсылка);
			лВопросСостояние 		= ?(НЕ лОбъектПометкаУдаления, ""Установить"", ""Снять"");
			Если Вопрос(лВопросСостояние + "" пометку на удаление?"", РежимДиалогаВопрос.ДаНет) = КодВозвратаДиалога.Да Тогда
				УстановитьСнятьПометкуУдаленияНаСервере(пСсылка);
			КонецЕсли; 
		Иначе
			УстановитьСнятьПометкуУдаленияНаСервере(пСсылка, пЗначение);
		КонецЕсли; 
	КонецЕсли;
	
КонецПроцедуры // УстановитьСнятьПометкуУдаления()

&НаСервереБезКонтекста
Функция ПолучитьПометкуУдаленияНаСервере(пСсылка)
	
	Возврат пСсылка.ПометкаУдаления;
	
КонецФункции // ПолучитьПометкуУдаленияНаСервере()

&НаСервереБезКонтекста
Процедура УстановитьСнятьПометкуУдаленияНаСервере(пСсылка, пЗначение = Неопределено)
	
	лОбъект 	= пСсылка.ПолучитьОбъект();
	Если пЗначение = Неопределено Тогда
		лОбъект.УстановитьПометкуУдаления(НЕ лОбъект.ПометкаУдаления);
	Иначе
		лОбъект.УстановитьПометкуУдаления(пЗначение);
	КонецЕсли; 
	
КонецПроцедуры // УстановитьСнятьПометкуУдаленияНаСервере()"}
},
{0,
{"Чтение отдельных реквизитов объекта из базы данных (ЗначенияРеквизитовОбъекта)",0,0,"","Чтение отдельных реквизитов объекта из базы данных
Область применения: управляемое приложение, мобильное приложение, обычное приложение.

При чтении отдельных реквизитов объекта из базы данных следует иметь в виду, что вызов метода ПолучитьОбъект или обращение к реквизитам объекта через точку от ссылки приводит к загрузке объекта из базы целиком, вместе с его табличными частями.

Поэтому для чтения значений отдельных реквизитов из базы данных следует использовать запрос. Например, неправильно:

Процедура ЗаполнитьКодИНаименованиеСтраны()
 
 СтранаСсылка = … // получаем ссылку на элемент справочника 
 КодСтраны = СтранаСсылка.Код; // первое обращение загружает объект целиком
 НаименованиеСтраны = СтранаСсылка.Наименование;
 
КонецПроцедуры

правильно:

Процедура ЗаполнитьКодИНаименованиеСтраны()
 
 Запрос = Новый Запрос(
  ""ВЫБРАТЬ
  | СтраныМира.Код,
  | СтраныМира.Наименование
  |ИЗ
  | Справочник.СтраныМира КАК СтраныМира
  |ГДЕ
  | СтраныМира.Ссылка = &Ссылка"");
 Запрос.УстановитьПараметр(""Ссылка"", Ссылка);
 
 Выборка = Запрос.Выполнить().Выбрать();
 Выборка.Следующий();

 КодСтраны = Выборка.Код;
 НаименованиеСтраны = Выборка.Наименование;

КонецПроцедуры

Для упрощения синтаксиса рекомендуется также использовать специальные функции ЗначенияРеквизитовОбъекта или ЗначениеРеквизитаОбъекта (входят в состав Библиотеки стандартных подсистем).
В этом случае исходный пример будет выглядеть так:

Процедура ЗаполнитьКодИНаименованиеСтраны()

 ЗначенияРеквизитов = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(СтранаСсылка, ""Код, Наименование"");
 КодСтраны = ЗначенияРеквизитов.Код;
 НаименованиеСтраны = ЗначенияРеквизитов.Наименование;
 
КонецПроцедуры"}
},
{0,
{"ОбщегоНазначения.ЗначенияРеквизитовОбъекта(СтранаСсылка, ""Код, Наименование"");",0,0,"ЗРО","ОбщегоНазначения.ЗначенияРеквизитовОбъекта(лСсылка, ""<?>"");"}
},
{0,
{"ОбщегоНазначения.ЗначенияРеквизитовОбъекта(СтранаСсылка, ""Код, Наименование""); описание",0,0,"","// Структура, содержащая значения реквизитов, прочитанные из информационной базы по ссылке на объект.
//
// Если необходимо зачитать реквизит независимо от прав текущего пользователя,
// то следует использовать предварительный переход в привилегированный режим.
//
// Параметры:
//  Ссылка    - ЛюбаяСсылка - объект, значения реквизитов которого необходимо получить.
//            - Строка      - полное имя предопределенного элемента, значения реквизитов которого необходимо получить.
//  Реквизиты - Строка - имена реквизитов, перечисленные через запятую, в формате
//                       требований к свойствам структуры.
//                       Например, ""Код, Наименование, Родитель"".
//            - Структура, ФиксированнаяСтруктура - в качестве ключа передается
//                       псевдоним поля для возвращаемой структуры с результатом, а в качестве
//                       значения (опционально) фактическое имя поля в таблице.
//                       Если ключ задан, а значение не определено, то имя поля берется из ключа.
//            - Массив, ФиксированныйМассив - имена реквизитов в формате требований
//                       к свойствам структуры.
//  ВыбратьРазрешенные - Булево - если Истина, то запрос к объекту выполняется с учетом прав пользователя, и в случае,
//                                    - если есть ограничение на уровне записей, то все реквизиты вернутся 
//                                      со значением Неопределено;
//                                    - если нет прав для работы с таблицей, то возникнет исключение.
//                              - если Ложь, то возникнет исключение при отсутствии прав на таблицу 
//                                или любой из реквизитов.
//
// Возвращаемое значение:
//  Структура - содержит имена (ключи) и значения затребованных реквизитов.
//            - если в параметр Реквизиты передана пустая строка, то возвращается пустая структура.
//            - если в параметр Ссылка передана пустая ссылка, то возвращается структура, 
//              соответствующая именам реквизитов со значениями Неопределено.
//            - если в параметр Ссылка передана ссылка несуществующего объекта (битая ссылка), 
//              то все реквизиты вернутся со значением Неопределено.
//
Функция ЗначенияРеквизитовОбъекта(Ссылка, Знач Реквизиты, ВыбратьРазрешенные = Ложь) Экспорт
	
	// Если передано имя предопределенного. 
	Если ТипЗнч(Ссылка) = Тип(""Строка"") Тогда 
		
		ПолноеИмяПредопределенногоЭлемента = Ссылка;
		
		// Вычисление ссылки по имени предопределенного.
		// - дополнительно выполняет проверку метаданных предопределенного, выполняется предварительно.
		Попытка
			Ссылка = ОбщегоНазначенияКлиентСервер.ПредопределенныйЭлемент(ПолноеИмяПредопределенногоЭлемента);
		Исключение
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр(""ru = 'Неверный первый параметр Ссылка:
			           |%1'""), КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
			ВызватьИсключение ТекстОшибки;
		КонецПопытки;
		
		// Разбор полного имени предопределенного.
		ЧастиПолногоИмени = СтрРазделить(ПолноеИмяПредопределенногоЭлемента, ""."");
		ПолноеИмяОбъектаМетаданных = ЧастиПолногоИмени[0] + ""."" + ЧастиПолногоИмени[1];
		
		// Если предопределенный не создан в ИБ, то требуется выполнить проверку доступа к объекту.
		// В других сценариях проверка доступа выполняется в момент исполнения запроса.
		Если Ссылка = Неопределено Тогда 
			
			МетаданныеОбъекта = Метаданные.НайтиПоПолномуИмени(ПолноеИмяОбъектаМетаданных);
			
			Если Не ПравоДоступа(""Чтение"", МетаданныеОбъекта) Тогда 
				ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр(""ru = 'Недостаточно прав для работы с таблицей """"%1""""'""), ПолноеИмяОбъектаМетаданных);
			КонецЕсли;
			
		КонецЕсли;
		
	Иначе // Если передана ссылка.
		
		Попытка
			ПолноеИмяОбъектаМетаданных = Ссылка.Метаданные().ПолноеИмя(); 
		Исключение
			ВызватьИсключение НСтр(""ru = 'Неверный первый параметр Ссылка: 
			                             |- Значение должно быть ссылкой или именем предопределенного элемента'"");	
		КонецПопытки;
		
	КонецЕсли;
	
	// Разбор реквизитов, если второй параметр Строка.
	Если ТипЗнч(Реквизиты) = Тип(""Строка"") Тогда
		Если ПустаяСтрока(Реквизиты) Тогда
			Возврат Новый Структура;
		КонецЕсли;
		
		// Удаление пробелов.
		Реквизиты = СтрЗаменить(Реквизиты, "" "", """");
		// Преобразование параметра в массив полей.
		Реквизиты = СтрРазделить(Реквизиты, "","");
	КонецЕсли;
	
	// Приведение реквизитов к единому формату.
	СтруктураПолей = Новый Структура;
	Если ТипЗнч(Реквизиты) = Тип(""Структура"")
		Или ТипЗнч(Реквизиты) = Тип(""ФиксированнаяСтруктура"") Тогда
		
		СтруктураПолей = Реквизиты;
		
	ИначеЕсли ТипЗнч(Реквизиты) = Тип(""Массив"")
		Или ТипЗнч(Реквизиты) = Тип(""ФиксированныйМассив"") Тогда
		
		Для Каждого Реквизит Из Реквизиты Цикл
			
			Попытка
				ПсевдонимПоля = СтрЗаменить(Реквизит, ""."", """");
				СтруктураПолей.Вставить(ПсевдонимПоля, Реквизит);
			Исключение 
				// Если псевдоним не является ключом.
				
				// Поиск ошибки доступности полей.
				Результат = НайтиОшибкуДоступностиРеквизитовОбъекта(ПолноеИмяОбъектаМетаданных, Реквизиты);
				Если Результат.Ошибка Тогда 
					ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр(""ru = 'Неверный второй параметр Реквизиты: %1'""), Результат.ОписаниеОшибки);
				КонецЕсли;
				
				// Не удалось распознать ошибку, проброс первичной ошибки.
				ВызватьИсключение;
			
			КонецПопытки;
		КонецЦикла;
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр(""ru = 'Неверный тип второго параметра Реквизиты: %1'""), Строка(ТипЗнч(Реквизиты)));
	КонецЕсли;
	
	// Подготовка результата (после выполнения запроса переопределится).
	Результат = Новый Структура;
	
	// Формирование текста запроса к выбираемым полям.
	ТекстЗапросаПолей = """";
	Для каждого КлючИЗначение Из СтруктураПолей Цикл
		
		ИмяПоля = ?(ЗначениеЗаполнено(КлючИЗначение.Значение),
						КлючИЗначение.Значение,
						КлючИЗначение.Ключ);
		ПсевдонимПоля = КлючИЗначение.Ключ;
		
		ТекстЗапросаПолей = 
			ТекстЗапросаПолей + ?(ПустаяСтрока(ТекстЗапросаПолей), """", "","") + ""
			|	"" + ИмяПоля + "" КАК "" + ПсевдонимПоля;
		
		
		// Предварительное добавление поля по псевдониму в возвращаемый результат.
		Результат.Вставить(ПсевдонимПоля);
		
	КонецЦикла;
	
	// Если предопределенного нет в ИБ.
	// - приведение результата к отсутствию объекта в ИБ или передаче пустой ссылки.
	Если Ссылка = Неопределено Тогда 
		Возврат Результат;
	КонецЕсли;
	
	ТекстЗапроса = 
		""ВЫБРАТЬ "" + ?(ВыбратьРазрешенные, ""РАЗРЕШЕННЫЕ"", """") + ""
		|"" + ТекстЗапросаПолей + ""
		|ИЗ
		|	"" + ПолноеИмяОбъектаМетаданных + "" КАК Таблица
		|ГДЕ
		|	Таблица.Ссылка = &Ссылка
		|"";
	
	// Выполнение запроса.
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр(""Ссылка"", Ссылка);
	Запрос.Текст = ТекстЗапроса;
	
	Попытка
		Выборка = Запрос.Выполнить().Выбрать();
	Исключение
		
		// Если реквизиты были переданы строкой, то они уже конвертированы в массив.
		// Если реквизиты - массив, оставляем без изменений.
		// Если реквизиты - структура - конвертируем в массив.
		// В остальных случаях уже было бы выброшено исключение.
		Если Тип(""Структура"") = ТипЗнч(Реквизиты) Тогда
			Реквизиты = Новый Массив;
			Для каждого КлючИЗначение Из СтруктураПолей Цикл
				ИмяПоля = ?(ЗначениеЗаполнено(КлючИЗначение.Значение),
							КлючИЗначение.Значение,
							КлючИЗначение.Ключ);
				Реквизиты.Добавить(ИмяПоля);
			КонецЦикла;
		КонецЕсли;
		
		// Поиск ошибки доступности полей.
		Результат = НайтиОшибкуДоступностиРеквизитовОбъекта(ПолноеИмяОбъектаМетаданных, Реквизиты);
		Если Результат.Ошибка Тогда 
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр(""ru = 'Неверный второй параметр Реквизиты: %1'""), Результат.ОписаниеОшибки);
		КонецЕсли;
		
		// Не удалось распознать ошибку, проброс первичной ошибки.
		ВызватьИсключение;
		
	КонецПопытки;
	
	// Заполнение реквизитов.
	Если Выборка.Следующий() Тогда
		ЗаполнитьЗначенияСвойств(Результат, Выборка);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции"}
},
{0,
{"Переворот или ТРАНСПОНИРОВАНИЕ Таблицы Значений",0,0,"","Переворот или ТРАНСПОНИРОВАНИЕ Таблицы Значений
Задача такова что необходимо поменять местами Колонки со Строками. Условие Первая колонка значений это название колонок будущей таблицы значений.

Исходная таблица:
Индекс    Колонка1    Колонка2    Колонка3    Колонка4
0    ""Тип11""    ""Тип21""    ""Тип31""    ""Тип41""
1    ""Тип12""    ""Тип22""    ""Тип32""    ""Тип42""
2    ""Тип13""    ""Тип23""    ""Тип33""    ""Тип43""
3    ""Тип14""    ""Тип24""    ""Тип34""    ""Тип44""
4    ""Тип15""    ""Тип25""    ""Тип35""    ""Тип45""

Полученная таблица:
Индекс    Тип11    Тип12    Тип13    Тип14    Тип15
0    ""Тип11""    ""Тип12""    ""Тип13""    ""Тип14""    ""Тип15""
1    ""Тип21""    ""Тип22""    ""Тип23""    ""Тип24""    ""Тип25""
2    ""Тип31""    ""Тип32""    ""Тип33""    ""Тип34""    ""Тип35""
3    ""Тип41""    ""Тип42""    ""Тип43""    ""Тип44""    ""Тип45""

Минус ы : 
1.того что имя колонок первоначальных не видно.
2. Значение исходной таблицы первой колонки должны быть типизированны для название колонок.

P.S. Может поможет кому ;-)
// Функция возвращает перевернутую ТЗ
// Кидаем ТЗ
Функция ПеревернутьТЗ(ТЗ)
	
	ТЗ2 = Новый ТаблицаЗначений;
	Массив=Тз.ВыгрузитьКолонку(Тз.Колонки[0]);
	Для Каждого Значения  ИЗ  Массив ЦИКЛ 		
		ЗН=ВРег(СокрЛП(Значения));
		ТЗ2.Колонки.Добавить(Значения);
	КонецЦикла;
	Для каждого стр из Тз.Колонки Цикл 		
		ТЗ2.Добавить();
	КонецЦикла;
	СчетчикСтрок=-1;
	Для каждого стр из Тз Цикл 		
		СчетчикСтрок=СчетчикСтрок+1;
		Мас= Новый Массив;
		счетчик=-1;
		Для каждого КН из Тз.Колонки Цикл 			счетчик=счетчик+1;
			ЗначениеИндекса=стр[КН.Имя];
			Мас.Вставить(счетчик,ЗначениеИндекса);
		КонецЦикла;
		ТЗ2.ЗагрузитьКолонку(Мас,ТЗ2.колонки[СчетчикСтрок]);
	КонецЦикла;
	Возврат ТЗ2;
	
КонецФункции "}
},
{0,
{"Обход массива если его ТипЗнч",0,0,"","Если ТипЗнч(<?""Название массива (слитно)"">) = Тип(""Массив"") Тогда
	л<?""Название массива (слитно)"">Массив 	= Новый Массив;
	
	Для каждого <?""Название массива (слитно)"">Строка Из л<?""Название массива (слитно)"">Массив Цикл
		
		л<?""Название массива (слитно)"">Массив.Добавить(<?""Название массива (слитно)"">Строка.Наименование);
		
	КонецЦикла;
Иначе
	л<?""Название массива (слитно)"">Наименование 	= <?""Название массива (слитно)"">.Наименование;
КонецЕсли;"}
},
{0,
{"Вопрос с ОписаниеОповещения",0,0,"Вопрос","Оповещение 	= Новый ОписаниеОповещения(""<?""Имя метода после закрытия диалога (слитно)"">"", ЭтаФорма, Параметры);
ПоказатьВопрос(Оповещение, ""Есть вопросы?"", РежимДиалогаВопрос.ДаНет, 0);

&НаКлиенте
Процедура <?""Имя метода после закрытия диалога (слитно)"">(Результат, Параметры) Экспорт
	
	Если Результат = КодВозвратаДиалога.Нет Тогда
		Возврат;
	КонецЕсли;
	
КонецПроцедуры"}
},
{0,
{"Цветовая схема кода конфигуратора (ethanschoonover.com/solarized)",0,0,"","https://infostart.ru/public/122391/
ethanschoonover.com/solarized

Несколько цветовых схем для встроенного языка 1С, которые минимизирует нагрузку на глаза, за счет чего повышается производительность!
 

Несколько цветовых схем для встроенного языка 1С, которые минимизирует нагрузку на глаза, за счет чего повышается производительность, а  так же Вы в конце рабочего дня не похожи на быка с налитыми кровью глазами! Цветовое оформление подобрано профессиональной группой, которая специализируется в этой области ethanschoonover.com/solarized.

Для повсеместного использования рекомендую светлую схему. Лично я, использую ее преимущественно в Ubuntu, а так же, по долгу службы в 1С:Предприятие 8.х в Windows - впечатления крайне положительные, предлагаю и Вам попробовать!

Для того что бы установить эту схему, зайдите в конфигуратор 1С 8.х, в меню «Сервис» -> «Параметры», перейдите на закладку «Модули»,  «Редактирование». В этом окне в группу «Выделение цветом синтаксических конструкций» внести следующие изменения:

 

// Светлая цветовая схема

Brightness contrast colorschemes:
Ключевые слова: D24C15
Константы типа ""Число"": B68900
Константы типа ""Строка"": 4CA49C
Константы типа ""Дата"": 859900
Идентификаторы: 258BD3
Операторы: D42F33
Комментарии: 93A1A1
Препроцессор: D53584
Прочее: 899A33  
Фон: FFFBF0
 

// Темная цветовая схема

Low contrast colorschemes:
Ключевые слова: D24C15
Константы типа ""Число"": B68900
Константы типа ""Строка"": 4CA49C
Константы типа ""Дата"": 859900
Идентификаторы: 258BD3
Операторы: D42F33
Комментарии: 93A1A1
Препроцессор: D53584
Прочее: 899A33  
Фон: 002B36
 

// Так же привожу цветовую схему для возвращения к настройкам по умолчанию

Default colorschemes:
Ключевые слова: FF0000
Константы типа ""Число"": 000000
Константы типа ""Строка"": 000000
Константы типа ""Дата"": 000000
Идентификаторы: 0000FF
Операторы: FF0000
Комментарии: 008000
Препроцессор: 963200
Прочее: 000000
Фон: FFFFFF


В окне «Выбора цвета» приведенные цвета вводить в поле «#» ( отмечено на скрине ), если возникли трудности с набором, то переносите настройки копированием ctrl+c / ctrl+v.

Так же рекомендую включить признак Жирный в шрифте, но это зависит от конкретного монитора, смотрите сами как Вам удобнее.

Цветовые схемы, кроме дефолтной, подобраны так, что отличаются только цветом фона, так что любителям работать по ночам, можно легко переключатся.

Доп:
Цветовая схема Visual studio и другие с++ IDE: 
Ключевые слова: 0000E7 
Константы типа ""Число"": 0000FF 
Константы типа ""Строка"": A6692F 
Константы типа ""Дата"": 0000FF 
Идентификаторы: 000000 
Операторы: 000000 
Комментарии: 808080 
Препроцессор: 008000 
Прочее: 000000 
Фон: FFFFFF 

Их еще мона переносить. Нужно скопировать файл 1cv8.pfl расположенный к примеру C:\Documents and Settings\user\Application Data\1C\1Cv81\ и скопировать на другой комп по этому пути и все настройки перенесены. 
Это для 8.1, для 8.2. не проверял
	"}
},
{0,
{"РегистрСведений Удалить 1 запись",0,0,"","лМенеджерЗаписи  		= РегистрыСведений.АйТи_ЗаказыКПодпитке.СоздатьМенеджерЗаписи();
лМенеджерЗаписи.Объект 	= лСсылка;
лМенеджерЗаписи.Прочитать();

Если лМенеджерЗаписи.Выбран() Тогда
	лМенеджерЗаписи.Удалить();
КонецЕсли;"}
},
{0,
{"Присвоить",0,0,"","Функция Присвоить(пЧему, пЧто = Неопределено)
	
	лРезультат = Неопределено;
	
	пЧему = пЧто;
	
	Возврат пЧто;
	
КонецФункции // Присвоить()
 "}
},
{0,
{"Из 1с программно прочитать код модулей конфигурации (декомпиляция) (командная строка, ЗапуститьПриложение)",0,0,"","//Из 1с программно прочитать код модулей конфигурации (декомпиляция).
//Требует закрытый конфигуратор, так как будет запускаться программно он.
Кавычка = """""""";
ПутьКБазе = СтрЗаменить(СтрокаСоединения, Кавычка, Кавычка + Кавычка);

КодВозврата = Неопределено;
Кавычка = """""""";
Пользователь = ПользователиИнформационнойБазы.ТекущийПользователь().Имя;
Пароль = """";
ИмяФайлаСообщений = КаталогВыгрузки + ""\СообщенияВыгрузкиКонфигурацииВФайлы.txt"";

ЗапуститьПриложение(Кавычка + КаталогПрограммы + ""1cv8.exe"" + Кавычка + "" DESIGNER""
+ "" /IBConnectionString "" + Кавычка + ПутьКБазе + Кавычка
+ "" /N ""                  + Кавычка + Пользователь + Кавычка
+ "" /P ""                  + Кавычка + Пароль + Кавычка
+ "" /DumpConfigToFiles ""  + Кавычка + КаталогВыгрузки + Кавычка
+ "" /Out ""                + Кавычка + ИмяФайлаСообщений + Кавычка
+ "" /DisableStartupMessages /DisableStartupDialogs ""
,
,
Истина,
КодВозврата);"}
},
{0,
{"Как правильно записывать данные с учетом блокировки транзакций",0,0,"","// Бензответственное чтение - доверять данным нельзя
Ссылка = Запрос.Выполнить.БлаБла.Ссылка;

НачатьТранзакцию();
Попытка
	
	// Надо ставить исключительную блокировку на изменяемые данные.
	// Чтобы никто их не мог прочитать до конца транзакции.
	Блокировка 	= Новый БлокировкаДанных;
	ЭлементБлокировки 	= Блокировка.Добавить(""Справочник.Изменяемый"");
	ЭлементБлокировки.УстановитьЗначение(""Ссылка"", Ссылка);
	Блокировка.Заблокировать();
	
	// Надо ставить разделяемую блокировку на читаемые данные.
	// Чтобы никто их не мог записать до конца транзакции, но все могли читать.
	Блокировка 	= Новый БлокировкаДанных;
	ЭлементБлокировки 	= Блокировка.Добавить(""РегистрНакопления.Читаемый"");
	ЭлементБлокировки.УстановитьЗначение(""ИзменяемыйВИзмерении"", Ссылка);
	ЭлементБлокировки.Режим 	= РежимБлокировкиДанных.Разделяемый;
	Блокировка.Заблокировать();
	
	// Ответственное чтение - доверять данным можно.
	Объект 		= Ссылка.ПолучитьОбъект();
	Читаемый 	= РегистрНакопления.Читаемый.СуперПуперВыборка();
	
	// Выполнить установку пессимистической блокировки объекта от изменения другими режимами или пользователями.
	Объект.Заблокировать();
	
	// Изменение объекта
	Объект.Реквизит 	= Читаемый;
	
	// Запись измененного объекта и снятие объектной пессимистической блокировки.
	Объект.Записать();
	
	// Фиксация Транзакции и снятие блокировок на изменение и на чтение данных
	ЗафиксироватьТранзакцию();
	
Исключение
	// Отмена транзакции в случае ошибки в блоке транзакции.
	ОтменитьТранзакцию();
	// Проброс исходного исключения выше по стеку.
	ВызватьИсключение;
	
КонецПопытки;"}
},
{0,
{"Получение логина и пароля ИТС из базы 1С",0,0,"","ДанныеАвторизации 	= ИнтернетПоддержкаПользователей.ДанныеАутентификацииПользователяИнтернетПоддержки();

Попытка
	
	Для Каждого Элемент Из ДанныеАвторизации Цикл
		
		//Сообщить(Элемент.Ключ + "":  "" + Элемент.Значение);
		Если Элемент.Ключ = ""Логин"" Тогда
			лЛогин 	= Элемент.Значение;
		ИначеЕсли Элемент.Ключ = ""Пароль"" Тогда
			лПароль = Элемент.Значение;            
		КонецЕсли; 
		
		Сообщить(лЛогин + "" / "" + лПароль);
		
	КонецЦикла;
	
Исключение
	Сообщить(""Нет данных регистрации ИТС."");
	
КонецПопытки"}
},
{0,
{"Параметры через запятую в массив",0,0,"","лПараметрыМассив 	= СтрРазделить(СтрЗаменить(пПараметры, "" "", """"), "",""); //пПараметры - получаемые параметры через запятую

Для каждого лПараметр Из лПараметрыМассив Цикл
	
	лПараметр
	
КонецЦикла;"}
},
{0,
{"Найстройки конфигуратора (1cv8.pfl)",0,0,"","{
{""""},
{
{""CnfPictureChooserDlg"",
{""LastOpenPage"",
{""N"",0},""""},
{
{""""}
}
},
{""ModuleColorCategory"",
{""Keywords"",
{""#"",9cd510c7-abfc-11d4-9434-004095e12fc7,2,
{3,0,
{1395922}
}
},""Numerics"",
{""#"",9cd510c7-abfc-11d4-9434-004095e12fc7,2,
{3,0,
{35254}
}
},""Strings"",
{""#"",9cd510c7-abfc-11d4-9434-004095e12fc7,2,
{3,0,
{10265676}
}
},""Dates"",
{""#"",9cd510c7-abfc-11d4-9434-004095e12fc7,2,
{3,0,
{39301}
}
},""Identifiers"",
{""#"",9cd510c7-abfc-11d4-9434-004095e12fc7,2,
{3,0,
{13863717}
}
},""Operators"",
{""#"",9cd510c7-abfc-11d4-9434-004095e12fc7,2,
{3,0,
{3354580}
}
},""Comments"",
{""#"",9cd510c7-abfc-11d4-9434-004095e12fc7,2,
{3,0,
{10592659}
}
},""Preprocessor"",
{""#"",9cd510c7-abfc-11d4-9434-004095e12fc7,2,
{3,0,
{8664533}
}
},""Others"",
{""#"",9cd510c7-abfc-11d4-9434-004095e12fc7,2,
{3,0,
{3381897}
}
},""Background"",
{""#"",9cd510c7-abfc-11d4-9434-004095e12fc7,2,
{3,0,
{15793151}
}
},""CurrentToken"",
{""#"",9cd510c7-abfc-11d4-9434-004095e12fc7,2,
{3,3,
{-10}
}
},""CurrentSelection"",
{""#"",9cd510c7-abfc-11d4-9434-004095e12fc7,2,
{3,3,
{-10}
}
},""PairLexeme"",
{""#"",9cd510c7-abfc-11d4-9434-004095e12fc7,2,
{3,0,
{15132390}
}
},""SearchResult"",
{""#"",9cd510c7-abfc-11d4-9434-004095e12fc7,2,
{3,0,
{13496051}
}
},""AutoAssistBackground"",
{""#"",9cd510c7-abfc-11d4-9434-004095e12fc7,2,
{3,0,
{14285567}
}
},""""},
{
{""""}
}
},
{""ModuleTextEditor"",
{""SyntaxHighlighting"",
{""B"",0},""CheckAutomatically"",
{""B"",1},""ExtCheckAutomatically"",
{""B"",0},""CheckSettings"",
{""#"",4772b3b4-f4a3-49c0-a1a5-8cb5961511a3,
{6,1e512aab-1b41-4ef6-9375-f0137be9dd91,0,0,
{27,
{1e512aab-1b41-4ef6-9375-f0137be9dd91,
{"""",1,
{""N"",1},
{4,0,
{0},"""",-1,-1,0,0,""""},0,0,""""}
},
{1e512aab-1b41-4ef6-9375-f0137be9dd91,
{"""",0,
{""N"",2},
{4,0,
{0},"""",-1,-1,0,0,""""},1,0,""""}
},
{1e512aab-1b41-4ef6-9375-f0137be9dd91,
{"""",0,
{""N"",5},
{4,0,
{0},"""",-1,-1,0,0,""""},2,0,""""}
},
{1e512aab-1b41-4ef6-9375-f0137be9dd91,
{"""",0,
{""N"",6},
{4,0,
{0},"""",-1,-1,0,0,""""},3,0,""""}
},
{1e512aab-1b41-4ef6-9375-f0137be9dd91,
{"""",0,
{""N"",7},
{4,0,
{0},"""",-1,-1,0,0,""""},4,0,""""}
},
{1e512aab-1b41-4ef6-9375-f0137be9dd91,
{"""",0,
{""N"",10},
{4,0,
{0},"""",-1,-1,0,0,""""},5,0,""""}
},
{1e512aab-1b41-4ef6-9375-f0137be9dd91,
{"""",0,
{""N"",11},
{4,0,
{0},"""",-1,-1,0,0,""""},6,0,""""}
},
{1e512aab-1b41-4ef6-9375-f0137be9dd91,
{"""",0,
{""N"",50},
{4,0,
{0},"""",-1,-1,0,0,""""},7,0,""""}
},
{1e512aab-1b41-4ef6-9375-f0137be9dd91,
{"""",0,
{""N"",12},
{4,0,
{0},"""",-1,-1,0,0,""""},8,0,""""}
},
{1e512aab-1b41-4ef6-9375-f0137be9dd91,
{"""",0,
{""N"",101},
{4,0,
{0},"""",-1,-1,0,0,""""},9,0,""""}
},
{1e512aab-1b41-4ef6-9375-f0137be9dd91,
{"""",0,
{""N"",102},
{4,0,
{0},"""",-1,-1,0,0,""""},10,0,""""}
},
{1e512aab-1b41-4ef6-9375-f0137be9dd91,
{"""",1,
{""N"",105},
{4,0,
{0},"""",-1,-1,0,0,""""},11,0,""""}
},
{1e512aab-1b41-4ef6-9375-f0137be9dd91,
{"""",1,
{""N"",106},
{4,0,
{0},"""",-1,-1,0,0,""""},12,0,""""}
},
{1e512aab-1b41-4ef6-9375-f0137be9dd91,
{"""",0,
{""N"",107},
{4,0,
{0},"""",-1,-1,0,0,""""},13,0,""""}
},
{1e512aab-1b41-4ef6-9375-f0137be9dd91,
{"""",0,
{""N"",110},
{4,0,
{0},"""",-1,-1,0,0,""""},14,0,""""}
},
{1e512aab-1b41-4ef6-9375-f0137be9dd91,
{"""",0,
{""N"",111},
{4,0,
{0},"""",-1,-1,0,0,""""},15,0,""""}
},
{1e512aab-1b41-4ef6-9375-f0137be9dd91,
{"""",0,
{""N"",150},
{4,0,
{0},"""",-1,-1,0,0,""""},16,0,""""}
},
{1e512aab-1b41-4ef6-9375-f0137be9dd91,
{"""",0,
{""N"",112},
{4,0,
{0},"""",-1,-1,0,0,""""},17,0,""""}
},
{1e512aab-1b41-4ef6-9375-f0137be9dd91,
{"""",0,
{""N"",201},
{4,0,
{0},"""",-1,-1,0,0,""""},18,0,""""}
},
{1e512aab-1b41-4ef6-9375-f0137be9dd91,
{"""",0,
{""N"",202},
{4,0,
{0},"""",-1,-1,0,0,""""},19,0,""""}
},
{1e512aab-1b41-4ef6-9375-f0137be9dd91,
{"""",1,
{""N"",205},
{4,0,
{0},"""",-1,-1,0,0,""""},20,0,""""}
},
{1e512aab-1b41-4ef6-9375-f0137be9dd91,
{"""",1,
{""N"",206},
{4,0,
{0},"""",-1,-1,0,0,""""},21,0,""""}
},
{1e512aab-1b41-4ef6-9375-f0137be9dd91,
{"""",0,
{""N"",207},
{4,0,
{0},"""",-1,-1,0,0,""""},22,0,""""}
},
{1e512aab-1b41-4ef6-9375-f0137be9dd91,
{"""",1,
{""N"",210},
{4,0,
{0},"""",-1,-1,0,0,""""},23,0,""""}
},
{1e512aab-1b41-4ef6-9375-f0137be9dd91,
{"""",1,
{""N"",211},
{4,0,
{0},"""",-1,-1,0,0,""""},24,0,""""}
},
{1e512aab-1b41-4ef6-9375-f0137be9dd91,
{"""",0,
{""N"",250},
{4,0,
{0},"""",-1,-1,0,0,""""},25,0,""""}
},
{1e512aab-1b41-4ef6-9375-f0137be9dd91,
{"""",0,
{""N"",212},
{4,0,
{0},"""",-1,-1,0,0,""""},26,0,""""}
}
},
{""Pattern""},0,26}
},""AutoPlacement"",
{""N"",2},""ReplaceTabOnInput"",
{""B"",0},""TabSize"",
{""N"",4},""IndentMode"",
{""N"",2},""UseAutoPlacementInComments"",
{""B"",0},""Font"",
{""#"",9cd510c8-abfc-11d4-9434-004095e12fc7,1,
{7,0,0,100,0,0,0,700,0,0,0,1,3,2,1,49,""Courier New"",1,100},0},""ProcCollapse"",
{""N"",2},""ProcCommentCollapse"",
{""N"",2},""LoopCollapse"",
{""N"",0},""ConditionCollapse"",
{""N"",0},""RegionCollapse"",
{""N"",1},""RegionsCommentCollapse"",
{""N"",2},""""},
{
{""""}
}
},
{""Launch"",
{""WebBrowser2"",
{""N"",0},""DisplayAllFunctions"",
{""B"",1},""MRULaunchUserList"",
{""#"",4772b3b4-f4a3-49c0-a1a5-8cb5961511a3,
{6,1e512aab-1b41-4ef6-9375-f0137be9dd91,1,8,
{3,
{1e512aab-1b41-4ef6-9375-f0137be9dd91,
{"""",0,
{""S"",""Иванова (бухгалтер)	""},
{4,0,
{0},"""",-1,-1,0,0,""""},4,0,""""}
},
{1e512aab-1b41-4ef6-9375-f0137be9dd91,
{"""",0,
{""S"",""ИвановаА""},
{4,0,
{0},"""",-1,-1,0,0,""""},3,0,""""}
},
{1e512aab-1b41-4ef6-9375-f0137be9dd91,
{"""",0,
{""S"",""КондратовичЯД""},
{4,0,
{0},"""",-1,-1,0,0,""""},1,0,""""}
}
},
{""Pattern""},0,4}
},""""},
{
{""""}
}
},
{""ModuleRefactoring"",
{""Modality"",
{""B"",1},""Synchronous"",
{""B"",1},""""},
{
{""""}
}
},
{""TextAssist"",
{""PointAutoAssist"",
{""B"",1},""AssignAutoAssist"",
{""B"",1},""QuoteAutoAssist"",
{""B"",1},""BracketAutoAssist"",
{""B"",1},""IncludeTemplates"",
{""B"",0},""IncludeKeywords"",
{""B"",1},""""},
{
{""""}
}
},
{""Config"",
{""MAUseADB"",
{""B"",0},""MAAndroidSDKPath"",
{""S"",""""},""MAPlatformPath"",
{""S"",""""},""MADeviceName"",
{""S"",""""},""MALaunchParam"",
{""N"",2},""""},
{
{""""}
}
},
{""ExternalMergeProgs"",
{""List"",
{""#"",4772b3b4-f4a3-49c0-a1a5-8cb5961511a3,
{6,1e512aab-1b41-4ef6-9375-f0137be9dd91,0,0,
{5,
{1e512aab-1b41-4ef6-9375-f0137be9dd91,
{"""",0,
{""#"",fc01b5df-97fe-449b-83d4-218a090e681e,2a9c9991-e363-474a-abfb-03f2d22aafd0},
{4,0,
{0},"""",-1,-1,0,0,""""},0,0,""""}
},
{1e512aab-1b41-4ef6-9375-f0137be9dd91,
{"""",0,
{""#"",fc01b5df-97fe-449b-83d4-218a090e681e,134d4db0-dbbf-4234-863e-4c95029d1e9e},
{4,0,
{0},"""",-1,-1,0,0,""""},1,0,""""}
},
{1e512aab-1b41-4ef6-9375-f0137be9dd91,
{"""",0,
{""#"",fc01b5df-97fe-449b-83d4-218a090e681e,e56e8b60-cb68-4355-bb74-500095efb2c6},
{4,0,
{0},"""",-1,-1,0,0,""""},2,0,""""}
},
{1e512aab-1b41-4ef6-9375-f0137be9dd91,
{"""",0,
{""#"",fc01b5df-97fe-449b-83d4-218a090e681e,52fea0af-51af-43d1-88d2-f7d730d463d3},
{4,0,
{0},"""",-1,-1,0,0,""""},3,0,""""}
},
{1e512aab-1b41-4ef6-9375-f0137be9dd91,
{"""",0,
{""#"",fc01b5df-97fe-449b-83d4-218a090e681e,5005872a-7e5a-4f82-ac9a-65ff444c103e},
{4,0,
{0},"""",-1,-1,0,0,""""},4,0,""""}
}
},
{""Pattern""},0,4}
},""ShowDiffProg"",
{""#"",fc01b5df-97fe-449b-83d4-218a090e681e,00000000-0000-0000-0000-000000000000},""MergeTwoProg"",
{""#"",fc01b5df-97fe-449b-83d4-218a090e681e,00000000-0000-0000-0000-000000000000},""MergeThreeWayProgStd"",
{""#"",fc01b5df-97fe-449b-83d4-218a090e681e,00000000-0000-0000-0000-000000000000},""MergeThreeWayProgEP"",
{""#"",fc01b5df-97fe-449b-83d4-218a090e681e,00000000-0000-0000-0000-000000000000},""UseModeByDefaultForModule"",
{""B"",0},""""},
{
{""2a9c9991-e363-474a-abfb-03f2d22aafd0"",
{""Name"",
{""S"",""Araxis Merge""},""Path"",
{""S"",""""},""CompareTwoCommand"",
{""S"",""/wait /readonly /2 /title1:%baseCfgTitle /title2:%secondCfgTitle %baseCfg %secondCfg""},""MergeTwoCommand"",
{""S"",""/wait /2 /title1:%baseCfgTitle /title2:%secondCfgTitle %baseCfg %secondCfg %merged""},""MergeThreeCommand"",
{""S"",""/wait /3 /merge /a1 /title1:%oldVendorCfgTitle /title2:%baseCfgTitle /title3:%secondCfgTitle %oldVendorCfg %baseCfg %secondCfg %merged""},""AutoMergeThreeCommand"",
{""S"",""""},""""},
{
{""""}
}
},
{""134d4db0-dbbf-4234-863e-4c95029d1e9e"",
{""Name"",
{""S"",""DiffMerge""},""Path"",
{""S"",""""},""CompareTwoCommand"",
{""S"",""-nosplash -ro2 -t1=%baseCfgTitle -t2=%secondCfgTitle %baseCfg %secondCfg""},""MergeTwoCommand"",
{""S"",""""},""MergeThreeCommand"",
{""S"",""-nosplash -result=%merged -t1=%baseCfgTitle -t2=%oldVendorCfgTitle -t3=%secondCfgTitle %baseCfg %oldVendorCfg %secondCfg""},""AutoMergeThreeCommand"",
{""S"",""""},""""},
{
{""""}
}
},
{""e56e8b60-cb68-4355-bb74-500095efb2c6"",
{""Name"",
{""S"",""KDiff3""},""Path"",
{""S"",""""},""CompareTwoCommand"",
{""S"",""%baseCfg %secondCfg --L1 %baseCfgTitle --L2 %secondCfgTitle""},""MergeTwoCommand"",
{""S"",""%baseCfg %secondCfg --L1 %baseCfgTitle --L2 %secondCfgTitle -o %merged""},""MergeThreeCommand"",
{""S"",""%oldVendorCfg %baseCfg %secondCfg --L1 %oldVendorCfgTitle --L2 %baseCfgTitle --L3 %secondCfgTitle -o %merged""},""AutoMergeThreeCommand"",
{""S"",""%oldVendorCfg %baseCfg %secondCfg --L1 %oldVendorCfgTitle --L2 %baseCfgTitle --L3 %secondCfgTitle -o %merged --auto""},""""},
{
{""""}
}
},
{""52fea0af-51af-43d1-88d2-f7d730d463d3"",
{""Name"",
{""S"",""TortoiseMerge""},""Path"",
{""S"",""""},""CompareTwoCommand"",
{""S"",""/readonly /basename:%baseCfgTitle /minename:%secondCfgTitle /mine:%secondCfg /base:%baseCfg""},""MergeTwoCommand"",
{""S"",""""},""MergeThreeCommand"",
{""S"",""/theirsname:%baseCfgTitle /basename:%oldVendorCfgTitle /minename:%secondCfgTitle /theirs:%baseCfg /base:%oldVendorCfg /mine:%secondCfg /merged:%merged""},""AutoMergeThreeCommand"",
{""S"",""""},""""},
{
{""""}
}
},
{""5005872a-7e5a-4f82-ac9a-65ff444c103e"",
{""Name"",
{""S"",""Perforce P4Merge""},""Path"",
{""S"",""""},""CompareTwoCommand"",
{""S"",""-C utf8-bom -nl %baseCfgTitle -nr %secondCfgTitle %baseCfg %secondCfg""},""MergeTwoCommand"",
{""S"",""""},""MergeThreeCommand"",
{""S"",""-C utf8-bom -nl %baseCfgTitle -nr %secondCfgTitle -nb %oldVendorCfgTitle %oldVendorCfg %baseCfg %secondCfg %merged""},""AutoMergeThreeCommand"",
{""S"",""""},""""},
{
{""""}
}
},
{""""}
}
},
{""debug"",
{""WatchVisible"",
{""B"",0},""CallStackVisible"",
{""B"",0},""""},
{
{""""}
}
},
{""67263150.06"",
{""21BA8BB0-FFFE-4c6c-93E8-38119F0FA7DA"",
{""N"",1.760697647963692469},""""},
{
{""""}
}
},
{""65432355.12"",
{""21BA8BB0-FFFE-4c6c-93E8-38119F0FA7DA"",
{""N"",1.620590805463749509},""""},
{
{""""}
}
},
{""71999336.97"",
{""21BA8BB0-FFFE-4c6c-93E8-38119F0FA7DA"",
{""N"",6.405697631463212341},""""},
{
{""""}
}
},
{""""}
}
}"}
},
{0,
{"Определить версию платформы, версию (редакцию) конфигурации",0,0,"","СистемнаяИнформация = Новый СистемнаяИнформация;
//Определить версию платформы ""1С:Предприятие""
СистемнаяИнформация.ВерсияПриложения
//Определить версию (редакцию) конфигурации
Сообщить(Метаданные.Версия)
"}
},
{0,
{"WSHShell.SendKeys",0,0,"","WSHShell 	= Новый COMОбъект(""WScript.Shell"");
WSHShell.SendKeys(""% "");
WSHShell.SendKeys(""{UP}{UP}{ENTER}"");
WSHShell 	= Неопределено;"}
},
{0,
{"В данном COM-объекте JavaScript выполняется на html странице",0,0,"","Функция ПолучитьСумму(Число1, Число2)
	
	Текст 	= ""<script type='text/javascript'>
	|var summa = "" + Число1 + "" + "" + Число2 + "";
	|document.write(summa);
	|</script>"";
	
	НовыйHTMLДокумент 	= Новый COMОбъект(""HtmlFile"");
	НовыйHTMLДокумент.open(""text/html"");
	НовыйHTMLДокумент.write(Текст);
	НовыйHTMLДокумент.close();
	
	Возврат НовыйHTMLДокумент.documentElement.outerText;
	
КонецФункции "}
},
{1,
{"График",1,0,"",""},
{0,
{"Точки на графике",0,0,"","ВыводитьТочек 	= 5; 
ВсегоТочек 		= График.Точки.Количество();
Шаг 			= Цел(ВсегоТочек/ВыводитьТочек);

//текст точки с индексом 0 надо очистить отдельно, если нужно

Для Точка = 1 По ВсегоТочек-1 Цикл 
	Если Цел(Точка / Шаг) * Шаг <> Точка Тогда
		График.Точки[Точка].Текст 	= """";
	КонецЕсли;	
КонецЦикла;	"}
}
},
{0,
{"Замена в запросе",0,0,"","Запрос.ТекстЗапроса 	= СтрЗаменить(Запрос.ТекстЗапроса, ""<?""Строка в запросе для замены (вида, Список.Ссылка КАК Ссылка,)"">"",
""""<?""Строка в запросе для замены (вида, Список.Ссылка КАК Ссылка,)"">""
|	""<?""Строка в запросе для замены (вида, Список.Ссылка КАК Ссылка,)"">""1"");"}
},
{0,
{"Правила доработки типовых конфигураций 1С для облегчения их дальнейшего обновления (часть 1)",0,0,"","Правила доработки типовых конфигураций 1С для облегчения их дальнейшего обновления (часть 1)
http://tavalik.ru/pravila-razrabotki-chast-1/
Опубликовано 26.07.2016 автором Виталий Онянов
Logo_1c_8_Razradotka

Почти все проекты почти в любой крупной компании-интеграторе 1С заключаются в доработке типовых конфигураций и направлены, в основном, на оптимизацию учета хозяйственной деятельности организации и сдачи соответственной регламентированной отчетности. А это, в свою очередь означает, что в дальнейшем внедряемые решения необходимо будет дорабатывать в соответствии с часто меняющимся законодательством. На практике это почти всегда означает обновление релизов типовых конфигураций, на основе которых выполнялось решение, и адаптация уже выполненных модификаций в соответствии с изменениями очередного релиза.

Часто проект нельзя назвать вполне успешным, если клиент не остался в организации-интеграторе на поддержке. И если придерживаться строгих правил изменения типовых конфигураций, то потратив совсем незначительное время на этапе разработки, можно сэкономить много-много часов и нервов в будущем на постоянном обновлении измененной конфигурации. И наоборот, грубое, «наплевательское» отношение к оформлению кода, выбор более быстрых и простых, а не правильных способов реализации задач могут превратить обновление получившейся конфигурации в настоящий ад для поддержки. В дальнейшем это выльется в огромные часы обновления, резкую загруженность разработчиков в отчетный период, большое количество ошибок после обновления, недовольство клиентов и т. д.

Ниже представлен набор правил разработки в типовых конфигурациях, который позволит значительно облегчить дальнейшее обновление конфигурации. Данный свод родился постепенно из многолетнего опыта большого числа разработчиков одной замечательной компании, и, по моему глубочайшему убеждению, должен быть обязательным для всех разработчиков, независимо от того, в каком отделе / проекте / направлении они работают.


0. Оглавление списка правил разработки:
Концепция минимизации «разрушений» типовой конфигурации
Комментирование изменений кода
Вставка кода
Удаление кода
Изменение существующего кода
Добавление процедур и функций в модуле
Добавление объектов верхнего уровня
Добавление подчиненных объектов
В типовые объекты конфигурации
В объекты, добавленных в рамках проекта
Добавление предопределенных элементов
В типовые объекты конфигурации
В объекты, добавленных в рамках проекта
Использование общих модулей и их строгая структура
Использование подписок и их строгая структура
Редактирование форм
Типовых объектов
Объектов, добавленных в рамках проекта
Принципы работы с ролями
Внешние отчеты и обработки
1. Концепция минимизации «разрушений» типовой конфигурации
Если модифицируемую типовую конфигурацию предполагается обновлять по мере выпуска новых релизов, то разработчикам следует всегда помнить об этом и принимать меры по облегчению обновления. Следует всегда выбирать те способы решения задач, которые обеспечат более простое обновление конфигурации в будущем, даже если они несколько сложнее в реализации. Конечно, только при условии, что у более удобного для обновления способа нет серьёзных недостатков в области производительности, понятности кода и т. д.

2. Комментирование изменений кода:
Абсолютно все изменения программного кода модулей должны комментироваться. Блок строк, подвергшийся изменению, должен быть обрамлён строками-комментариями особого формата. Принцип формирования этих строк показан на примере:

//++ VION 20.07.2016 0001234 Доработка на старте
//-- VION 20.07.2016
Где

//++ — начало блока
//— — конец блока
VION — имя (или ник) разработчика
0001234 — номер задачи по трекеру, ставится только в открывающем комментарии, чтобы в результаты глобального поиска по номеру задачи каждое изменение кода попадало только один раз
Доработка на старте — произвольный комментарий, используется при необходимости, но если номер задачи отсутствует, то краткий пояснительный текст обязателен
Комментарии призваны выделять модификации по сравнению с типовым функционалом. Если разработчик изменяет текст своей собственной модификации через некоторое время в рамках этой же задачи, то такие изменения отдельно не комментируются (и имеющийся внешний комментарий тоже не изменяется). Если разработчик вносит изменения в свой текст, но уже по другой задаче или изменяется код, написанный другим разработчиком, то комментирование следует использовать обязательно.

Обрамляющие комментарии выравниваются по левому краю редактируемого блока кода. Способы использования комментирования изменений продемонстрированы на примерах ниже:

2.1 Вставка кода
Пример:

Процедура ПриОткрытии()
    Если ЭтоНовый() Тогда
        ЗаполнитьПоляПоУмолчанию();
    КонецЕсли;
    НастроитьЭлементыФормы();
    //++ VION 20.07.2016 0001234
    НастроитьДополнительныеЭлементы();
    //-- VION 20.07.2016
    УстановитьВидимостьПолей();
КонецПроцедуры
2.2 Удаление кода
Пример:

Процедура ПриОткрытии()
    //++ VION 20.07.2016 0001234
    //Если ЭтоНовый() Тогда
    //    ЗаполнитьПоляПоУмолчанию();
    //КонецЕсли;
    НастроитьДополнительныеЭлементы();
    //-- VION 20.07.2016
    УстановитьВидимостьПолей();
КонецПроцедуры
2.3 Изменение существующего кода
При изменении существующего кода сначала обязательно комментируется старый блок, затем пишется новый вариант.

Пример:

Процедура ПриОткрытии()
    Если ЭтоНовый() Тогда
        //++ VION 20.07.2016 000123
        //ЗаполнитьПоляПоУмолчанию();
        НастройкаЗаполненияПолей = ПолучитьНастройкуЗаполненияПолей();
        ЗаполнитьПоляПоУмолчаниюРасширенная(НастройкаЗаполненияПолей);
        //-- VION 20.07.2016
    КонецЕсли;
    НастроитьЭлементыФормы();
    УстановитьВидимостьПолей();
КонецПроцедуры
2.4 Добавление процедур и функций в модуле
Для добавляемых процедур и функций, а также для объявления переменных модуля типовых объектов действуют дополнительные правила оформления комментариев:

Комментируется не блок добавленных процедур в целом, а каждая добавленная процедура или функция в отдельности.
Открывающий комментарий идёт на строке, предшествующей заголовку процедуры или функции, а закрывающий комментарий идёт на той же строке, где написано «Конец процедуры» или «Конец процедуры», через пробел.
Комментирование изменений внутри существующих процедур осуществляется по общим правилам.
Пример:

//++ VION 20.07.2016 000123
Перем мНастройкаЗаполненияПолей; //-- VION 20.07.2016

//++ VION 20.07.2016 000123
Процедура ДоработатьФормуПрограммно()
    ...
    ...
КонецПроцедуры //-- VION 20.07.2016

//++ VION 20.07.2016 000123
Процедура ДатаОтгрузкиОбработкаВыбора()
    ...
    ...
КонецПроцедуры //-- VION 20.07.2016
Данное правило позволяет легко переносить изменения в модуле в «попроцедурном сравнении» конфигураций.

pravila-razrabotki-tipovyx-konfiguracij_002

Если же закрывающий комментарий поставить на следующей строке:

pravila-razrabotki-tipovyx-konfiguracij_003

То при «попроцедурном сравнении» данный комментарий будет признан описанием следующей по тексту процедуры, которая будет считаться измененной.

pravila-razrabotki-tipovyx-konfiguracij_001

3. Добавление объектов верхнего уровня
Имена объектов верхнего уровня, создаваемых в конфигурации, обязательно должны начинаться с префикса вашей компании или отдельного префикса проекта. Как правило, он состоит из двух-трех заглавных букв и подчёркивания, например АБ_. Соответственно, создаваемые объекты будут называться АБ_НовыйСправочник, АБ_НовыйРегистрСведений, АБ_НовыйДокумент и т. д.

Синонимы (видимые пользователю имена) добавленных объектов верхнего уровня должны начинаться с префикса, заключённого в круглые скобки: (АБ). В результате эти объекты будут визуально выделяться в списках и сгруппировано располагаться в их начале (что облегчает и тестирование, и использование).

pravila-razrabotki-tipovyx-konfiguracij_005

В комментарии создаваемого объекта следует указать имя разработчика, дату и номер задачи, по аналогии с заголовочным комментарием добавляемого кода, но без знаков «++». Это обеспечит привязку объекта конфигурации к задаче, отыскиваемую глобальным поиском.

Пример: Создать справочник «Проекты».

Действия разработчика: в конфигурации создается следующий справочник:

Имя: АБ_Проекты
Синоним: (АБ) Проекты
Комментарий: // VION 20.07.2016 000123
pravila-razrabotki-tipovyx-konfiguracij_004

4. Добавление подчиненных объектов
Способ добавления реквизитов объектов конфигурации зависит от того, в какой объект конфигурации добавляется реквизит: в объект конфигурации, созданный поставщиком типового решения (т. е. объект на поддержке) или объекта, добавленного в рамках текущего проекта (т. е. уже имеющего префикс).

4.1 Добавление подчиненных объектов в типовые объекты конфигурации
Подчинённые объекты, добавляемые в существующие (типовые) объекты конфигурации, должны снабжаться префиксами: АБ_ДополнительныйРеквизит, АБ_НоваяТабличнаяЧасть, АБ_ФормаНастроекПользователя, АБ_МакетСпециальнаяНакладная. Но при этом синонимы таких подчинённых объектов создаются без префикса.

В комментарии создаваемого объекта следует указать имя разработчика, дату и номер задачи, по аналогии с оформлением созданного модуля. Это обеспечит привязку объекта конфигурации к задаче, отыскиваемую глобальным поиском.

Пример: Создать реквизит «Проект» документа «Авансовый платеж».

Действия разработчика: в конфигурации создается следующий реквизит:

Имя: АБ_Проект
Синоним: Проект
Комментарий: // VION 20.07.2016 000123
pravila-razrabotki-tipovyx-konfiguracij_006

4.2 Добавление подчиненных объектов в объекты, добавленные в рамках проекта
Подчиненные объекты, добавляемые в объекты верхнего уровня добавленные в конфигурацию в рамках проекта, т. е. уже содержащие в имени префикс, добавляются без префикса. Синонимы таких подчиненных объектов создаются также без префикса.

В комментарии создаваемого объекта следует указать имя разработчика, дату и номер задачи, по аналогии с оформлением созданного модуля. Это обеспечит привязку объекта конфигурации к задаче, отыскиваемую глобальным поиском. Комментарий можно не указывать, если реквизиты создаются в рамках той же задачи, что и сам объект верхнего уровня.

Пример: Создать реквизит «Ответственный» у справочника «(АБ) Проекты».

Действия разработчика: Если задача отличная от той, в которой создавался справочник «(АБ) Проекты», то в конфигурации создается следующий реквизит:

Имя: Ответственный
Синоним: Ответственный
Комментарий: // VION 20.07.2016 000456
pravila-razrabotki-tipovyx-konfiguracij_007

5. Добавление предопределенных элементов
При добавлении предопределенных элементов справочников, планов видов характеристик и планов счетов следует использовать те же правила, что и при добавлении подчиненных объектов (табличных частей, реквизитов) в объекты верхнего уровня.

5.1 Добавление предопределенных элементов в типовые объекты конфигурации
Предопределенные элементы для типовых объектов конфигурации обязательно добавляются с префиксом. Наименование задается без префикса.

Пример: В план счетов «Хозрасчетный» добавить предопределенный счет 10.15 — Бланки строгой отчетности.

Действия разработчика: Добавить следующий предопределенный счет:

Имя: АБ_БланкиСрогойОтчетности
Код: 10.15
Наименование: Бланки строгой отчетности
pravila-razrabotki-tipovyx-konfiguracij_016

Если необходимо переименовать предопределенный элемент типового объекта конфигурации (например, счет), следует оставить сам объект без изменений, а переименование выполнить программно в специальной обработке инициализации.

5.2 Добавление предопределенных элементов в объекты, добавленные в рамках проекта
В объекты конфигурации добавленные в рамках проекта, т. е. уже содержащие в своем имени префикс, предопределенные элементы добавляются без префикса в имени и наименовании.

6. Использование общих модулей и их строгая структура
Неоднократно используемые в конфигурации процедуры и функции, обработчики подписок и регламентных заданий размещаются в общих модулях. Для этих целей следует добавлять собственные модули, добавленные по правилам добавления объектов верхнего уровня, оставляя типовые модули неизменными. При разработке будут полезны следующие общие модули («АБ_» — префикс):

АБ_ОбщегоНазначения (клиент, сервер, внешнее соединение) — для размещения обычных процедур и функций.
АБ_Серверный (только сервер) — для процедур и функций, которые обязательно должны исполняться в среде сервера.
АБ_Глобальный — для процедур и функций, вызов которых стандартным способом (через имя модуля и точку) неудобен.
АБ_Привилегированный — для процедур и функций, которые всегда нужно исполнять под полными правами.
АБ_ПовторноеИспользование — для кэширования возвращаемых значений некоторых функций.
pravila-razrabotki-tipovyx-konfiguracij_008

В отдельные общие модули можно выносить код функциональных блоков большого объёма, в этом случае упрощается отладка такого кода при использовании хранилища конфигурации. В остальных случаях, разработчику следует убедиться в наличии подходящего общего модуля перед добавлением нового модуля в конфигурацию.

7. Использование подписок и их строгая структура
Для обработки различных событий, связанных с объектами типовой конфигурации, следует использовать механизм подписок вместо внесения модификации в модули самих объектов, если есть такая возможность.

Для каждого события может быть не более одной подписки (как объекта метаданных), обработчик которой и связанный с ним код должны размешаться в отдельном общем модуле (для повышения параллельности работы разработчиков с хранилищем). Имя подписки и имя общего модуля должны быть одинаковы и соответствовать обрабатываемому событию. В качестве источника подписки указываются все потенциально возможные для обработки объекты (все справочники, все документы и т. п.).

Процедура-обработчик подписки должна содержать вызовы подпроцедур, выполняющих нужные действия. Обращение к ним осуществляется в зависимости от типа источника, а также в нужной последовательности. Комментирование в модуле подписки при добавлении кода по новым задачам осуществляется по общим правилам.

Пример: При проведении документа «Авансовый платеж», делать записи в регистр накопления «(АБ) Затраты по проектам».

Действия разработчика:

1. Создать подписку «АБ_ДокументыОбработкаПроведения» (если такая подписка не была создана раннее), в качестве источника указать все документы, событие — «ОбработкаПроведения».

pravila-razrabotki-tipovyx-konfiguracij_009

2. Создать общий серверный модуль «АБ_ДокументыОбработкаПроведения».

pravila-razrabotki-tipovyx-konfiguracij_010

3.  В модуле создать экспортную процедуру «ОбработкаПроведения». Выбрать данную процедуру в качестве обработчика созданной ранее подписки. В процедуре, в зависимости от типа документа, вызываются необходимые обработчики.

pravila-razrabotki-tipovyx-konfiguracij_011

4. Модуль документа «Авансовый платеж» должен остаться без изменений.

8. Редактирование форм
8.1 Редактирование форм типовых объектов
Если изменение типовой формы (как обычной, так и управляемой) небольшое (например, вынести на форму несколько новых реквизитов), то выполнять такое изменение следует полностью программно. Т. е. изменения вносятся только в модуль формы, а сама форма в конфигураторе остается неизменной. Некоторым разработчикам такой метод редактирования форм поначалу может показаться довольно трудоемким. Однако, имея достаточный опыт программного изменения форм, на добавление одного элемента будет уходить не более 3-5 минут. Затраченное время многократно окупается при последующих обновлениях типовой конфигурации.

Пример: На основную форму документа «Авансовый платеж», добавить реквизит «(АБ) Проект».

Действия разработчика: В обработчике формы «ПриСозданииНаСервере» добавить процедуру «ДоработатьФормуПрограммно()». В данной процедуре добавить нужный элемент в элементы формы.

pravila-razrabotki-tipovyx-konfiguracij_012

Возможно создание отдельного модуля, в котором будут содержаться все необходимые процедуры и функции для изменения типовых форм.

pravila-razrabotki-tipovyx-konfiguracij_013

В типовых конфигурациях на базе БСП 2, уже есть специальный функционал для данных целей:

pravila-razrabotki-tipovyx-konfiguracij_017

В процедуре «ПриСозданииНаСервере» общего модуля «МодификацияКонфигурацииПереопределяемый» можно вызвать свой обработчик.

pravila-razrabotki-tipovyx-konfiguracij_018

Где по имени формы можно вызвать необходимую процедуру с программной доработкой формы.

pravila-razrabotki-tipovyx-konfiguracij_019

Если же на форму планируется добавить большое количество элементов или табличных частей, то возможно и ручное изменение формы. В этом случае рекомендуется создать на форме отдельную вкладку, и уже на ней размещать все необходимые элементы. Это значительно облегчит дальнейшее обновление формы.

8.2 Редактирование форм объектов, добавленных в рамках проекта
Формы объектов, добавленных в рамках проекта (т. е. имеющие в своем названии префикс) редактируются обычным способом.

9. Принципы работы с ролями
Типовые роли всегда следует оставлять неизменными (если это возможно). Это нужно для облегчения обновления изменённой конфигурации из новых релизов, потому что сравнение и восстановление ролей является сложным и кропотливыми процессом.

Права на добавляемые в конфигурацию объекты следует назначать в новых, создаваемых для этой цели ролях.

Запреты на доступ к данным, разрешенным типовыми ролями, следует реализовывать программным способом, пока это возможно. И только когда подобный запрет будет очень сложно реализовать программно (либо такое решение будет ненадёжным), допустимо модифицировать типовые роли. Изменения типовых ролей должны быть минимально необходимыми и документированными. Например, если необходимо изменить текст ограничений доступа в роли (RLS), то согласно общим правилам, следует закомментировать весь типовой код, после чего добавить код с необходимыми изменениями.

pravila-razrabotki-tipovyx-konfiguracij_014

10. Внешние отчеты и обработки
Большинство доработок в системе может быть выполнено с помощью механизма Дополнительных отчетов и обработок.

pravila-razrabotki-tipovyx-konfiguracij_015

В конфигурациях на основе БСП 2 (ERP, УТ 11, БП 3.0, ЗУП 3.0 и т. д) этот механизм значительно расширен. С его помощью без изменения конфигурации возможно создавать внешние отчеты и обработки (с размещением команды запуска в командном интерфейсе и возможностью настройки доступа различным пользователям), обработки заполнения документа, обработки создания документа на основании, дополнительные печатные формы и др.

Разработчикам рекомендуется активно использовать механизм Дополнительных отчетов и обработок, когда это возможно."}
},
{0,
{"Правила доработки типовых конфигураций 1С для облегчения их дальнейшего обновления (часть 2)",0,0,"","Правила доработки типовых конфигураций 1С для облегчения их дальнейшего обновления (часть 2)
Опубликовано 05.10.2016 автором Виталий Онянов
Logo_1c_8_Razradotka

Продолжаем знакомиться с правилами доработки типовых конфигураций, соблюдение которых позволяет значительно облегчить последующее обновление и поддержку измененных конфигураций.

Первую часть читайте здесь. В этой статье будет рассказано о некоторых приемах и методах, которые, по моему мнению, обязательно должны присутствовать в редактируемой конфигурации вне зависимости от масштаба проекта.


0. Оглавление
Использование хранилища конфигураций
Самоидентификация тестовых баз
Обработка инициализации
Справочник предопределённых значений
Просмотр временных таблиц в отладчике
Версии внешних отчётов и обработок
1. Использование хранилища конфигураций
Разработка обязательно должна вестись с использованием хранилища конфигурации. В некоторых случаях хранилищ конфигураций может быть несколько. Например, в схеме ниже используется 2 независимых хранилища:

Для разработочных и одной тестовой базы.
Для рабочей базы и специальной базы — сборки.
pravila-razrabotki-tipovyx-konfiguracij-chast2__001

В этом случае задача с момента начала разработки до переноса в продуктивную базу проходит следующие этапы:

Разработка ведется в одной из разработочных баз
После выполнения, задача помещается в разработочное хранилище конфигурации
Далее, через хранилище задача попадает в тестовую базу (Тестовая 1)
Если по задаче есть замечания, разработчик исправляет их в своей разработочной базе, а затем через хранилище снова передает изменения на тест в тестовую базу.
Когда все этапы тестирования пройдены, разработчик сохраняет файл конфигурации из тестовой базы и посредством сравнения / объединения конфигураций переносит свою задачу в специальную базу — сборку.
В сборке происходит дополнительный тест задачи (после переноса).
Затем, все затронутые объекты помещаются в хранилище рабочей базы и сборки.
В назначенное время все задачи помещенные в хранилище переносятся в рабочую базу.
На совсем небольших проектах возможно подключение всех баз к одному общему хранилищу конфигурации:

pravila-razrabotki-tipovyx-konfiguracij-chast2__002

2. Самоидентификация тестовых баз
В проекте часто имеется несколько тестовых и разработочных баз. Они периодически обновляются выгрузками из рабочей базы. В связи с этим, для снижения риска порчи данных и повышения удобства работы, полезен следующий функционал. Информационная база хранит реквизиты рабочей базы (имя базы, имя сервера или полный путь подключения) — например, в константе.

pravila-razrabotki-tipovyx-konfiguracij-chast2__003

pravila-razrabotki-tipovyx-konfiguracij-chast2__004

В результате каждая копия может определить, является она рабочей базой или нет.

Если база — не рабочая, то:

При начале работы системы в заголовок главного окна нужно автоматически добавить информацию о том, что данная база является тестовой.
Не должен выполняться код обработчиков некоторых регламентных заданий. Например, проверка на рабочую базу должна осуществляться для всех регламентных заданий, выполняющий периодический обмен с внешними системами. При необходимости отладки таких заданий константу можно изменить на реквизиты данной тестовой базы (после изменения настроек обмена).
Функцию проверку можно добавить, например, в процедуру «ПриНачалеРаботыСистемы()» модуля управляемого приложения.

Процедура ПриНачалеРаботыСистемы()

    // СтандартныеПодсистемы
    СтандартныеПодсистемыКлиент.ПриНачалеРаботыСистемы();
    // Конец СтандартныеПодсистемы

    //++ VION 08.09.2016 Общие объекты
    АБ_ОбщегоНазначенияКлиент.УстановитьЗаголовокИнформационнойБазы();
    //-- VION 08.09.2016

КонецПроцедуры
Где процедура «УстановитьЗаголовокИнформационнойБазы()» имеет следующий вид:

//**************************************************
Процедура УстановитьЗаголовокИнформационнойБазы() Экспорт
    Если АБ_ОбщегоНазначенияСервер.ЭтоРабочаяБаза() Тогда
        Возврат;
    КонецЕсли;
    ИмяИнформационнойБазы = АБ_ОбщегоНазначенияСервер.ПолучитьИмяИнформационнойБазы();
    УстановитьКраткийЗаголовокПриложения(""(! ""+ИмяИнформационнойБазы+"" !)"");
КонецПроцедуры
Также в этом примере используются следующие серверные процедуры:

//**************************************************
Функция ЭтоРабочаяБаза() Экспорт
    Если Врег(ПолучитьИмяИнформационнойБазы() )= Врег(СокрЛП(Константы.АБ_ИмяРабочейБазы.Получить())) Тогда
        Возврат Истина;
    Иначе
        Возврат Ложь;
    КонецЕсли;
Конецфункции

//**************************************************
Функция ПолучитьИмяИнформационнойБазы() Экспорт

    СтрокаПодключения = СтрокаСоединенияИнформационнойБазы();

    НомерСимвола = СтрНайти(СтрокаПодключения,""File="");
    Если НомерСимвола > 0 Тогда
        //Это Файловая база
        СтрокаСправа = Сред(СтрокаПодключения,НомерСимвола+6);
        Возврат Сред(СтрокаСправа,1,СтрДлина(СтрокаСправа)-2);
    КонецЕсли;

    НомерСимвола = СтрНайти(СтрокаПодключения,""Ref="");
    Если НомерСимвола > 0 Тогда
        //Это серверная база
        СтрокаСправа = Сред(СтрокаПодключения,НомерСимвола+5);
        Возврат Сред(СтрокаСправа,1,СтрДлина(СтрокаСправа)-2);
    КонецЕсли;

    Возврат """";

Конецфункции
Результат:

pravila-razrabotki-tipovyx-konfiguracij-chast2__005

Обработчик регламентного задания, связанного с обменом данными, должен иметь соответствующую проверку:

//**************************************************
Процедура ВыполнитьОбменДанными() Экспорт

    Если НЕ АБ_ОбщегоНазначенияСервер.ЭтоРабочаяБаза() Тогда
        Возврат;
    КонецЕсли;

    //... Код регламентной процедуры

Конецфункции
3. Обработка инициализации
Некоторые модификации требуют действий, которые нельзя выполнить в конфигураторе. Например, заполнение реквизитов предопределённых элементов справочника (помимо кода и наименования), обязательное первоначальное заполнение каких-либо значений. Все подобные действия по разным задачам проекта следует выполнять в одном месте — в обработке инициализации.

Для данной обработки должны соблюдаться следующие правила:

Обработка должна быть доступна только пользователям с полными правами.
Отдельное вынесение в интерфейс данной обработки не требуется.
Обработка должна иметь одну форму с кратким пояснительным текстом и кнопкой вызова процедуры выполнения пакета инициализационных действий.
Данная процедура должна быть доступна для программного вызова извне.
Процедура выполнения пакета должна последовательно вызвать подпроцедуры инициализации, написанные разными разработчиками в рамках своих задач. В каждой из них должна быть собственная (независимая) обработка исключительных ситуаций, с выдачей сообщений об ошибках.
Ошибка, возникшая в одной в подпроцедуре, не должна влиять на остальную инициализацию.
Обработку предполагается запускать многократно. Каждое действие должно корректно отрабатывать как при первом запуске обработки, так и при повторных запусках. Во втором случае не должно быть каких-либо побочных эффектов или потери введённых пользователем данных.
В конфигурацию также должен быть добавлен механизм автоматического обнаружения изменений в обработке инициализации и предложения пользователю с полными правами выполнить инициализацию при первой же возможности.

Один из вариантов реализации такого механизма:

pravila-razrabotki-tipovyx-konfiguracij-chast2__008

В конфигурации предусматривается константа, хранящая версию последней выполненной обработки инициализации.
В обработке предусматривается экспортная переменная, хранящая версию (целое число). Версия устанавливается при создании обработки-объекта, значение версии прописано в коде модуля. При любой модификации обработки разработчик должен увеличить данную версию на единицу.
При начале работы системы, если текущий пользователь имеет полные права и версии обработки в конфигурации и в константе отличаются, выполняется обработка инициализации.
В данном примере, добавлена константа «АБ_ВерсияВыполненнойОбработкиИнициализации»

pravila-razrabotki-tipovyx-konfiguracij-chast2__007

В модуле управляемого приложения в процедуру «ПриНачалеРаботыСистемы()» добавлен вызов серверной процедуры:

Процедура ПриНачалеРаботыСистемы()

    // СтандартныеПодсистемы
    СтандартныеПодсистемыКлиент.ПриНачалеРаботыСистемы();
    // Конец СтандартныеПодсистемы

    //++ VION 08.09.2016 Общие объекты
    АБ_ОбщегоНазначенияКлиент.УстановитьЗаголовокИнформационнойБазы();
    АБ_ОбщегоНазначенияСервер.ВыполнитьОбработкуИнициализации();
    //-- VION 08.09.2016

КонецПроцедуры
Которая проверяет наличие прав и вызывает обработку инициализации:

//**************************************************
Процедура ВыполнитьОбработкуИнициализации() Экспорт

    Если РольДоступна(""ПолныеПрава"") Тогда
        Обработки.АБ_ОбработкаИнициализации.Создать().ВыполнитьОбработку();
    КонецЕсли;

КонецПроцедуры
Код модуля обработки инициализации

//////////////////////////////////////////////////////////

// ОБРАБОТКА ИНИЦИАЛИЗАЦИИ
// --------------------------
// Обработку предполагается запускать многократно.
// Каждое действие должно корректно отрабатывать как при первом запуске обработки, так и при повторных запусках.
// Во втором случае не должно быть каких-либо побочных эффектов или потери введённых пользователем данных.
// В некоторых случаях (если того требует задача) возможно выявление и исправление настроек, уже сделанных,
// но некорректно изменённых пользователем с момента предыдущей инициализации.
// --------------------------
// Используемые объекты конфигурации:
//  1. Константа.ВерсияВыполненнойОбработкиИнициализации - Тип: Число (5,0)
//  2. Вызов обработки при старте системы: Обработки.ОбработкаИнициализации.Создать().ВыполнитьОбработку();
// --------------------------
// Алгоритм для разработчика:
//   1. В процедуре ПолучитьТекущуюВерсиюОбработки() увеличиваете весрию на 1, напрмер было 3, вы ставите 4.
//   2. В модуль обработки добавляете процедуру ОбработкаИнициализации_Весия_4(Отказ).
//   3. Если в процессе обработки возникли ошибки, необходимо установить переменную Отказ в значение Истина.
//   4. Необходимый код располагаете в данной процедуре.

//********************************************************
Функция ПолучитьТекущуюВерсиюОбработки() Экспорт

    // ВНИМАНИЕ!
    // Код не комментируем, просто увеличиваем текущую версию обработки
    // Тип версии - Число (5,0)
    Возврат 3;

КонецФункции

//********************************************************
Функция ПолучитьПрошлуюВерсиюОбработки() Экспорт

    Возврат Константы.АБ_ВерсияВыполненнойОбработкиИнициализации.Получить();

КонецФункции

//********************************************************
Функция УстановитьВерсиюОбработки(ТекущаяВерсия) Экспорт

    //Запишем текущую версию в константу
    Попытка
        Константы.АБ_ВерсияВыполненнойОбработкиИнициализации.Установить(ТекущаяВерсия);
        Возврат Истина;
    Исключение
        Сообщить(""Обработка инициализации: "" + ОписаниеОшибки());
        Возврат Ложь;
    КонецПопытки;

КонецФункции

//********************************************************
Функция ВыполнитьОбработку(ВсеОбработчики = Ложь) Экспорт

    //Обработку инициализации может выполнить только пользователь с полными правами
    Если Не РольДоступна(""ПолныеПрава"") Тогда
        Сообщить(""Обработка инициализации: Недостаточно прав для выполнения обработки!"");
        Возврат Ложь;
    КонецЕсли;

    Если ВсеОбработчики Тогда
        ПрошлаяВерсия = 0;
    Иначе
        ПрошлаяВерсия = ПолучитьПрошлуюВерсиюОбработки();
    КонецЕсли;
    ТекущаяВерсия = ПолучитьТекущуюВерсиюОбработки();

    //Обработка не нужна
    Если ТекущаяВерсия <= ПрошлаяВерсия Тогда
        Возврат Истина;
    КонецЕсли;

    //В цикле выполняем все необходимые обработки
    Отказ = Ложь;
    Для Сч = ПрошлаяВерсия+1 По ТекущаяВерсия Цикл
        Выполнить(""ОбработкаИнициализации_Весия_""+Сч+""(Отказ);"");
    КонецЦикла;

    Если Отказ Тогда
        Сообщить(""Обработка инициализации: Ошибка выполнения обоработки!"");
        Возврат Ложь;
    КонецЕсли;

    //Запишем текущую версию в константу
    Если УстановитьВерсиюОбработки(ТекущаяВерсия) Тогда
        Сообщить(""Обработка инициализации: Переход на версию "" + ТекущаяВерсия + "" выполнен успешно!"");
        Возврат Истина;
    Иначе
        Возврат Ложь;
    КонецЕсли;

КонецФункции

//********************************************************
Процедура ОбработкаИнициализации_Весия_1(Отказ)

    //Действия обработчика
    Сообщить(""Обработка инициализации, выполнен переход на версию 1"");

КонецПроцедуры
Форма обработки:

pravila-razrabotki-tipovyx-konfiguracij-chast2__006

Скачать обработку можно, например, здесь.

4. Справочник предопределённых значений
При доработке конфигураций часто возникает необходимость обращаться из кода с существующим элементам справочников, не являющихся предопределёнными. Т. к. поиск по коду, наименованию или реквизиту не является надёжным решением, можно добавить в конфигурацию справочник «Предопределённые значения» с единственным реквизитом «Значение» типа «СправочникСсылка».

pravila-razrabotki-tipovyx-konfiguracij-chast2__009

Далее по каждой возникшей задаче в этот справочник добавляется предопределенный элемент.

pravila-razrabotki-tipovyx-konfiguracij-chast2__011

Реквизит «Значение» данного элемента заполняется обработкой инициализации или вручную.

pravila-razrabotki-tipovyx-konfiguracij-chast2__010

Обращение к такому значению осуществляется подобным кодом:

КонтрагентАгроимпульс = Справочники.АБ_ПредопределенныеЗначения.Контрагент_Агроимпульс.Значение;
Права на справочник предопределенных значений должны обеспечивать как доступность его содержимого, так и возможность настройки значений только пользователями с нужными ролями.

5. Просмотр временных таблиц в отладчике
При отладке сложных запросов с временными таблицами нужна возможность просматривать содержимое этих таблиц, которую отладчик не предоставляет.

Для просмотра временных таблиц запроса в отладчике удобно использовать специальную функцию. Данная функция парсит текст запроса, вычленяет все временные таблицы, вычисляет их и результат складывает в структуру.

Для удобства использования удобно поместить процедуру в один из глобальных модулей конфигурации.

funkciya-prosmotra-vremennyx-tablic-zaprosa-v-otladchike_03

funkciya-prosmotra-vremennyx-tablic-zaprosa-v-otladchike_04

Функция предназначена для использования в окне «Вычислить выражение» отладчика — возвращает значение, удобное для просмотра в этом окне. Функция максимально автоматизирована и может работать с входными данными разных типов. Назначение аргументов функции понятно из их имён.

funkciya-prosmotra-vremennyx-tablic-zaprosa-v-otladchike_01

Текст процедур можно посмотреть — здесь.

6. Версии внешних отчётов и обработок
При использовании внешних отчетов и обработок в поле «Комментарий» следует указывать строку, отображающую условную версию объекта. Например, начиная с «v1.0» и далее увеличивая старший или младший номер (в зависимости от объёма изменений) при каждом цикле доработки объекта.

pravila-razrabotki-tipovyx-konfiguracij-chast2__012

Данный комментарий доступен из кода, и при открытии формы его следует добавлять к заголовку окна:

#Область СобытияФормы

////////////////////////////////////////////////////////////
// ОБРАБОТЧИКИ СОБЫТИЙ ФОРМЫ

//**********************************************************
&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)

    //Заголовок формы
    ЭтаФорма.АвтоЗаголовок = Ложь;
    ЭтаФорма.Заголовок = ЗаголовокОтчета();

КонецПроцедуры

//**********************************************************
&НаСервере
Функция ЗаголовокОтчета()

    ТекОбъект = РеквизитФормыВЗначение(""Объект"");
    Комментарий = ТекОбъект.Метаданные().Комментарий;
    Возврат ТекОбъект.Метаданные().Синоним
        + ?(ЗначениеЗаполнено(Комментарий),"" ("" + Комментарий + "")"","""");

КонецФункции

#КонецОбласти
Тогда версия обработки или отчета всегда будет видна в заголовке формы."}
},
{0,
{"Отладка (попасть в отладку)",0,0,"","Только самые простые задачи не требуют отладки. Для решения сложных задач без отладки в принципе не обойтись. С годами придумал способ упростить этот процесс.
1) Включаем отладку (без точек останова), включаем замер производительности, выполняем отлаживаемые действия, выключаем замер производительности (появится список выполненных команд и он будет подсвечен в коде).
2) Потом устанавливаем точки останова и идем по шагам, т.е. выполняем обычную отладку.
Теперь мы заранее видим какой код будет исполнен (и сколько раз). Это значительно ускоряет процесс отладки сложного, объемного кода."}
}
}
}